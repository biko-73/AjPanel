import os
import hashlib
from io       import open as ioOpen
from json      import loads as jLoads, dumps as jDumps
from glob      import glob as iGlob
from re       import match as iMatch, escape as iEscape
from re       import sub as iSub, subn as iSubn, split as iSplit
from re       import search as iSearch, compile as iCompile
from re       import findall as iFindall, finditer as iFinditer
from re       import IGNORECASE
from math      import floor as iFloor, ceil as iCeil, log as iLog
from time      import localtime, mktime, strftime, time as iTime
from time      import sleep as iSleep, timezone as iTimezone
from threading     import Thread as iThread, enumerate as iEnumerate
from threading     import currentThread
from datetime     import datetime, timedelta
from collections    import Counter as iCounter
from base64      import b64encode, b64decode
from sys      import version_info as pyVersion
from skin      import parseColor
from Tools.Directories   import resolveFilename, SCOPE_PLUGINS, SCOPE_FONTS
from Tools.Directories   import SCOPE_CURRENT_SKIN, SCOPE_SKIN
from Plugins.Plugin    import PluginDescriptor
from Screens.Screen    import Screen
from Screens.ChannelSelection import ChannelContextMenu, ChannelSelectionBase
from Screens.ChannelSelection import service_types_tv, service_types_radio
from Screens.InfoBar   import InfoBar
from Tools.BoundFunction  import boundFunction as BF
from Tools.LoadPixmap   import LoadPixmap
from Components.PluginComponent import plugins as iPlugins
from Components.Harddisk  import harddiskmanager
from Components.Label   import Label
from Components.ScrollLabel  import ScrollLabel
from Components.Button   import Button
from Components.MenuList  import MenuList
from Components.ActionMap  import ActionMap
from Components.Pixmap   import Pixmap
from Components.NimManager  import nimmanager
from Components.Slider   import Slider
from enigma      import getDesktop, ePoint, eSize, gFont, eRect
from enigma      import eTimer, eDVBDB, addFont, fontRenderClass
from enigma      import iServiceInformation
from enigma      import eServiceReference, eServiceCenter
from enigma      import eListboxPythonMultiContent
from enigma      import RT_HALIGN_LEFT as LEFT
from enigma      import RT_HALIGN_RIGHT as RIGHT
from enigma      import RT_HALIGN_CENTER as CENTER
from enigma      import RT_VALIGN_CENTER
from Components.ConfigList  import ConfigListScreen
from Components.config   import config, ConfigSubsection, configfile
from Components.config   import getConfigListEntry, ConfigDirectory
from Components.config   import ConfigYesNo, ConfigElement, ConfigText
from Components.config   import ConfigSelection, ConfigSelectionNumber
from Components.config   import ConfigSubList, ConfigInteger
try:  import tarfile as iTar
except: iTar = None
try:  import zipfile as iZip
except: iZip = None
try: from xml.etree import ElementTree as iElem
except: iElem = None
try: from shutil import move as iMove, rmtree, copyfile as iCopyfile, copymode as iCopymode
except: iMove = iCopyfile = iCopymode = None
try:
 from urllib2 import Request as iRequest, urlopen as iUrlopen, URLError as iURLError, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
 from urllib  import unquote as iUnquote, quote as iQuote
 from urlparse import urlparse as iUrlparse, parse_qs as iUrlparse_qs
except:
 try:
  from urllib.request import Request as iRequest, urlopen as iUrlopen, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
  from urllib.error import URLError as iURLError
  from urllib.parse import unquote as iUnquote, quote as iQuote, urlparse as iUrlparse, parse_qs as iUrlparse_qs
 except:
  iRequest = iUrlopen = iURLError = iUnquote = iQuote = iUrlparse = build_opener = install_opener = HTTPPasswordMgrWithDefaultRealm = HTTPDigestAuthHandler = HTTPHandler = None
VVryLp    = "AJPanel"
VVk74U  = "Enigma2 Tools"
VVsBow   = "v10.8.3"
VVV71L    = "13-05-2025"
VVX985    = 0
VVCB0I   = 0
VVdoek   = 0
VVSaol  = resolveFilename(SCOPE_PLUGINS, base="Extensions/")
VVBSnt  = resolveFilename(SCOPE_PLUGINS, base="SystemPlugins/")
VVAH7M   = "AJPan"
VV1rMY  = "AUTO FIND"
VVUWre  = "Custom"
VV2vhe    = "/usr/share/enigma2/picon/"
VVHX6T   = "/etc/enigma2/"
VVrRe3   = VVHX6T + "settings"
VVlCrP = VVHX6T + "blacklist"
VVSz7C = VVHX6T + "whitelist_streamrelay"
VVIo9e    = ""
VVxg3T = "Regular"
VVFYAr = "Fixed"
VV5PlV  = "AJP_Main"
VVNq6S = "AJP_Terminal"
VVrWau  = "AJP_Added"
VV67H9 = "AJP_System"
VVQVcT  = VVxg3T
VVhZdB    = ""
VVJkPQ   = " && echo 'Successful' || echo 'Failed!'"
VVaw89  = "Cannot continue (No Enough Memory) !"
VVrew6  = ["#119f1313","#11005500","#11a08000","#1118188b"]
VVh3eS    = ["KeyMap_RC"]
VVMHLG  = "utf8"
VVT6xx  = False
VVzg1X    = ("-" * 100, )
SEP      = "-" * 80
VVd25Y = 0
VVpSLv = 0
VVkmr2     = 0
VVKdMd    = 1
VVDwJ1    = 2
VVJy40   = 3
VVRfWo   = 4
VVMqR2 = 5
VVEbHC    = 6
VVfBCq    = 7
VVxEpD = 8
VVusjP = 9
VVYVzy  = 10
VVyGmA   = 11
VVCj4p  = 12
VVKSTX  = 13
VVe7bi   = 14
VVJvMX    = 15
VVU3Ky   = 16
VVbJFv   = 17
VV2ZKp    = 18
VVM9On    = 19
VVZjg7  = 20
VVMfHP    = 21
VVWqOp   = 0
VV73ng   = 1
VVtU2A   = 2
if not "VVD5Pj" in globals(): VVD5Pj = set()
def FFB3Un(path, alias, scale=100, isRepl=0, save=True):
 try:
  addFont(path, alias, scale, isRepl)
  if save: VVD5Pj.add(alias)
  return True
 except:
  try:
   addFont(path, alias, scale, isRepl, 0)
   if save: VVD5Pj.add(alias)
   return True
  except:
   pass
 return False
VVrRHR = os.path.exists
def FFf0vs(f, mode="r"):
 return os.access(f, {"r": os.R_OK, "w":os.W_OK}.get(mode, os.F_OK)) if f else False
def FFaW27(f):
 return (os.path.exists(f) or os.path.islink(f)) if f else False
def FFkHoj(path):
 lst = []
 try:
  for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
   if elem.tag == "include":
    incF = elem.get("filename", "")
    incF = incF and resolveFilename(SCOPE_CURRENT_SKIN, incF)
    if FFf0vs(incF):
     lst.append(incF)
 except:
  pass
 return lst
def FFjXxe():
 defSk = resolveFilename(SCOPE_SKIN, "skin_default/skin.xml")
 subSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin_subtitles.xml")
 curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
 lst = []
 for f in set((defSk, subSk, curSk)):
  if FFf0vs(f):
   lst.append(f)
   lst.extend(FFkHoj(f))
 return list(set(lst))
def FFvhXh():
 lst = []
 for skinF in FFjXxe():
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(skinF, events=("start", ))):
    if elem.tag == "fonts":
     for fnt in elem.findall("font"):
      name = fnt.get("name", "Regular")
      scale = fnt.get("scale", "100")
      repl = fnt.get("replacement", "")
      fName = fnt.get("filename", "")
      if fName and scale.isdigit():
       if fName.startswith("/"): fPath = fName
       else     : fPath = resolveFilename(SCOPE_FONTS, fName)
       if FFf0vs(fPath): lst.append((name, scale, repl, fName, fPath, skinF))
     break
  except:
   pass
 return lst
def FFutdK(isSort=True):
 lst = []
 for name, scale, repl, fName, fPath, skinF in FFvhXh():
  lst.append(name)
 curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
 fbFnt = resolveFilename(SCOPE_FONTS, "fallback.font", path_prefix=curSk)
 if FFf0vs(fbFnt): lst.append("Fallback")
 if isSort: return list(set(lst))
 else  : return lst
def FF2tgn(isSort=True):
 lst = []
 try:
  from enigma import getFontFaces
  lst = getFontFaces()
 except:
  try:
   from skin import getFontFaces
   lst = getFontFaces()
  except:
   lst = FFutdK(isSort)
 if isSort: return list(set(lst))
 else  : return lst
def FFHlE6():
 lst = FF2tgn()
 lst.extend(VVD5Pj)
 if lst:
  global VVQVcT
  if VV5PlV in lst and CFG.fontPathMain.getValue(): VVQVcT = VV5PlV
  else               : VVQVcT = VVxg3T
  return sorted(list(set(lst)))
 else:
  return [VVxg3T]
config.plugins.AJPanel = ConfigSubsection()
CFG = config.plugins.AJPanel
CFG.showInMainMenu    = ConfigYesNo(default=False)
CFG.showInExtensionMenu   = ConfigYesNo(default=True)
CFG.showInChannelListMenu  = ConfigYesNo(default=True)
CFG.EventsInfoMenu    = ConfigYesNo(default=True)
CFG.keyboard     = ConfigSelection(default="v", choices=[("v", "Virtual Keyboard"),("s", "System Default")])
CFG.FileManagerExit    = ConfigSelection(default="d", choices=[("d", "Directory Up"),("e", "Exit")])
CFG.hotkey_signal    = ConfigSelection(default="lesc", choices=[("off", "Disable"),("lok", "Long-OK"),("lesc", "Long-Exit"),("lred", "Long-Red")])
CFG.subtDefaultEnc    = ConfigDirectory(default=VVMHLG)
CFG.screenshotFType    = ConfigSelection(default="jpg", choices=[("off", "Disable"),("jpg", "JPG"),("png", "PNG"),("bmp", "BMP")])
CFG.iptvAddToBouquetRefType  = ConfigSelection(default="4097", choices=[("1", "1     (DVB Stream)"),("4097", "4097 (ServiceMp3)"),("5001", "5001 (GST Player)"),("5002", "5002 (Ext-3 EPlayer)"),("8192", "8192 (HDMI input)"),("8193", "8193 (eServiceUri)"),("8793", "8793 (ServiceUrl)")])
CFG.autoResetFrozenIptvChan  = ConfigSelection(default="1", choices=[("off", "Off"),("on+", "Refresh + Notify"),("on", "Silent Refresh")])
CFG.hideIptvServerAdultWords = ConfigYesNo(default=False)
CFG.hideIptvServerChannPrefix = ConfigYesNo(default=False)
CFG.iptvHostsMode    = ConfigDirectory(default=VV1rMY, visible_width=45)
CFG.resumeMovies    = ConfigSelection(default="a", choices=[("off", "Disabled"),("a", "All"),("i", "IPTV Only"),("l", "All (Except IPTV)")])
CFG.MovieDownloadPath   = ConfigDirectory(default="/media/hdd/movie/", visible_width=45)
CFG.portalConnTimeout   = ConfigSelectionNumber(default=2, stepwidth=1, min=1, max=5, wraparound=False)
CFG.PIconsPath     = ConfigDirectory(default=VV2vhe, visible_width=45)
CFG.customMenuPath    = ConfigDirectory(default="/", visible_width=45)
CFG.backupPath     = ConfigDirectory(default="/", visible_width=45)
CFG.iptvHostsDirs    = ConfigText(default="")
CFG.subtitleEventLang   = ConfigSelection(default="o", choices=[("o", "Original"),("s", "English")])
CFG.subtitleFavPath    = ConfigText(default="/")
CFG.favServerPlaylist   = ConfigText(default="")
CFG.favServerPortal    = ConfigText(default="")
CFG.simplePortal    = ConfigYesNo(default=False)
CFG.browserStartPath   = ConfigText(default="/")
CFG.browserBookmarks    = ConfigText(default="/media/,/tmp/,/")
CFG.browserSortMode    = ConfigInteger(default=0, limits=(0, 5))
CFG.browserSortMix    = ConfigYesNo(default=False)
CFG.signalPos     = ConfigInteger(default=5, limits=(1, 9))
CFG.signalSize     = ConfigInteger(default=3, limits=(1, 13))
CFG.mixedColorScheme   = ConfigInteger(default=4, limits=(0, 4))
CFG.checkForUpdateAtStartup  = ConfigYesNo(default=False)
CFG.downloadAutoResume   = ConfigYesNo(default=True)
CFG.downloadMonitor    = ConfigYesNo(default=False)
CFG.lastTerminalCustCmdLineNum = ConfigInteger(default=0)
CFG.lastFileManFindPatt   = ConfigText(default="")
CFG.lastSubtFManFindDir   = ConfigText(default="/media/")
CFG.lastPkgProjDir    = ConfigText(default="/media/")
CFG.lastFeedPkgsDir    = ConfigText(default="/media/")
CFG.lastCustMenuPicDir   = ConfigText(default="")
CFG.lastCustMenuXmlDir   = ConfigText(default="")
CFG.lastCopyMoveDir    = ConfigText(default="")
CFG.lastFindTerminal   = ConfigText(default="")
CFG.lastFindServers    = ConfigText(default="")
CFG.lastFindIptv    = ConfigText(default="")
CFG.lastFindMovie    = ConfigText(default="")
CFG.lastFindSubtitle   = ConfigText(default="")
CFG.lastFindPackages   = ConfigText(default="")
CFG.lastFindServices   = ConfigText(default="")
CFG.lastFindSatName    = ConfigText(default="")
CFG.lastFindContextFind   = ConfigText(default="")
CFG.lastFindEditor    = ConfigText(default="")
CFG.lastFindGeneral    = ConfigText(default="")
CFG.lastFindRepl_fnd   = ConfigText(default="")
CFG.lastFindRepl_rpl   = ConfigText(default="")
CFG.fontPathMain    = ConfigText(default="")
CFG.fontPathTerm    = ConfigText(default="")
CFG.fontPathAdd     = ConfigText(default="")
CFG.fontPathSys     = ConfigText(default="")
CFG.fontScaleSys    = ConfigInteger(default=100)
CFG.fontAllPerc     = ConfigInteger(default=0)
CFG.transpColorPicons   = ConfigText(default="#11404040")
CFG.transpColorChannels   = ConfigText(default="#88004040")
CFG.epgLangTitle    = ConfigText(default="")
CFG.epgLangDescr    = ConfigText(default="")
CFG.lastFtpLocalPath   = ConfigText(default="")
CFG.lastNetworkDevice   = ConfigInteger(default=0)
CFG.terminalCmdFile    = ConfigText(default="ajpanel_cmd")
CFG.ConfirmTerminalExit   = ConfigYesNo(default=False)
CFG.terminalTextWrap   = ConfigYesNo(default=True)
CFG.terminalFontSizeCmd   = ConfigInteger(default=26, limits=(22, 35))
CFG.terminalFontSizeHist  = ConfigInteger(default=26, limits=(22, 35))
CFG.xmlTvNameCompRatio   = ConfigSelectionNumber(default=50, stepwidth=10, min=40, max=100)
CFG.xmlTvChannelRefFile   = ConfigText(default="")
CFG.wsAutoStart     = ConfigYesNo(default=True)
CFG.wsPort      = ConfigInteger(default=8383)
tmp = [("0", "No Timeout")]
for i in range(3,11): tmp.append((str(i), str(i)))
tmp.extend((("15", "15"), ("20", "20")))
CFG.playerPos     = ConfigInteger(default=0, limits=(0, 1))
CFG.playerJumpMin    = ConfigInteger(default=5, limits=(1, 10))
CFG.playerTimeout     = ConfigSelection(default="0", choices=tmp)
CFG.playerRedBtn    = ConfigSelection(default="e", choices=[("e", "Close Bar & Recall Last DVB Service"),("s", "Show Signal Monitor")])
tmp = [("srt","FROM SRT FILE"),("#00FFFF","Aqua"),("#000000","Black"),("#0000FF","Blue"),("#FF00FF","Fuchsia"),("#808080","Gray"),("#008000","Green"),("#00FF00","Lime"),("#800000","Maroon"),("#000080","Navy"),("#808000","Olive"),("#800080","Purple"),("#FF0000","Red"),("#C0C0C0","Silver"),("#008080","Teal"),("#FFFFFF","White"),("#FFFF00","Yellow")]
CFG.subtBGTransp    = ConfigSelectionNumber(default=100, stepwidth=10, min=0, max=100, wraparound=False)
CFG.subtTextFg     = ConfigSelection(default="#FFFFFF", choices=tmp)
CFG.subtTextFont    = ConfigSelection(default=VVQVcT, choices=[(x,  x) for x in FFHlE6()])
CFG.subtTextSize    = ConfigSelectionNumber(default=50, stepwidth=5, min=30, max=100, wraparound=False)
CFG.subtTextAlign    = ConfigSelection(default="1", choices=[("0", "Left"),("1", "Center"),("2", "Right")])
CFG.subtShadowColor    = ConfigSelection(default="#000080", choices=tmp[1:])
CFG.subtShadowSize    = ConfigSelectionNumber(default=5, stepwidth=1, min=0, max=10, wraparound=False)
CFG.subtVerticalPos    = ConfigSelectionNumber(default=90, stepwidth=1, min=0, max=100, wraparound=False)
CFG.subtDelayMax    = ConfigSelectionNumber(default=10, stepwidth=10, min=10, max=60, wraparound=False)
CFG.subtDelaySec    = ConfigSelectionNumber(default=0, stepwidth=1, min=-CFG.subtDelayMax.getValue() * 60, max=CFG.subtDelayMax.getValue() * 60, wraparound=False)
del tmp
def FFvXmp():
 mode = CFG.mixedColorScheme.getValue()
 if mode == 4:
  if os.path.isfile("/etc/apt/apt.conf"): return 0
  try:
   with open("/etc/issue", "r") as f:
    if iMatch(r"open.*vision", f.read(), IGNORECASE):
     return 1
  except: pass
  return 3
 else:
  return max(min(3, mode), 0)
VV1DPb = FFvXmp()
VVgzFX = VVVAvR = VVsm0W = VVu50a = VVcahY = VVCBkQ = VV6uFd = VVeG3E = VV8QGw = VVnQYw = VVaR8d = VV6UAe = VVi4ay = VVkLs0 = VVUPyu = VVHFlX = ""
def FFn214()  : FFyBXP(FFKh6z())
def FFyIAN()  : FFyBXP(FFSFm0())
def FFMd8X(tDict): FFyBXP(jDumps(tDict, indent=4, sort_keys=True))
def FFfSxt(*args): FFvS1g(1, 1,  *args)
def FFyBXP(*args) : FFvS1g(1 ,0,  *args)
def FF8kNd(*args): FFvS1g(0, 0,  *args)
def FFvS1g(addSep=1, isArray=1, *args):
 if not VVCB0I: return
 sep = (">>>> %s\n" % ("#" * 80)) if addSep else ""
 txt = sep
 if isArray:
  for item in args:
   if type(item) in (list, tuple, set):
    txt += ">>>> --> LIST START <--\n"
    for itm in item: txt += ".... %s\n" % str(itm)
    txt += ">>>> --> LIST END <--\n"
   elif isinstance(item, dict):
    txt += ">>>> LIST START <--\n"
    Len = 0
    for key, val in item.items(): Len = max(Len, len(str(key)))
    for key, val in item.items(): txt += ".... %s: %s\n" % (str(str(key).ljust(Len)), str(val))
    txt += ">>>> LIST END <--\n"
   else:
    txt += "---> %s\n" % str(item)
 else:
  cr = "\n" if addSep else ""
  txt += ">>>> %s%s" % (" , ".join(list(map(str, args))), cr)
 txt += sep.replace("#", "-")
 os.system("cat << '_EOF' \n" + str(txt) + "\n_EOF")
def FF2TA5(fnc):
 def VV4Uti(*args, **kwargs):
  t1 = iTime()
  fnc(*args, **kwargs)
  FFyBXP(">>>>>> Elapsed : %s sec\nargs = %s\nkwargs = %s" % (("%.6f" % (iTime() - t1)).rstrip("0"), args, kwargs))
 return VV4Uti
def FFqYjR(*args):
 t = "[%s] %s >> %s" % (VVryLp, datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), " , ".join(list(map(str, args))))
 os.system("cat << '_EOF' \n%s\n_EOF" % t)
def FFFV4a(*args):
 with open("/tmp/ajpanel_log.txt", "a") as f:
  t =  datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
  f.write("%s %s\n" % (t, " , ".join(list(map(str, args)))))
def FF9UnH(tDict): FFwH0K(jDumps(tDict, indent=4, sort_keys=True))
def FFwH0K(*args):
 if not VVCB0I: return
 path = "/tmp/ajp_log.txt"
 with open(path, "a") as f:
  f.write(">>>> %s\n" % (" , ".join(list(map(str, args)))))
 FF8kNd("Added to : %s" % path)
def FFOPh6(txt, isAppend=True, ignoreErr=False):
 if not VVCB0I: return
 tm = FFm4ac()
 err = "" if not ignoreErr else FFSFm0()
 fileName = "/tmp/ajp_log.txt"
 with open(fileName, "a" if isAppend else "w") as f:
  if err: f.write(err)
  f.write("%s >> %s\n" % (tm, str(txt)))
 if err: FFyBXP(err)
 FFyBXP("Output Log File : %s" % fileName)
def FFSFm0():
 try:
  from traceback import format_exc, format_stack
  trace = format_exc()
  if trace and len(trace) > 5:
   tm = FFm4ac()
   stack = format_stack()[:-1]
   sep = "*" * 70
   err = "\n%s\n*** %s\n%s\n\n" % (sep, tm, sep)
   err += "%s\n\n%s\n%s\n" % ("".join(stack), trace, sep)
   return err
 except:
  return "Cannot Trace !"
def FFKh6z():
 import inspect
 lst = []
 for ndx, f in enumerate(inspect.stack()):
  if ndx > 0:
   lst.append("%s\t>> %s" % (os.path.basename(f[1]).ljust(20), f[3]))
 return "Last Fncs:\n" + "\n".join(lst)
VVk49n = 0
def FFX9Lm():
 global VVk49n
 VVk49n = iTime()
def FFfPdE(txt=""):
 FFyBXP(">>>>>> Elapsed : %s sec\t%s" % (("%.6f" % (iTime() - VVk49n)).rstrip("0"), txt))
def FFQC8W(*args):
 for arg in args:
  if VVryLp[:5].lower() in os.path.basename(arg).lower():
   return True
 return False
def FFK5uM(SELF, keep=""):
 lst = []
 try:
  for w in SELF.session.dialog_stack[::-1]:
   w = w[0]
   if keep and keep in str(w): break
   elif "Plugins.Extensions.AJPan." in str(w): lst.append(w)
 except:
  pass
 return lst
def FFBHAU(SELF):  FFd5UK(SELF, "")
def FF9hlZ(*args): FFd5UK(args[0], ".CCEj76")
def FFd5UK(SELF, keep):
 SELF.close()
 for w in FFK5uM(SELF, keep):
  try: w.close()
  except: pass
def FFdsOh(vTxt):
 if vTxt in globals(): del globals()[vTxt]
def FFQ25W():
 BT_SCALE = BT_KEEP_ASPECT_RATIO = None
 try:
  from enigma import BT_SCALE, BT_KEEP_ASPECT_RATIO
 except:
  try  : from enigma import BT_SCALE, BT_FIXRATIO as BT_KEEP_ASPECT_RATIO
  except : pass
 if BT_SCALE and BT_KEEP_ASPECT_RATIO: return BT_SCALE | BT_KEEP_ASPECT_RATIO
 else        : return None
VVFzqL = FFQ25W()
def getDescriptor(fnc, where, name, descr="", needsRestart=False):
 w = getDesktop(0).size().width()
 if w and w < 1920 : icon="icon.png"
 else    : icon="iconhd.png"
 if name == VVryLp:
  descr = VVk74U
 else:
  if not descr:
   descr = "%s %s" % (VVryLp, name or VVk74U)
  name = "AJ - %s" % name
 return PluginDescriptor(fnc=fnc, where=where, needsRestart=needsRestart, name=name, description=descr, icon=icon)
def FFmiJ9()  : return getDescriptor(FF0e0O , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "File Manager")
def FFexgg() : return getDescriptor(FFGIA1  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "IPTV Menu")
def FFOjLJ()  : return getDescriptor(FFmN8A   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Movies Resume History")
def FFCzIT()  : return getDescriptor(FFjD3z  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Player Bar")
def FFazVz(): return getDescriptor(FFyDzZ, [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Plugin Browser")
def FF0Vk6()  : return getDescriptor(FF6CSF   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Signal Monitor")
def FFn1lr() : return getDescriptor(FFQsve  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Terminal")
def FFBYWY() : return getDescriptor(FF8Wn9  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], CCNm9T.VVQ894())
def FFA4vG()      : return getDescriptor(FFaUW7 , [ PluginDescriptor.WHERE_EVENTINFO  ], "Service Information")
def Plugins(**kwargs):
 lst = [ getDescriptor(FFkIjg , [PluginDescriptor.WHERE_PLUGINMENU], VVryLp, needsRestart=True)
  ,   getDescriptor(FFVoFG , [PluginDescriptor.WHERE_MENU]   , VVryLp)
  ,   PluginDescriptor(fnc=FFeYeX, where=[PluginDescriptor.WHERE_SESSIONSTART], needsRestart=True, description="AJPanel Startup")
  ]
 if CFG.showInExtensionMenu.getValue():
  lst.append(FFmiJ9())
  lst.append(FFexgg())
  lst.append(FFCzIT())
  lst.append(FFazVz())
  lst.append(FF0Vk6())
  lst.append(FFn1lr())
  lst.append(FFBYWY())
  lst.append(FFOjLJ())
 if CFG.EventsInfoMenu.getValue():
  lst.append(FFA4vG())
 return lst
def FFeYeX(reason, **kwargs):
 if reason == 0:
  FFH0EA()
  CCV3QD.VVAChB()
  CCEj76.VVG6En()
  if "session" in kwargs:
   session = kwargs["session"]
   FFHbVQ(session)
   CCOwzx(session)
   if CFG.wsAutoStart.getValue():
    CCvOXK(session).VV7xyw(True)
def FFVoFG(menuid, **kwargs):
 if menuid == "mainmenu" and CFG.showInMainMenu.getValue():
  return [(VVryLp, FFkIjg, VVryLp, 1)]
 else:
  return []
def FFkIjg(session, **kwargs):
 session.open(CCEj76)
def FF0e0O(session, **kwargs) : session.open(CCQdsv)
def FFGIA1(session, **kwargs)  : session.open(CCSB3R)
def FFmN8A(session, **kwargs)    : session.open(CCBoou)
def FFjD3z(session, **kwargs)  : CC2lVw.VVbVSZ(session, VVMjFx=2)
def FFyDzZ(session, **kwargs): CCF1F0.VVvLoF(session)
def FF6CSF(session, **kwargs)   : FFNSo6(session, reopen=True)
def FFQsve(session, **kwargs)  : session.open(CCz488)
def FF8Wn9(session, **kwargs)  : CCNm9T.VVVT2N(session, True)
def FFaUW7(session, **kwargs):
 CCISy5.VViCdN(session)
def FFHbVQ(session):
 hk = None
 dm = FFujkg()
 if dm:
  try:
   from keymapparser import readKeymap
   readKeymap(VVL26S + "keymap.xml")
   from GlobalActions import globalActionMap as hk
  except:
   pass
 else:
  cont = ["KeyMap_HK"]
  try: hk = ActionMap(contexts=cont, prio=1, parentScreen=session.screen)
  except: hk = ActionMap(contexts=cont, prio=0 if CC6z2a.VVOCgj() else 1)
  hk.execBegin()
 if hk:
  hk.actions["longOK"] = BF(FFygVL, session, "lok")
  hk.actions["longCancel"]= BF(FFygVL, session, "lesc")
  hk.actions["longRed"] = BF(FFygVL, session, "lred")
  for k in (CCHa3c.VVKLUU, CCHa3c.VVsvPZ, CCHa3c.VVYZRp):
   hk.actions[k] = BF(CCHa3c.VVWQmH, session, k, dm)
def FFygVL(session, key):
 if CCHa3c.VVvPJO(session) or CFG.hotkey_signal.getValue() != key:
  return
 try:
  if CCK62W.VVm49H:
   CCK62W.VVm49H.close()
  if not CC2lVw.VVHlBB:
   CC2lVw.VVbVSZ(session, VVMjFx=1)
 except:
  pass
def FFDDwF(confItem, val):
 confItem.setValue(val)
 confItem.save()
 configfile.save()
def FF0kJX(confItem):
 if isinstance(confItem, ConfigSelectionNumber):
  if confItem.saved_value is None and str(confItem.value) == str(confItem.default):
   return False
  return str(confItem.value) != str(confItem.saved_value)
 else:
  return confItem.isChanged()
def FFfmZP(SELF, title="", addLabel=False, addScrollLabel=False, VVXXzc=None, addCloser=False):
 Screen.__init__(SELF, SELF.session)
 if title: title = "  %s  " % title
 else : title = "" if SELF.VVuaAL["VVHdm7"] == VVMfHP else FFQfhO()
 SELF["myTitle"] = Label(title)
 SELF["myBody"] = Label()
 SELF["myWP"] = Pixmap()
 SELF["myInfoFrame"] = Label()
 SELF["myInfoBody"] = Label()
 SELF.VVYcwt = eTimer()
 try: SELF.VVTOLZ = SELF.VVYcwt.timeout.connect(BF(FFsNEE, SELF))
 except: SELF.VVYcwt.callback.append(BF(FFsNEE, SELF))
 SELF.onClose.append(SELF.VVYcwt.stop)
 FFsNEE(SELF)
 btnMode = SELF.VVuaAL["VV1fgG"]
 if btnMode in (1, 2): SELF["keyMenu"] = Pixmap()
 if btnMode in (2, 3): SELF["keyInfo"] = Pixmap()
 if SELF.VVuaAL["VVZ3ZU"] > 0:
  SELF["myBar"]  = Label()
  SELF["myLine"]  = Label()
  SELF["keyRed"]  = Label()
  SELF["keyGreen"] = Label()
  SELF["keyYellow"] = Label()
  SELF["keyBlue"]  = Label()
  SELF["keyRed"].hide()
  SELF["keyGreen"].hide()
  SELF["keyYellow"].hide()
  SELF["keyBlue"].hide()
 if addLabel:
  SELF["myLabel"] = Label()
 if addScrollLabel:
  SELF["myLabel"] = CCxtRQ(SELF)
 if VVXXzc:
  SELF["myMenu"] = MenuList(VVXXzc, True)
  FFewq4(SELF,
  {
   "ok" : SELF.VVTOku ,
   "cancel": SELF.close ,
  })
 if addCloser:
  FFewq4(SELF,
  {
   "ok" : SELF.close,
   "cancel": SELF.close,
   "red" : SELF.close
  })
def FFewq4(SELF, tDict, name="", prio=-1):
 name = name or "myActionMap"
 try: SELF[name] = ActionMap(contexts=VVh3eS, actions=tDict, prio=prio, parentScreen=SELF.session.screen)
 except: SELF[name] = ActionMap(contexts=VVh3eS, actions=tDict, prio=prio)
def FFyNtd(SELF, tDict, name=""):
 SELF[name or "myActionMap"].actions.update(tDict)
def FFRo1g(SELF, name=""):
 SELF[name or "myActionMap"].actions.clear()
def FFQfhO():
 return ("  %s" % VVhZdB)
def FFiaTH(SELF):
 global VVhZdB
 VVhZdB = SELF["myMenu"].l.getCurrentSelection()[0]
 return SELF["myMenu"].l.getCurrentSelection()[1]
def FFrvOP(btn, txt):
 btn.setText(txt)
 if txt : btn.show()
 else : btn.hide()
def FFes9J(txt):
 if r"\c" in txt:
  txt = iSub(r"\\c(.){8}" ,"" , txt, flags=IGNORECASE)
 return txt
def FF2xYM(txt):
 while txt.startswith(("#f#", "#b#")):
  txt = txt[12:]
 return txt
def FFEIV2(color):
 return parseColor(color).argb()
def FFcfsH(obj, fg): FFNucL(obj, fg, "", inv=True)
def FFu0W6(obj, bg): FFNucL(obj, "", bg, inv=True)
def FFNucL(obj, fg, bg, inv=True):
 if fg: obj.instance.setForegroundColor(parseColor(fg))
 if bg: obj.instance.setBackgroundColor(parseColor(bg))
 if inv: obj.instance.invalidate()
def FF0VVA(txt, color):
 if color:
  if "/" in txt: txt = txt.replace("/", r"\/")
  return r" | sed 's/%s/\\%s&\%s/gI'" % (txt, color, VVHFlX)
 else:
  return ""
def FFUpXM(word, color):
 if color: return r"echo -e '\%s%s\n--- %s\n%s\%s';" % (color, SEP, word, SEP, VVHFlX)
 else : return r"echo -e '%s\n--- %s\n%s';" % (SEP, word, SEP)
def FFITtK(word, color, backToColor=None):
 if backToColor : return color + str(word) + backToColor
 else   : return color + str(word) + VVHFlX
def FFuaF5(color):
 if color: return "echo -e '%s' %s;" % (SEP, FF0VVA(SEP, VVaR8d))
 else : return "echo -e '%s';" % SEP
def FFiN5A(title, color):
 title = "%s\n%s\n%s\n" % (SEP, title, SEP)
 return FFITtK(title, color)
def FFTDN6(menuObj, fg="#00ffffff", bg="#08005555"):
 menuObj.instance.setForegroundColorSelected(parseColor(fg))
 menuObj.instance.setBackgroundColorSelected(parseColor(bg))
def FFDiNL(fncCB):
 FFtPqW(":", BF(FFfxb7, fncCB))
def FFfxb7(fncCB, result, retval):
 fncCB()
def FFUttZ(SELF, delay, fnc):
 SELF.timedFncTimer = eTimer()
 try: SELF.timedFncTimer_conn = SELF.timedFncTimer.timeout.connect(fnc)
 except: SELF.timedFncTimer.callback.append(fnc)
 SELF.timedFncTimer.start(delay, True)
def FFTSvN(SELF, fnc, title="Processing ...", clearMsg=True):
 FF8PJn(SELF, title)
 FFtPqW(":", BF(FFRpQ0, SELF, fnc, clearMsg))
def FFRpQ0(SELF, fnc, clearMsg, result, retval):
 fnc()
 if clearMsg:
  FF8PJn(SELF)
def FFHDdB(session, fnc, title="Processing ..."):
 session.open(CCssxL, fnc, title)
def FFHF2S(title="Processing ...", clearMsg=True, par=0, tNdx=-1):
 def VVEyAm(fnc):
  def VV4Uti(*args, **kwargs):
   FFTSvN(args[par], BF(fnc, *args, **kwargs), args[tNdx] if tNdx > -1 else title, clearMsg)
  return VV4Uti
 return VVEyAm
def FFdV6p(cmd):
 from subprocess import Popen, PIPE
 try:
  process = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
  stdout, stderr = process.communicate()
  stdout = stdout.strip()
  stderr = stderr.strip()
  if stderr : return stderr
  else  : return stdout
 except Exception as e:
  if "memory" in str(e).lower(): return VVaw89
  else       : return ""
def FFunRV(cmd, trim=True):
 lst = FFdV6p(cmd).splitlines()
 if trim : return list(map(str.strip, lst))
 else : return lst
def FFhWCj(cmd):
 lines = FFunRV(cmd)
 if lines: return lines[0]
 else : return ""
def FF2gLS(cmd):
 tFile = "/tmp/ajp_lines"
 FFqlCI(tFile)
 FFdV6p("%s > %s" % (cmd, tFile))
 lst = FF2iRW(tFile)
 FFqlCI(tFile)
 return lst
def FFtPqW(cmd, cbFnc):
 global VVmOn9
 VVmOn9 = CCqTV0()
 VVmOn9.VVyeGQ(cmd, cbFnc)
def FF6usE(cmd):
 return os.system(FFDTPf(cmd)) == 0
def FF6BfM(cmd):
 return os.system(FFUMSl(cmd)) == 0
def FFDTPf(cmd)  : return cmd.rstrip("\t; ") + " > /dev/null 2>&1;"
def FFUMSl(cmd) : return cmd.rstrip("\t; ") + " 2> /dev/null;"
def FFpL0U(    SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, VV4v81=True, VVPsQd=VV73ng, **kwargs)
def FFMdwM(  SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, **kwargs)
def FF3BM3(   SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, VVR4HM=True, VVwMgk=True, VVPsQd=VV73ng, **kwargs)
def FFyWVZ(  SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, VVR4HM=True, VVwMgk=True, VVPsQd=VVtU2A, **kwargs)
def FFNQkI(  SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, VVDClQ=True , **kwargs)
def FF3rcG(  session, cmd, **kwargs):      session.open(CCNqUU, VVqx93=cmd, VVDClQ=True , **kwargs)
def FF4uzP( SELF, cmd, **kwargs): SELF.session.open(CCNqUU, VVqx93=cmd, VVZ1IW=True  , **kwargs)
def FFsGnd(cmd):
 return FF6usE("which %s" % cmd)
def FFzyl2(cmd):
 if FFsGnd(cmd): return True, "BusyBox" in FFdV6p("%s --help" % cmd)
 else   : return False, False
def FFpr6N():
 cmd = "if [ -f /etc/apt/apt.conf ]; then echo dpkg; else if [ -f /etc/opkg/opkg.conf ]; then echo opkg; else if which dpkg; then echo dpkg; else if which opkg; then echo opkg; else if which ipkg; then echo ipkg; else echo ''; fi; fi; fi; fi; fi"
 return FFhWCj(cmd)
def FFujkg():
 return FFf0vs("/etc/apt/apt.conf")
def FFoSAW(mode, moreDirs=None):
 if mode == 0:
  dirs = [ "*boot*", "*/ba", "/proc" ]
 else:
  dirs = [  "*boot*"
    , "*picon*"
    , "*/ba"
    , "/bin"
    , "/dev"
    , "/hdd"
    , "/lib"
    , "/linuxrc"
    , "/mnt"
    , "/newroot"
    , "/proc"
    , "/run"
    , "/sbin"
    , "/sys"
    , "/usr"
    ]
 if moreDirs:
  dirs.extend(moreDirs)
 paths = []
 for item in dirs:
  paths.append("-ipath '%s'" % item)
 txt = " -o ".join(paths)
 return r"-type d \( %s \) -prune -o " % txt
VVtAyn     = 0
VVqwax      = 1
VV2z4R      = 2
VVWBay      = 3
VV6GVy     = 4
VVEEmk     = 5
VVUWS4     = 6
VVV8Uu = 7
VVEY1Y = 8
VV6Aie = 9
VVWy79  = 10
VVfSvc     = 11
VVpt2P  = 12
VVcXNB  = 13
VVsKJh      = 14
VVeaGm     = 15
def FFKA8e(parmNum, grepTxt=""):
 if   parmNum == VVtAyn: param = ["update" , "apt-get update" ]
 elif parmNum == VVqwax : param = ["list" , "apt list"  ]
 pkg = FFpr6N()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], grepTxt)
 elif pkg == "dpkg"   : return "%s %s" % (param[1]  , grepTxt)
 return ""
def FFiD2M(mode, package):
 if   mode == VV2z4R      : param = ["info"      , "apt show"]
 elif mode == VVWBay     : param = ["files"      , "dpkg -L"]
 elif mode == VV6GVy     : param = ["search"      , "dpkg -S"]
 elif mode == VVEEmk     : param = ["download"     , "apt-get download"]
 elif mode == VVUWS4     : param = ["install"     , "apt-get install -y"]
 elif mode == VVV8Uu : param = ["install --force-reinstall" , "apt-get install --reinstall -y"]
 elif mode == VVEY1Y : param = ["install --force-overwrite" , "dpkg -i --force-all"]
 elif mode == VV6Aie : param = ["install --force-downgrade" , "apt-get install --allow-downgrades -y"]
 elif mode == VVWy79 : param = ["install --force-depends" , "apt-get install --no-install-recommends -y"]
 elif mode == VVfSvc     : param = ["remove"      , "apt-get purge --auto-remove -y"]
 elif mode == VVpt2P  : param = ["remove --force-remove"  , "dpkg --purge --force-all"]
 elif mode == VVcXNB : param = ["remove --force-depends"  , "dpkg --remove --force-depends"]
 elif mode == VVsKJh      : param = ["flag hold"     , "apt-mark hold"]
 elif mode == VVeaGm     : param = ["flag user"     , "apt-mark unhold"]
 else           : return ""
 if package:
  package = "'%s'" % package
 pkg = FFpr6N()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], package)
 elif pkg == "dpkg"   : return "%s %s" % (param[1], package)
def FFkDck():
 result = FFhWCj("ar -V 2> /dev/null | grep 'GNU ar'")
 if result.startswith("GNU ar"):
  cmd = " allOK='1';"
 else:
  notFoundCmd = " echo -e 'GNU \"ar\" command not found!';"
  installCmd = FFiD2M(VVUWS4, "")
  if installCmd:
   verCmd = "FOUND=$(ar -V 2> /dev/null | grep 'GNU ar');"
   failed1 = "Please update your software or manually install \"ar\" command and try again."
   failed2 = "(\"ar\" is available in the packages : \"opkg-tools\" or \"binutils\")"
   failed3 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += verCmd
   cmd += 'if [[ -z "$FOUND" ]]; then '
   cmd +=   notFoundCmd
   cmd += "  echo -e 'Trying to install \"opkg-Tools\" ...';"
   cmd +=    FFDTPf("%s enigma2-plugin-extensions-opkg-tools" % installCmd)
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += " echo -e 'Trying to install \"binutils\" ...';"
   cmd +=   FFDTPf("%s binutils" % installCmd)
   cmd += " fi;"
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += "  echo -e 'Installation failed !';"
   cmd += "  echo -e '%s' %s;"  % (failed1, FF0VVA(failed1, VVaR8d))
   cmd += "  echo -e '%s' %s;"  % (failed2, FF0VVA(failed2, VVaR8d))
   cmd += "  echo -e '\n%s' %s;" % (failed3, FF0VVA(failed3, VVsm0W))
   cmd += " else"
   cmd += "  echo -e 'Installed successfully.';"
   cmd += "  allOK='1';"
   cmd += " fi;"
   cmd += "else"
   cmd += "  allOK='1';"
   cmd += "fi;"
  else:
   cmd = " allOK='0';"
   cmd += notFoundCmd
 return cmd
def FF3F9l(commandTool, toolPkgName, displayedName):
 cmd1 = ""
 installCmd = FFiD2M(VVUWS4 , "")
 if installCmd:
  failed1 = "Please update your software and try again."
  failed2 = "Process Failed."
  cmd1 += " echo -e '%s not found.';" % displayedName
  cmd1 += " echo -e 'Trying to install ...';"
  cmd1 +=   FFDTPf("%s %s" % (installCmd, toolPkgName))
  cmd1 += " FOUND=$(which  %s);"  % commandTool
  cmd1 += ' if [[ -z "$FOUND" ]]; then '
  cmd1 += "  echo -e 'Installation failed !';"
  cmd1 += "  echo -e '%s\n' %s;" % (failed1, FF0VVA(failed1, VVaR8d))
  cmd1 += "  echo -e '%s' %s;" % (failed2, FF0VVA(failed2, VVsm0W))
  cmd1 += " else"
  cmd1 += "  echo -e 'Installed successfully.';"
  cmd1 += "  allOK='1';"
  cmd1 += " fi;"
 else:
  cmd1 += " echo -e '%s not found.';" % displayedName
 cmd  = " allOK='0';"
 cmd += "FOUND=$(which %s);" % commandTool
 cmd += 'if [[ -z "$FOUND" ]]; then '
 cmd +=   cmd1
 cmd += "else"
 cmd += "  allOK='1';"
 cmd += "fi;"
 return cmd
def FFlMQJ():
 pFound, pBBox = FFzyl2("xz")
 if pFound:
  if pBBox:
   failed1 = "Please update your software and try again."
   failed2 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += "echo -e 'Found BusyBox xz';"
   cmd += "echo -e 'Upgrading xz ...';"
   cmd +=  FFDTPf("%s" % FFiD2M(VVUWS4 , "xz"))
   cmd += "if [ $? -eq 0 ]; then"
   cmd += " echo -e 'Installed successfully.';"
   cmd += " allOK='1';"
   cmd += "else"
   cmd += " echo -e 'Installation failed !';"
   cmd += " echo -e '%s' %s;" % (failed1, FF0VVA(failed1, VVaR8d))
   cmd += " echo -e '\n\n%s' %s;" % (failed2, FF0VVA(failed2, VVsm0W))
   cmd += "fi;"
   return cmd
  else:
   return " allOK='1';"
 else:
  return FF3F9l("xz", "xz", "XZ")
def FF05rJ(path, maxSize=-1, encLst=None):
 if   encLst is None    : encLst = CC2Ldo.VV8NYe()
 elif isinstance(encLst, str) : encLst = [encLst]
 txt = ""
 for enc in encLst:
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    txt = f.read(maxSize)
    txt = str(txt)
   break
  except:
   pass
 if txt.startswith(chr(239) + chr(187) + chr(191)):
  txt = txt[3:]
 return txt
def FF2iRW(path, keepends=False, maxSize=-1, encLst=None):
 txt = FF05rJ(path, maxSize, encLst=encLst)
 return txt.splitlines(keepends)
def FFGPHz(SELF, path, encLst=None):
 title = os.path.basename(path)
 if FFf0vs(path):
  maxSize = 60000
  if (FFX42v(path) > maxSize):
   title="File too big (showing first 60kB only)"
  else:
   maxSize = -1
  lines = FF05rJ(path, maxSize=maxSize, encLst=encLst)
  if lines: FFyijw(SELF, lines, title=title, VVPsQd=VV73ng, width=1600, height=1000, VVNYa4=30, resize=False)
  else : FFMgxa(SELF, path, title=title)
 else:
  FFbHk5(SELF, path, title)
def FFpIdO(SELF, fName, title):
 path = VV30Jg + fName
 if FFf0vs(path):
  txt = FF05rJ(path)
  for k, v in {"#W#":VVHFlX,"#Y#":VV6UAe,"#G#":VVVAvR,"#Gn#":VV8QGw,"#C#":VVkLs0,"#P#":VVcahY}.items():
   txt = txt.replace(k, v)
  FFyijw(SELF, txt, title=title, width=1600)
 else:
  FFbHk5(SELF, path, title)
def FFi2MT(path):
 if VVrRHR(path):
  tList = os.listdir(path)
  if tList:
   dirs = []
   for item in tList:
    if os.path.isdir(path + item):
     dirs.append(item)
   if dirs:
    dirs.sort()
    return dirs
 return []
def FF5AKn(path, addTrailingSlash):
 parent = os.path.abspath(os.path.join(path, os.pardir))
 if addTrailingSlash : return FFA4GT(parent)
 else    : return FFHP0y(parent)
def FFVUvT(path):
 return os.path.basename(os.path.normpath(path))
def FFsnOK(path):
 try:
  os.mkdir(path)
  return "" if VVrRHR(path) else "Cannot create dir !"
 except Exception as e:
  return str(e)
def FFX42v(path):
 try:
  if os.path.islink(FFHP0y(path)): return os.lstat(path).st_size
  elif os.path.isfile(path)    : return os.path.getsize(path)
 except:
  pass
 return -1
def FFzhsp(path):
 p = FFHP0y(path)
 if   os.path.islink(p) : return "SymLink"
 elif os.path.ismount(p) : return "Mount"
 elif os.path.isfile(p) : return "File"
 elif os.path.isdir(p) : return "Directory"
 else     : return ""
def FFT3Nn(path):
 size = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   try:
    if os.path.islink(FFHP0y(fp)) : size += os.lstat(fp).st_size
    elif os.path.isfile(fp)     : size += os.path.getsize(fp)
   except:
    pass
 return size
def FFhWIm(path):
 totDir = totFile = totLink = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   if os.path.islink(FFHP0y(fp)) : totLink += 1
   elif os.path.isfile(fp)     : totFile += 1
   else         : totDir += 1
 return totDir, totFile, totLink
def FFqlCI(path):
 try: os.remove(path)
 except: pass
def FFelXn(path):
 try: rmtree(path)
 except: pass
def FFQQ78(path):
 FF6usE("chattr -AacDdijsStu '%s' &> /dev/null; rm -fr '%s'" % (path, path))
 FFqlCI(path)
 FFelXn(path)
def FFW48g():
 FF6usE("rm -rf /tmp/ajp_*")
def FFxGSn(path):
 with open(path, "rb+") as f:
  try:
   f.seek(-1, 2)
   if ord(f.read(1)) not in (10, 13):
    f.write(b"\n")
  except:
   pass
def FFyxsN(path):
 return FF6usE("cp -f '%s' '%s.bak'" % (path, path))
def FFA4GT(path):
 if not path.endswith("/"):
  path += "/"
 return path
def FFHP0y(path):
 if not path == "/":
  path = path.rstrip("/")
 return path
def FFYjQm(path, patt):
 if "[" in path or "]" in path:
  newPath = ""
  for char in path:
   if   char == "[": char = "[[]"
   elif char == "]": char = "[]]"
   newPath += char
 else:
  newPath = path
 return iGlob("%s%s" % (FFA4GT(newPath), patt))
def FFfrZf():
 sigFile = "ajpanel_res_marker"
 try:
  p = os.path.abspath(os.path.dirname(__file__))
  if p:
   mainP = os.path.join(p, "")
   resP = os.path.join(p, "res", "")
   if FFf0vs(os.path.join(resP, sigFile)):
    return mainP, resP
 except:
  pass
 paths = []
 paths.append(VVSaol)
 paths.append(VVSaol.replace("lib", "lib64"))
 ba = "/media/ba/ba/"
 list = FFi2MT(ba)
 for p in list:
  p = ba + p + VVSaol
  paths.append(p)
 for p in paths:
  p = os.path.join(p, VVAH7M, "")
  if FFf0vs(os.path.join(p, "res", sigFile)):
   mainP = os.path.join(p, "")
   resP = os.path.join(mainP, "res", "")
   return mainP, resP
 mainP = os.path.join(VVSaol, VVAH7M , "")
 resP = os.path.join(mainP, "res", "")
 return mainP, resP
VVL26S, VV30Jg = FFfrZf()
def FFH0EA(SELF=None):
 tLst = ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", "/")
 bDir = FFmAG5()
 if not VVrRHR(bDir) or bDir in tLst:
  for p in tLst:
   newP = p + "ajpanel_backup/"
   if VVrRHR(p) and FF6usE("mkdir -p %s" % newP):
    bDir = newP
    break
 VVdxaU = ""
 mvDir = FFA4GT(CFG.MovieDownloadPath.getValue())
 if not VVrRHR(mvDir) or not mvDir.endswith("/movie/"):
  for p in ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", bDir, "/"):
   tmpP = p + "movie/"
   if VVrRHR(p) and FF6usE("mkdir -p %s" % tmpP):
    CFG.MovieDownloadPath.setValue(tmpP)
    CFG.MovieDownloadPath.save()
    VVdxaU = mvDir
    break
 def VVYI7z(item):
  path = item.getValue()
  if not VVrRHR(path) or path in tLst:
   item.setValue(bDir)
   item.save()
   return path
  return ""
 VV6lw7  = VVYI7z(CFG.backupPath)
 VV90uy = VVYI7z(CFG.customMenuPath)
 if any((VV6lw7 or VV90uy or VVdxaU)):
  configfile.save()
  if SELF:
   VVEQGt = lambda subj, oldP, newP: "%s:\n    From\t: %s\n    To\t: %s\n\n" % (FFITtK(subj, VV6UAe), FFITtK(oldP, VVsm0W), FFITtK(newP, VVnQYw)) if oldP and newP and oldP != "/" and oldP != newP else ""
   txt  = VVEQGt("Backup/Restore Path"    , VV6lw7   , CFG.backupPath.getValue())
   txt += VVEQGt("Custom Menu"      , VV90uy  , CFG.customMenuPath.getValue())
   txt += VVEQGt("Movie/Series Download"   , VVdxaU , CFG.MovieDownloadPath.getValue())
   if txt.strip():
    txt = "The following directories were reset to default:\n\n%s\nYou can change paths from Settings.\n" % txt
    FFyijw(SELF, txt, title="Settings Paths")
def FFmAG5():    return FFA4GT(CFG.backupPath.getValue())
def FFg1mx():  return FFfmce("export")
def FFY5i9():   return FFfmce("iptv")
def FF7GbY():     return FFfmce("logo")
def FFJOWV(): return FFfmce("pkg_download")
def FFsiHs():  return FFfmce("pkg_project")
def FFi8bi():   return FFfmce("screenshot")
def FFW675():  return FFfmce("share")
def FFfmce(p):
 bPath = FFmAG5()
 p = bPath + FFA4GT("ajpanel_" + p)
 return p if (VVrRHR(p) or FF6usE("mkdir -p '%s'" % p)) else bPath
def FFI5rG():
 lst = []
 for nm in ("Portal", "Playlist"): lst.extend(FFYjQm(FFmAG5(), "%s_Bookmarks*.txt" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FFY5i9() + os.path.basename(oldF)
   if not FFf0vs(newF): FF6usE("mv '%s' '%s'" % (oldF, newF))
def FFgqIf():
 lst = []
 for nm in ("ref", "data"): lst.extend(FFYjQm(FFmAG5(), "ajpanel_share_%s_*.xml" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FFW675() + os.path.basename(oldF)
   if not FFf0vs(newF): FF6usE("mv '%s' '%s'" % (oldF, newF))
def FFoSpw():
 lst = FFYjQm(FFmAG5(), "ajpanel_package_*")
 for oldP in lst:
  if os.path.isdir(oldP):
   newP = FFsiHs() + os.path.basename(oldP)
   if not VVrRHR(newP):
    FF6usE("cp -r '%s' '%s' && rm -r '%s'" % (oldP, newP, oldP))
def FF7Qtj(path):
 path = FFHP0y(path)
 target = ""
 try:
  if VVrRHR(path) and os.path.islink(path):
   target = os.readlink(path)
 except:
  pass
 return target
def FF1uow(SELF):
 btnMode = SELF.VVuaAL["VV1fgG"]
 if btnMode in (1, 2): FFgfSp(SELF["keyMenu"], "menu")
 if btnMode in (2, 3): FFgfSp(SELF["keyInfo"], "info")
def FFbO0w(pixmap, path):
 p = FF0T82(path)
 if p:
  pixmap.instance.setScale(1)
  pixmap.instance.setPixmap(p)
 return p
def FFgfSp(pixmap, fName):
 return FFbO0w(pixmap, "%s%s%s" % (VV30Jg, fName, ".png"))
def FF0T82(path):
 try:
  p = LoadPixmap(path)
  if p: return p
 except:
  pass
 return None
def FF3CFU(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satName = ""
  try:
   satName = nimmanager.getSatName(satNum)
  except:
   pass
  if not satName or "N/A" in satName:
   satName = FFhCU0(satNum)
  return satName
def FFhCU0(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satDir = "E"
  if satNum > 1800:
   satDir = "W"
   satNum = 3600 - satNum
  satNum /= 10.0
  return "%s%s" % (str(satNum), satDir)
def FFkz1q(VVDhju, isLong):
 sat = ""
 if VVDhju.count(":") > 8:
  nameSpace = VVDhju.split(":")[6]
  s   = nameSpace.zfill(8)[:4]
  val   = int(s, 16)
  if isLong : sat = FF3CFU(val)
  else  : sat = FFhCU0(val)
 return sat
def FFYWFN(sat):
 try:
  s = sat.upper()
  if s.endswith("E") or s.endswith("W"):
   num = float(sat[:-1]) * 10
   if s.endswith("W"):
    num = 3600 - num
   return FF3CFU(num)
 except:
  pass
 return sat
def FFOg1j(satNumStr):
 satDir = "E"
 satNum = int(satNumStr)
 if satNum < 0:
  satDir = "W"
 satNum /= 10.0
 return "%s%s" % (str(abs(satNum)), satDir)
def FFGxNQ(SELF):
 s = CCaZ62(SELF.session)
 return s.VVDhju, s.VVu69c, s.VVQwVu, s.VVLZ0Z, s.VVeZBd
def FF7SHi(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1  : return ""
  elif v in (-2, 1) : return info.getInfoString(param)
  else    : return str(v)
 else:
  return ""
def FFSeHR(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1: return ""
  elif v == -2: return info.getInfoString(param)
  else  : return str(v)
 else:
  return ""
def FFKQxn(VVDhju, VVLZ0Z, VVeZBd):
 if VVLZ0Z : return VVLZ0Z.replace(":" + VVeZBd, "")
 else  : return VVDhju
def FFCbnj(VVDhju):
 info = FF5HY0(VVDhju)
 return info and info.getName(eServiceReference(VVDhju)) or ""
def FFC21b(VVDhju):
 try:
  ns = VVDhju.split(":")[6]
  ns = ns.zfill(8)[:4]
 except:
  ns = ""
 return ns.upper()
def FFrhwJ(path, fName):
 if os.path.isfile(path + fName):
  return fName
 else:
  if fName.count("_") > 8:
   parts = fName.split("_")
   parts[2] = "1"
   fName = "_".join(parts)
   if os.path.isfile(path + fName):
    return fName
 return ""
def FF5HY0(VVDhju):
 service = eServiceReference(VVDhju)
 info = None
 if service:
  VVTQSe = eServiceCenter.getInstance()
  if VVTQSe:
   info = VVTQSe.info(service)
 return info
def FF5deK(session, VVDhju, checkParentalControl=False, VVlFbr=False):
 if VVDhju.count(":") > 8:
  serviceRef = eServiceReference(str(VVDhju))
  servRef = eServiceReference(VVDhju)
  session.nav.playService(servRef, checkParentalControl=checkParentalControl)
 try:
  VVI3vF = InfoBar.instance
  if VVI3vF:
   VVokbs = VVI3vF.servicelist
   if VVokbs:
    servRef = eServiceReference(VVDhju)
    VVokbs.saveChannel(servRef)
    if VVlFbr: VVokbs.VVMWh1(servRef)
 except:
  pass
def FFi8da(session, serviceRef, checkParentalControl=False):
 session.nav.playService(serviceRef, checkParentalControl=checkParentalControl)
def FFPrVr(VVDhju):
 return iMatch(r"([A-Fa-f0-9]+[:]){10}.+\/\/.+", VVDhju)
def FF2eiM(ref):
 return bool(iMatch(r"^[A-Fa-f0-9]+:64:", ref or ""))
def FFDGYu(ref):
 return "FROM BOUQUET " in ref.upper()
def FFOr4F(ref):
 if "chcm=" in ref.lower(): return False
 else      : return bool(iMatch(r".*https?(:|%3a)\/\/((127|0)\.\d+\.\d+\.\d+|localhost)(:|%3a)\d+\/.*", ref, IGNORECASE))
def FF6Jet(url)  : return CCxgvM.VV1lfy(url)
def FFBaXf(url)  : return FF6Jet(url) == "VOD"
def FFJoTR(url)  : return FF6Jet(url) == "Series"
def FFzNJJ(url): return FF6Jet(url) in ("VOD", "Series")
def FF0rS9(url):
 if url and iUnquote : return iUnquote(url)
 else    : return url
def FFma3M(url):
 if url and iQuote : return iQuote(url)
 else    : return url
def FFEkBW(txt):
 return hashlib.md5(txt.encode("UTF-8")).hexdigest()
def FF5VBY(txt):
 try:
  return str(b64encode(txt.encode("utf-8")).decode("utf-8"))
 except:
  return txt
def FFG0BS(txt):
 try:
  return str(b64decode(txt).decode("utf-8"))
 except:
  return txt
def FFyVyt(txt):
 try:
  return FF5VBY(FFG0BS(txt)) == txt
 except:
  return False
def FFNSo6(session, reopen=False):
 if reopen:
  try:
   session.openWithCallback(BF(FFNSo6, session), CCK62W)
  except:
   try:
    FFZMNU(session, "Cannot launch Signal Monitor !", title="Signal Monitor")
   except:
    pass
def FFPNoO(VVDhju):
 tp = CCAAmm()
 if tp.VV8YJD(VVDhju) : return True
 else        : return False
def FFYzNS(VVDhju, isHide, skipReload=False):
 if VVDhju.count(":") > 8:
  sRef = eServiceReference(VVDhju)
  if sRef:
   db = eDVBDB.getInstance()
   if db:
    if isHide : ret = db.addFlag(sRef , 0x2)
    else  : ret = db.removeFlag(sRef, 0x2)
    if skipReload:
     return True if ret == 0 else False
    elif ret == 0:
     FFfve1(True)
     return True
 return False
def FFfve1(save=False):
 db = eDVBDB.getInstance()
 if db:
  if save:
   db.saveServicelist()
  db.reloadServicelist()
  db.reloadBouquets()
 FF1p2N()
def FF1p2N():
 VVI3vF = InfoBar.instance
 if VVI3vF:
  VVokbs = VVI3vF.servicelist
  if VVokbs:
   VVokbs.setMode()
def FFaKV3(root, mode=0):
 lst = []
 try:
  servicelist  = root and eServiceCenter.getInstance().list(root)
  VVTQSe = eServiceCenter.getInstance()
  if servicelist:
   while True:
    service = servicelist.getNext()
    if not service.valid():
     break
    flags = service.flags
    if mode == 0 and service.flags & (eServiceReference.isDirectory | eServiceReference.isMarker):
     continue
    ref, info = service.toString(), VVTQSe.info(service)
    name = info.getName(service)
    if   mode == 0: lst.append((ref, name))
    elif mode == 1: lst.append((ref, name, flags))
 except:
  pass
 return lst
def FFhJdE():
 VVgAfG = {0x01:"TV MPEG-2 SD",0x02:"Radio MPEG-1",0x03:"Teletext",0x04:"NVOD SD",0x05:"NVOD SD T.Shift",0x06:"Mosaic",0x07:"FM Radio",0x08:"DVB SRM",0x09:"Res. 9",0x0A:"Radio Adv. Codec",0x0B:"AVC Mosaic",0x0C:"Data",0x0D:"CI",0x0E:"RCS Map",0x0F:"RCS FLS",0x10:"DVB MHP",0x11:"TV HD MPEG-2",0x16:"TV SD H.264",0x17:"NVOD SD T.Sh.",0x18:"NVOD SD Ref.",0x19:"TV HD H.264",0x1A:"NVOD HD T.Sh.",0x1B:"NVOD HD Ref.",0x1C:"TV HD H.264",0x1D:"NVOD HD T.Sh.",0x1E:"NVOD HD Ref.",0x1F:"TV HEVC",0x20:"TV HEVC (HDR)",0x80:"User Def.",0x64:"Custom",0x81:"Custom",0x82:"Custom",0x84:"Custom",0x95:"Custom",0x98:"Custom",0x9B:"Custom",0xAB:"Custom",0xB4:"Custom",0xB5:"Custom",0xC6:"Custom",0xFA:"Custom",0xFB:"Custom",0xFC:"Custom"}
 VVUg5o = list(VVgAfG)
 return VVUg5o, VVgAfG
def FFq7xa():
 try:
  iPlugins.clearPluginList()
  iPlugins.readPluginList(resolveFilename(SCOPE_PLUGINS))
 except:
  pass
def FFjgCu(delta=0):
 Time = datetime.now() + timedelta(delta)
 midnight = Time.replace(hour=0, minute=0, second=0, microsecond=0)
 return mktime(midnight.timetuple())
def FFMYsv(unixTime, wDay=False):
 return datetime.fromtimestamp(unixTime).strftime("%Y-%m-%d %H:%M:%S" + (" %a" if wDay else ""))
def FFpe77():
 year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
 return "%04d-%02d-%02d %02d:%02d:%02d" % (year, month, day, hour, minute, second)
def FFH0yd(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def FFm4ac(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
def FF6eWd():
 return FFpe77().replace(" ", "_").replace("-", "").replace(":", "")
def FF79L2(secs):
 m, s = divmod(secs, 60)
 h, m = divmod(m   , 60)
 return "%02d:%02d:%02d" % (h, m, s)
def FFb6rW(head, fixName=True):
 try : cont = head.get("content-disposition")
 except: cont = None
 if cont:
  span = iSearch(r'filename=([^;]+)', str(cont), IGNORECASE)
  if span:
   fName = span.group(1).strip('" ')
   if fixName : return FF80BW(fName)
   else  : return fName
 return ""
def FFEyUQ(url, outFile, timeout=3, VVtOxO=False, tmpPath="", VVJplu=True):
 tmpDir = tmpPath or "/tmp/"
 outFile = tmpDir + outFile
 span = iSearch(r".*data.+base64,(.+)", url, IGNORECASE)
 if span:
  b64 = span.group(1)
  with open(outFile, "wb") as f:
   f.write(b64decode(b64))
  return outFile, ""
 if not CCSB3R.VVsV5B(url, justValidate=True):
  return "", "Invalid URL"
 if not iRequest:
  return "" , "Cannot import URLLIB/URLLIB2 !"
 try:
  req = iRequest(url.strip())
  req.add_header("User-Agent", CCSB3R.VVmGzj())
  res = iUrlopen(req, timeout=timeout)
  resCode = res.code
  if resCode == 200 :
   if VVtOxO and "text/html" in res.headers.get("Content-Type"):
    return "", "Received TEXT/HTML (instead of image)"
   with open(outFile, "wb") as f:
    f.write(res.read())
   if VVJplu:
    fName = FFb6rW(res.headers)
    if fName:
     newPath = tmpDir + fName
     if FF6usE("mv -f '%s' '%s'" % (outFile, newPath)):
      outFile = newPath
   if FFf0vs(outFile) : return outFile, ""
   else     : return "", "Cannot create file."
  else:
   if   resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", "Download Failed (%s)" % err
 except iURLError as e:
  return "",  FFwBVl(e)
 except Exception as e:
  return "", str(e)
def FFwBVl(e):
 err = ""
 if hasattr(e, "code") : err = "Error Code : %s\n" % str(e.code)
 if hasattr(e, "reason") : err += "Reason : %s\n" % str(e.reason)
 if not err    : err += "Error : %s"  % str(e)
 return err.strip()
def FFjWX8(numStr):
 return iMatch(r"^([-+]?\d+(\.\d*)?$)", numStr) is not None
def FFEnJs(num):
 return "s" if num > 1 else ""
def FF9BdF(num, minNum, maxNum):
 return max(min(maxNum, num), minNum)
def FFxmv7(s):
 return ''.join([chr(int(s[i:i+2], 16)) for i in range(0, len(s), 2)])
def FFJQht(txt, repl):
 return iSub(r"[^\x00-\x7F]", repl, txt)
def FFFoIQ(txt, repl):
 return iSub(r"[^A-Za-z0-9._-]", repl, txt)
def FF80BW(txt, repl="_"):
 for ch in " ():/\\,;*/:*?<>|\"'": txt = txt.replace(ch, repl)
 txt = txt.replace("_-_", repl).replace("-_-", repl)
 txt = FF7h5n(txt, repl)
 return txt.strip(".") or "File"
def FF7h5n(txt, repl):
 while repl * 2 in txt: txt = txt.replace(repl * 2, repl)
 return txt.strip(repl) or repl
def FFPSde(OldValue, OldMin, OldMax, NewMin, NewMax):
 return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
def FF1FIM(a, b):
 return (a > b) - (a < b)
def FFyTkm(a, b):
 def VVnNRU(var):
  return [ (int(c) if c.isdigit() else c) for c in iSplit(r'(\d+)', var) ]
 a = VVnNRU(a)
 b = VVnNRU(b)
 return (a > b) - (a < b)
def FFNnh8(mycmp):
 class CCaMLD(object):
  def __init__(self, obj, *args) : self.obj = obj
  def __lt__(self, other): return mycmp(self.obj, other.obj) < 0
  def __gt__(self, other): return mycmp(self.obj, other.obj) > 0
  def __eq__(self, other): return mycmp(self.obj, other.obj) == 0
  def __le__(self, other): return mycmp(self.obj, other.obj) <= 0
  def __ge__(self, other): return mycmp(self.obj, other.obj) >= 0
  def __ne__(self, other): return mycmp(self.obj, other.obj) != 0
 return CCaMLD
def FFMX7D(elem):
 return str(elem.text.encode("UTF-8").decode()).strip() if elem is not None and elem.text else ""
def FFOW7Q(elem, attrib):
 return str(elem.attrib.get(attrib, "").encode("UTF-8").decode()).strip() if elem is not None else ""
def FFgrDd(elem, child):
 return FFMX7D(elem.find(child))
def FF8Prx(elem, child, attrib):
 x = elem.find(child)
 if not x is None:
  return str(x.attrib.get(attrib, "").encode("UTF-8").decode()).strip()
 return ""
def FFwcNq(elem, child):
 lst = []
 for el in elem.findall(child):
  lst.append(FFMX7D(el))
 return lst
def FFqNZM(elem):
 return str(iElem.tostring(elem, encoding="utf-8").decode()).strip()
def FFX7JA(item, key, isDate=False, is_base64=False, isToHHMMSS=False):
 if key in item:
  val = str(item[key])
  try:
   if   isDate  : val = FFMYsv(int(val))
   elif is_base64 : val = FFG0BS(val)
   elif isToHHMMSS : val = FF79L2(float(val))
  except:
   pass
  if val == "None": return ""
  else   : return val.strip()
 else:
  return ""
def FFSQn9(SELF, message, title="", VVuQkS=None):
 SELF.session.openWithCallback(VVuQkS, CCagnF, title=title, message=message, VV0tn7=True)
def FFyijw(SELF, message, title="", VVPsQd=VV73ng, VVuQkS=None, **kwargs):
 return SELF.session.openWithCallback(VVuQkS, CCagnF, title=title, message=message, VVPsQd=VVPsQd, **kwargs)
def FFb7ob(SELF, txt):
 SELF.session.open(CCNHXv, txt)
def FFxLiP(session, *args, **kwargs):
 session.open(CCjjKr, *args, **kwargs)
def FFU9uk(SELF, message, title="")  : FFZMNU(SELF.session, message, title)
def FFbHk5(SELF, path, title="") : FFZMNU(SELF.session, "File not found:\n\n%s" % path, title)
def FFMgxa(SELF, path, title="") : FFZMNU(SELF.session, "File is empty !\n\n%s"  % path, title)
def FFD8hf(SELF, title="")  : FFZMNU(SELF.session, "No Packaging Tools:\n\n(OPKG / IPKG / DPKG )", title)
def FFZMNU(session, message, title="") : session.open(CCJzoa, title=title, message=message)
def FF8PJn(SELF, txt="", timeout=0, isGrn=False):
 if len(txt) > 0:
  try:
   FFu0W6(SELF["myInfoBody"], "#00004040" if isGrn else "#00550000")
   SELF["myInfoFrame"].show()
   SELF["myInfoBody"].show()
   SELF["myInfoBody"].setText(str(txt))
   if timeout > 0: SELF.VVYcwt.start(timeout, True)
  except: pass
 else: FFsNEE(SELF)
def FFar20(SELF, txt="", timeout=1000):
 FF8PJn(SELF, txt, timeout=timeout, isGrn=True)
def FFRuJP(SELF, txt="", timeout=1000):
 FFDiNL(BF(FF8PJn, SELF, txt=txt, timeout=timeout, isGrn=True))
def FFk1YE(*kargs, **kwargs):
 FFDiNL(BF(FF8PJn, *kargs, **kwargs))
def FFsNEE(SELF):
 try:
  SELF.VVYcwt.stop()
  SELF["myInfoFrame"].hide()
  SELF["myInfoBody"].hide()
 except:
  pass
def FF5gvI(SELF):
 try: return SELF["myInfoBody"].visible
 except: return False
def FFttdT(SELF, VVuQkS, title="", defaultText="", message=""):
 mode = CFG.keyboard.getValue()
 allOK = False
 if mode == "v":
  try:
   from Screens.VirtualKeyBoard import VirtualKeyBoard
   obj = SELF.session.openWithCallback(VVuQkS, VirtualKeyBoard, title=message, text=defaultText)
   allOK = True
   obj.setTitle(title)
  except:
   pass
 elif mode == "s":
  try:
   from Screens.InputBox import InputBox
   SELF.session.openWithCallback(VVuQkS, InputBox, windowTitle=title, title=message.replace("\n", " "), text=defaultText)
   allOK = True
  except:
   pass
 if not allOK:
  try:
   FFU9uk(SELF, "Cannot run the Input Dialog (keyboard) !", title="Keyboard Error")
  except:
   pass
def FFHsPu(SELF, callBack_Yes, VVYjCX, callBack_No=None, title="", VVys8X=False, VV817A=True, VVMjFx=False):
 session = SELF if VVMjFx else SELF.session
 return session.openWithCallback(BF(FF3W0X, callBack_Yes, callBack_No)
         , BF(CCw9aH, title=title, VVYjCX=VVYjCX, VV817A=VV817A, VVys8X=VVys8X))
def FF3W0X(callBack_Yes, callBack_No, FFHsPued):
 if FFHsPued : callBack_Yes()
 elif callBack_No: callBack_No()
def FFdCaM(SELF, callBackFunc, **kwargs):
 try:
  if callBackFunc : return SELF.session.openWithCallback(callBackFunc, BF(CCzs7U, **kwargs))
  else   : return SELF.session.open(CCzs7U, **kwargs)
 except:
  return None
def FFw2XU(SELF, callBackFunc, **kwargs):
 return SELF.session.openWithCallback(callBackFunc, BF(CCMunD, **kwargs))
def FFlfvg(pixmapObj, path, VVpaQ6=None, fncCb_ok=None, fncCb_fail=None):
 return CC7kfO(pixmapObj, path, VVpaQ6, fncCb_ok, fncCb_fail).VVoqtB()
def FFAiun(txt):
 return ("--[ %s ]%s" % (txt,  "-" * 100), )
def FFwjWO(txt, ref, cond, color=""):
 return (color + txt, ref) if cond else (txt,)
def FFE1T7(SELF, isTopBar=False):
 if isTopBar : names = [ "keyRedTop" , "keyGreenTop" , "keyYellowTop", "keyBlueTop"  ]
 else  : names = [ "keyRed" , "keyGreen" , "keyYellow" , "keyBlue"  ]
 for name in names:
  try:
   FFiZTW(SELF[name], "#000000", 3)
  except:
   pass
def FFiZTW(label, color, w):
 try:
  inst = label.instance
  inst.setBorderColor(parseColor(color))
  inst.setBorderWidth(w)
 except:
  try:
   inst = label.instance
   inst.setShadowColor(parseColor(color))
   inst.setShadowOffset(ePoint(-2, -2))
  except:
   pass
def FFvED5(SELF, menuObj):
 try:
  menuObj.instance.setFont(gFont(VVQVcT, SELF.VVuaAL["VVdJm7"]))
 except:
  try: menuObj.l.setFont(gFont(VVQVcT, SELF.VVuaAL["VVdJm7"]))
  except: pass
def FFqz3G(menuObj, offset):
 if hasattr(menuObj.instance, "setTextOffset"):
  menuObj.instance.setTextOffset(ePoint(offset, 0))
 else:
  try:
   menuObj.l.setLeftOffset(offset)
   menuObj.l.setRightOffset(offset)
  except:
   pass
def FFbm8U(SELF, menuObj=None, VVnojT=0, offset=20):
 if not menuObj:
  menuObj = SELF["myMenu"]
 FFvED5(SELF, menuObj)
 FFqz3G(menuObj, offset)
 winInst  = SELF.instance
 menuInst = menuObj.instance
 maxH = SELF.VVuaAL["height"]
 winW = winInst.size().width()
 winH = winInst.size().height()
 menuW = menuInst.size().width()
 menuH = menuInst.size().height()
 lineH = menuObj.l.getItemSize().height()
 menuH1 = (max(VVnojT, len(menuObj.list))) * lineH
 diff = menuH1 - menuH
 winNewH = winH + diff
 btnDiff = diff
 if winNewH > winH:
  if winH + lineH <= maxH:
   btnDiff = lineH
   menuH = menuH + lineH
   menuInst.resize(eSize(*(menuW, menuH)))
   winInst.resize(eSize(*(winW, winH + lineH)))
  else:
   btnDiff = 0
  pos  = menuObj.getPosition()
  part = menuInst.size().height() % lineH
  half = int(part / 2)
  menuInst.resize(eSize(*(menuW, menuH - part)))
  menuInst.move(ePoint(pos[0], pos[1] + half))
 else:
  menuInst.resize(eSize(*(menuW, menuH + diff)))
  winInst.resize(eSize(*(winW, winNewH)))
 winH = winInst.size().height()
 screenSize = getDesktop(0).size()
 winInst.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winH) // 2))
 names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
 for name in names:
  try:
   obj = SELF[name]
   pos = obj.getPosition()
   obj.instance.move(ePoint(pos[0], pos[1] + btnDiff))
  except:
   pass
 winSize = winInst.size()
 w, h = winSize.width(), winSize.height()
 SELF["myWP"].instance.resize(eSize(*(w, h)))
 FFDEXp(SELF, w, h)
def FFDEXp(SELF, w, h):
 fSize = SELF["myInfoFrame"].instance.size()
 bSize = SELF["myInfoBody"].instance.size()
 SELF["myInfoFrame"].instance.move(ePoint((w - fSize.width()) // 2, (h - fSize.height()) // 2))
 SELF["myInfoBody"].instance.move(ePoint((w - bSize.width()) // 2, (h - bSize.height()) // 2))
def FFZV7X(win, mode):
 inst = win.instance
 pos, sz = inst.position(), inst.size()
 x, y = pos.x(), pos.y()
 w, h = sz.width(), sz.height()
 sz = getDesktop(0).size()
 sW, sH = sz.width(), sz.height()
 if   mode == 0: x = (sW - w) // 2
 elif mode == 1: y = (sH - h) // 2
 elif mode == 2: x, y = (sW - w) // 2,  (sH - h) // 2
 inst.move(ePoint(int(x), int(y)))
def FFk61d(w):
 pos, sz = w.instance.position(), w.instance.size()
 return pos.x(), pos.y(), sz.width(), sz.height()
def FFUA0v():
 s = getDesktop(0).size()
 return (s.width(), s.height())
def FFl21N(VV1Wwb):
 screenSize  = FFUA0v()
 screenH   = screenSize[1]
 ratioH   = screenH / 1080.0
 VVdJm7 = int(ratioH  * VV1Wwb)
 return VVdJm7
def FFwvYs(VV1Wwb, extraSpace):
 font = gFont(VVQVcT, VV1Wwb)
 VVwOMI = fontRenderClass.getInstance().getLineHeight(font) or (VV1Wwb * 1.25)
 return int(VVwOMI + VVwOMI * extraSpace)
def FFJH4U(VVHdm7, width, height, VVNYa4, VVNGHW, VV8IXD, VVZsVH, VVQbHY, VVdJm7, VVZ3ZU=0, VVKMHf=0, VV1fgG=0, VVO8hC=0.15, VVFHRx=None, VVtyk2=False, VVb1Vz=1, VVJlYA=True, VV6DX9=0, VVZ5LV={}):
 screenSize = FFUA0v()
 screenW = int(screenSize[0] * VVb1Vz)
 screenH = int(screenSize[1] * VVb1Vz)
 if width == 0 : width  = screenW
 if height == 0: height = screenH
 retPar   = None
 ratioW   = screenW / 1920.0
 ratioH   = screenH / 1080.0
 width   = int(ratioW  * width)
 height   = int(ratioH  * height)
 titleH   = int(ratioH  * 50)
 VVNGHW  = int(ratioW  * VVNGHW)
 VV8IXD  = int(ratioH  * VV8IXD)
 VVdJm7 = int(ratioH  * VVdJm7)
 VVZ3ZU  = int(ratioH  * VVZ3ZU)
 VVKMHf  = int(ratioW  * VVKMHf)
 VV8IXD  = max(1, VV8IXD)
 scrollBarW  = int(ratioW * 15)
 bodyFontStr  = 'font="%s;%d"' % (VVQVcT, VVdJm7)
 alignCenter  = 'halign="center" valign="center"'
 alignLeftTop = 'halign="left" valign="top"'
 alignLeftCenter = 'halign="left" valign="center"'
 alignRightCenter= 'halign="right" valign="center"'
 VVNYa4 = min(int(ratioH  * VVNYa4), int(0.7  * titleH))
 bodyLineH  = FFwvYs(VVdJm7, VVO8hC)
 bodyW   = width - VVNGHW * 2
 bodyTop   = titleH + 1 + VV8IXD
 bodyH   = height - bodyTop - VV8IXD
 if VVZ3ZU > 0: bodyH -= VVZ3ZU
 zPos = 'zPosition="10000000"' if VVHdm7 == VVZjg7 else ""
 tmp  = '<screen position="center,center" size="%d,%d" backgroundColor="%s" title="%s" flags="wfNoBorder" %s >' % (width, height, VVQbHY, VVryLp, zPos)
 tmp += '<widget  name="myBody" position="0,0" size="%d,%d" zPosition="-1" backgroundColor="%s" />' % (width, height, VVQbHY)
 if VVJlYA:
  tmp += '<eLabel position="0,%d" size="%d,1" zPosition="1" backgroundColor="#00666666" />' % (titleH + 1, width)
 tmp += '<widget name="myTitle" position="0,0" size="%d,%d" zPosition="2" noWrap="1" backgroundColor="%s" font="%s;%d" foregroundColor="#ffffbb" %s />' % (width, titleH, VVZsVH, VVQVcT, VVNYa4, alignLeftCenter)
 tmp += '<widget name="myWP" position="0,0" size="%d,%d" alphatest="blend" />' % (width, height)
 if VVHdm7 == VVMfHP:
  pass
 elif VVHdm7 in (VVkmr2, VVKdMd):
  if VVHdm7 == VVKdMd : menuName = "config"
  else      : menuName = "myMenu"
  menuW = bodyW - int(bodyW * VV6DX9 / 100.0) - VVNGHW if VV6DX9 else bodyW
  tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="3" foregroundColor="#eeeeee" backgroundColor="%s" itemHeight="%d" scrollbarMode="showOnDemand" />' % (menuName, VVNGHW, bodyTop, menuW, bodyH, VVQbHY, bodyLineH)
  if VV6DX9:
   param = 'backgroundColor="%s" foregroundColor="#ffffff" %s' % (VVQbHY, bodyFontStr)
   x, w, gap = menuW + VVNGHW * 2, bodyW - menuW - VVNGHW, int(VVNGHW / 2.0)
   tmp += '<widget name="myLabelFrm" position="%d,%d" size="%d,%d" zPosition="3" %s />' % (x - gap, bodyTop, w + gap * 2, bodyH, param)
   tmp += '<widget name="myLabelTit" position="%d,%d" size="%d,%d" zPosition="4" %s %s />' % (x, bodyTop + 10, w, titleH, alignCenter, param)
   tmp += '<widget name="myLabelTxt" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" %s %s />' % (x, bodyTop + titleH + gap , w, bodyH - titleH - gap * 2, alignLeftCenter, param)
 elif VVHdm7 == VVZjg7:
  tmp += '<widget name="myWinTitle" position="0,0" size="%d,%d" zPosition="3" noWrap="1" transparent="1" foregroundColor="#ffffff" shadowColor="#440000" shadowOffset="-2,-2" %s %s />' % (width, titleH, bodyFontStr, alignCenter)
 elif VVHdm7 == VVM9On:
  names = ("Red", "Green", "Yellow", "Blue")
  colors = [ "#229f1313", "#22005500", "#22a08000", "#2218188b"]
  totBtns = len(names)
  gap  = 5
  btnW = int(width * 0.09)
  btnH = int(titleH * 0.7)
  left = width - btnW - titleH * 2
  top  = int((titleH - btnH) / 2.0)
  fSize = int(0.45  * titleH)
  for i in range(totBtns-1, -1, -1):
   tmp += '<widget name="key%s" position="%d,%d" size="%d,%d" zPosition="3" font="%s;%d" backgroundColor="%s" %s />' % (names[i], left, top, btnW, btnH, VVQVcT, fSize, colors[i], alignCenter)
   left -= (btnW + gap)
  names = ("Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos")
  totBtns = len(names)
  btnW = int((width - gap * (totBtns + 1)) / totBtns)
  btnH = titleH
  left = gap
  param = 'size="%d,%d" zPosition="3" backgroundColor="#33222222" %s %s ' % (btnW, btnH, bodyFontStr, alignCenter)
  for i in range(totBtns):
   tmp += '<widget name="mySubt%s"  position="%d,%d" foregroundColor="#00cccccc" %s />' % (names[i], left, titleH + gap  , param)
   tmp += '<widget name="mySubt%s1" position="%d,%d" foregroundColor="#00ffff88" %s />' % (names[i], left, titleH + btnH + 1, param)
   left += btnW + gap
  tmp += '<widget name="mySubtCursor" position="0,%d" size="%d,%d" zPosition="2" backgroundColor="#00ffff00" />' % (titleH + 1, btnW + gap * 2, btnH * 2 + gap - 1)
  top = titleH + 1 + btnH * 2 + gap
  tmp += '<widget name="mySubtCover" position="0,0" size="%d,%d" zPosition="5" backgroundColor="#ff000000" />' % (width, top - 1)
  tmp += '<widget name="mySubtFr" position="0,%d" size="%d,%d" zPosition="3" backgroundColor="#ff002233" />' % (top, width, height - top)
  for i in range(4):
   tmp += '<widget name="mySubtSep%d" position="1,%d" size="%d,1" zPosition="7" backgroundColor="#00555555" />' % (i, top + 1, width - 2)
   if i < 3:
    tmp += '<widget name="mySubt%d" position="1,%d" size="%d,%d" zPosition="6" noWrap="1" backgroundColor="#00000000" %s %s />' % (i, top + 1, width - 2, titleH - 2, bodyFontStr, alignCenter)
   top += titleH
  y, w1, = 1, int(width / 3.0)
  x = int((width - w1) / 2.0)
  tmp += '<widget name="mySubtChng0" position="%d,0" size="%d,%d" zPosition="8" backgroundColor="#22555555" />' % (x-1, w1+2, btnH*3 + 5)
  fnt = 'font="%s;%d"' % (VVQVcT, int(btnH * 0.63))
  for i in range(1, 4):
   fg, bg = ("#00FFFF00", "#22220000") if i == 1 else ("#00ffffff", "#33002233")
   tmp += '<widget name="mySubtChng%d" position="%d,%d" size="%d,%d" zPosition="9" foregroundColor="%s" backgroundColor="%s" %s %s />' % (i, x, y, w1, btnH, fg, bg, fnt, alignCenter)
   y += btnH + 1
  w = int(w1 / 6.5)
  h = int(btnH * 0.65)
  gap = int((btnH - h)/ 2)
  x += w1 - w - gap
  y = y - btnH + gap
  tmp += '<widget name="myRest1" position="%d,%d" size="%d,%d" zPosition="90" backgroundColor="#22a08000" font="%s;%d" %s />' % (x, y, w, h, VVQVcT, int(h * 0.7), alignCenter)
 elif VVHdm7 == VVJvMX:
  barH = int((bodyH + VV8IXD - VV8IXD * 3.0) / 3.0)
  picW = int(bodyW * 0.07)
  barW = bodyW - picW - VVNGHW
  b1Top = bodyTop
  b2Top = b1Top + barH + VV8IXD
  b3Top = b2Top + barH + VV8IXD
  timeW = int(barW * 0.1)
  b2Left1 = VVNGHW
  b2Left2 = timeW + VVNGHW * 2
  b2Left4 = barW - timeW + VVNGHW
  b2Left3 = b2Left4 - VVNGHW - timeW
  pLeft = width - picW - VVNGHW
  FFSQn9L = b2Left2 + timeW + VVNGHW
  FFSQn9W = b2Left3 - VVNGHW - FFSQn9L
  name = "myPlay"
  tmp += '<widget name="%sBarF"  position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#0a444444" />' % (name, VVNGHW, b1Top, barW, barH)
  tmp += '<widget name="%sBarBG" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#11000000" />' % (name, VVNGHW + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sBar"   position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#06445566" />' % (name, VVNGHW + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sMov"   position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#0aff8000" />' % (name, VVNGHW + 1, b1Top - 4, 3, barH + 8)
  tmp += '<widget name="%sVal"   position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#0a005555" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" %s %s />' % (name, VVNGHW + 1, b1Top + 1, barW - 2, barH - 2, bodyFontStr, alignCenter)
  param = 'zPosition="1" noWrap="1" backgroundColor="%s" %s' % (VVQbHY, bodyFontStr)
  tmp += '<widget name="%sPos"  position="%d,%d" size="%d,%d" %s foregroundColor="#00aacccc" %s />' % (name, b2Left1, b2Top, timeW, barH, param, alignLeftCenter)
  tmp += '<widget name="%sSkp"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffff00" %s />' % (name, b2Left2, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sMsg"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffffff" %s />' % (name, FFSQn9L , b2Top, FFSQn9W , barH, param, alignCenter)
  tmp += '<widget name="%sRem"  position="%d,%d" size="%d,%d" %s foregroundColor="#00CDAE77" %s />' % (name, b2Left3, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sDur"  position="%d,%d" size="%d,%d" %s foregroundColor="#00B1C177" %s />' % (name, b2Left4, b2Top, timeW, barH, param, alignRightCenter)
  sepTop = int(b3Top - VV8IXD / 2.0)
  tmp += '<widget name="myPlaySep" position="0,%d" size="%d,1" zPosition="1" backgroundColor="#11444444" />' % (sepTop, pLeft)
  color = ["#0a004400", "#00555555", "#00bbbb55", "#00bbbb55", "#00999999", "#00999999", "#00999999", "#00FFFF88" , "#0a18188b"]
  names = ["Grn"  , "Jmp"   , "Dat"   , "Tim"    , "Res"   , "Fps"   , "Asp"   , "Yel"  , "Blu"]
  Len  = len(names)
  b3W  = int((barW - VVNGHW * (Len - 1)) / Len)
  left = VVNGHW
  for i in range(Len):
   if i in (0, Len-1) : bg = 'foregroundColor="#00FFFFFF" backgroundColor="%s"' % color[i]
   else     : bg = 'foregroundColor="%s"'        % color[i]
   tmp += '<widget name="myPlay%s" position="%d,%d" size="%d,%d" zPosition="1" noWrap="1" %s %s %s />' % (names[i], left, b3Top + 1, b3W, barH, bodyFontStr, alignCenter, bg)
   if names[i] == "Blu":
    txtW = 25
    barH2 = (barH - 8) // 3
    barTop = b3Top + 2
    barTL = left + 15
    barL = barTL + txtW + 5
    bW  = pLeft - barL - VVNGHW
    fSz  = int(barH2 * 0.9)
    namesB = ("SNR", "AGC", "BER")
    for i1 in range(3):
     tmp += '<widget name="mySliderTxt%s" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" font="%s;%d" foregroundColor="#00aaaaaa" backgroundColor="#1100102a" %s />' % (namesB[i1], barTL, barTop, txtW, barH2, VVQVcT, fSz, alignRightCenter)
     tmp += '<widget name="mySliderFrm%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#333333" />' % (namesB[i1], barL-1, barTop-1, bW+2, barH2+2)
     tmp += '<widget name="mySliderBak%s" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="%s" />' % (namesB[i1], barL, barTop, bW, barH2, VVQbHY)
     tmp += '<widget name="mySliderPic%s" position="%d,%d" size="%d,%d" zPosition="6" alphatest="blend" />' % (namesB[i1], barL, barTop, bW, barH2)
     tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="7" />' % (namesB[i1], barL, barTop, bW, barH2)
     barTop += barH2 + 4
   left += b3W + VVNGHW
  pTop = titleH + 6
  pW  = width - pLeft - 8
  pH  = height - pTop - 4
  tmp += '<eLabel position="%d,%d" size="1,%d" zPosition="1" backgroundColor="#00333333" />' % (pLeft, titleH + 2, height - titleH + 1)
  tmp += '<widget name="myPlayPic" position="%d,%d" size="%d,%d" zPosition="1" alphatest="blend" />' % (pLeft + 4, pTop, pW, pH)
  tmp += '<widget name="myPlayTyp" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#1100202a" %s %s />' % (pLeft + 4, pTop, pW, pH, alignCenter, bodyFontStr)
  sz = int(titleH * 0.6)
  top = int((titleH - sz) / 2.0)
  gap = 6
  lft = width - sz - (titleH * 2 + gap * 2)
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="10" alphatest="blend" />' % (nm, lft, top, sz, sz)
   lft -= sz + gap
  params = 'zPosition="10" backgroundColor="#11444411"'
  tmp += '<eLabel %s position="0,0"  size="%d,1" />' % (params, width)
  tmp += '<eLabel %s position="0,%d" size="%d,1" />' % (params, height - 1, width)
  tmp += '<eLabel %s position="0,0"  size="1,%d" />' % (params, height)
  tmp += '<eLabel %s position="%d,0" size="1,%d" />' % (params, width - 1, height -1)
 elif VVHdm7 == VVU3Ky:
  w  = int((width - 10) / 4.0)
  h  = bodyH - 10
  left = 5
  top  = bodyTop + 5
  tmp += '<widget name="myColorF" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00ffffff" />' % (left, top, w, h)
  for i in range(4):
   tmp += '<widget name="myColor%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (i, left + 4, top + 4, w - 8, h - 8, VVQbHY, bodyFontStr, alignLeftCenter)
   left += w
 elif VVHdm7 == VVEbHC:
  itemsH  = bodyLineH * 2.0
  menuH  = int(bodyLineH * 2.5)
  menuW  = int(ratioW  * 200)
  menuLeft = int((width - menuW) / 2.0)
  textH  = bodyH - menuH
  menuTop  = bodyTop + textH
  itemsTop = int(menuTop + VV8IXD / 2.0 + (menuH - itemsH) / 2.0)
  tmp += '<widget name="myLine"  position="0,%d"  size="%d,1"  zPosition="3" backgroundColor="#11444444" />' % (menuTop, width)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (VVNGHW, bodyTop, bodyW, textH, VVQbHY, alignCenter, bodyFontStr)
  tmp += '<widget name="myMenu"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" scrollbarMode="showOnDemand" itemHeight="%d" />' % (menuLeft, itemsTop, menuW, itemsH, VVQbHY, bodyLineH)
 elif VVHdm7 == VVDwJ1:
  tmp += '<widget name="myTableH" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVNGHW, bodyTop, bodyW, 0, VVQbHY, scrollBarW)
  tmp += '<widget name="myTable"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVNGHW, bodyTop, bodyW, bodyH, VVQbHY, scrollBarW)
 elif VVHdm7 == VVJy40:
  perc1, perc2, tbg1, tbg2, bg1, bg2 = VVZ5LV["perc1"], VVZ5LV["perc2"], VVZ5LV["tbg1"], VVZ5LV["tbg2"], VVZ5LV["bg1"], VVZ5LV["bg2"]
  lblH = int(titleH * 0.75)
  lblF = int(lblH * 0.65)
  mnuF = int(lblH * 0.7)
  w1 = int((width - VVNGHW * 4) * perc1 / 100.0)
  w2 = int((width - VVNGHW * 4) * (100 - perc1) / 100.0)
  wt1 = int(w2 * perc2 / 100.0)
  wt2 = w2 - wt1
  bgW = width // 2
  lft2 = VVNGHW + w1 + VVNGHW * 2
  mTop = bodyTop + lblH + 3
  h = bodyH - lblH
  h = height - VVZ3ZU - mTop - VV8IXD
  lblP = 'noWrap="1" font="%s;%d" %s' % (VVQVcT, lblF, alignCenter)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle1" backgroundColor="%s" %s />' % (VVNGHW, bodyTop, w1, lblH, tbg1, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle2" backgroundColor="%s" %s />' % (lft2, bodyTop , wt1-3, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle3" backgroundColor="%s" %s />' % (lft2 + wt1 + 2, bodyTop, wt2-2, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm1" backgroundColor="%s" />' % (VVNGHW, mTop, w1, h, bg1)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm2" backgroundColor="%s" />' % (lft2, mTop, w2, h, bg2)
  gap, gap2 = 8, 16
  mnuP = 'transparent="1" scrollbarMode="showOnDemand" scrollbarWidth="%d"' % scrollBarW
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="list"   %s />' % (VVNGHW + gap, mTop + gap, w1 - gap2, h - gap2, mnuP)
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="myMenu" %s />' % (lft2 + gap, mTop + gap, w2 - gap2, h - gap2, mnuP)
 elif VVHdm7 == VVRfWo:
  titleFont = int(VVdJm7 * 0.6)
  boxFont  = int(VVdJm7 * 1.2)
  boxH  = int(VVdJm7 * 2.0)
  digitW  = int(VVdJm7 * 1.3)
  names  = ["year", "month", "day", "gap", "hour", "min", "sec"]
  boxW  = [  4   ,    2   ,   2  ,   1  ,   2   ,   2  ,   2  ]
  gap   = 4
  boxLeft  = int((width - digitW * 15) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVZ3ZU - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  tmp += '<widget name="curTime" position="0,%d" size="%d,%d" zPosition="2" foregroundColor="white" transparent="1" %s %s />' % (titleH + 1, width, titleTop - titleH - 2, bodyFontStr, alignCenter)
  par = 'zPosition="3" foregroundColor="white" backgroundColor="#11404040" %s' % alignCenter
  for i in range(0, 7):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVQVcT, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVQVcT, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVHdm7 == VVMqR2:
  titleFont = int(VVdJm7 * 0.6)
  boxFont  = int(VVdJm7 * 1.2)
  boxH  = int(VVdJm7 * 2.0)
  digitW  = int(VVdJm7 * 1.3)
  names, boxW = ["sign", "hour", "min"], [2, 4, 4]
  gap   = 6
  boxLeft  = int((width - digitW * 10) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVZ3ZU - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  par   = 'zPosition="3" foregroundColor="white" backgroundColor="%s" %s' % (VVQbHY, alignCenter)
  for i in range(0, 3):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVQVcT, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVQVcT, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVHdm7 == VVCj4p:
  barW = int(ratioW  * 500)
  infH = int(titleH * 0.8)
  infTop = height - infH
  infFont = int(0.5  * infH)
  bAreaH = int(height - titleH - infH)
  barH = int((bAreaH - VV8IXD * 4) / 3)
  barTop = titleH + VV8IXD
  barL = int(width - barW - titleH / 2)
  txtW = barL - VVNGHW - 4
  name = [ "SNR", "AGC", "BER"]
  tmp += '<widget name="mySNRdB" text="0 dB" position="%d,%d" size="%d,%d" %s %s zPosition="4" transparent="1" foregroundColor="white" />' % (0, 0, width - 20, titleH, bodyFontStr, alignRightCenter)
  for i in range(3):
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="5" text="%s" %s %s backgroundColor="%s" foregroundColor="white" />' % (VVNGHW, barTop, txtW, barH, name[i], bodyFontStr, alignLeftCenter, VVQbHY)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#ffffff" />' % (barL-1, barTop-1, barW+2, barH+2)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="%s" />' % (barL, barTop, barW, barH, VVQbHY)
   tmp += '<widget name="mySlider%s" position="%d,%d" size="%d,%d" zPosition="5" alphatest="blend" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="6" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="my%s" position="%d,%d" size="%d,%d" %s %s zPosition="7" text="0 " foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" />' % (name[i], barL, barTop, barW, barH, bodyFontStr, alignCenter)
   barTop += barH + VV8IXD
  tmp += '<widget name="myTPInfo" position="0,%d" size="%d,%d" zPosition="8" backgroundColor="%s" font="%s;%d" %s />' % (infTop, width, infH, VVZsVH, VVQVcT, infFont, alignCenter)
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="9" backgroundColor="#22aaaaaa" />' % (infTop -1, width)
 elif VVHdm7 == VVbJFv:
  totBars = VVZ5LV.get("totBars")
  h1  = int(bodyH / 2.0) if totBars == 2 else bodyH
  barL = VVNGHW
  barT = bodyTop
  barW = bodyW
  barH = int((height - bodyTop - VV8IXD * 2 ) / 2.0) if totBars == 2 else int(height - bodyTop - VV8IXD)
  fontH= int(0.7  * barH)
  for i in range(1, 3):
   tmp += '<widget name="myProgFr%s" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#ffffff" />' % (i, barL-1, barT-1, barW+2, barH+2)
   tmp += '<widget name="myProgBG%s" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" />' % (i, barL, barT, barW, barH, VVQbHY)
   tmp += '<widget name="myProgFG%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#884422" foregroundColor="#ffffff" />' % (i, barL, barT, barW, barH)
   tmp += '<widget name="myProgVal%s" position="%d,%d" size="%d,%d" zPosition="5" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" font="%s;%d" %s />' % (i, barL, barT, barW, barH, VVQVcT, fontH, alignCenter)
   barT += h1 + int(VV8IXD / 2.0)
 elif VVHdm7 in (VVKSTX, VVe7bi):
  totRows , totCols= VVZ5LV.get("rows"), VVZ5LV.get("cols")
  picR , lblR  = VVZ5LV.get("picR"), VVZ5LV.get("lblR")
  w1  , w2  = int(width * VVZ5LV.get("w1R")), int(width * VVZ5LV.get("w2R"))
  transpBG = VVZ5LV.get("trC")
  upSBar  = VVZ5LV.get("upSBar", False)
  bGap  = VVZ5LV.get("bGap", 0)
  infH = int(height * 0.092)
  addH = int(infH * (1000 - height) / 1000.0)
  infH += addH if addH > 0 else 0
  infT = titleH + 1
  boxT = infT + infH + VV8IXD + 2
  boxW = int((width - bGap * (totCols - 1) - (0 if upSBar else VVKMHf) - VVNGHW * 2)  / totCols)
  boxH = int((height - bGap  * (totRows - 1)  - VVZ3ZU - boxT - VV8IXD) / totRows)
  s = '<widget name="myPiconInf%d" position="%d,%d" size="%d,%d" zPosition="1" foregroundColor="%s" noWrap="1" backgroundColor="%s" font="%s;%d" %s />'
  h = int(infH * 0.3333)
  y = infT
  fg= "#00ffffff"
  if VVHdm7 == VVKSTX:
   totInf = 6
   fntSz, bg = int(h * 0.7), ("#00002828", "#00003333", "#00004444", "#00002233", "#00003344", "#00004455")
   for i in range(3):
    tmp += s % (i  , 0   , y, w1, h, fg, bg[i]  , VVQVcT, fntSz, alignLeftCenter)
    tmp += s % (i+3, w1+1, y, w2, h, fg, bg[i+3], VVQVcT, fntSz, alignLeftCenter)
    y += h
  else:
   totInf = 4
   h1, h2 = int(infH * 0.58), int(infH * 0.42)
   tmp += s % (0, 0, y  , w1, h1 , "#0088ff88", "#00333333", VVQVcT, int(h1 * 0.7), alignLeftCenter)
   tmp += s % (1, 0, y + h1, w1, h2 , "#00aaaaaa", "#002a2a2a", VVQVcT, int(h2 * 0.7), alignLeftCenter)
   h, fntSz, fg, bg = int(infH * 0.50), int(h2 * 0.60), "#00888888", "#0a111111"
   tmp += s % (2, w1, y , w2, h, fg, bg, VVQVcT, fntSz, alignCenter)
   tmp += s % (3, w1, y + h, w2, h, fg, bg, VVQVcT, fntSz, alignCenter)
  retPar = VVNGHW, boxT, boxW, boxH, infT, infH, totInf, bGap
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="1" backgroundColor="#00555555" />' % (infT + infH, width)
  pT = infT + 3
  pH = infH - 6
  pW = int(pH * 1.66)
  pL = width - pW - 12
  tmp += '<widget name="myPiconF"   position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#0a555500" />' % (pL    , pT    , pW  , pH)
  tmp += '<widget name="myPiconBG"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#0a220000" />' % (pL + 1, pT + 1, pW - 2 , pH - 2)
  tmp += '<widget name="myPiconPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />'    % (pL + 2, pT + 2, pW - 4 , pH - 5)
  tmp += '<widget name="myCursorLbl" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#00ffff66" />' % (VVNGHW, boxT + VV8IXD, boxW-2, boxH-2)
  tmp += '<widget name="myCursorPic" position="%d,%d" size="%d,%d" zPosition="5" alphatest="on" scale="1" />' % (VVNGHW, boxT + VV8IXD, boxW-2, boxH-2)
  picBgTr = 'transparent="1"' if VVZ5LV.get("picBgTr", 0) else ""
  lblTr = 'transparent="1"' if VVZ5LV.get("lblTr", 0) else ""
  lblFR = VVZ5LV.get("lblFR", 0.65)
  lblFg = VVZ5LV.get("lblFg", "#00ffffff")
  lblBg = VVZ5LV.get("lblBg", VVQbHY)
  gapX = VVZ5LV.get("gapX", 4)
  gapY = VVZ5LV.get("gapY", 4)
  midGap = VVZ5LV.get("mGap", 0)
  percBar = VVZ5LV.get("percBar", 0)
  areaW = boxW - gapX * 2
  areaH = boxH - gapY * 2 - midGap
  picT = boxT + gapY
  picH = int(areaH * picR)
  lblH = int(areaH * lblR)
  lblT = boxT + gapY + picH + midGap
  lblFS= int(lblH * lblFR)
  transpBG = 'backgroundColor="%s"'% transpBG if transpBG else ""
  boxT1 = boxT
  for row in range(totRows):
   left = VVNGHW + gapX
   for col in range(totCols):
    tmp += '<widget name="myPosterBak%d%d" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" scale="1" />' % (row, col, left-gapX, boxT1, boxW, boxH)
    tmp += '<widget name="myPosterRep%d%d" position="%d,%d" size="%d,%d" zPosition="6" %s %s />' % (row, col, left, picT, areaW, picH, transpBG, picBgTr)
    tmp += '<widget name="myPosterLbl%d%d" position="%d,%d" size="%d,%d" zPosition="7" foregroundColor="%s" backgroundColor="%s" noWrap="1" %s font="%s;%d" %s />' % (row, col, left, lblT, areaW, lblH, lblFg, lblBg, lblTr, VVQVcT, lblFS, alignCenter)
    tmp += '<widget name="myPosterPic%d%d" position="%d,%d" size="%d,%d" zPosition="13" alphatest="blend" />' % (row, col, left, picT, areaW, picH)
    if percBar:
     x, y, w, h =  left, lblT + lblH + 5, areaW, lblH // 3
     tmp += '<widget name="myPercFr%d%d" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#00ffffff" />' % (row, col, x, y, w, h)
     tmp += '<widget name="myPercBG%d%d" position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" />'   % (row, col, x+1, y+1, w-2, h-2, lblBg)
     tmp += '<widget name="myPercFG%d%d" position="%d,%d" size="%d,%d" zPosition="12" backgroundColor="#0055aabb" />' % (row, col, x+1, y+1, w-2, h-2)
    left += boxW + bGap
   boxT1 += boxH + bGap
   picT += boxH + bGap
   lblT += boxH + bGap
 elif VVHdm7 == VV2ZKp:
  totRows = 6
  totCols = 8
  tstW = int(width - VVNGHW  * 2)
  tstH = int(height * 0.15)
  tstT = int(height - VVZ3ZU - tstH)
  boxT = titleH + 2
  boxW = int(width  / totCols)
  boxH = int((height - VVZ3ZU - tstH - boxT) / totRows)
  tmp += '<widget name="myColorPtr" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00aaaa00" />' % (0, boxT, boxW, boxH)
  gap  = VV8IXD
  gap1 = int(gap / 2.0)
  for row in range(totRows):
   boxL = 0
   for col in range(totCols):
    tmp += '<widget name="myColor%d%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00000000" />' % (row, col, boxL+gap1, boxT+gap1, boxW-gap, boxH-gap)
    boxL += boxW
   boxT += boxH
  tmp += '<widget name="myColorTst" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00aaaaaa" %s %s />' % (VVNGHW, tstT, tstW, tstH, alignCenter, bodyFontStr)
 elif VVHdm7 == VVfBCq:
  tmp += '<widget name="myPic" position="0,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (bodyTop+1, bodyW, bodyH-1)
 else:
  if   VVHdm7 == VVusjP : align = alignLeftCenter
  elif VVHdm7 == VVxEpD : align = alignLeftTop
  else          : align = alignCenter
  if VVHdm7 == VVyGmA:
   iconSize = 60
   iconLeft = int(ratioH  * 20)
   iconTop  = int(bodyTop + (height - bodyTop - iconSize) / 2.0)
   iconW  = iconSize + iconLeft * 2
   VVNGHW += iconW
   bodyW  -= iconW
   tmp += '<widget name="errPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (iconLeft, iconTop, iconSize, iconSize)
  fontName = VVQVcT
  if VVtyk2 and VVHdm7 == VVxEpD:
   fLst = FFHlE6()
   if   VVNq6S in fLst and CFG.fontPathTerm.getValue(): fontName = VVNq6S
   elif VVFYAr in fLst         : fontName = VVFYAr
  VVvJb6 = 'backgroundColor="%s" foregroundColor="#ffffff" font="%s;%d" %s ' % (VVQbHY, fontName, VVdJm7, align)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="4" %s />' % (VVNGHW, bodyTop, bodyW, bodyH, VVvJb6)
 infoW  = int(ratioW  * 500)
 infoH  = int(ratioH  * 100)
 infoLeft = int((width - infoW) / 2.0)
 infoTop  = int((height - infoH) / 2.0)
 VV1Wwb = int(ratioH  * 30)
 tmp += '<widget name="myInfoFrame" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#aaaa00" />' % (infoLeft, infoTop, infoW, infoH)
 tmp += '<widget name="myInfoBody"  position="%d,%d" size="%d,%d" zPosition="21" backgroundColor="#550000" foregroundColor="#ffff00" font="%s;%d" %s />' % (infoLeft+2, infoTop+2, infoW-4, infoH-4, VVQVcT, VV1Wwb, alignCenter)
 if VV1fgG > 0:
  gap = 6
  sz = titleH - gap * 2
  mnuL= width - sz - gap * 2
  infL= mnuL if VV1fgG == 3 else mnuL - sz - gap
  par = 'size="%d,%d" zPosition="20" alphatest="blend"' % (sz, sz)
  if VV1fgG in (1, 2): tmp += '<widget name="keyMenu" position="%d,%d" %s />' % (mnuL, gap, par)
  if VV1fgG in (2, 3): tmp += '<widget name="keyInfo" position="%d,%d" %s />' % (infL, gap, par)
  if VVHdm7 == VVDwJ1:
   w = int(ratioH  * 200)
   tmp += '<widget name="myTotSel" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#550055" font="%s;%d" %s />' % (infL - gap - w, gap, w, sz, VVQVcT, int(sz * 0.6), alignCenter)
 if VVZ3ZU > 0:
  lineTop = height - VVZ3ZU
  topGap = max(3, int(ratioH  * 3))
  btnTop = lineTop + topGap
  btnH = height - btnTop - topGap
  barFont = int(0.7  * btnH)
  gap  = btnH
  spaceW = gap * (5)
  btnW = int((width - spaceW) / 4)
  left = gap
  name = [ "keyRed"   , "keyGreen" , "keyYellow", "keyBlue"  ]
  tmp += '<widget name="myBar"  position="0,%d"  size="%d,%d" zPosition="7" backgroundColor="%s" font="%s;%d" %s />' % (lineTop, width, height - lineTop, VVZsVH, VVQVcT, barFont, alignLeftCenter)
  tmp += '<widget name="myLine" position="0,%d"  size="%d,1"  zPosition="8" backgroundColor="#22aaaaaa" />' % (lineTop, width)
  for i in range(4):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="9" backgroundColor="%s" font="%s;%d" foregroundColor="white" noWrap="1" %s />' % (name[i], left, btnTop, btnW, btnH, VVrew6[i], VVQVcT, barFont, alignCenter)
   left += btnW + gap
 if VVKMHf:
  par = 'position="0,0" size="20,20"'
  tmp += '<widget name="mySbFrm" zPosition="13" %s />' % par
  tmp += '<widget name="mySbBak" zPosition="14" %s />' % par
  tmp += '<widget name="mySbSld" zPosition="15" %s />' % par
 if VVHdm7 == VVxEpD or VVZ5LV.get("topBtnEW", 0):
  btnW = int(ratioW  * (85 + VVZ5LV.get("topBtnEW", 0)))
  btnH = int(titleH * 0.6)
  btnTop = int(titleH * 0.2)
  btnLeft = width - (btnW + btnTop) * 4
  btnFont = int(btnH * 0.65)
  name = [ "Red", "Green", "Yellow", "Blue" ]
  for i in range(4):
   tmp += '<widget name="key%sTop1" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#0affffff" />' % (name[i], btnLeft, btnTop, btnW, btnH)
   tmp += '<widget name="key%sTop"  position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" font="%s;%d" foregroundColor="white" %s />' % (name[i], btnLeft+1, btnTop+1, btnW-2, btnH-2, VVrew6[i], VVQVcT, btnFont, alignCenter)
   btnLeft += (btnW + btnTop)
 if VVFHRx:
  w, h = VVFHRx
  w = int(ratioW  * w) if w > 0 else int(width  * 0.2)
  h = int(ratioH  * h) if h > 0 else int(w * 0.75)
  x, y = width - w - VVNGHW - scrollBarW * 2, bodyTop
  tmp += '<widget name="myPicF" position="%d,%d" size="%d,%d" zPosition="7" backgroundColor="#0affffff" />' % (x-1, y-1, w+2, h+2)
  tmp += '<widget name="myPicB" position="%d,%d" size="%d,%d" zPosition="8" backgroundColor="%s" />'   % (x, y, w, h, VVQbHY)
  tmp += '<widget name="myPic"  position="%d,%d" size="%d,%d" zPosition="9" alphatest="blend" />'    % (x, y, w, h)
  retPar = x, y, w, h
 tmp += '</screen>'
 VVuaAL = {"VVHdm7":VVHdm7, "width":width, "height":height, "titleH":titleH, "VVNGHW":VVNGHW, "VV8IXD":VV8IXD, "VVZsVH":VVZsVH, "VVQbHY":VVQbHY, "VVdJm7":VVdJm7, "VVZ3ZU":VVZ3ZU, "VV1fgG":VV1fgG, "bodyLineH":bodyLineH, "scrollBarW":scrollBarW, "VVO8hC":VVO8hC, "retPar":retPar, "VVZ5LV":VVZ5LV}
 return tmp, VVuaAL
class CCEj76(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 800, 1050, 40, 40, 20, "#1a002244", "#10002233", 33, VVZ3ZU=40, VV1fgG=2)
  self.session  = session
  self.VVruHz = ""
  self.VVlBFz  = r"0{4}t{2}f?$"
  self.themsList  = []
  self.Title   = "%s - %s" % (VVryLp, VVsBow)
  self.timer   = eTimer()
  self.chkVerResult = ""
  self.VV1V0y = True
  VVXXzc = []
  if VVdoek:
   VVXXzc.append(("-- MY TEST --", "myTest" ))
  VVXXzc.append(("File Manager"  , "fMan" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("IPTV"    , "iptv" ))
  VVXXzc.append(("Movies Browser" , "movie" ))
  VVXXzc.append(("Services/Channels", "chan" ))
  VVXXzc.append(("Bouquet Editor" , "bouq" ))
  VVXXzc.append(("PIcons"   , "picon" ))
  VVXXzc.append(("EPG"    , "epg"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Terminal"   , "term" ))
  VVXXzc.append(("SoftCam"   , "soft" ))
  VVXXzc.append(("Plugins"   , "plug" ))
  VVXXzc.append(("Backup & Restore" , "bakup" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Date/Time"  , "date" ))
  VVXXzc.append(("Network"   , "net"  ))
  FFfmZP(self, title=self.Title, VVXXzc=VVXXzc)
  FFrvOP(self["keyRed"] , "Exit")
  FFrvOP(self["keyGreen"] , "Settings")
  FFrvOP(self["keyYellow"], "Dev. Info.")
  FFrvOP(self["keyBlue"] , "Color/Font")
  FFyNtd(self,
  {
   "red" : self.close     ,
   "green" : self.VVH2qm    ,
   "yellow": self.VVSEDH    ,
   "blue" : self.VVpBnz   ,
   "info" : self.VVjIHw    ,
   "menu" : self.VVFQkW  ,
   "text" : BF(self.VVbmG7, "t")  ,
   "f4" : BF(self.VVbmG7, "f")  ,
   "0"  : BF(self.VVOgtr, 0) ,
   "1"  : BF(self.VVFJs1, "fMan") ,
   "2"  : BF(self.VVFJs1, "iptv") ,
   "3"  : BF(self.VVFJs1, "movie") ,
   "4"  : BF(self.VVFJs1, "chan") ,
   "5"  : BF(self.VVFJs1, "bouq") ,
   "6"  : BF(self.VVFJs1, "picon") ,
   "7"  : BF(self.VVFJs1, "epg") ,
   "8"  : BF(self.VVFJs1, "term") ,
   "9"  : BF(self.VVFJs1, "soft") ,
   "last" : BF(self.VVFJs1, "plug") ,
   "next" : BF(self.VVFJs1, "bakup")
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
  global VVd25Y, VVpSLv, VVwjls
  VVd25Y = VVpSLv = 0
  VVwjls = 1
 def VVTOku(self):
  self.VVFJs1(self["myMenu"].l.getCurrentSelection()[1])
 def VVFJs1(self, item):
  if item is not None:
   for ndx, param in enumerate(self["myMenu"].list):
    if len(param) > 1 and param[1] == item:
     self["myMenu"].moveToIndex(ndx)
     break
   global VVhZdB
   VVhZdB = self["myMenu"].l.getCurrentSelection()[0].strip()
   if   item == "myTest" : self.VVkpcm()
   elif item == "fMan"  : self.session.open(CCQdsv)
   elif item == "iptv"  : self.session.open(CCSB3R)
   elif item == "movie" : CCBgul.VVPSpu(self)
   elif item == "chan"  : self.session.open(CCAnLc)
   elif item == "bouq"  : self.session.open(CC5Hkx)
   elif item == "picon" : self.VVHCtr()
   elif item == "epg"  : self.session.open(CCfClD)
   elif item == "term"  : self.session.open(CCz488)
   elif item == "soft"  : FFTSvN(self, BF(self.session.open, CC6pkA))
   elif item == "plug"  : self.session.open(CCJFyo)
   elif item == "bakup" : self.session.open(CCRex8)
   elif item == "date"  : self.session.open(CCWwVN)
   elif item == "net"  : self.session.open(CC5LkQ)
 def VVvFMs(self):
  FFbm8U(self)
  if self.VV1V0y:
   self.VV1V0y = False
   FFTDN6(self["myMenu"])
   FFE1T7(self)
   FF1uow(self)
   self.VVGD5j()
 def VVGD5j(self):
  if not hasattr(self["myMenu"].instance, "setTextOffset"):
   for ndx, item in enumerate(self["myMenu"].list):
    if len(item) == 2:
     self["myMenu"].list[ndx] = ("   %s" % item[0], item[1])
  FFH0EA(self)
  self.VV1siF()
  if (VVX985 or VVCB0I or VVdoek):
   FFu0W6(self["myTitle"], "#ff0000")
  var = "PLUGIN" + "_VERSION"
  if var in globals():
   FF8PJn(self, "Welcome", 300)
  if CFG.checkForUpdateAtStartup.getValue():
   self["myTitle"].instance.setFont(gFont(VVQVcT, 30))
   self["myTitle"].setText("  %s      %s" % (VVryLp, FFITtK("Checking for updates ...", VVVAvR)))
   try: self.timer_conn = self.timer.timeout.connect(self.VV9eQX)
   except: self.timer.callback.append(self.VV9eQX)
   self.timer.start(500, False)
   myThread = iThread(name="ajp_chk_ver", target=self.VV0mUI)
   myThread.start()
 def VV9eQX(self):
  if self.chkVerResult:
   self.timer.stop()
   if self.chkVerResult == "no":
    fnt = gFont(VVQVcT, 33)
    txt = self.Title
   else:
    fnt = gFont(VVQVcT, 30)
    txt = "%s    (v%s available)" % (self.Title, self.chkVerResult)
   self["myTitle"].instance.setFont(fnt)
   self["myTitle"].setText("  %s" % txt)
 def VV0mUI(self):
  url = CC8MwG.VVMfkC()
  curVer = VVsBow
  path, err = FFEyUQ(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFf0vs(path):
   self.chkVerResult = "no"
  else:
   cVer, wVer, isHigher = CCJFyo.VVhhmr(curVer, FF05rJ(path))
   FFqlCI(path)
   self.chkVerResult = wVer if isHigher else "no"
 def onExit(self):
  self.timer.stop()
  FFW48g()
  global VVd25Y, VVpSLv
  VVd25Y = VVpSLv = 0
  FFdsOh("VVwjls")
 def VVOgtr(self, digit):
  self.VVruHz += str(digit)
  ln = len(self.VVruHz)
  global VVd25Y
  if ln == 4:
   if self.VVruHz == "0" * ln:
    VVd25Y = 1
    FFu0W6(self["myTitle"], "#11805040")
   else:
    self.VVruHz = "x"
 def VVbmG7(self, s):
  self.VVruHz += s
  if iMatch(self.VVlBFz, self.VVruHz):
   global VVpSLv
   VVpSLv, c = (2, "#ff8000") if self.VVruHz.endswith("f") else (1, "#dd5588")
   FFu0W6(self["myTitle"], c)
 def VVHCtr(self):
  found = False
  pPath = CCUNc6.VVQ490()
  if VVrRHR(pPath):
   for fName, fType in CCUNc6.VVaXg8(pPath):
    if fName:
     found = True
     break
  if found:
   self.session.open(CCUNc6)
  else:
   VVXXzc = []
   VVXXzc.append(("PIcons Tools" , "CCUNc6" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(CCUNc6.VVJ98d())
   VVXXzc.append(VVzg1X)
   VVXXzc += CCUNc6.VVXCd0()
   FFw2XU(self, self.VVL4Dz, VVXXzc=VVXXzc)
 def VVL4Dz(self, item=None):
  if item:
   if   item == "CCUNc6"   : self.session.open(CCUNc6)
   elif item == "VVStbS"  : CCUNc6.VVStbS(self)
   elif item == "VV6cOK"  : CCUNc6.VV6cOK(self)
   elif item == "findPiconBrokenSymLinks" : CCUNc6.VV1PjS(self, True)
   elif item == "FindAllBrokenSymLinks" : CCUNc6.VV1PjS(self, False)
 @FFHF2S()
 def VVjIHw(self):
  fil = VV30Jg + "_changeLog.txt"
  title = "%s %s  -  %s  (by AMAJamry)" % (VVryLp, VVsBow, VVk74U)
  if FFf0vs(fil):
   txt = "\n%s%s\n" % (FFITtK("Home Page : ", VV6UAe), FFITtK(CC8MwG.VVQInW(), VVnQYw))
   lines  = FF2iRW(fil)
   for line in lines:
    line = line.strip()
    if line and not line.startswith("#"):
     if line.startswith("[") and line.endswith("]"):
      line = line.replace("[", "").replace("]", "")
      line = FFITtK("\n%s\n%s\n%s" % (SEP, line, SEP), VVaR8d, VVHFlX)
     elif line.strip().startswith("-"): line = "\n" + line
     elif line.strip().startswith(".."): line = FFITtK(line, VVgzFX, VVHFlX)
     txt += line +"\n"
   FFyijw(self, txt.strip(), title=title, VV1Wwb=28, width=1600, height=1000, titleBg="#11000020", VVpaQ6="#0a00000a")
  else:
   FFU9uk(self, "Change Log file not found:\n\n%s" % fil, title=title)
 def VVFQkW(self):
  VVXXzc = []
  VVXXzc.append(("Open Custom Menu ", "cMenu"))
  VVXXzc.append(("Custom Menu Help" , "cmHlp"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Movies Resume History", "resum"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("%s Optional Dependencies" % VVryLp, "libr"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("General Guide", "ghHlp" ))
  VVXXzc.append(("Keys Help" , "hlp"  ))
  FFw2XU(self, self.VVHs6q, VVXXzc=VVXXzc, width=650, title="Options")
 def VVHs6q(self, item=None):
  if item:
   if   item == "cMenu": CCNm9T.VVVT2N(self)
   elif item == "cmHlp": FFpIdO(self, "_help_cmenu", "Custom Menu Help")
   elif item == "resum": self.session.open(CCBoou)
   elif item == "libr" : self.VV0txy()
   elif item == "ghHlp": self.VVopuE()
   elif item == "hlp" : FFpIdO(self, "_help_main", "Main Page (Keys Help)")
 def VVopuE(self):
  lst = [tuple(line.split("@")) for line in FF2iRW(VV30Jg + "_hlpG") if "@" in line]
  if lst: FFw2XU(self, None, title="General Guide", VVXXzc=sorted(lst), width=1200, height=1000, VVVzvS="#11101100", VVhHWW="#11112222", VV5LxL=self.VV16TI, VVfP2Q=True)
 def VV16TI(self, item=None):
  if item:
   VVZzW8, title, pic, ndx = item
   self.VVgc3T(VVZzW8, title, pic)
 @FFHF2S("Loading ...", par=1)
 def VVgc3T(self, VVZzW8, title, pic):
  url = CC8MwG.VVMfkC()
  path, err = FFEyUQ(url + "help/%s" % pic, "ajp_tmp%s" % os.path.splitext(pic)[1], timeout=2)
  if err or not FFf0vs(path) : FFU9uk(self, "Cannot get help file from server !", title=title)
  else       : CCC0Lg.VVESKQ(self, path, title=title)
  FFqlCI(path)
 def VVH2qm(self) : self.session.open(CC8MwG)
 def VVSEDH(self) : self.session.open(CC6z2a)
 def VVpBnz(self):
  title = "Colors and Fonts"
  c1, c2, c3, c4, c5 = VVkLs0, VVu50a, VV6UAe, VVnQYw, VVCBkQ
  added = CFG.fontPathAdd.getValue()
  VVXXzc = []
  VVXXzc.append((c1 + "Change Title Colors"   , "title"  ))
  VVXXzc.append((c1 + "Change Menu Area Colors"  , "body"  ))
  VVXXzc.append((c1 + "Change Menu Pointer Colors" , "cursor"  ))
  VVXXzc.append((c1 + "Change Bottom Bar Colors" , "bar"   ))
  VVXXzc.append((c2 + "Reset Colors"    , "resetColor" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Change %s Font" % VVryLp, "mainFont" ))
  VVXXzc.append((c3 + "Change Terminal Font"   , "termFont" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Add Extra Font to System" , "addFont", not added , c4))
  VVXXzc.append(FFwjWO("Replace Extra Font"  , "rplFont", added  , c4))
  VVXXzc.append(FFwjWO("Remove Extra Font"  , "delFont", added  , c4))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Change System Fonts Size" , "fntScl", not CFG.fontPathSys.getValue(), c5))
  VVXXzc.append((c5 + "Change System Font"     , "sysFont" ))
  FFw2XU(self, BF(self.VVBmEa, title), VVXXzc=VVXXzc, width=600, height=1000, title=title, VVVzvS="#11001122", VVhHWW="#11001122")
 def VVBmEa(self, title, item=None):
  if item:
   if item in ("title", "body", "cursor", "bar"):
    tDict = self.VVA4e0()
    fg = tDict.get("main_%s_fg" % item, "")
    bg = tDict.get("main_%s_bg" % item, "")
    self.session.openWithCallback(BF(self.VVcyKx, tDict, item), CCYGxc, defFG=fg, defBG=bg)
   elif item == "resetColor" : FFHsPu(self, self.VVnCnq, "Reset to default colors ?", title=title)
   elif item == "mainFont"  : self.VVsSDH(VV5PlV)
   elif item == "termFont"  : self.VVsSDH(VVNq6S)
   elif item == "addFont"  : self.VVsSDH(VVrWau)
   elif item == "rplFont"  : self.VVsSDH(VVrWau)
   elif item == "delFont"  : FFHsPu(self, self.VVQle2, "Remove Extra Font and Restart GUI ?", title="Remove Extra Font")
   elif item == "fntScl"  : self.VVHwKl()
   elif item == "sysFont"  : self.VVsSDH(VV67H9, chFontSz=True)
 def VVQle2(self):
  FFDDwF(CFG.fontPathAdd, "")
  CCNqUU.VVtJwR(self)
 @FFHF2S()
 def VV0txy(self):
  title = "%s Optional Dependencies (for more features)" % VVryLp
  VVJwgn = self.VVWvGt()
  VV5CrJ = ("Install"    , BF(self.VVrQfg, title), [])
  VVvrJb  = ("Update Sys. Packages", self.VVvMls , [])
  header  = ("Library", "State", "Usage" )
  widths  = (20   , 25  , 55  )
  VVgKQc = (LEFT  , CENTER , LEFT  )
  VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=28, width=1350, VV5CrJ=VV5CrJ, VVvrJb=VVvrJb, VV4HrS=2)
 def VVrQfg(self, Title, VV5ybN, title, txt, colList):
  pkg, state, usage = colList
  cbFnc = BF(self.VVWRfm, VV5ybN)
  if pkg == "xz" and "BusyBox" in state:
   FFNQkI(self, FFiD2M(VVUWS4, pkg), VVUYyP=cbFnc, title=Title)
  elif "Installed" in state:
   FFar20(VV5ybN, "Already installed.")
  else:
   pkgDict = self.VVzKss()
   if   pkg == "requests" : CC5ENZ.VVPib3(self, cbFnc=cbFnc)
   elif pkg == "Imaging" : CCHa3c.VVV1rP(self, Title, False, cbFnc=cbFnc)
   elif pkg == "ar"  : FFNQkI(self, FFkDck(), VVUYyP=cbFnc, title=Title)
   elif pkg in pkgDict  : FFNQkI(self, FF3F9l(pkgDict[pkg], pkg, pkg.capitalize()), VVUYyP=cbFnc, title=Title)
 def VVvMls(self, VV5ybN, title, txt, colList):
  CCJFyo.VViLrr(self)
 def VVWRfm(self, VV5ybN):
  VVJwgn = self.VVWvGt()
  VV5ybN.VVULq3(VVJwgn[VV5ybN.VVfkJL()])
 def VVWvGt(self):
  tDict = {}
  path = VV30Jg + "_sup_lib"
  if FFf0vs(path):
   for line in FF2iRW(path):
    lib, _, txt = line.partition("=")
    tDict[lib] = txt
  def VVEQGt(lib, ok):
   txt = tDict.get(lib, "")
   if ok: return (lib, "#f#0000ff00#" + "Installed" , txt)
   else : return (lib, "#f#00ff8000#" + "Not installed", txt)
  VVJwgn = []
  VVJwgn.append(VVEQGt("requests", CC5ENZ.VVPib3(self, install=False)))
  VVJwgn.append(VVEQGt("Imaging" , CCHa3c.VVV1rP(self, "", False, install=False)))
  VVJwgn.append(VVEQGt("ar"   , CCJFyo.VVmOIe()))
  for pkg, cmd in self.VVzKss().items():
   row = VVEQGt(pkg, FFsGnd(cmd))
   if pkg == "xz":
    pFound, pBBox = FFzyl2(pkg)
    if pFound and pBBox:
     c1 = VVsm0W
     stt = FFITtK("BusyBox xz (old)", c1)
     usg = "%s  ...  %s" % (row[2], FFITtK("xz v5 recommended", c1))
     row = (pkg, stt, usg)
   VVJwgn.append(row)
  VVJwgn.sort(key=lambda x: x[0].lower())
  return VVJwgn
 def VVzKss(self):
  d = {}
  for pkg in ("xz", "zip", "p7zip", "unrar", "bzip2", "ffmpeg"):
   d[pkg] = pkg
  d["p7zip"] = "7za"
  return d
 def VVrJuc(self):
  return FFmAG5() + "ajpanel_colors"
 def VVA4e0(self):
  tDict = { "main_title_fg" : ""
    , "main_title_bg" : ""
    , "main_body_fg" : ""
    , "main_body_bg" : ""
    , "main_cursor_fg" : ""
    , "main_cursor_bg" : ""
    , "main_bar_fg"  : ""
    , "main_bar_bg"  : ""
    }
  p = self.VVrJuc()
  if FFf0vs(p):
   txt = FF05rJ(p)
   lst = iFindall(r"(.*[^\s])\s*=\s*(#(?:[A-Fa-f0-9]{8}))", txt, IGNORECASE)
   for txt, c in lst:
    tDict[txt] = c
  return tDict
 def VVcyKx(self, tDict, item, fg, bg):
  if fg:
   self.VVooVe(item, fg)
   self.VVcwul(item, bg)
   tDict["main_%s_fg" % item] = fg
   tDict["main_%s_bg" % item] = bg
   self.VVbNiW(tDict)
 def VVbNiW(self, tDict):
   p = self.VVrJuc()
   with open(p, "w") as f:
    for key, val in tDict.items():
     f.write("%s=%s\n" % (key, val))
 def VVooVe(self, item, fg):
  if   item == "title" : FFcfsH(self["myTitle"], fg)
  elif item == "body"  :
   FFcfsH(self["myMenu"], fg)
   FFcfsH(self["myBody"], fg)
  elif item == "cursor" : self["myMenu"].instance.setForegroundColorSelected(parseColor(fg))
  elif item == "bar"  :
   for item in ("myBar", "keyRed", "keyGreen", "keyYellow", "keyBlue"): FFcfsH(self[item], fg)
 def VVcwul(self, item, bg):
  if   item == "title" : FFu0W6(self["myTitle"], bg)
  elif item == "body"  :
   FFu0W6(self["myMenu"], bg)
   FFu0W6(self["myBody"], bg)
  elif item == "cursor" : self["myMenu"].instance.setBackgroundColorSelected(parseColor(bg))
  elif item == "bar"  : FFu0W6(self["myBar"], bg)
 def VVnCnq(self):
  FF6usE("rm '%s'" % self.VVrJuc())
  self.close()
 def VV1siF(self):
  tDict = self.VVA4e0()
  for item in ("title", "body", "cursor", "bar"):
   self.VVbXvm(tDict, item)
 def VVbXvm(self, tDict, name):
  fg = tDict.get("main_%s_fg" % name, "")
  bg = tDict.get("main_%s_bg" % name, "")
  if fg: self.VVooVe(name, fg)
  if bg: self.VVcwul(name, bg)
 def VVHwKl(self):
  cur = CFG.fontAllPerc.getValue()
  tab = lambda sign, rng:  [("%s%s%s  %s %%" % (" " * 15, VV8QGw if i == cur else "", sign, abs(i)), i) for i in rng]
  lst = tab("+", [x for x in range(5, 45, 5)])
  lst.append(VVzg1X)
  lst.extend(tab("-", [x for x in range(-5,-45, -5)]))
  if cur != 0:
   lst.insert(0, VVzg1X)
   lst.insert(0, ("Reset Size %s" % FFITtK(" (Requires GUI Restart)", VVCBkQ), 0))
  FFw2XU(self, self.VVOJqz, VVXXzc=lst, title="Change Size", width=700, height=1050, VV1Wwb=28, VVVzvS="#22221122", VVhHWW="#22220022")
 @FFHF2S()
 def VVOJqz(self, addPerc):
  if addPerc is None or addPerc == CFG.fontAllPerc.getValue(): return
  if addPerc == 0:
   FFHsPu(self, self.VV7nzo, "Restore and Restart ?", title="Restore Original Font Size")
  else:
   FFDDwF(CFG.fontAllPerc, addPerc)
   if CCEj76.VVQJvV():
    self.hide()
    self.show()
   else:
    FFk1YE(self, "Cannot change fonts", 1500)
 def VV7nzo(self):
  FFDDwF(CFG.fontAllPerc, 0)
  CCNqUU.VVtJwR(self)
 @FFHF2S()
 def VVsSDH(self, which, chFontSz=False):
  if   which == VV5PlV  : rest, defFnt, title = False, CFG.fontPathMain.getValue(), VVryLp
  elif which == VVNq6S : rest, defFnt, title = False, CFG.fontPathTerm.getValue(), "Terminal "
  elif which == VVrWau  : rest, defFnt, title = True , CFG.fontPathAdd.getValue() , "System Extra"
  elif which == VV67H9  : rest, defFnt, title = True , CFG.fontPathSys.getValue() , "System"
  CC1BSt.VVK9Do(self, "Change %s Font" % title, defFnt, rest, BF(self.VVe4Hu, which), chFontSz)
 def VVe4Hu(self, which, fntPar=None):
  if fntPar: path, scale = fntPar
  else  : return
  if path == "DEFAULT": path = ""
  if   which == VV5PlV  : FFDDwF(CFG.fontPathMain, path)
  elif which == VVNq6S: FFDDwF(CFG.fontPathTerm, path)
  elif which == VVrWau  : FFDDwF(CFG.fontPathAdd , path)
  elif which == VV67H9:
   FFDDwF(CFG.fontPathSys , path)
   FFDDwF(CFG.fontScaleSys, scale if path else 100)
  err = CCEj76.VVeORA(which)
  if err          : FFU9uk(self, err, title=title)
  elif which == VV5PlV   : self.close()
  elif which == VVNq6S  : FFar20(self, "Terminal font applied", 1500)
  elif which == VVrWau and path : FFar20(self, "Font Added", 1500)
  elif which == VV67H9 and path: FFar20(self, "System font applied", 1500)
  elif which == VV67H9   : FFHsPu(self, BF(CCNqUU.VVtJwR, self), "Font changed (will take effect after GUI Restart).\n\nRestart GUI ?", title="Reset font to default")
 @staticmethod
 def VVG6En():
  if CFG.fontPathSys.getValue():
   CCEj76.VVeORA(VV5PlV  )
   CCEj76.VVeORA(VVNq6S)
   CCEj76.VVeORA(VVrWau  )
   CCEj76.VVeORA(VV67H9  )
  elif CFG.fontAllPerc.getValue() != 0:
   CCEj76.VVQJvV()
 @staticmethod
 def VVQJvV():
  perc, tot = CFG.fontAllPerc.getValue(), 0
  for name, scale, repl, fName, fPath, skinF in FFvhXh():
   newScale = int(int(scale) + float(scale) * int(perc) / 100.0)
   if FFB3Un(fPath, name, scale=newScale, isRepl=1 if repl else 0):
    tot += 1
  return tot
 @staticmethod
 def VVeORA(name):
  if   name == VV5PlV : path, repl = CFG.fontPathMain.getValue(), 0
  elif name == VVNq6S: path, repl = CFG.fontPathTerm.getValue(), 0
  elif name == VVrWau  : path, repl = CFG.fontPathAdd.getValue() , 1
  elif name == VV67H9 : path, repl = CFG.fontPathSys.getValue() , 1
  if not path:
   FFHlE6()
   return ""
  elif not FFf0vs(path):
   return "Font file not found"
  scale = 100
  nameLst = []
  if name == VV67H9:
   scale = CFG.fontScaleSys.getValue()
   nameLst = []
   for nm in FFHlE6():
    if not nm in (VV5PlV, VVNq6S):
     nameLst.append(nm)
  else:
   nameLst = [name]
  totDone = 0
  for fntName in nameLst:
   if FFB3Un(path, fntName, scale=scale, isRepl=repl):
    totDone += 1
  if totDone > 0: FFHlE6()
  else    : return "Could not add font"
 def VVkpcm(self):
  self.session.open(CC7qmh, mode=0)
class CC7qmh(Screen):
 def __init__(self, session, mode=0, dstP="", evName=""):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVJlYA=False)
  self.session = session
  self.mode  = mode
  self.dstP  = dstP
  self.evName  = evName or CCfClD.VVZ1cH(self)
  self.pDir  = "/tmp/ajp_p/"
  self.cleanName = CClqOe.VVW0yF()
  self.tbl  = None
  FFfmZP(self)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVZYcQ()
 def cancel(self, VV5ybN=None, ret=None):
  if self.tbl: self.tbl.cancel()
  self.VVmWog()
  self.close(ret)
 def VVqIBc(self, err, end=False):
  FFU9uk(self, err, self.evName or "Get Poster")
  if end: self.cancel()
 def VVmWog(self):
  FF6usE("rm -rf '%s'" % self.pDir)
 @FFHF2S()
 def VVZYcQ(self):
  self.evName = self.cleanName(self.evName)
  if not self.evName:
   self.VVqIBc("Invalid Event Name", True)
   return
  self.VVmWog()
  if not FF6usE("mkdir -p '%s'" % self.pDir):
   self.VVqIBc("Cannot create working directory", True)
   return
  if self.mode == 0:
   self.mode = 1
   lst, err = self.VVejUa()
   if not lst:
    self.mode = 2
    lst, err = self.VV8PdY()
    if err:
     self.VVqIBc(err, True)
     return
  else:
   if self.mode == 1: lst, err = self.VVejUa()
   else    : lst, err = self.VV8PdY()
   if err:
    self.VVqIBc(err, True)
    return
  if not lst:
   self.VVqIBc("Not found", True)
   return
  if self.mode == 1:
   for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
    ratio1 = CCUNc6.VVZ29q(self.evName, self.cleanName(titl))
    lst[ndx] = (titl, rel, ov, smlU, page, ratio1)
   lst = sorted(lst, key=lambda x: (x[5], x[1].lower(), x[0].lower()), reverse=True)
  else:
   for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
    ratio1 = CCUNc6.VVZ29q(self.evName, self.cleanName(titl))
    lst[ndx] = (titl, cap, rel, topCr, picU, smlU, ratio1)
   lst = sorted(lst, key=lambda x: (x[6], x[2].lower(), x[0].lower()), reverse=True)
  picDic = self.VVtd9W(lst)
  VVJwgn = []
  if self.mode == 1:
   bg = VVhHWW="#22002233"
   for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
    VVJwgn.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), page, str(ratio)))
  else:
   bg = VVhHWW="#22110011"
   for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
    if cap and (cap == titl or cap == topCr or cap == "%s (%s)" % (titl, rel)): cap = ""
    if cap and topCr: ov = "%s ... %s" % (cap, topCr)
    else   : ov = cap or topCr
    VVJwgn.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), picU, str(ratio)))
  VVLj1d = self.cancel
  VVI3Oq  = ("View Poster"    , self.VVFnme , [])
  VV4dTm = (""       , self.VVtBy7  , [])
  if self.dstP: VVbQ6N = ("Select"  , self.VVlo3Q  , [])
  else  : VVbQ6N = ("Save Poster" , self.VV7Rw0 , [])
  VVvrJb = ("More Posters"    , self.VVlXqI , []) if self.mode == 1 else None
  VVLQWC  = (1, None, 5)
  header  = ("Num" , "" , "Title" , "Release" , "Overview", "smlP", "picU", "ratio" )
  widths  = (6  , 3  , 42  , 10  , 39  , 0  , 0  , 0   )
  VVgKQc = (CENTER , LEFT , LEFT  , CENTER , LEFT  , LEFT , LEFT , LEFT  )
  self.tbl = FFdCaM(self, None, title=self.evName, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, width=1800, height=950, VV1PTZ=widths, VV1Wwb=28, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVLj1d=VVLj1d, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVFHRx=(0, 240), VVLQWC=VVLQWC
    , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVqecq="#11ffff00", VVI4UA="#11220000", VVcv6F=bg, VVsOjr="#11400040")
  self.tbl.VVIl4g(self.VVOETb)
 def VVlXqI(self, VV5ybN, title, txt, colList):
  VV5ybN.cancel()
  self.mode, self.tbl = 2, None
  self.VVZYcQ()
 def VVOETb(self):
  if not self.tbl.VVpLGs(self.tbl.VVqY3Q()[5]):
   self.tbl.VVykua()
 def VVFnme(self, VV5ybN, title, txt, colList):
  self.VV5fJo(0, colList[6])
 def VVtBy7(self, VV5ybN, title, txt, colList):
  num, pstr, titl, rel, ov, smlP, picU, ratio = colList
  txt  = "Title\t: %s\n" % titl
  if rel: txt += "Release\t: %s\n" % rel
  if ov : txt += "\n%s\n%s" % (FFITtK("Overview", VV6UAe), ov)
  FFyijw(self, txt, title)
 def VVlo3Q(self, VV5ybN, title, txt, colList):
  self.VV5fJo(3, colList[6])
 def VV7Rw0(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("Set as a Poster for a Local Media", "1"))
  VVXXzc.append(("Save to backup directory"   , "2"))
  FFw2XU(self, BF(self.VVAvUw, colList[6]), title="Save Poster", VVXXzc=VVXXzc)
 def VVAvUw(self, picU, item=None):
  if  item == "1": self.VV5fJo(1, picU)
  elif item == "2": self.VV5fJo(2, picU)
 def VVejUa(self):
  res, err = CChTrx.VVAHM2(("s%=yreuq?hcraes/gro.bdeivomeht.www//:sptth")[::-1] % FFma3M(self.evName), timeout=5)
  if err: return [], "Netowrk Error"
  lst = []
  d1 = iCompile(r'"lazy".+src="(.+\.jpg)".+srcset="(.+)"\salt="(.+)"')
  d2 = iCompile(r'href="(.+)"')
  d3 = iCompile(r'<span class="release_date">.+(\d{4})<')
  d4 = iCompile(r'<p>(.+)<\/p>')
  src1 = src2 = titl = page = rel = ov = ""
  for line in res.text.split("\n"):
   if "lazy" in line: src1 = src2 = titl = page = rel = ov = ""
   elif "search_results person hide" in line:  break
   span = d1.search(line)
   if span: src1, src2, titl = span.groups()
   span = d2.search(line)
   if span: page = "gro.bdeivomeht.www//:sptth"[::-1] + span.group(1)
   span = d3.search(line)
   if span: rel = span.group(1)
   span = d4.search(line)
   if span: ov = span.group(1)
   if all((src1, src2, titl, page, rel, ov)):
    src1, src2, titl, page, rel, ov = [CC2EFP.VVILpl(str(x.encode().decode())).strip() for x in (src1, src2, titl, page, rel, ov)]
    pics = [src1]
    for pic in iFindall(r"(http.+?.jpg)", src2):
     pic = str(pic.encode().decode())
     if not pic in pics: pics.append(pic)
    lst.append((titl, rel, ov, pics[-1] if pics else "", page, 0))
    src1 = src2 = titl = page = rel = ov = ""
  return lst, "" if lst else "Not found"
 def VV8PdY(self):
  res, err = CChTrx.VVAHM2(("ms_rs_vn=_fer&s%=q&tt=s?/dnif/moc.bdmi.www//:sptth")[::-1] % FFma3M(self.evName), timeout=5)
  if err: return [], "Netowrk Error"
  lst, err = self.VVMKeI(res.text)
  if err: return [], err
  return lst, ""
 def VVMKeI(self, txt):
  x = txt.find("<img alt=")
  if x == -1: return [], "Tag-1 not found"
  txt = txt[x:].replace("<img alt=", "\n<img alt=").replace("<svg", "\n<svg").replace("</a>", "</a>\n")
  lst1 = []
  for line in [ln for ln in txt.split("\n")]:
   if line.startswith("<img ") and not "Get the IMDb app" in line:
    span = iSearch(r'alt="(.+?)"\s+src="(.+?)"\s+srcSet="(.+?)".+\/title\/(.+?)\/', line)
    if not span: continue
    nam1, src1, src2, id1 = [CC2EFP.VVILpl(str(x.encode().decode())) for x in span.groups()]
    pics = [src1]
    for pic in iFindall(r"(http.+?.jpg)", src2):
     pic = str(pic.encode().decode())
     if not pic in pics: pics.append(pic)
    lst1.append((nam1, pics, id1))
  lst2 = []
  span = iSearch(r'"titleResults":(.+}),"companyResults"', txt)
  if not span: return [], "Tag-2 not found"
  try:
   tDic = jLoads(span.group(1))["results"]
   for item in tDic:
    id2  = FFX7JA(item, "id")
    titl = FFX7JA(item, "titleNameText")
    rel  = FFX7JA(item, "titleReleaseText")
    topCr = FFX7JA(item, "topCredits")
    if not "titlePosterImageModel" in item: continue
    item = item["titlePosterImageModel"]
    picU = FFX7JA(item, "url")
    cap  = FFX7JA(item, "caption")
    try: topCr = ", ".join([CC2EFP.VVILpl(str(x.encode())) for x in eval(topCr)])
    except: pass
    if not picU: continue
    titl, cap, rel, picU, id2 = [CC2EFP.VVILpl(str(x.encode().decode())) for x in (titl, cap, rel, picU, id2)]
    rel = rel.strip(str(u"\u2013"))
    lst2.append((titl, cap, rel, topCr, picU, id2))
  except Exception as e:
   return [], str(e)
  l1, l2 = len(lst1), len(lst2)
  if  not all((l1, l2)) : return [], "Not found"
  elif not (l1 == l2)  : return [], "Incorrect Lengths (%s/%s)" % (l1, l2)
  pLst = []
  for titl, cap, rel, topCr, picU, id2 in lst2:
   for nam1, pics, id1 in lst1:
    if id1 == id2:
     row = (titl, cap, rel, topCr, picU, pics[-1] if pics else "", 0)
     if not row in pLst: pLst.append(row)
     break
   else:
    return [], "Incorrect IDs (1 & 2)"
  return pLst, "" if pLst else "No searh result"
 def VVtd9W(self, lst):
  def VVjJzY(ndx, smlU):
   path, err = FFEyUQ(smlU, "p%s.jpg" % ndx, timeout=3, VVtOxO=True, tmpPath=self.pDir)
   if path: picDic[ndx] = path
  picDic, threads = {}, []
  for ndx, item in enumerate(lst):
   if self.mode == 1: titl, rel, ov, smlU, page, ratio = item
   else    : titl, cap, rel, topCr, picU, smlU, ratio = item
   if smlU:
    thr = iThread(target=VVjJzY, args=(ndx, smlU))
    thr.start()
    threads.append(thr)
  for thr in threads: thr.join()
  return picDic
 def VV5fJo(self, mode, picU):
  FFTSvN(self.tbl, BF(self.VVkiVf, mode, picU))
 def VVkiVf(self, mode, picU):
  if self.mode == 1:
   picU = self.VVKdjU(picU)
   if not picU: return
  path, err = FFEyUQ(picU, "p.jpg", timeout=2, VVtOxO=True, tmpPath=self.pDir)
  if path:
   resized, curW, curH, curW, curH = CCHa3c.VVmlOY(path, 1200, 1800)
   if  mode == 0: CCC0Lg.VVESKQ(self, path, title=self.evName, cbFnc=self.VV7SWF)
   elif mode == 1: self.session.openWithCallback(BF(self.VV9Eb3, path), BF(CCQdsv, VVmysg="movies", VV82pi=CFG.MovieDownloadPath.getValue()))
   elif mode == 2: self.VVlFDd("Save to backup directory", path, FFmAG5() + self.evName + ".jpg")
   elif mode == 3: self.VVlFDd("Save as Local Media Poster", path, self.dstP)
  else:
   self.VVqIBc("Cannot download poster")
 def VV7SWF(self, path):
  FFqlCI(path)
 def VVKdjU(self, url):
  picU = ""
  res, err = CChTrx.VVAHM2(url, timeout=3)
  if err:
   self.VVqIBc("Cannot get poster")
  else:
   for line in res.text.split("\n"):
    span = iSearch(r'srcset=".+,(.+)\s2x"', line)
    if span:
     picU = span.group(1)
     break
   else:
    self.VVqIBc("Cannot download poster")
  return picU
 def VV9Eb3(self, path, mPath):
  if mPath:
   dstF = "%s%s" % (os.path.splitext(mPath)[0], os.path.splitext(os.path.basename(path))[1])
   self.VVlFDd("Save as Local Media Poster", path, dstF)
 def VVlFDd(self, title, path, dst):
  if FFf0vs(dst) : FFHsPu(self, BF(self.VV2qOE, title, path, dst), "Overwrite existing file ?", title=title)
  else    : self.VV2qOE(title, path, dst)
 def VV2qOE(self, title, path, dst):
  if FF6usE("mv -f '%s' '%s'" % (path, dst)):
   if self.dstP: self.cancel(ret=path)
   else  : FFSQn9(self, "Saved to:\n\n%s" % dst, False)
  else:
   self.VVqIBc("Cannot save file.")
   FFqlCI(path)
class CCvOXK():
 VVP3eN = "ajpWebServer"
 def __init__(self, session):
  self.session = session
  tw = skt = srv = None
  try: from twisted.internet import reactor as tw
  except: pass
  try: import SocketServer as skt
  except:
   try: import socketserver as skt
   except: pass
  try: import SimpleHTTPServer as srv
  except:
   try: import http.server as srv
   except: pass
  self.VV9SUa, self.VVV2ed, self.VVJp75 = skt, srv, tw
 def VVycZs(self):
  if not self.VV9SUa or not self.VVV2ed: return
  fnc = self.VVGYqo
  VVJp75 = self.VVJp75
  class CCOOaj(self.VVV2ed.SimpleHTTPRequestHandler):
   def do_GET(self):
    self.VV64gt("")
   def do_POST(self):
    length = int(self.headers["Content-Length"])
    data = str(self.rfile.read(length))
    self.VV64gt(data)
   def VV64gt(self, data):
    if   len(self.path) > 100: mode, rCode, rTxt = 1, 414, "URI Too Long"
    elif not VVJp75   : mode, rCode, rTxt = 1, 400, "Missing Twisted Module"
    else      : mode, rCode, rTxt = fnc(self.path, data)
    if mode == 1:
     cType = "application/json"
     dic = {VVryLp: VVsBow, "Request": self.path, "Result" : rTxt}
     rTxt = jDumps(dic).encode()
    else:
     cType = "text/html"
    self.send_response(rCode)
    self.send_header("Content-type", cType)
    self.end_headers()
    self.wfile.write(rTxt)
  try:
   global VVMXfj
   handler = CCOOaj
   self.VV9SUa.TCPServer.allow_reuse_address = True
   VVMXfj = self.VV9SUa.TCPServer(("", CFG.wsPort.getValue()), handler)
   th = iThread(name=CCvOXK.VVP3eN, target=VVMXfj.serve_forever)
   th.setDaemon(True)
   th.start()
  except:
   pass
 def VVGYqo(self, uPath, data):
  uPath = uPath.lower()
  if  uPath.startswith("/player"): rCode, rTxt = self.VVMI2g(data)
  else       : rCode, rTxt = 400, "Unknown request"
  mode = 1
  return mode, rCode, rTxt
 def VVrVvi(self, fnc):
  def VVjJzY():
   if currentThread().getName() == "MainThread": fnc()
  if self.VVJp75: self.VVJp75.callFromThread(VVjJzY)
 def VVMI2g(self, data):
  try: dic = jLoads(data)
  except: dic = {}
  tab = lambda x: FF0rS9(str(dic[x]).strip()) if x in dic else ""
  url = tab("url")
  ref = tab("ref")
  name= tab("name")
  logo= tab("logo")
  endRef= tab("endRef")
  if not name and url.startswith("/"): name = os.path.splitext(os.path.basename(url))[0]
  name = name or "No Name"
  if ref and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10})$", ref)   : return 400, "Incorrect ref format"
  if endRef and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10}).*", endRef): return 400, "Incorrect endRef format"
  chUrl = ""
  if url:
   ref = ref or "%s:0:1:0:0:0:0:0:0:0:" % CFG.iptvAddToBouquetRefType.getValue()
   if  url.startswith("http") : url = FFma3M(url)
   elif url.startswith("/") : pass
   else      : return 400, "Incorrect URL"
   chUrl = "%s%s:%s" % (ref.upper(), url, name)
  elif ref:
   chUrl = ref
  if CC2lVw.VVHlBB:
   txt = "Channel Changed" if ref else "Player is already shown"
   fnc = BF(CC2lVw.VVHlBB.VV35gS, chUrl, endRef, logo)
  else:
   txt = "Player Started"
   fnc = BF(CC2lVw.VVbVSZ, self.session, VV7GTU=chUrl, endRef=endRef, VVthiO=logo)
  self.VVrVvi(fnc)
  return 200, txt
 def VV7xyw(self, trunOn):
  err = ""
  if not all((self.VV9SUa, self.VVV2ed)):
   err = "Missing Python libraries"
  else:
   isOn = CCvOXK.VVQN7G()
   if trunOn:
    if isOn : err = "Already running"
    else : self.VVycZs()
   else:
    if isOn : CCvOXK.VVGhIc()
    else : err = "Already stopped"
  return err, CCvOXK.VVNGpj()
 @staticmethod
 def VVGhIc():
  if "VVMXfj" in globals():
   global VVMXfj
   if hasattr(VVMXfj, "_BaseServer__shutdown_request"):
    VVMXfj._BaseServer__shutdown_request = True
   VVMXfj.shutdown()
   VVMXfj.server_close()
   FFdsOh("VVMXfj")
 @staticmethod
 def VVNGpj():
  return "Turned %s" % ("ON" if CCvOXK.VVQN7G() else "OFF")
 @staticmethod
 def VVQN7G():
  thrListUrls = []
  for thr in iEnumerate():
   if thr.name == CCvOXK.VVP3eN:
    return True
  else:
   return False
class CCaZ62():
 def __init__(self, session):
  self.Session = session
  self.servPtr  = CCaZ62.VVtSAP(self.Session)
  self.VVDhju  = ""
  self.VVu69c  = ""
  self.VVQwVu  = ""
  self.VVLZ0Z  = ""
  self.VVeZBd   = ""
  self.prov   = ""
  self.state   = ""
  self.isMarker  = False
  self.info   = self.servPtr and self.servPtr.info()
  if self.info:
   self.VVeZBd  = self.info.getName()
   ref     = FF7SHi(self.info, iServiceInformation.sServiceref)
   state   = FF7SHi(self.info, iServiceInformation.sDVBState)
   self.prov  = FF7SHi(self.info, iServiceInformation.sProvider)
   self.isMarker = FF2eiM(ref)
   if self.isMarker:
    self.state = "Marker"
    self.VVDhju = ref.rstrip(":")
    self.VVeZBd = self.VVYP0A()
   else:
    self.VVLZ0Z = ref if self.VVu69c else ""
    self.state = self.VVCEOc(state)
    self.VVDhju, self.VVu69c, self.VVQwVu, self.VVLZ0Z = CCaZ62.VVXPhc(ref)
  self.servRef = CCaZ62.VVOcgs(self.Session)
  if self.servRef:
   self.Name  = self.servRef.getName()
   self.VVkcp9 = self.servRef.toString()
   self.VV0Mi9 = self.servRef.toCompareString()
   self.refType = str(self.servRef.type)
   self.Path  = self.servRef.getPath()
   self.isValid = self.servRef.valid()
   self.flags  = self.servRef.flags
   try: self.chNum = self.servRef.getChannelNum()
   except: self.chNum = 0
  else:
   self.Name  = ""
   self.VVkcp9 = ""
   self.VV0Mi9 = ""
   self.refType = ""
   self.Path  = ""
   self.isValid = False
   self.flags  = 0
   self.chNum  = 0
  span = iSearch(r"^((?:[A-F0-9]+[:]){9}(?:[A-F0-9]+))", self.VVDhju or self.VVkcp9, IGNORECASE)
  self.VV6phL = span.group(1).upper().rstrip(":") if span else ""
  span = iSearch(r"http.+\/((?:[A-Fa-f0-9]+:){10}):", self.VVu69c)
  self.VV5zMI = span.group(1).rstrip(":") if span else ""
  self.isLocal = self.isIptv = self.isFtp = self.isDvb = self.isDvbS = self.isDvbC = self.isDvbT = self.VVsC9C = False
  typ = ""
  if   "file?file" in self.VVkcp9 or ":ftp%3a//" in self.VVkcp9 : typ, self.isFtp = "FTP", True
  elif FFOr4F(self.VVkcp9) or self.VV5zMI    : typ, self.VVsC9C= "S. Relay", True
  elif FFPrVr(self.VVkcp9)          : typ, self.isIptv = "IPTV", True
  elif self.Path.startswith("/")         : typ, self.isLocal = "Local Media", True
  elif not self.Path:
   self.isDvb = True
   ns = FFC21b(self.VVkcp9)
   if   ns.startswith("EEEE") : typ, self.isDvbT = "DVB-T", True
   elif ns.startswith("FFFF") : typ, self.isDvbC = "DVB-C", True
   else      : typ, self.isDvbS = "DVB-S", True
  self.streamType = typ
  span = iSearch(r"(.+)(mode=.+end=)", self.VVu69c, IGNORECASE)
  if span:
   self.VVJ8Yn = span.group(1).rstrip("&?")
   self.myPhp = span.group(2)
  else:
   self.VVJ8Yn = ""
   self.myPhp = ""
  self.uniqueId = self.myPhp if self.myPhp else self.Path or self.VVDhju
  self.userTxt = self.VVJ8Yn or self.Path or self.VVDhju
 def VVYP0A(self):
  for r, n, f in CC41Tt.VVSaEJ(mode=1):
   if self.VVDhju in r:
    return n
  return self.VVeZBd + " (Marker)"
 def VVCEOc(self, s):
  if   not s :s=""
  elif s=="0" :s="*No free tuner"
  elif s=="1" :s="*Tune Failed"
  elif s=="2" :s="*Timeout reading PAT"
  elif s=="3" :s="*SID not found in PAT"
  elif s=="4" :s="*Timeout reading PMT"
  elif s=="5" :s="New program info"
  elif s=="6" :s="Tuned"
  elif s=="7" :s="Pre-Start"
  elif s=="8" :s="SOF"
  elif s=="9" :s="EOF"
  elif s=="10":s="*Check tuner configuration"
  elif s=="11":s="HBBTV Info"
  elif s=="12":s="*Stopped"
  elif s=="13":s="Channel Allocated"
  return s
 @staticmethod
 def VVOcgs(session):
  return session.nav.getCurrentlyPlayingServiceReference()
 @staticmethod
 def VVtSAP(session):
  return session.nav.getCurrentService()
 @staticmethod
 def VVXPhc(ref):
  if ref.endswith(("%3a", "%3A")): ref = ref[:-3]
  span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})(.+\/\/.+)", ref)
  if span:
   VVDhju = span.group(1).upper().rstrip(":")
   VVQwVu = span.group(2)
   return VVDhju, FF0rS9(VVQwVu), VVQwVu, VVDhju + ":" + VVQwVu
  else:
   VVDhju = ref
  return VVDhju.rstrip(":"), "", "", ""
class CCBUJe():
 def __init__(self, SELF, tableObj, colNum=0):
  self.SELF  = SELF
  self.tableObj = tableObj
  self.colNum  = colNum
  self.VVX3gF = -1
  self.SERVICE = 0
  self.STRING  = 1
  self.MULTI  = 2
  s = str(type(self.tableObj.l))
  if   "'enigma.eListboxServiceContent'" in s  : self.mode = self.SERVICE
  elif "'enigma.eListboxPythonStringContent'" in s: self.mode = self.STRING
  elif "'enigma.eListboxPythonMultiContent'" in s : self.mode = self.MULTI
  else           : return
  from Tools.NumericalTextInput import NumericalTextInput
  self.numericalTextInput = NumericalTextInput(nextFunc=self.VVxdV4)
  self.numericalTextInput.setUseableChars('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  FFyNtd(SELF, {str(i):BF(self.VVBADD, i) for i in range(10)})
 def VVBADD(self, key):
  self.VVX3gF = self.numericalTextInput.getKey(key)
  for group in ("1", "2ABC", "3DEF", "4GHI", "5JKL", "6MNO", "7PQRS", "8TUV", "9WXYZ", "0"):
   if self.VVX3gF in group:
    if VVHFlX:
     txt = " ".join(group)
     txt = txt.replace(self.VVX3gF, VVHFlX + self.VVX3gF + VVVAvR)
     txt = VVVAvR + txt
    else:
     sep = "    "
     txt = sep + sep.join(group) + sep
     txt = txt.replace(sep + self.VVX3gF + sep, "   [%s]   " % self.VVX3gF)
    FF8PJn(self.SELF, txt)
 def VVxdV4(self):
  FF8PJn(self.SELF)
  try:
   if not self.tableObj:
    return
   if self.mode == self.SERVICE:
    try: self.tableObj.moveToChar(self.VVX3gF)
    except: self.tableObj.moveToChar(self.VVX3gF.encode())
   elif self.tableObj.list:
    for ndx in range(len(self.tableObj.list)):
     item = self.tableObj.list[ndx]
     if self.mode == self.STRING : item = item[self.colNum]
     else      : item = item[self.colNum + 1][7]
     item = FFes9J(item).strip().encode().decode()
     if item.upper()[:1] == self.VVX3gF:
      self.tableObj.moveToIndex(ndx)
      break
  except:
   pass
class CCcFcS(Screen):
 def __init__(self, session, isMove, VV5dDF, srcDir, dstDir):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", 30)
  self.session  = session
  self.isMove   = isMove
  self.VV5dDF   = VV5dDF
  self.srcDir   = FFA4GT(srcDir)
  self.dstDir   = FFA4GT(dstDir)
  self.isMoveFast  = isMove and CCQdsv.VVZBjZ(self.srcDir) == CCQdsv.VVZBjZ(self.dstDir)
  self.files   = []
  self.dirs   = []
  self.others   = []
  self.action   = "move" if isMove else "copy"
  self.Title   = self.action.capitalize()
  self.resText  = ""
  self.totPaths  = 0
  self.totFiles  = 0
  self.totDirs  = 0
  self.curItem  = ""
  self.curErr   = ""
  FFfmZP(self, addScrollLabel=True, title=self.Title)
  FFyNtd(self, { "ok": self.VVkIEK, "cancel": self.VVkIEK })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP()
  err = ""
  itemExists = False
  if self.srcDir == self.dstDir:
   self.VVqIBc("Cannot %s to same directory" % self.action)
  else:
   itself = "Cannot %s a directory to itself" % self.action
   for name in self.VV5dDF:
    err = ""
    path = os.path.join(self.srcDir, name)
    if path == self.dstDir:
     err = itself
    elif os.path.islink(FFHP0y(path)):
     self.totPaths += 1
    elif os.path.ismount(path):
     err = "Cannot include mount"
    elif os.path.isdir(path):
     self.totPaths += 1
     if FFA4GT(path) == self.dstDir:
      err = itself
     else:
      totDir, totFile, totLink = FFhWIm(path)
      self.totPaths += totDir + totFile + totLink
    else:
     self.totPaths += 1
    if err:
     self.VVqIBc("%s\n\n%s" % (err, path))
     return
    elif FFf0vs(os.path.join(self.dstDir, FFVUvT(path))):
     itemExists = True
  if itemExists: FFHsPu(self, self.VVwEW2, "Overwrite items in destination ?", callBack_No=self.close, title=self.Title)
  else   : self.VVwEW2()
 def VVkIEK(self):
  self.close()
 def VV98tz(self, txt):
  self["myLabel"].appendText(str(txt))
 def VVqIBc(self, txt):
  FFU9uk(self, txt, title=self.Title)
  self.VVkIEK()
 def VVwEW2(self):
  totBars = 1 if self.isMoveFast else 2
  CCXRxc.VVJ9VK(self, VVmj1O=self.Title, VV9L2m=CCXRxc.VVE4fR, titleBg="#22220022", bodyBg="#22220022", totBars=totBars
      , VVCJhW  = self.VVEL5L
      , VVuQkS = self.VVJ4Re )
 def VVEL5L(self, VVM2wn):
  VVM2wn.VVqMKy(self.totPaths)
  for name in self.VV5dDF:
   srcPath = os.path.join(self.srcDir, name)
   dstPath = os.path.join(self.dstDir, name)
   self.curItem = srcPath
   if not VVM2wn or VVM2wn.isCancelled: return
   if os.path.islink(FFHP0y(srcPath)):
    self.totFiles += self.VVKLiG(srcPath, dstPath, VVM2wn)
   elif os.path.isdir(srcPath):
    for Dir, subdirs, files in os.walk(srcPath):
     if not VVM2wn or VVM2wn.isCancelled: return
     if not subdirs and not files:
      VVM2wn.VVwOHf(1)
      dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
      try:
       if not VVrRHR(dstDir): os.makedirs(dstDir)
       self.totDirs += 1
      except Exception as e:
       self.curErr = str(e)
       VVM2wn.VVNQHr()
       return
     else:
      VVM2wn.VVwOHf(1)
      dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
      try:
       if not VVrRHR(dstDir): os.makedirs(dstDir)
       self.totDirs += 1
      except Exception as e:
       self.curErr = str(e)
       VVM2wn.VVNQHr()
       return
      for name in files:
       if not VVM2wn or VVM2wn.isCancelled: return
       self.totFiles += self.VVKLiG(os.path.join(Dir, name), os.path.join(dstDir, name), VVM2wn)
    if self.isMove: FFQQ78(srcPath)
   else:
    self.totFiles += self.VVKLiG(srcPath, dstPath, VVM2wn)
 def VVKLiG(self, srcPath, dstPath, VVM2wn):
  title = "../" + os.path.join(FFVUvT(FF5AKn(srcPath, True)), os.path.basename(srcPath))
  VVM2wn.VVkdWG(title)
  self.curItem = srcPath
  size = FFX42v(srcPath)
  if size == -1:
   size = 0
  VVM2wn.VV75eC(0)
  VVM2wn.VVFO1V(size)
  VVM2wn.VVwOHf(1)
  if os.path.islink(FFHP0y(srcPath)):
   FFQQ78(dstPath)
   try:
    os.symlink(os.readlink(srcPath), dstPath)
   except:
    self.curErr = "Cannot copy SymLink"
    VVM2wn.VVNQHr()
    return 0
  elif self.isMoveFast:
   if not FF6usE("mv -f '%s' '%s'" % (srcPath, dstPath)):
    VVM2wn.VVNQHr()
    return 0
  else:
   try:
    with open(srcPath, "rb") as srcF:
     with open(dstPath, "wb") as dstF:
      while True:
       if not VVM2wn or VVM2wn.isCancelled:
        FFqlCI(dstPath)
        return 0
       try:
        data = srcF.read(1024)
        if not data:
         break
        dstF.write(data)
        VVM2wn.VVoreX(len(data))
       except Exception as e:
        self.curErr = str(e)
        FFqlCI(dstPath)
        VVM2wn.VVNQHr()
        return 0
      VVM2wn.VVkdWG(FFITtK(title, VV8QGw))
   except Exception as e:
    self.curErr = str(e)
    return 0
  try: iCopymode(srcPath, dstPath)
  except: pass
  if self.isMove: FFQQ78(srcPath)
  return 1
 def VVJ4Re(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  txt  = "Total\t: %s\n" % self.totPaths
  txt += "Processed\t: %s\n\n" % (FFITtK(threadCounter, VV8QGw if threadCounter == self.totPaths else VVcahY))
  txt += "%s Files\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totFiles)
  txt += "%s Dirs\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totDirs)
  if not VV9zbx or self.curErr or threadErr or threadCounter != self.totPaths:
   txt += FFITtK("\n\nLast Processed:\n", VVcahY)
   txt += "%s\n" % self.curItem
   if self.curErr:
    txt += FFITtK("\nLast Error:\n", VVcahY)
    txt += "%s\n" % self.curErr
  self.VV98tz(txt)
  self["myLabel"].VVNtRi()
class CCCHs8():
 def __init__(self):
  self.nmUselessWords  = CCCHs8.VVe9Ck()
  self.nmComp2yearsPatt = iCompile(r".*\d{4}.+\d{4}")
  self.nmSkip2yearsPatt = iCompile(r"(.*\d{4}.+)\d{4}\s*(.*)")
  self.nmSkip1yearsPatt = iCompile(r" \d{4}")
  self.nmSkipWordsPatt = CCCHs8.VVfTvc()
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
 def VVW7IJ(self, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if   not pathLst  : return [] , ""
  elif not self.iClosest : return [], 'Missing "difflib" library'
  if maxRes == 0:
   maxRes = len(pathLst)
  refLst = []
  for ndx, path in enumerate(pathLst):
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt:
    refLst.append("%d,%s" % (ndx, txt))
  bestLst = self.iClosest(textToFind, refLst, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  return lst, ""
 def VVwKwI(self, SELF, cbFnc, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if  not pathLst  : cbFnc([] , "")
  elif not self.iClosest : cbFnc([], 'Missing "difflib" library')
  else:
   CCXRxc.VVJ9VK(self, VVmj1O="Searching ...", titleBg="#22220022", bodyBg="#22220022", VV9L2m=CCXRxc.VVE4fR
       , VVCJhW  = BF(self.VVsM6Y, textToFind, pathLst, maxRes, cutoff, cbFnc)
       , VVuQkS = BF(self.VVjQHz, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc))
 def VVsM6Y(self, textToFind, pathLst, maxRes, cutoff, cbFnc, VVM2wn):
  VVM2wn.VVqMKy(len(pathLst))
  VVM2wn.VViN1g = []
  if maxRes == 0:
   maxRes = len(pathLst)
  for ndx, path in enumerate(pathLst):
   if not VVM2wn or VVM2wn.isCancelled:
    return
   VVM2wn.VVwOHf(1)
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt and VVM2wn and not VVM2wn.isCancelled:
    VVM2wn.VViN1g.append("%d,%s" % (ndx, txt))
 @FFHF2S("Filtering ...", par=1)
 def VVjQHz(self, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  bestLst = self.iClosest(textToFind, VViN1g, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  cbFnc(lst, "")
 @staticmethod
 def VVe9Ck():
  return ('4k','8k','aac5','am','ar','arabic','avc','blueray','bluray','brrip','ddp5','dts','en','english','evo','hd','hdr','hdrip','hevc','mora','multi','multisub','mx','netflix','nf','remux','srt','sub','utf8','web','webrip','xvid','yify','yts')
 @staticmethod
 def VVfTvc():
  return iCompile(r"\d{3,4}p"
      r"|[A-Za-z]\d{3}"
      r"|\d{1,3}bit[s]?"
      r"|25r|25rat|25rate"
      r"|[A-Za-z]{2}\d"
      , IGNORECASE)
class CC5LkQ(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 800, 950, 40, 50, 30, "#22300030", "#0a202020", 33)
  self.session  = session
  self.netEntryFile = FFmAG5() + "ajpanel_network"
  c1, c2 = VV6UAe, VVnQYw
  VVXXzc = []
  VVXXzc.append((c1 + "Network Storage (FTP)"   , "dev" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Network Scanner (ping)"    , "ping"))
  VVXXzc.append(("Port Scanner (scan for famous ports)" , "port"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Check Internet Connection"  , "intr"))
  FFfmZP(self, title="Network Tools", VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if   item == "dev" : self.VVRizb()
  elif item == "ping" : self.VVMKQa()
  elif item == "port" : CChg05.VVec5M(self, self.VVA8dd, title="Select host to scan")
  elif item == "intr" : self.session.open(CC5l7M)
 @FFHF2S("Reading Devices ...")
 def VVRizb(self, canCencel=False):
  title = "Network Devices"
  VVJwgn = self.VVA77s()
  if VVJwgn:
   bg = "#0a223333"
   VVJwgn.sort(key=lambda x: x[0].lower())
   VVLj1d = BF(self.VVqPyy, canCencel)
   VVI3Oq  = ("Start FTP"   , self.VV1dcf    , [])
   VVbQ6N = ("Entry Options"  , self.VVuUoX  , [])
   VVvrJb = ("Scan for Devices" , self.VV8Ii1 , [])
   header  = ("Num" , "IP-Address" , "Username", "Password", "Default Path", "Remarks" )
   widths  = (7  , 25   , 19  , 19  , 0.01   , 30  )
   VVgKQc = (CENTER , LEFT   , LEFT  , LEFT  , LEFT   , LEFT  )
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, width=1500, height=900, VV1PTZ=widths, VV1Wwb=28, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb
       , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVqecq="#11ffff00", VVI4UA="#11220000", VVcv6F="#00333333", VVsOjr="#11400040")
   ndx = CFG.lastNetworkDevice.getValue()
   if isinstance(ndx, int):
    VV5ybN.VV43d2(ndx)
  else:
   FFHsPu(self, BF(self.VVM9Tx, canCencel=canCencel), "No devices found !\n\nScan network ?", callBack_No=BF(self.VVqPyy, canCencel), title=title)
 def VVuUoX(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("Change Username"   , "user"))
  VVXXzc.append(("Change Password"   , "pass"))
  VVXXzc.append(("Change Remarks"   , "rem"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Remove Selected Server" , "del"))
  FFw2XU(self, BF(self.VVcsci, VV5ybN), VVXXzc=VVXXzc, title="Entry Options")
 def VVcsci(self, VV5ybN, item=None):
  if item:
   if   item == "user" : self.VVN21T("u", VV5ybN)
   elif item == "pass" : self.VVN21T("p", VV5ybN)
   elif item == "rem" : self.VVN21T("r", VV5ybN)
   elif item == "del" : FFHsPu(self, BF(self.VVQpRF, VV5ybN), "Continue ?", title="Delete Entry")
 def VVqPyy(self, canCencel, VV5ybN=None):
  if VV5ybN: VV5ybN.cancel()
  if canCencel : self.close()
 def VV1dcf(self, VV5ybN, title, txt, colList):
  num, ip, u, p, path, rem = colList
  entry = (ip, u, p, path, rem)
  FFDDwF(CFG.lastNetworkDevice, VV5ybN.VVfkJL())
  self.session.openWithCallback(BF(self.VVLfpS, entry, VV5ybN), CCjfEP, entry)
 def VVLfpS(self, entry, VV5ybN, newPath=None):
  if newPath:
   ip, u, p, path, rem = entry
   if path != newPath:
    self.VVyQQB("d", newPath, ip, u, p, path, rem)
    self.VVYtLU(VV5ybN)
 @FFHF2S("Scanning Network ...", clearMsg=False, par=1)
 def VV8Ii1(self, VV5ybN, title, txt, colList):
  self.VVM9Tx(mainTableInst=VV5ybN)
 @FFHF2S("Scanning ...")
 def VVM9Tx(self, canCencel=False, mainTableInst=None):
  title = "Network Devices"
  ftpLst, err = CChg05.VVsYvW(CChg05.VVJws4)
  if err:
   FFU9uk(self, err, title=title)
   return
  telLst, err = CChg05.VVsYvW(CChg05.VV7RnO)
  if err:
   FFU9uk(self, err, title=title)
   return
  tLst = list(set(ftpLst + telLst))
  lst = []
  for item in tLst:
   typ = []
   if item in ftpLst: typ.append("FTP")
   if item in telLst: typ.append("Telnet")
   lst.append((item[0], item[1], " / ".join(typ)))
  ftpLst = telLst = tLst = None
  if mainTableInst:
   mainTableInst.VV8SQf()
  if lst:
   def VVs8kf(p1, p2): return FFyTkm(p1[0], p2[0])
   lst.sort(key=FFNnh8(VVs8kf))
   bg = "#0a202020"
   VVLj1d = BF(self.VVqPyy, canCencel)
   VVI3Oq  = ("Add to Devices" , BF(self.VVBYWZ, mainTableInst, canCencel), [])
   header  = ("IP-Address" , "MAC-Address" , "Open Ports" )
   widths  = (40   , 34   , 26   )
   VVgKQc = (LEFT   , CENTER  , CENTER  )
   FFdCaM(self, None, title=title, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1200, VV1Wwb=30, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VV4HrS=2
     , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a225555", VVsOjr="#11403040")
  else:
   FFU9uk(self, "No devices found !", title=title)
 @FFHF2S("Scanning ...")
 def VVMKQa(self):
  title = 'Hosts that responded to "ping"'
  lst, err = CChg05.VVsYvW(-1)
  if err:
   FFU9uk(self, err, title=title)
  elif lst:
   def VVs8kf(p1, p2): return FFyTkm(p1[0], p2[0])
   lst.sort(key=FFNnh8(VVs8kf))
   bg = "#0a202020"
   header  = ("IP-Address" , "MAC-Address" )
   widths  = (50   , 50   )
   VVgKQc = (LEFT   , LEFT   )
   FFdCaM(self, None, title=title, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1000, height=700, VV1Wwb=30
     , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a225555", VVsOjr="#11403040")
  else:
   FFU9uk(self, "Network scanning failed !", title=title)
 @FFHF2S("Scanning")
 def VVA8dd(self, ip=None):
  if not ip: return
  dct = {20: "FTP Data Transfer", 21: "FTP Control", 22: "SSH", 23: "Telnet", 25: "SMTP (eMail)", 80: "HTTP", 443: "HTTPS"}
  txt  = "IP:\n   %s\n\n" % ip
  txt += "Ping Result:\n   %s\n\n" % ("OK" if CChg05.VVaD2s(ip) else "Failed")
  txt += "Available Ports:\n"
  ports = ""
  for port, subj in dct.items():
   ok = CChg05.VVR1V7(ip, port, timeout=0.5)
   if ok:
    ports += "   %d : %s\n" % (port, subj)
  FFyijw(self, txt + (ports or "   None"), title="Scanned ports : %s" % str(list(dct)).strip("[]"))
 def VVA77s(self):
  tLst = []
  if FFf0vs(self.netEntryFile):
   txt = FF05rJ(self.netEntryFile)
   data = iFindall(r"host\s*=(.+),\s*user\s*=(.+),\s*pass\s*=(.*),\s*path\s*=(.*),\s*rem\s*=(.*)", txt, IGNORECASE)
   for ip, u, p, path, rem in data:
    ip, u, p, path, rem = ip.strip(), u.strip(), p.strip(), path.strip() or "/", rem.strip()
    tLst.append((ip, u, p, path, rem))
  def VVs8kf(p1, p2): return FFyTkm(p1[0], p2[0])
  tLst.sort(key=FFNnh8(VVs8kf))
  lst = []
  for num1, item in enumerate(tLst, start=1):
   ip, u, p, path, rem = item
   lst.append((str(num1), ip, u, p, path, rem))
  return lst
 def VVBYWZ(self, mainTableInst, canCencel, VV5ybN, title, txt, colList):
  ip, mac, typ = VV5ybN.VVVB7s(VV5ybN.VVfkJL())
  if "Own" in ip:
   FF8PJn(VV5ybN, "Cannot add your device", 1500)
  else:
   gw = "Gateway"
   if gw in ip : ip, u, p, path, rem = ip.split()[0].strip(), "admin", "123456", "/", gw
   else  : ip, u, p, path, rem = ip, "root", "dreambox", "/", "No-name"
   for entry in self.VVA77s():
    num1, ip1, u1, p1, path1, rem1 = entry
    if (ip, u, p, path, rem) == (ip1, u1, p1, path1, rem1):
     break
   else:
    if FFf0vs(self.netEntryFile):
     FFxGSn(self.netEntryFile)
    with open(self.netEntryFile, "a") as f:
     f.write(self.VVWTxh(ip, u, p, path, rem))
   if mainTableInst: self.VVYtLU(mainTableInst, [ip, u, p, path, rem])
   else   : self.VVRizb(canCencel)
   VV5ybN.cancel()
 def VVWTxh(self, ip, u, p, path, rem):
  return "host=%s,user=%s,pass=%s,path=%s,rem=%s\n" % (ip, u, p, path, rem)
 @FFHF2S("Deleting ...", par=1)
 def VVQpRF(self, VV5ybN):
  num, ip, u, p, path, rem = VV5ybN.VVVB7s(VV5ybN.VVfkJL())
  lst = self.VVA77s()
  tot = 0
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if not (ip1, u1, p1, path1, rem1) == (ip, u, p, path, rem):
     f.write(self.VVWTxh(ip1, u1, p1, path1, rem1))
     tot += 1
  if tot:
   self.VVYtLU(VV5ybN)
  else:
   VV5ybN.cancel()
 def VVN21T(self, col, VV5ybN):
  num, ip, u, p, path, rem = VV5ybN.VVVB7s(VV5ybN.VVfkJL())
  if   col == "u": orig, subj = u  , "User"
  elif col == "p": orig, subj = p  , "Password"
  elif col == "r": orig, subj = rem, "Remarks"
  FFttdT(self, BF(self.VVl0Lc, col, orig, VV5ybN, num, ip, u, p, path, rem), defaultText=orig, title="Change %s" % subj, message="Enter %s:" % subj)
 def VVl0Lc(self, col, orig, VV5ybN, num, ip, u, p, path, rem, newTxt):
  if not newTxt == None:
   newTxt = newTxt.strip()
   if orig == newTxt:
    FF8PJn(VV5ybN, "No change", 1500)
   elif not newTxt and col == "u":
    FF8PJn(VV5ybN, "No user !", 2000)
   else:
    self.VVyQQB(col, newTxt, ip, u, p, path, rem)
    self.VVYtLU(VV5ybN)
 def VVyQQB(self, col, newTxt, ip, u, p, path, rem):
  lst = self.VVA77s()
  oldItem = (ip, u, p, path, rem)
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if (ip1, u1, p1, path1, rem1) == oldItem:
     if   col == "u": u1  = newTxt
     elif col == "p": p1  = newTxt
     elif col == "d": path1 = newTxt
     elif col == "r": rem1 = newTxt
    f.write(self.VVWTxh(ip1, u1, p1, path1, rem1))
 def VVYtLU(self, VV5ybN, newEntry=None):
  VVJwgn = self.VVA77s()
  if VVJwgn : VV5ybN.VVxhz9(VVJwgn, VVK0Fc=BF(self.VVNPjW, newEntry))
  else  : VV5ybN.cancel()
 def VVNPjW(self, newEntry, VV5ybN, title, txt, colList):
  if newEntry:
   for ndx, row in enumerate(VV5ybN.VVTq0J()):
    if row[1:] == newEntry:
     VV5ybN.VV43d2(ndx)
 def VVqPyy(self, canCencel, VV5ybN=None):
  if VV5ybN: VV5ybN.cancel()
  if canCencel : self.close()
class CChg05():
 VVJws4 = 21
 VV7RnO = 23
 def __init__(self):
  self.VVSxRQ()
 def VVSxRQ(self):
  self.ftp  = None
  self.ftpIp  = ""
  self.ftpUser = ""
  self.ftpPass = ""
  self.ftpSys  = ""
 def VV6Q8P(self, ip, User, Pass, timeout=5):
  myIp = CChg05.VVdFtN()
  if ip != myIp:
   if CChg05.VVR1V7(ip, CChg05.VVJws4):
    self.VVSxRQ()
    err = ""
    try:
     from ftplib import FTP
     self.ftp  = FTP(ip, user=User, passwd=Pass, timeout=timeout)
     self.ftp.set_pasv(False)
     self.ftpIp  = ip
     self.ftpUser = User
     self.ftpPass = Pass
    except Exception as e:
     err = str(e)
   else:
    err = "Connection timed out !\n\n%s" % ip
  else:
   err = "Cannot FTP to your Device-IP:\n\n%s" % ip
  return err
 def VVjGaN(self):
  try: return self.ftp.sendcmd("SYST")
  except: return ""
 def VV00PL(self):
  try: return self.ftp.sendcmd("NOOP")
  except: return ""
 def VVVsGL(self, timeout=3):
  t1 = iTime()
  while True:
   state = self.VV00PL()
   if not state or state == "200 OK" or iTime() - t1 >= timeout:
    break
 def VV5Jco(self):
  try: return self.ftp.sendcmd("STAT")
  except: return ""
 def VVpZ50(self, Dir, isLong=False):
  files, err = [], ""
  if self.ftp and self.VV7xwg(Dir):
   try:
    if isLong: self.ftp.dir(files.append)
    else  : self.ftp.nlst()
   except Exception as e:
    err = str(e)
  else:
   err = "No FTP Connection !"
  return files, err
 def VV7Fo2(self):
  try: return self.ftp.pwd()
  except: return ""
 def VV7KAI(self, path):
  try:
   size = self.ftp.sendcmd("SIZE %s" % path)
   return "f"
  except:
   VVVhOI = self.VV7Fo2()
   if self.VV7xwg(path) : typ = "d"
   else      : typ = "b"
   self.VV7xwg(VVVhOI)
   return typ
 def VVG4kw(self, path):
  try: return self.ftp.size(path)
  except: return -1
 def VV7xwg(self, path):
  try:
   self.ftp.cwd(path)
   return True
  except:
   return False
 def VV8xP8(self, path):
  try:
   self.ftp.mkd(path)
   return True
  except:
   return False
 def VVYuKJ(self, path, flag):
  try:
   if flag == "d" : self.ftp.rmd(path)
   else   : self.ftp.delete(path)
   return True
  except:
   return False
 def VVpVHu(self, fromN, toN):
  try:
   self.ftp.rename(fromN, toN)
   return True
  except:
   return False
 def VVITJ9(self, remFile, locFile="", maxSz=10000000):
  sz = self.VVG4kw(remFile)
  if   sz == -1 : return "", sz, "Cannot read file size."
  elif sz > maxSz : return "", sz, "File too big."
  else   : err= ""
  locFile = locFile or "/tmp/%s" % os.path.basename(remFile)
  try:
   self.ftp.retrbinary("RETR %s" % remFile, open(locFile, "wb").write)
   if FFf0vs(locFile) : return locFile, sz, ""
   else     : return "", sz, "Download Failed."
  except Exception as e:
   FFqlCI(locFile)
   return "", sz, str(e)
 def VVrtKG(self):
  if self.ftp:
   try: self.ftp.quit()
   except: pass
  self.VVSxRQ()
 @staticmethod
 def VVFbBj():
  from uuid import getnode
  return ':'.join(iFindall('..', '%012x' % getnode())).upper()
 @staticmethod
 def VVdFtN():
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_DGRAM
  try:
   setdefaulttimeout(1)
   s = socket(AF_INET, SOCK_DGRAM)
   s.connect(("1.1.1.1", 80))
   ip = s.getsockname()[0]
   s.close()
   return ip
  except:
   return ""
 @staticmethod
 def VVxZIB():
  myIp = CChg05.VVdFtN()
  if myIp.count(".") == 3:
   parts = myIp.split('.')
   return ".".join(parts[:3]) + "."
  return ""
 @staticmethod
 def VVJ4An():
  span = iSearch(r"((?:\d+.){3}\.\d+)", FFhWCj("ip route | grep default"), IGNORECASE)
  return span.group(1) if span else ""
 @staticmethod
 def VVPM8v(port=-1):
  lst = []
  def VVjJzY(ip):
   if port > -1: ok = CChg05.VVR1V7(ip, port)
   else  : ok = CChg05.VVaD2s(ip)
   if ok:
    lst.append(ip)
  try:
   baseIp = CChg05.VVxZIB()
   thLst  = []
   for num in range(1, 255):
    ip = "%s%d" % (baseIp, num)
    th = iThread(name="ajp_scanIp%d" % num, target=BF(VVjJzY, ip))
    th.start()
    thLst.append(th)
   for th in thLst: th.join()
   return lst, ""
  except Exception as e:
   err = str(e)
   return [], err + '\n\nMax Threads = %d\nCheck your system "Max User Processes" with "ulimit -u"' % len(thLst) if "can't start new thread" in err else ""
 @staticmethod
 def VVsYvW(port):
  myIp = CChg05.VVdFtN()
  myGw = CChg05.VVJ4An()
  tDict = { myIp: CChg05.VVFbBj() }
  devLst, err = CChg05.VVPM8v(port)
  if err:
   return [], err
  else:
   for ip in devLst:
    span = iSearch(r"((?:\d+.){3}\.\d+).+\s+((?:[a-f\d]{2}:){5}[a-f\d]{2})", FFdV6p("arp -n %s" % ip), IGNORECASE)
    if span    : tDict[ip] = span.group(2).upper()
    elif not ip == myIp : tDict[ip] = ""
   lst = []
   for key, val in tDict.items():
    if   key == myIp: txt = " %s Own" % VV6UAe
    elif key == myGw: txt = " %s Gateway" % VV6UAe
    else   : txt = ""
    lst.append((key + txt, val))
   return lst, ""
 @staticmethod
 def VVaD2s(ip):
  return FF6usE("ping -W1 -q -c1 %s" % ip)
 @staticmethod
 def VVR1V7(host, port, timeout=1.0):
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_STREAM
  setdefaulttimeout(timeout)
  try:
   socket(AF_INET, SOCK_STREAM).connect((host, port))
   return True
  except:
   return False
 @staticmethod
 def VVIg8w(ip="1.1.1.1", timeout=1):
  if CChg05.VVR1V7(ip, 53, timeout):
   return True
  if CChg05.VVaD2s(ip):
   return True
  return FF6usE("wget -q -T %d -t 1 --spider %s" % (timeout, ip))
 @staticmethod
 def VVec5M(SELF, okFnc, title):
  baseIp = CChg05.VVxZIB()
  lst = []
  for num in range(1, 255):
   item = "%s%d" % (baseIp, num)
   lst.append((item, item))
  FFw2XU(SELF, okFnc, VVXXzc=lst, width=600, title=title, VVVzvS="#222222", VVhHWW="#222222")
class CCjfEP(Screen, CChg05):
 def __init__(self, session, entry):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 1400, 920, 40, 50, 30, "#11333344", "#08303030", 30, VVZ3ZU=40, VV1fgG=2)
  self.session  = session
  self.ftpEntry  = entry
  self.VV1Wwb  = self.VVuaAL["VVdJm7"]
  self.VVwOMI  = self.VVuaAL["bodyLineH"]
  self.VVVJxU  = self.VVuaAL["width"]
  self.VVVhOI   = "/"
  self.list   = []
  self.png_fil  = CCf9Gq.VVXRSy("fil")
  self.png_dir  = CCf9Gq.VVXRSy("dir")
  self.png_dirup  = CCf9Gq.VVXRSy("dirup")
  self.png_slwfil  = CCf9Gq.VVXRSy("slwfil")
  self.png_slbfil  = CCf9Gq.VVXRSy("slbfil")
  self.png_slwdir  = CCf9Gq.VVXRSy("slwdir")
  self.serverOrigData = None
  self.Title   = "FTP (%s)" % entry[0]
  CChg05.__init__(self)
  VVXXzc = [("Item-%d" % x,) for x in range(50)]
  FFfmZP(self, title=self.Title, VVXXzc=VVXXzc)
  FFrvOP(self["keyRed"] , "Exit")
  self["myMenu"] = MenuList(VVXXzc, True, eListboxPythonMultiContent)
  self["myMenu"].l.setFont(0, gFont(VVQVcT, self.VV1Wwb))
  self["myMenu"].l.setItemHeight(self.VVwOMI)
  FFewq4(self,
  {
   "red" : BF(self.VVkIEK, True) ,
   "ok" : self.VVTOku    ,
   "cancel": self.VVkIEK    ,
   "menu" : self.VVvNU2   ,
   "info" : self.VVA9vy  ,
   "pageUp": self.VVSNb5    ,
   "chanUp": self.VVSNb5
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVgufH)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
  FFE1T7(self)
  FF1uow(self)
  FFu0W6(self["keyBlue"], "#11333333")
  self.VV5Dw8()
 @FFHF2S("Connecting ...")
 def VV5Dw8(self):
  ip, u, p, path, rem = self.ftpEntry
  err = self.VV6Q8P(ip, u, p)
  if err:
   FFU9uk(self, err, title=self.Title)
   FFrvOP(self["keyBlue"] , "")
   self.close()
  elif self.ftp:
   FFrvOP(self["keyBlue"], self.ftpIp)
   if not self.VV7xwg(path):
    path = "/"
   self.VVe7Ta(path)
   self.serverOrigData = (ip, u, p, path, rem)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.VV00PL():
   self.VVrtKG()
 def VVTOku(self):
  if self.VVUMWF():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    if   flag == "d" or targetState == "d" : self.VVe7Ta(os.path.join(self.VVVhOI, name))
    elif flag == "x"      : self.VVSNb5()
    else         : self.VVRUfL(os.path.join(self.VVVhOI, name))
 def VVkIEK(self, force=False):
  if force or CFG.FileManagerExit.getValue() == "e": self.close(self.VVVhOI)
  else            : self.VVSNb5()
 def VVUMWF(self):
  if self.VV00PL():
   return True
  else:
   FFU9uk(self, "FTP Server is now diconnected !", title=self.Title)
   return False
 def VVRUfL(self, path):
  cat = CCf9Gq.VVl2HO(path)
  if cat in ("pic"):
   self.VVJ2AK(path)
  elif cat in ("mov", "mus"):
   if CCSB3R.VV25ja("5002"):
    url = "ftp%%3a//%s%%3a%s@%s%s" % (self.ftpUser, self.ftpPass, self.ftpIp, path)
    rType = "5002"
   else:
    rType = CFG.iptvAddToBouquetRefType.getValue()
    url = "http%%3a//%s/file?file=%s" % (self.ftpIp, path)
   FFTSvN(self, BF(CCQdsv.VVMj5s, self, url, rType=rType), title="Playing Media ...")
 @FFHF2S()
 def VVJ2AK(self, path):
  locFile, size, err = self.VVITJ9(path)
  if err: FFU9uk(self, err, title="View Picture File")
  else  : CCC0Lg.VVESKQ(self, locFile, fakePath="ftp:/%s" % path, cbFnc=BF(FFqlCI))
 def VVgufH(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel: title = "  %s  " % os.path.join(self.VVVhOI, "" if sel[0][0] == CCf9Gq.VV4CiQ else sel[0][0])
  else  : title=  VVsm0W + "  No Files Found !"
  self["myTitle"].setText(title)
 def VVSNb5(self):
  if self.VVUMWF():
   lastPart = FFVUvT(self.VVVhOI)
   parentDir = os.path.abspath(os.path.join(self.VVVhOI, os.pardir))
   self.VVe7Ta(parentDir, lastPart, "d")
 @FFHF2S()
 def VVe7Ta(self, Dir, moveTo="", moveToType=""):
  files, err = self.VVpZ50(Dir, isLong=True)
  self.VVVhOI = self.VV7Fo2() or "/"
  self.VV1vtS(files)
  if moveTo:
   for ndx, item in enumerate(self.list):
    name, target, targetState, flag, sortSeq = item[0]
    if moveTo == name:
     if not moveToType or moveToType == flag:
      self["myMenu"].moveToIndex(ndx)
      break
  else:
   self["myMenu"].moveToIndex(0)
 def VV1vtS(self, files):
  self.list = []
  if self.VVVhOI != "/":
   self.list.append(self.VVuBPq(CCf9Gq.VV4CiQ, CCf9Gq.VV4CiQ, "", "", "x"))
  for item in files:
   linkTo = ""
   isDir = isFile = isLink = False
   item = item.strip()
   if   item.startswith("l")     : flag = "l"
   elif item.startswith("d") or "<DIR>" in item: flag = "d"
   else          : flag = "f"
   gaps = 3 if item[:1].isdigit() else 8
   name = item.split(None, gaps)[gaps]
   linkSep = " -> "
   origName = name
   target = targetState = ""
   if linkSep in name:
    flag = "l"
    name, _, target = name.partition(linkSep)
    if not target.startswith("/"):
     target = "/" + target
    targetState = self.VV7KAI(target)
    color = VVsm0W if targetState == "b" else VV8QGw
    origName = name + VVaR8d + linkSep + color + " "+ target
   self.list.append(self.VVuBPq(origName, name, target, targetState, flag))
  self.list.sort(key=lambda x: (x[0][4], x[0][0]))
  self["myMenu"].l.setList(self.list)
 def VVuBPq(self, origName, name, target, targetState, flag):
  if flag == "f":
   png = self.png_fil
   ext = os.path.splitext(name)[1]
   if ext:
    cat = CCf9Gq.VVl2HO(name)
    if cat: png = LoadPixmap("%s%s.png" % (VV30Jg, cat))
  elif flag == "d": png = self.png_dir
  elif flag == "l":
   if   targetState == "f" : png = self.png_slwfil
   elif targetState == "d" : png = self.png_slwdir
   elif targetState == "b" : png = self.png_slbfil
   else      : png = self.png_slwfil
  elif flag == "x": png = self.png_dirup
  else   : png = self.png_fil
  if   origName == CCf9Gq.VV4CiQ: sortSeq = 0
  elif flag == "d" or targetState == "d"  : sortSeq = 1
  else          : sortSeq = 2
  tableRow = [ (name, target, targetState, flag, sortSeq) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VVwOMI + 10, 0, self.VVVJxU, self.VVwOMI, 0, LEFT | RT_VALIGN_CENTER, origName))
  tableRow.append(CCzs7U.VVUqW9(0, 2, self.VVwOMI-4, self.VVwOMI-4, png))
  return tableRow
 def VVvNU2(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel : name, target, targetState, flag, sortSeq = sel[0]
  else : name = target = targetState = flag = ""
  isTop  = name == CCf9Gq.VV4CiQ
  isDir  = flag == "d" or targetState == "d"
  isFile = flag == "f" or targetState == "f"
  def VVneCI(titl, ref, chk, color=""):
   if chk: return VVXXzc.append((color + titl, ref))
   else  : return VVXXzc.append((titl, ))
  VVXXzc = []
  VVneCI("Properties", "VVA9vy", not isTop)
  c = VV6UAe
  VVXXzc.append(VVzg1X)
  VVneCI("Download Selected File ..."    , "VVLBM4", isFile, c)
  VVneCI("Upload a Local File to Remote Server ...", "VVNh2W" , True  , c)
  VVXXzc.append(VVzg1X)
  VVneCI("Create new directory", "VVLRLV", True)
  VVneCI("Rename", "VV9R06", not isTop)
  VVneCI("DELETE", "VV2jZj", not isTop, VVcahY)
  VVXXzc.append(VVzg1X)
  VVneCI("FTP Server Information", "VV6E45", True)
  VVXXzc.append(VVzg1X)
  VVneCI("Refresh File List", "refresh", True)
  FFw2XU(self, self.VV32vL, VVXXzc=VVXXzc, title="Options")
 def VV32vL(self, item=None):
  if item:
   if   item == "VVA9vy"     : self.VVA9vy()
   elif item == "VVLBM4"   : self.VVLBM4()
   elif item == "VVNh2W"   : self.VVNh2W()
   elif item == "VVLRLV"   : self.VVLRLV()
   elif item == "VV9R06"   : self.VV9R06()
   elif item == "VV2jZj"   : self.VV2jZj()
   elif item == "VV6E45"    : self.VV6E45()
   elif item == "refresh" and self.VVUMWF(): self.VVe7Ta(self.VVVhOI)
 def VVA9vy(self):
  if self.VVUMWF():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    path = os.path.join(self.VVVhOI, name)
    txt = "%s:\n%s\n\n" % (FFITtK("Path", VV6UAe), path)
    typ = {"d": "Directory", "f": "File", "l": "SymLink", "x": ""}.get(flag, "")
    if typ: txt += "Type\t: %s%s\n" % (typ, " (Broken)" if targetState == "b" else "")
    if target: txt += "Target\t: %s\n" % target
    sz = self.VVG4kw(path)
    if sz > -1: txt += "Size\t: %s" % CCQdsv.VVAcha(sz)
   else:
    txt = "Nothing selected"
   FFyijw(self, txt, title="Properties")
 def VV6E45(self):
  if self.VVUMWF():
   Sys  = self.VVjGaN() or " -"
   txt = "%s\n  %s\n\n" % (FFITtK("System:", VV6UAe), Sys[4:] if Sys.startswith("215 ") else Sys)
   Stat = self.VV5Jco() or " -"
   txt += "%s\n" % (FFITtK("Status:", VV6UAe))
   for line in Stat.splitlines():
    txt += "  %s\n" % (line[4:] if line.startswith("211-") or line.startswith("211 ") else line)
   FFyijw(self, txt, title="FTP Server Information")
 def VVLRLV(self, name=""):
  if self.VVUMWF():
   title = "Add New Directory"
   FFttdT(self, BF(self.VVR0Ww, title), defaultText=name, title=title, message="Enter Directory name")
 def VVR0Ww(self, title, name):
  if name and name.strip():
   if self.VV8xP8(name) : self.VVe7Ta(self.VVVhOI, name, "d")
   else     : FFU9uk(self, "Failed to create : %s" % name, title)
 def VV9R06(self):
  if self.VVUMWF():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Rename"
    name, target, targetState, flag, sortSeq = sel[0]
    FFttdT(self, BF(self.VVHLch, title, name, flag), defaultText=name, title=title, message="Enter new name")
 def VVHLch(self, title, name, flag, newName):
  if newName and newName.strip():
   if self.VVpVHu(name, newName.strip()) : self.VVe7Ta(self.VVVhOI, newName, flag)
   else          : FFU9uk(self, "Failed to rename to : %s" % newName, title)
 def VV2jZj(self):
  if self.VVUMWF():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    FFHsPu(self, BF(self.VV9yic, name, flag), "Delete ?\n\n%s" % name, title="Delete")
 @FFHF2S("Deleting ...")
 def VV9yic(self, name, flag):
  if self.VVYuKJ(name, flag) : self.VVe7Ta(self.VVVhOI)
  else         : FFU9uk(self, "Failed to delete:\n\n%s" % name, "Delete")
 def VVLBM4(self):
  if self.VVUMWF():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Download File"
    name, target, targetState, flag, sortSeq = sel[0]
    remFile = os.path.join(self.VVVhOI, name)
    size = self.VVG4kw(remFile)
    if size == -1:
     FFU9uk(self, "Cannot get file size for:\n\n%s" % remFile, title=title)
    else:
     Dir = CFG.lastFtpLocalPath.getValue() if VVrRHR(CFG.lastFtpLocalPath.getValue()) else FFmAG5()
     self.session.openWithCallback(BF(self.VVRoJG, title, remFile, name, size), BF(CCQdsv, mode=CCQdsv.VVx2Yd, VVa5ZQ="Download here", VV82pi=Dir, width=1200, height=840, pickTitleBG="#11002222", pickBodyBG="#11003333", VVlIBH="#11005566"))
 def VVRoJG(self, title, remFile, name, size, locPath):
  if locPath:
   FFDDwF(CFG.lastFtpLocalPath, locPath)
   locFile = os.path.join(locPath, name)
   CCXRxc.VVJ9VK(self, VVmj1O="Downloading ...", titleBg="#22220022", bodyBg="#22220022"
       , VVCJhW  = BF(self.VV8O5z, remFile, size, locFile)
       , VVuQkS = BF(self.VVjjsU, remFile, size, locFile))
 def VV8O5z(self, remFile, size, locFile, VVM2wn):
  VVM2wn.VVqMKy(size)
  VVM2wn.VViN1g = ""
  with open(locFile, "wb") as locFileObj:
   try:
    def VVssjx(data):
     if not VVM2wn or VVM2wn.isCancelled:
      return
     locFileObj.write(data)
     VVM2wn.VVwOHf(len(data))
    self.ftp.retrbinary("RETR %s" % remFile, VVssjx)
   except Exception as e:
    VVM2wn.VViN1g = str(e)
 def VVjjsU(self, remFile, size, locFile, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  title = "File Download"
  delF = False
  if VViN1g:
   FFU9uk(self, "%s\n\nftp:/%s" % (VViN1g, remFile), title="Download Error")
   delF = True
  elif not VV9zbx:
   FFU9uk(self, "Download cancelled for:\n\nftp:/%s" % remFile, title=title)
   delF = True
  else:
   if size == FFX42v(locFile):
    txt = "Successfully downloaded to:\n\n%s" % locFile
    FFSQn9(self, txt, title=title)
   else:
    FFU9uk(self, "Incorrect downloaded file size for:\n\nftp:/%s" % remFile, title=title)
    delF = True
  if delF:
   FFqlCI(locFile)
 def VVNh2W(self):
  if self.VVUMWF():
   Dir = CFG.lastFtpLocalPath.getValue() if VVrRHR(CFG.lastFtpLocalPath.getValue()) else FFmAG5()
   self.session.openWithCallback(self.VV6X2T, BF(CCQdsv, VVa5ZQ="Upload selected file", VV82pi=Dir, VVmysg="all", width=1200, height=850, pickTitleBG="#11001122", pickBodyBG="#11330033", VVlIBH="#11662200"))
 def VV6X2T(self, locFile):
  if locFile:
   title = "Upload File to Remote Server"
   FFDDwF(CFG.lastFtpLocalPath, os.path.dirname(locFile))
   size = FFX42v(locFile)
   if size == -1:
    FFU9uk(self, "Cannot get file size for:\n\n%s" % locFile, title=title)
   else:
    remFile = os.path.join(self.VVVhOI, os.path.basename(locFile))
    CCXRxc.VVJ9VK(self, VVmj1O="Uploading ...", titleBg="#22220022", bodyBg="#22220022"
        , VVCJhW  = BF(self.VVgZR1, locFile, size, remFile)
        , VVuQkS = BF(self.VVGShI, locFile, size, remFile))
 def VVgZR1(self, locFile, size, remFile, VVM2wn):
  VVM2wn.VVqMKy(size)
  VVM2wn.VViN1g = ""
  with open(locFile, "rb") as locFileObj:
   try:
    def VVkoFd(data):
     if not VVM2wn or VVM2wn.isCancelled:
      VVM2wn.VViN1g = "Upload cancelled"
      locFileObj.close()
      return
     VVM2wn.VVwOHf(len(data))
    self.ftp.storbinary("STOR %s" % remFile, locFileObj, callback=VVkoFd)
   except Exception as e:
    VVM2wn.VViN1g = VVM2wn.VViN1g or str(e)
 def VVGShI(self, locFile, size, remFile, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  title = "File Upload"
  err = ""
  if VV9zbx:
   if size == FFX42v(locFile) : FFSQn9(self, "Successfully uploaded to:\n\n%s" % remFile, title=title)
   else       : err = "Incorrect uploaded file size for:\n\nftp:/%s" % remFile
  elif VViN1g : err = "%s\n\n%s" % (VViN1g, locFile)
  else    : err = "Incomplete file transfer:\n\n%s" % locFile
  if err:
   FFU9uk(self, err, title=title)
   self.VVVsGL()
   self.VVYuKJ(remFile, "")
  self.VVe7Ta(self.VVVhOI)
class CCHa3c():
 VVKLUU  = "all"
 VVsvPZ = "vid"
 VVYZRp  = "osd"
 VVPtTO = "dreamboxctl"
 VV3wJF  = "grab"
 @staticmethod
 def VVWQmH(session, k, dm):
  if CCHa3c.VVvPJO(session) or CFG.screenshotFType.getValue() == "off":
   return
  title = "%s Screenshot" % VVryLp
  err = ""
  if   not FFsGnd(CCHa3c.VV3wJF)   : err = "g"
  elif dm and not FFsGnd(CCHa3c.VVPtTO): err = "gd"
  if err:
   FFZMNU(session, "Missing %s-command !" % err, title=title)
   return
  winShown = session.current_dialog.shown
  if k == CCHa3c.VVsvPZ and winShown: session.current_dialog.hide()
  FFDiNL(BF(CCHa3c.VV3fuK, title, session, k, winShown, dm))
 @staticmethod
 def VV3fuK(title, session, k, winShown, dm):
  fTitle = skinName = ""
  x = y = w = h = 0
  if k == CCHa3c.VVYZRp:
   if not winShown:
    FFZMNU(session, "No Window to capture !", title=title)
    return
   if not CCHa3c.VVV1rP(session, title, True):
    return
   valid, origTitle, clnTitle, skinName, x, y, w, h = CCHa3c.VVDLTM(session)
   fTitle = "%s_(%s)" % (clnTitle, skinName)
   if not valid:
    FFZMNU(session, "Cannot get Window Dimensions !", title=title)
    return
  if not fTitle:
   s = CCaZ62(session)
   fTitle = FF80BW(s.VVeZBd.strip(), "-") or s.VV6phL.replace(":", "_")
  ext = CFG.screenshotFType.getValue()
  path = "%sscreenshot_%s_%s.%s" % (FFi8bi(), fTitle, FF6eWd(), ext)
  fnc = BF(CCHa3c.VVve6S, path, title, session, k, winShown, x, y, w, h)
  if dm:
   CCqTV0().VVyeGQ("%s screenshot -f '%s'" % (CCHa3c.VVPtTO, path), fnc)
  else:
   FF6BfM("%s -q -s %s > '%s'" % (CCHa3c.VV3wJF, {"jpg":"-j 100", "png":"-p"}.get(ext, ""), path))
   fnc()
 @staticmethod
 def VVve6S(path, title, session, k, winShown, x, y, w, h, *args):
  if k == CCHa3c.VVsvPZ and winShown:
   session.current_dialog.show()
  elif k == CCHa3c.VVYZRp:
   ok = CCHa3c.VVqqpg(path, x, y, w, h)
   if not ok:
    FFqlCI(path)
    FFZMNU(session, "Error while cropping image file !", title=title)
    return
  if FFf0vs(path) : session.open(CCC0Lg, VV0hkT=path, title=path, menuFnc=CCHa3c.VVpk25)
  else    : FFZMNU(session, "Error while capturing screen !", title=title)
 @staticmethod
 def VVpk25(pvObj):
  def VVz6Dm():
   FFqlCI(pvObj.VV0hkT)
   pvObj.close()
  FFHsPu(pvObj, VVz6Dm, "Delete Screenshot File ?\n\n%s" % pvObj.VV0hkT, title="Screen Shot")
 @staticmethod
 def VVV1rP(SELF, title, VVMjFx, install=True, cbFnc=None):
  try:
   from PIL import Image
   return True
  except:
   if install:
    FFHsPu(SELF, BF(CCHa3c.VVna5o, SELF, VVMjFx, cbFnc=cbFnc), "Imaging Library is required.\n\nInstall ?", title=title, VVMjFx=VVMjFx)
   return False
 @staticmethod
 def VVna5o(SELF, VVMjFx, cbFnc=None):
  if pyVersion[0] >= 3: name = "python3-pillow"
  else    : name = "python-imaging"
  if VVMjFx: fnc = BF(FF3rcG, VVUYyP=cbFnc)
  else    : fnc = BF(FFNQkI , VVUYyP=cbFnc)
  fnc(SELF, FFiD2M(VVUWS4, name), VVTHJE=True, title="Installing Imaging Library")
 @staticmethod
 def VVDLTM(session):
  valid = False
  origTitle = clnTitle = skinName = ""
  x = y = w = h = 0
  obj = session.current_dialog
  if obj:
   skinName = obj.skinName
   if isinstance(skinName, list) : skinName = "-".join(skinName)
   else       : skinName = str(skinName)
   inst = obj.instance
   if inst:
    origTitle = inst.getTitle()
    pos, size = inst.position(), inst.size()
    x, y, w, h = pos.x(), pos.y(), size.width(), size.height()
    valid = w != 0 and h !=0
    clnTitle = FF80BW(origTitle.strip(), r"-")
    clnTitle = FF7h5n(clnTitle, "-")
  return valid, origTitle, clnTitle, skinName, x, y, w, h
 @staticmethod
 def VVvPJO(session):
  valid, origTitle, clnTitle, skinName, x, y, w, h = CCHa3c.VVDLTM(session)
  return skinName.lower() in ("hotkeysetup", "buttonsetup", "spaQButton")
 @staticmethod
 def VVqqpg(path, x, y, w, h, scaleToScreen=True):
  try:
   from PIL import Image
   im = Image.open(path)
   x1 = w + x
   y1 = h + y
   if scaleToScreen:
    scrW, scrH = FFUA0v()
    w, h = im.size
    if w != scrW or h != scrH:
     x  = FFPSde(x , 0, scrW, 0, w)
     y  = FFPSde(y , 0, scrH, 0, h)
     x1 = FFPSde(x1, 0, scrW, 0, w)
     y1 = FFPSde(y1, 0, scrH, 0, h)
   im = im.crop((x, y, x1, y1))
   im.save(path)
   return True
  except:
   return False
 @staticmethod
 def VVF76v(path):
  size = FFX42v(path)
  sizeTxt = CCQdsv.VVAcha(size) if size > -1 else ""
  try:
   from PIL import Image
   im = Image.open(path)
   form = im.format
   mode = im.mode
   resTxt = "%d x %d" % im.size
  except:
   resTxt = form = mode = ""
  return size, sizeTxt, resTxt, form, mode
 @staticmethod
 def VVDhWu(path):
  try:
   from PIL import Image
   im = Image.open(path)
   w, h = im.size
   return w, h, ""
  except IOError as e:
   return -1, -1, "Error: %s" % str(e)
  except:
   pass
  res = FFhWCj("ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=X:p=0 '%s' 2> /dev/null" % path)
  if "X" in res:
   w, h = res.split("X")
   if w.isdigit() and h.isdigit():
    w, h, = int(w), int(h)
    if w > 0 and h > 0:
     return w, h, ""
  return -1, -1, res or "Error"
 @staticmethod
 def VVmlOY(path, maxW, maxH, toRgb=True):
  curW, curH, err = CCHa3c.VVDhWu(path)
  if err or (curW <= maxW and curH <= maxH): return False, curW, curH, curW, curH
  w, h = min(curW, maxW), min(curH, maxH)
  try:
   from PIL import Image
   im = Image.open(path)
   im = im.resize((w, h))
   if toRgb and im.mode == "CMYK": im = im.convert("RGB")
   im.save(path)
   return True, curW, curH, w, h
  except:
   if FFsGnd("ffmpeg") and FF6usE("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, path)):
    return True , curW, curH, w, h
   else:
    return False, curW, curH, curW, curH
 @staticmethod
 def VVR0sK(pixMap, path, toPng=False):
  if not FFf0vs(path):
   return ""
  sz = pixMap.instance.size()
  w, h = sz.width(), sz.height()
  fil, ext = os.path.splitext(path)
  tFile = "%s_ajp_%sx%s%s" % (fil, w, h, ".png" if toPng else ext)
  if FFf0vs(tFile):
   return tFile
  else:
   try:
    from PIL import Image
    im = Image.open(path)
    im = im.resize((w, h))
    im.save(tFile)
    return tFile
   except:
    if FFsGnd("ffmpeg") and FF6usE("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, tFile)):
     return tFile
    else:
     return ""
 @staticmethod
 def VVbBnJ(path, headers=""):
  tab1 = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2 = lambda Dic, nm, k: tab1(nm, FFX7JA(Dic, k))
  mExt, mCat, mTitle = CCHa3c.VVuMj7(path)
  if not mExt:
   return ""
  txt  = "\n" + FFiN5A(("%s Metadata" % mTitle).strip(), VV6UAe )
  try:
   res = FFdV6p("ffprobe -loglevel 0 %s -of json -show_format -show_streams -show_chapters '%s'" % (headers, path))
   d = jLoads(res)
   d1 = d["format"]
   dur = FFX7JA(d1, "duration")
   if FFjWX8(dur):
    dur = "%s\t( %s sec )" % (FF79L2(float(dur)), dur.rstrip("0").rstrip("."))
   sz = FFX7JA(d1, "size")
   if sz.isdigit():
    sz = "%s\t( %s )" % (sz, CCQdsv.VVAcha(int(sz), mode=4))
   txt += tab1("Duration"  , dur   )
   txt += tab1("File Size"  , sz   )
   txt += tab2(d1, "Bit Rate" , "bit_rate" )
   txt += tab2(d1, "Format" , "format_name" )
   txt += tab2(d1, "Streams" , "nb_streams" )
   txt += tab1("Chapters"  , len(d["chapters"]))
   if "tags" in d1:
    d1 = d1["tags"]
    tm = FFX7JA(d1, "creation_time")
    span = iSearch(r"(.+)T(.+)\.", tm)
    txt += tab2(d1, "Encoder" , "encoder")
    txt += tab1("Created", "  ".join(span.groups()) if span else tm)
   for d1 in d["streams"]:
    ind = FFX7JA(d1, "index"  )
    typ = FFX7JA(d1, "codec_type" )
    frmR= FFX7JA(d1, "r_frame_rate")
    frmR= frmR if frmR != "0/0" else ""
    w = FFX7JA(d1, "width" )
    h = FFX7JA(d1, "height" )
    dim = " x ".join((w, h)) if w and h else ""
    txt += "\n"
    txt += FFITtK(tab1("Stream - %s" % ind, typ.title()), VVkLs0)
    txt += tab2(d1, "Codec"   , "codec_name"  )
    txt += tab1("Dimensions"  , dim    )
    txt += tab2(d1, "Aspect Ratio" , "display_aspect_ratio")
    txt += tab2(d1, "Pixel Format"  , "pix_fmt"   )
    txt += tab1("Frame Rate"  , frmR    )
    txt += tab2(d1, "Sample Rate" , "sample_rate"  )
    txt += tab2(d1, "Frames"  , "nb_frames"  )
    txt += tab2(d1, "Channels"  , "channels"  )
    txt += tab2(d1, "Ch. Layout"  , "channel_layout" ).title()
    if "tags" in d1:
     txt += tab2(d1["tags"], "Title"  , "title" )
     txt += tab2(d1["tags"], "Language"  , "language").title()
   return txt
  except:
   return ""
 @staticmethod
 def VVC8cp(path, headers=""):
  lst = []
  try:
   res = FFdV6p("ffprobe -loglevel 0 %s -of json -show_chapters '%s'" % (headers, path))
   for item in jLoads(res)["chapters"]:
    try:
     tm = float(FFX7JA(item, "start_time"))
     if tm > 0:
      tmTxt = FF79L2(tm)
      pts = int(tm * 90000)
      name = ""
      if "tags" in item:
       name = FFX7JA(item["tags"], "title")
      lst.append(("%s   %s" % (tmTxt, name), pts))
    except:
     pass
  except:
   pass
  return lst
 @staticmethod
 def VVp5GZ(VVu69c, VVeZBd):
  path = headers = ""
  if FFzNJJ(VVu69c):
   url = VVu69c.replace(":" + VVeZBd, "")
   if "chCode=" in url:
    if "j.php" in url:
     pass
    else:
     path = iSub(r"[&?]mode=.+end=", r"", url, flags=IGNORECASE)
     p, err = CCNREC.VVJX6y(VVu69c)
     head = p.portal_latestResponse["headers"] if p else ""
     auth = "Authorization"
     if head and auth in head:
      headers  = '-headers "%s: %s"' % (auth, head[auth])
      headers += " -headers $'Cookie: mac=%s; stb_lang=en\r\n'" % p.VV0Iab
   else:
    path = url
  return path, headers
 @staticmethod
 def VVuMj7(path):
  ext = os.path.splitext(path)[1]
  mExt = mCat = mName = ""
  for cat, lst in CCf9Gq.VVl1a5().items():
   if cat in ("mov", "pic", "mus"):
    if ext in lst:
     mExt, mCat = ext, cat
     break
    else:
     for x in lst:
      if "." + x in path:
       mExt, mCat = x, cat
       break
  return mExt, mCat, {"mov": "Video", "pic": "Picture", "mus": "Audio"}.get(mCat, "")
 @staticmethod
 def VVEtPc():
  try:
   import pickle, zlib
   with open("%sMisc/inf.png" % FFmAG5(), 'rb') as f:
    return pickle.loads(zlib.decompress(f.read().split(bytearray.fromhex("6082"))[1]))
  except:
   return None
 @staticmethod
 def VVCDdv(i):
  try: return FFxmv7(CCHa3c.VVEtPc()[i][1:-1])
  except: return None
class CC1BSt(Screen):
 def __init__(self, session, title, fontsList, defFnt, withRestart, chFontSz, regF):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 1400, 1000, 40, 40, 30, "#0a001100", "#10110000", 30, VVZ3ZU=220, VVZ5LV={"topBtnEW":25})
  self.session = session
  self.fontsList = fontsList
  self.defFnt  = defFnt
  self.chFontSz = chFontSz
  self.regF  = regF
  self.defScale = CFG.fontScaleSys.getValue()
  txt = FFITtK(" (Requires GUI Restart)", VVCBkQ) if withRestart else ""
  VVXXzc = []
  for path in self.fontsList:
   VVXXzc.append((os.path.splitext(os.path.basename(path))[0], path))
  VVXXzc.sort(key=lambda x: x[0].lower())
  VVXXzc.insert(0, VVzg1X)
  VVXXzc.insert(0, ("Reset to Default%s" % txt, "DEFAULT"))
  self.VVlBZZ = 0
  if self.defFnt:
   for ndx, item in enumerate(VVXXzc):
    if len(item) == 2 and item[1] == self.defFnt:
     VVXXzc[ndx] = (VV8QGw + item[0] + "  (Current font)", item[1])
     self.VVlBZZ = ndx
     break
  else:
   VVXXzc[self.VVlBZZ] = (VV8QGw + VVXXzc[self.VVlBZZ][0], VVXXzc[self.VVlBZZ][1])
  FFfmZP(self, VVXXzc=VVXXzc, title=title)
  self["keyRedTop"] = Label("%s%%" % self.defScale)
  self["keyGreenTop"] = Label("Current")
  self["keyYellowTop"]= Label("Font -")
  self["keyBlueTop"] = Label("Font +")
  for s in ("Red", "Green", "Yellow", "Blue"):
   self["key%sTop1" % s] = Label()
   if not chFontSz and s != "Green":
    self["key%sTop" % s].hide()
    self["key%sTop1" % s].hide()
  FFyNtd(self,
  {
   "red" : BF(self.VVBwAZ,  0),
   "green" : self.VVQyFu   ,
   "yellow": BF(self.VVBwAZ, -5),
   "blue" : BF(self.VVBwAZ,  5),
   "cancel": self.cancel
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFE1T7(self, isTopBar=True)
  FFbm8U(self)
  self["myBar"].setText(self.VVHvdE())
  self["myBar"].instance.setHAlign(1)
  self["myMenu"].onSelectionChanged.append(self.VVdZB7)
  self.VVdZB7()
 def VVTOku(self):
  self["myMenu"].onSelectionChanged = []
  self.close((self["myMenu"].l.getCurrentSelection()[1], self.defScale))
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVQyFu(self):
  self["myMenu"].moveToIndex(self.VVlBZZ)
 def VVBwAZ(self, val):
  if not self.chFontSz:
   return
  ok = False
  if  val == 0       : self.defScale, ok = 100, True
  elif val < 0 and self.defScale == 70 : FF8PJn(self, "Minimum Scale = 70%", 500)
  elif val > 0 and self.defScale == 140: FF8PJn(self, "Maximum Scale = 140%", 500)
  else         : self.defScale, ok = self.defScale + val, True
  if ok : self.VVdZB7()
 def VVdZB7(self):
  path = self["myMenu"].l.getCurrentSelection()[1]
  if FFf0vs(path):
   fnt = "AJP_Sample"
   FFB3Un(path, fnt, scale=self.defScale, isRepl=1, save=False)
  elif FFf0vs(self.regF):
   fnt = "AJP_Sample"
   FFB3Un(self.regF, fnt, scale=self.defScale, isRepl=1, save=False)
  else:
   fnt = VVxg3T
  try:
   inst = self["myMenu"].instance
   inst.setFont(gFont(fnt, self.VVuaAL["VVdJm7"]))
   inst.invalidate()
  except:
   try:
    l = self["myMenu"].l
    l.setFont(gFont(fnt, self.VVuaAL["VVdJm7"]))
    l.invalidate()
   except:
    pass
  self["myBar"].instance.setFont(gFont(fnt, int(self.VVuaAL["VVdJm7"] * 1.3)))
  self["myBar"].instance.invalidate()
  if self.chFontSz:
   self["keyRedTop"].setText("%s%%" % self.defScale)
   FFcfsH(self["keyRedTop"], "#00aaffaa" if self.defScale == 100 else "#00ffeebb")
 def VVHvdE(self):
  txt = ""
  for i in range(65, 91): txt += chr(i)
  txt += "\n"
  for i in range(97, 123): txt += chr(i)
  txt += "  "
  for i in range(48, 58): txt += chr(i)
  txt += "\n"
  txt += u"\u0623\u0628\u062c\u062f \u0647\u0648\u0632 \u062d\u0637\u064a \u0643\u0644\u0645\u0646 \u0633\u0639\u0641\u0635 \u0642\u0631\u0634\u062a \u062b\u062e\u0630 \u0636\u0638\u063a  \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669"
  return str(txt)
 @staticmethod
 def VVIdUV():
  lst, regF = set(), ""
  for name, scale, repl, fName, fPath, skinF in FFvhXh():
   lst.add(fPath)
   if name == "Regular": regF = fPath
  for fil in FFYjQm(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"): lst.add(fil)
  return sorted(list(lst)), regF
 @staticmethod
 def VVK9Do(SELF, title, defFnt, rest, VVuQkS, chFontSz):
  fLst, regF = CC1BSt.VVIdUV()
  defFnt = defFnt or regF
  if fLst : SELF.session.openWithCallback(VVuQkS, CC1BSt, title, fLst, defFnt, rest, chFontSz, regF)
  else : FFU9uk(SELF, "No fonts found.", title=title)
class CCbZqx(Screen):
 def __init__(self, session, path, VVXXzc, title):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 1700, 1000, 40, 40, 30, "#11001122", "#11002233", 30, VV6DX9=50)
  self.session = session
  self.path  = path
  FFfmZP(self, VVXXzc=VVXXzc, title=title)
  self["myLabelFrm"] = Label()
  self["myLabelTit"] = Label("Result Sample")
  self["myLabelTxt"] = Label()
  FFewq4(self,
  {
   "ok"  : self.VVTOku   ,
   "cancel" : self.cancel   ,
   "pageUp" : self.VVQhoy,
   "chanUp" : self.VVQhoy,
   "pageDown" : self.VVdwrx ,
   "chanDown" : self.VVdwrx ,
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
  FFu0W6(self["myLabelFrm"], "#11110000")
  FFu0W6(self["myLabelTit"], "#11663322")
  FFu0W6(self["myLabelTxt"], "#11110000")
  self["myMenu"].onSelectionChanged.append(self.VVjxz2)
  self.VVjxz2()
 def VVjxz2(self):
  if FFf0vs(self.path): txt = FF05rJ(self.path, maxSize=1000, encLst=[self["myMenu"].l.getCurrentSelection()[1]])
  else     : txt = "Review error !"
  self["myLabelTxt"].setText(txt.strip())
 def VVTOku(self):
  self["myMenu"].onSelectionChanged = []
  self.close(self["myMenu"].l.getCurrentSelection()[1])
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVQhoy(self) : self["myMenu"].moveToIndex(0)
 def VVdwrx(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CC2Ldo():
 @staticmethod
 def VV8NYe():
  return [None, "utf-8"] + ["iso-8859-%d" % i for i in range(1,17)] + ["windows-125%d" % i for i in range(1,9)]
 @staticmethod
 def VV4g4e(SELF):
  import sys, locale
  lst = []
  c1 = "#f#00ffbbff#"
  c2 = "#f#00ffffaa#"
  lst.append(("Language Code"     , locale.getdefaultlocale()[0]  ))
  lst.append(("Default Locale Encoding"  , locale.getdefaultlocale()[1]  ))
  lst.append((c1 + "Preferred Encoding"  , c1 + locale.getpreferredencoding(False)))
  lst.append((c2 + "System Default Encoding" , c2 + sys.getdefaultencoding()  ))
  lst.append((c2 + "Filesystem Encoding"  , c2 + sys.getfilesystemencoding() ))
  c = "#f#11aaffff#"
  for item in locale.setlocale(locale.LC_ALL).split(";"):
   parts = item.split("=")
   if len(parts) == 2:
    lst.append((c + parts[0], c +
    parts[1]))
  FFdCaM(SELF, None, VV5dDF=lst, VV1Wwb=30, VV4HrS=1)
 @staticmethod
 def VVM9Xv(path, SELF=None):
  for enc in CC2Ldo.VV8NYe():
   try:
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      pass
    return enc
   except:
    pass
  if SELF:
   FFU9uk(SELF, "Cannot detect file encoding for:\n\n%s" % path)
  return -1
 @staticmethod
 def VVCfu0(path):
  for enc in CC2Ldo.VV8NYe():
   try:
    c = 0
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      c += 1
    return enc, c
   except:
    pass
  return -1, 0
 @staticmethod
 def VVQKht(path, enc):
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     pass
   return True
  except:
   return False
 @staticmethod
 def VVXlDL(SELF, path, cbFnc, curEnc=VVMHLG, title="Select Encoding"):
  lst = CC2Ldo.VV9O72(SELF, path, "")
  if lst:
   SELF.session.openWithCallback(cbFnc, CCbZqx, path, lst, title)
 @staticmethod
 def VVSIp1(SELF, cbFnc, curEnc=VVMHLG, title="Select Encoding"):
  lst = CC2Ldo.VV9O72(SELF, "", "")
  if lst:
   FFw2XU(SELF, cbFnc, title=title, VVXXzc=lst, width=1000, height=1000, VVVzvS="#22220000", VVhHWW="#22220000")
 @staticmethod
 def VV9O72(SELF, path, curEnc):
  lst = CC2Ldo.VVM5rV(path)
  if lst:
   VVXXzc = []
   for name, enc in lst:
    txt = "%s (%s)" % (name, enc)
    if   enc == curEnc   : c = VV8QGw
    elif enc == VVMHLG: c = VVaR8d
    else      : c = ""
    VVXXzc.append((c + txt, enc))
   return VVXXzc
  else:
   FFk1YE(SELF, "No proper encoding", 2000)
 @staticmethod
 def VVM5rV(path=""):
  encLst = []
  cPath = VV30Jg + "_sup_codecs"
  if FFf0vs(cPath):
   lines = FF2iRW(cPath)
   for line in lines:
    parts = line.split("\t")
    if len(parts) == 2:
     encLst.append((parts))
  if not encLst:
   tmp = list(CC2Ldo.VV8NYe())
   tmp.pop(0)
   encLst = [("General", ",".join(tmp))]
  lst = []
  for item in encLst:
   for enc in (item[1].split(",")):
    if path:
     try:
      with ioOpen(path, "r", encoding=enc) as f:
       for line in f:
        pass
      lst.append((item[0], enc))
     except:
      pass
    else:
     lst.append((item[0], enc))
  return lst
class CC6z2a(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 900, 950, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  VVXXzc = []
  VVXXzc.append(("Settings File"   , "SettingsFile" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Box Info"     , "VVacfl"  ))
  VVXXzc.append(("Tuners Info"    , "VVudgh" ))
  VVXXzc.append(("Python Version"   , "VVITPo" ))
  VVXXzc.append(("Stream Relay Patch"  , "VVx8d6" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Screen Size"    , "ScreenSize"  ))
  VVXXzc.append(("Language/Locale"   , "Locale"   ))
  VVXXzc.append(("Processor"    , "Processor"  ))
  VVXXzc.append(("Operating System"   , "VV9UVx" ))
  VVXXzc.append(("Drivers (Kernel Object)"     , "VVfv7Y"))
  VVXXzc.append(("Drivers (Loadable Kernel Modules - LKM)" , "VVcfDU" ))
  VVXXzc.append(("Drivers (Built-in Kernel Modules)"  , "VVvX3R" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("System Users"    , "SystemUsers"   ))
  VVXXzc.append(("Logged-in Users"   , "LoggedInUsers"  ))
  VVXXzc.append(("Uptime"     , "Uptime"    ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Host Name"    , "HostName"   ))
  VVXXzc.append(("MAC Address"    , "MACAddress"   ))
  VVXXzc.append(("Network Configuration" , "NetworkConfiguration"))
  VVXXzc.append(("Network Status"   , "NetworkStatus"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Disk Usage"    , "VVB9ZX"   ))
  VVXXzc.append(("Mount Points"    , "VV3tVk"  ))
  VVXXzc.append(("File System Table (FSTAB)", "VVWEFg"  ))
  VVXXzc.append(("USB Devices"    , "USB_Devices"   ))
  VVXXzc.append(("Block-Devices List"  , "blockDevices"  ))
  VVXXzc.append(("Directory Size"   , "DirectorySize"  ))
  VVXXzc.append(("Memory"     , "Memory"    ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Running Processes"  , "RunningProcesses" ))
  VVXXzc.append(("Processes with open files", "ProcessesOpenFiles" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Bootloader Second-stage (old DreamBox only)" , "DreamBoxBootloader"))
  FFfmZP(self, VVXXzc=VVXXzc, title="Device Information")
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "SettingsFile"   : self.session.open(CCqBeU)
   elif item == "VVacfl"   : self.VVacfl()
   elif item == "VVudgh"  : self.VVudgh()
   elif item == "VVITPo"  : self.VVITPo()
   elif item == "VVx8d6"  : self.VVx8d6()
   elif item == "ScreenSize"   : FFyijw(self, "Width\t: %s\nHeight\t: %s" % (FFUA0v()[0], FFUA0v()[1]))
   elif item == "Locale"    : CC2Ldo.VV4g4e(self)
   elif item == "Processor"   : self.VVQjRw()
   elif item == "VV9UVx"  : self.VV9UVx()
   elif item == "VVfv7Y"  : self.VVfv7Y()
   elif item == "VVcfDU"  : self.VVcfDU()
   elif item == "VVvX3R"  : self.VVvX3R()
   elif item == "SystemUsers"   : FFpL0U(self, "id")
   elif item == "LoggedInUsers"  : FFpL0U(self, "who -a")
   elif item == "Uptime"    : FFpL0U(self, "uptime")
   elif item == "HostName"    : FFpL0U(self, "hostname")
   elif item == "MACAddress"   : self.VVS0cT()
   elif item == "NetworkConfiguration" : FFpL0U(self, "ifconfig %s %s" % (FF0VVA("HWaddr", VVUPyu), FF0VVA("addr:", VVaR8d)))
   elif item == "NetworkStatus"  : FFpL0U(self, "netstat -tulpn", VV1Wwb=24)
   elif item == "VVB9ZX"   : self.VVB9ZX()
   elif item == "VV3tVk"  : self.VV3tVk()
   elif item == "VVWEFg"  : self.VVWEFg()
   elif item == "USB_Devices"   : FFpL0U(self, "lsusb")
   elif item == "blockDevices"   : FFpL0U(self, "blkid")
   elif item == "DirectorySize"  : FFpL0U(self, "du -shc /* 2> /dev/null | sed '/total/i-----\t-------------' | sed 's/total/TOTAL/g'")
   elif item == "Memory"    : FFpL0U(self, "cat /proc/meminfo | sed 's/ //g' | sed 's/:/\t: /g' | sed '/MemAvailable/a%s'" % ("-" * 25), consFont=False)
   elif item == "RunningProcesses"  : FFpL0U(self, "ps")
   elif item == "ProcessesOpenFiles" : FFpL0U(self, "lsof")
   elif item == "DreamBoxBootloader"  : self.VVdsq3()
   else        : self.close()
 def VVS0cT(self):
  res = FFdV6p("ip link")
  list = iFindall(r"[0-9]+:\s+(.+):\s+.+\n.+\s+(.+)brd", res, IGNORECASE)
  if list:
   txt = ""
   for item in list:
    brd = item[0].upper()
    mac = item[1].upper()
    if not brd == "LO":
     txt += "%s\t: %s\n" % (item[0].upper(), item[1].upper())
   FFyijw(self, txt)
  else:
   FFpL0U(self, "ip link")
 @FFHF2S()
 def VVB9ZX(self):
  VVJwgn, cols = [], 0
  for cmd, cols in (("df -aTh", 7), ("df -ah", 6)):
   txt = FFdV6p(cmd)
   if not "invalid option" in txt:
    for line in txt.split("\n"):
     parts = line.split()
     if len(parts) >= cols and not "Mounted on" in line:
      VVJwgn.append(parts[:cols])
    break
  if VVJwgn:
   if cols == 7:
    header  = ("Filesystem" , "Type", "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (25   , 12 , 10 , 9  , 10   , 9  , 25   )
    VVgKQc = (LEFT   , CENTER, CENTER, CENTER, CENTER  , CENTER, LEFT   )
   else:
    header  = ("Filesystem" , "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (30   , 11 , 11 , 11   , 11 , 26   )
    VVgKQc = (LEFT   , CENTER, CENTER, CENTER  , CENTER, LEFT   )
   VVJwgn.sort(key=lambda x: x[0].lower())
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, width=1700, height=1000, VVnete=True, VV1PTZ=widths, VV1Wwb=28)
  else:
   FFU9uk(self, "Cannot get data !")
 def VV3tVk(self):
  lines = FFunRV("mount")
  VVJwgn = []
  for line in lines:
   span = iSearch(r"(.+)\son\s(.+)\stype\s(.+)\s\((.+)\)", line, IGNORECASE)
   if span:
    VVJwgn.append(span.groups())
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   header  = ("Device/FS" , "Mount Point" , "VFS Type", "Mount Options")
   widths  = (20   , 25   , 13  , 42 )
   VVgKQc = (LEFT   , LEFT   , CENTER , LEFT )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVnete=True)
  else:
   FFU9uk(self, "Cannot process data.")
 def VVWEFg(self):
  lst =  []
  for line in FF2iRW("/etc/fstab"):
   s1 = line.strip().split()
   if len(s1) == 6:
    lst.append(s1)
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   header  = ("Device" , "Mount Point" , "FS Type" , "Options" , "Backup" , "FS Check")
   widths  = (24  , 24   , 10  , 24  , 9   , 9   )
   VVgKQc = (LEFT  , LEFT   , CENTER , LEFT  , CENTER , CENTER )
   FFdCaM(self, None, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVnete=True, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00004455", VVcv6F="#0a282828")
  else:
   FFU9uk(self, "Cannot read FSTAB !\n\n( or no data )")
 @FFHF2S()
 def VVvX3R(self):
  def VVjJzY(p1, bg=""):
   tLst =  []
   for line in FFunRV("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FF2iRW(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFVUvT(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  lst =  []
  for line in FFunRV("cat /lib/modules/$(uname -r)/modules.builtin"):
   if line.startswith("kernel"):
    driv = os.path.splitext(os.path.basename(line))[0]
    p1 = "/sys/module/%s/" % driv
    p2 = os.path.join(p1, "parameters/")
    tot1 = len([f for f in os.listdir(p1) if FF2iRW(p1 + f)]) if VVrRHR(p1) else 0
    tot2 = len([f for f in os.listdir(p2) if FF2iRW(p2 + f)]) if VVrRHR(p2) else 0
    lst.append((driv, line, "Yes" if tot1 + tot2 > 0 else ""))
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VV4dTm = ("", self.VVTKKD, [])
   header  = ("Driver" , "Name", "Info")
   widths  = (36   , 57 , 7  )
   VVgKQc = (LEFT  , LEFT, CENTER )
   FFdCaM(self, None, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, VVnete=True, VV1Wwb=28, VV4dTm=VV4dTm, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00004455", VVcv6F="#0a282828")
  else:
   FFU9uk(self, "Cannot read Builtin Drivers List !")
 @FFHF2S()
 def VVfv7Y(self):
  lst = []
  for line in FFunRV("find /lib/modules/ -iname *.ko"):
   lst.append((os.path.splitext(os.path.basename(line))[0], line))
  if lst : FFdCaM(self, None, header=("Driver", "Path"), VV5dDF=sorted(lst, key=lambda x: x[0].lower()), VV1PTZ=(20, 80), VVnete=True, VV1Wwb=26)
  else : FFU9uk(self, "No list found !")
 @FFHF2S()
 def VVcfDU(self):
  lst =  []
  for line in FFunRV("lsmod"):
   s1 = line.split()
   Len = len(s1)
   if Len >= 3 and s1[1] != "Size":
    if   Len == 3: lst.append(s1)
    else   : lst.append(s1[:2] + [" ".join(s1[2:])])
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VV4dTm = ("", self.VVTKKD, [])
   header  = ("Module" , "Size", "Used By" )
   widths  = (30  , 15 , 55  )
   VVgKQc = (LEFT  , CENTER, LEFT  )
   FFdCaM(self, None, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, VVnete=True, VV1Wwb=28, VV4dTm=VV4dTm, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00004455", VVcv6F="#0a282828")
  else:
   FFU9uk(self, "Cannot get drivers Info !")
 @FFHF2S(par=1)
 def VVTKKD(self, VV5ybN, title, txt, colList):
  driv = colList[0]
  lst1, lst3 = [], []
  for line in FFunRV("modinfo %s" % driv):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip().capitalize(), val.strip()
    if not val.startswith("ERROR"):
     tLst = lst1 if subj in ("Filename", "Version", "Author", "Description", "License", "Srcversion", "Depends", "Vermagic") else lst3
     tLst.append((subj, val))
  def VVjJzY(p1, bg=""):
   tLst =  []
   for line in FFunRV("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FF2iRW(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFVUvT(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  path = "/sys/module/%s" % driv
  lst2 = [("#b#0a220000#" + a, b) for (a,b) in VVjJzY(path) if (a,b) not in lst1]
  lst4 = VVjJzY(os.path.join(path, "parameters"), "#b#0a221133#")
  lst1 = [("#b#11000a0f#" + a,b) for a,b in lst1]
  lst3 = [("#b#0a003344#" + a,b) for a,b in lst3]
  VV5dDF = lst1 + lst2 + lst3 + lst4
  bg, title = "#11001122", "Driver : %s" % driv
  if VV5dDF: FFdCaM(self, None, title=title, VV5dDF=VV5dDF, VV1PTZ=(40, 60), VV4HrS=1, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00883300", VVcv6F="#0a444444")
  else  : FFU9uk(self, "No Driver Info !", title=title)
 def VVQjRw(self):
  cmd  = "RES=$(uname -m | awk '{print toupper($0)}');"
  cmd += "if [ -z \"$RES\" ] ; then RES=$(uname -a | awk '{print toupper($12)}'); fi;"
  cmd += "if [ -z \"$RES\" ] ; then echo 'Could not read Info.!'; else echo $RES; fi"
  FFpL0U(self, cmd)
 def VV9UVx(self):
  FFpL0U(self, "uname -a")
 def VVdsq3(self):
  cmd = FFKA8e(VVqwax, "| grep secondstage")
  if cmd : FFpL0U(self, 'output=$(%s); if [ -z "$output" ] ; then echo "Not found for this receiver."; else echo $output; fi' % cmd)
  else : FFD8hf(self)
 def VVacfl(self):
  c1, c2, c3 = "#b#11000a0f#", "#b#0a220000#", "#b#0a003344#"
  VV5dDF = []
  VV5dDF.append((c1 + "Box Type"  , self.VVEKcj("boxtype").upper() ))
  VV5dDF.append((c1 + "Board Version" , self.VVEKcj("board_revision") ))
  VV5dDF.append((c1 + "Chipset"  , self.VVEKcj("chipset")   ))
  VV5dDF.append((c1 + "S/N"   , self.VVEKcj("sn")    ))
  VV5dDF.append((c1 + "Version"  , self.VVEKcj("version")   ))
  VVEhnZ   = []
  VVhC2U = ""
  try:
   from Components.SystemInfo import SystemInfo
   keysList = list(SystemInfo)
   if keysList:
    for key in keysList:
     if key == "canMultiBoot":
      VVhC2U = SystemInfo[key]
     else:
      VVEhnZ.append((c3 + str(key), str(SystemInfo[key])))
  except:
   pass
  if VVhC2U:
   VVzOvz = self.VVwEaX(VVhC2U, c2)
   if VVzOvz:
    VVzOvz.sort(key=lambda x: x[0].lower())
    VV5dDF += VVzOvz
  if VVEhnZ:
   VVEhnZ.sort(key=lambda x: x[0].lower())
   VV5dDF += VVEhnZ
  if VV5dDF:
   header  = ("Subject" , "Value")
   widths  = (40    , 60)
   FFdCaM(self, None, header=header, VV5dDF=VV5dDF, VV1PTZ=widths, VV1Wwb=28, VV4HrS=1, VVqecq="#00ffff00", VVI4UA="#0a884400")
  else:
   FFyijw(self, "Could not read info!")
 def VVEKcj(self, fileName):
  fileName = "/proc/stb/info/" + fileName
  if FFf0vs(fileName):
   try:
    txt = FF2iRW(fileName)[0]
    if txt:
     return txt
   except:
    pass
  return "-"
 def VVwEaX(self, mbDict, bg):
  try:
   mbList = list(mbDict)
   VV5dDF = []
   for key in mbList:
    bootDict = mbDict[key]
    device  = bootDict.get("device"  , "")
    rootsubdir = bootDict.get("rootsubdir" , "")
    startupfile = bootDict.get("startupfile", "")
    subject  = "Multiboot-" + str(key)
    value  = ""
    if startupfile : subject += " ... "      + startupfile
    if rootsubdir : value  += "Root-Sub-Dir = %s  ...  " % rootsubdir
    if device  : value  += "Device = "     + device
    if not value:
     value  = str(bootDict)
    VV5dDF.append((bg + subject, value))
  except:
   pass
  return VV5dDF
 def VVudgh(self):
  title = "Tuners"
  c1 = "#f#00ffff88#"
  sName = [c1 + "Slot Name"]
  Type = [c1 + "Type"]
  Descr = [c1 + "Description"]
  conn = [c1 + "Connectable to"]
  fId  = [c1 + "Frontend ID"]
  sId  = [c1 + "Slot ID"]
  mType = [c1 + "Multi-Type"]
  mStream = [c1 + "Multi-Stream"]
  FCB  = [c1 + "FCB"]
  bScan = [c1 + "Supports Blind-Scan"]
  tot = 0
  for ndx, slot in enumerate(nimmanager.nim_slots):
   if slot.frontend_id is not None:
    tot += 1
    sName.append(slot.getSlotName())
    Type.append(slot.getType())
    Descr.append(slot.getFriendlyFullDescription())
    conn.append(" , ".join(slot.connectableTo()))
    fId.append(str(slot.frontend_id))
    sId.append(slot.getSlotID())
    mType.append("Yes" if slot.isMultiType() else "No")
    try:  mStream.append("Yes" if slot.isMultistream() else "No")
    except:  mStream.append("?")
    try:  FCB.append("Yes" if slot.isFBCTuner() else "No")
    except:  FCB.append("?")
    try:  bScan.append("Yes" if slot.supportsBlindScan() else "No")
    except:  bScan.append("?")
  if tot:
   VVJwgn = []
   VVJwgn.append(sName)
   VVJwgn.append(Type)
   VVJwgn.append(Descr)
   VVJwgn.append(conn)
   VVJwgn.append(fId)
   VVJwgn.append(sId)
   VVJwgn.append(mType)
   VVJwgn.append(mStream)
   VVJwgn.append(FCB)
   VVJwgn.append(bScan)
   FFdCaM(self, None, title="%s (Total = %s)" % (title, tot), VV5dDF=VVJwgn, width=1700, height=1000, VV4HrS=1)
  else:
   FFU9uk(self, "No Tuner Info.", title=title)
 def VVITPo(self):
  major   = pyVersion[0]
  minor   = pyVersion[1]
  micro   = pyVersion[2]
  releaselevel = pyVersion[3]
  serial   = pyVersion[4]
  txt = "Version\t: %d.%d.%d\n" % (major, minor, micro)
  txt += "Release\t: %s\n"  % releaselevel
  txt += "Serial\t: %d\n"   % serial
  FFyijw(self, txt)
 def VVx8d6(self):
  if CCAnLc.VV6w46():
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt = tab("Stream Relay", "Supported")
   host, port = CCAnLc.VVXSpe()
   txt += tab("Hosts List", host or "?")
   txt += tab("Port", port or "?")
   txt += tab("Total Services", len(CCAnLc.VV6meg()))
   FFyijw(self, txt, width=900)
  else:
   FFU9uk(self, "Patch not found.")
 @staticmethod
 def VVjIf8():
  def VVEQGt(v, ndx):
   lst = v.split(";")[ndx].split(",")
   return {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
  v = "openbox,OpenBox,openpli,OpenPLI,openvision,OpenVision;areadeltasat,ArEaDeltaSat,cobralibero,Cobralibero,opentr,OpenTR,peter,PeterPan,Gemini,Gemini;italysat,ItalySat,oozoon,OoZooN,openatv,openATV,openeight,OpenEight,openmips,OpenMips,opennfr,OpenNFR,openplus,OpenPlus,openspa,OpenSPA,pure2,Pure2,rudream,ruDream,teamblue,teamBlue,titannit,OpenAFF_Titan"
  v = {"/etc/issue": VVEQGt(v,0), "/etc/issue.net": VVEQGt(v,1), "/etc/image-version": VVEQGt(v,2)}
  for p1, d in v.items():
   img = CC6z2a.VV3WrK(p1, d)
   if img: return img
  v = "Blackhole,Blackhole,DE,Dream-Elite,EGAMI,Egami,LT,LT,MediaSat,MediaSat,OPENDROID,OpenDroid,Bp/geminimain,GP3;Domica,Domica,DreamElite,Dream-Elite,GP4,GP4,SatLodge,Satlodge,Satdreamgr,SatdreamGr,TSimage,OpenTS_Ts,newnigma2,newnigma2;DemonisatManager,DDD-Demoni,VTIPanel,VTI,ViX,OpenVIX;AddOnManager,Merlin3,DreamOSatcamManager,DreamOSat CamManager,ExtraAddonss,OpenESI,HDF-Toolbox,OpenHDF,HDMUCenter,HDMU,LDteam,OpenLD,NssPanel,NonSoloSat,PKT,PKT,PowerboardCenter,PBNigma-VX,TDW,TDW"
  p = "/usr/lib/enigma2/python/"
  v = {p: VVEQGt(v,0), p + "Plugins/": VVEQGt(v,1), VVBSnt: VVEQGt(v,2), VVSaol: VVEQGt(v,3)}
  for p1, d in v.items():
   img = CC6z2a.VVJKgD(p1, d)
   if img: return img
  return "OpenBlackhole" if iGlob("%sScreens/BpBlue.p*" % p) else ""
 @staticmethod
 def VV3WrK(path, d):
  if FFf0vs(path):
   txt = FF05rJ(path).lower()
   for key, val in d.items():
    if key.lower() in txt: return val
  return ""
 @staticmethod
 def VVJKgD(path, d):
  for key, val in d.items():
   if VVrRHR(path + key): return val
  return ""
 @staticmethod
 def VVOCgj():
  return VVrRHR(VVBSnt + "VTIPanel")
class CCqBeU(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 700, 630, 50, 40, 30, "#22003300", "#22001100", 32)
  self.session  = session
  VVXXzc = []
  VVXXzc.append(("Settings (All)"   , "all" ))
  VVXXzc.append(("Settings (Hot Keys)"  , "hk" ))
  VVXXzc.append(("Settings (Tuner/DiSEqC)" , "tun" ))
  VVXXzc.append(("Settings (Plugins)"  , "plug"))
  VVXXzc.append(("Settings (Usage)"   , "usg" ))
  VVXXzc.append(("Settings (Time Zone)"  , "tz" ))
  VVXXzc.append(("Settings (Skin)"   , "sk" ))
  FFfmZP(self, VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "all" : g = ""
   elif item == "hk" : g = ("config.misc.ButtonSetup." if CCRex8.VVSb5Y() else "config.misc.hotkey.")
   elif item == "tun" : g = "config.Nims."
   elif item == "plug" : g = ".plugins."
   elif item == "usg" : g = ".usage."
   elif item == "tz" : g = ".timezone."
   elif item == "sk" : g = ".skin."
   title = self["myMenu"].l.getCurrentSelection()[0]
   lst = []
   for line in FFunRV("cat %s%s" % (VVrRe3, (" | grep %s" % g) if g else "")):
    k, _, v = line.partition("=")
    k, v = k.strip(), v.strip() or "-"
    if not g or g in line:
     lst.append((k.strip() or "-", v.strip() or "-"))
   if lst : FFdCaM(self, None, title=title, header=("Key", "Value"), VV5dDF=lst, VV1Wwb=28, VVnete=True)
   else : FFU9uk(self, "No settings changes found.", title=title)
class CC6pkA(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 950, 800, 50, 40, 30, "#22003300", "#22001100", 30)
  self.VV90JV, VVq527, VVrQxz, camCommand = CC6pkA.VVh0NH()
  self.session  = session
  self.VVq527  = VVq527
  self.camInfo_cmd = camCommand + " -V 2> /dev/null"
  camName = "SoftCam"
  nC = oC = c = ""
  if VVq527:
   c = VVnQYw if VVrQxz else VVkLs0
   if   "oscam" in VVq527 : camName, oC = "OSCam", c
   elif "ncam"  in VVq527 : camName, nC = "NCam" , c
  VVXXzc = []
  VVXXzc.append(("OSCam Files" , "OSCamFiles" ))
  VVXXzc.append(("NCam Files" , "NCamFiles" ))
  VVXXzc.append(("CCcam Files" , "CCcamFiles" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((VV6UAe + 'Convert "/etc/CCcam.cfg" to OSCam/NCam Readers', "VVZneP"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((oC + "OSCam Readers" , "OSCamReaders"))
  VVXXzc.append((nC + "NCam Readers" , "NSCamReaders"))
  VVXXzc.append(VVzg1X)
  camCmd = os.path.basename(camCommand)
  txt = "%s Settings%s" % (camName, "" if camCmd in ("oscam", "ncam") else " ( %s )" % camCmd)
  VVXXzc.append(FFwjWO(txt, "camInfo", VVq527, c))
  VVXXzc.append(VVzg1X)
  camLst = ((c + camName + " Live Status" , "camLiveStatus" )
    , (c + camName + " Live Log" , "camLiveLog"  ))
  if VVq527:
   for item in camLst: VVXXzc.append(item)
  else:
   for item in camLst: VVXXzc.append((item[0], ))
  FFfmZP(self, title="SoftCam Tools", VVXXzc=CC6pkA.VVcqIB(VVXXzc, 5))
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "OSCamFiles"  : self.session.open(CCPLX0, "oscam")
   elif item == "NCamFiles"  : self.session.open(CCPLX0, "ncam")
   elif item == "CCcamFiles"  : self.session.open(CCPLX0, "cccam")
   elif item == "VVZneP" : self.VVZneP()
   elif item == "VV6WKa" : self.VV6WKa()
   elif item == "OSCamReaders"  : self.VVlI4j("os")
   elif item == "NSCamReaders"  : self.VVlI4j("n")
   elif item == "camInfo"   : self.VVimxR(self.camInfo_cmd)
   elif item == "camLiveStatus" : CC6pkA.VVFENe(self.session, True)
   elif item == "camLiveLog"  : CC6pkA.VVFENe(self.session, False)
   else       : self.close()
 def VVimxR(self, cmd):
  lines = FFunRV(cmd)
  VVJwgn = []
  for line in lines:
   line = line.strip()
   if ":" in line:
    parts = line.split(":")
    key  = parts[0].strip()
    val  = parts[1].strip()
    VVJwgn.append((key, val))
   elif line:
    VVJwgn.append((line, ""))
  if VVJwgn:
   header   = ("Parameter" , "Value" )
   widths   = (50    , 50  )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VV1PTZ=widths, VV1Wwb=28, VVnete=True)
  else:
   FFpL0U(self, cmd)
 def VVZneP(self):
  path = CC6pkA.VV1FJX()
  outFile = "%scccam_to_reader_%s.txt" % (FFmAG5(), FF6eWd())
  if FFf0vs(path):
   lines = FF2iRW(path)
   lst = []
   for line in lines:
    line = line.strip()
    if line.startswith("C:"):
     while "  " in line: line = line.replace("  ", " ")
     parts = line.split(" ")
     if len(parts) == 5:
      CTxt, host, port, User, Pass = parts
      lst.append((host, port, User, Pass))
   newLine = []
   if lst:
    VVEQGt = lambda txt, val: "%s= %s\n" % (txt.ljust(30), str(val))
    with open(outFile, "w") as f:
     for ndx, item in enumerate(lst, start=1):
      host, port, User, Pass = item
      f.write("[reader]\n")
      f.write(VVEQGt("label"    , "CCcam-Line-%d" % ndx))
      f.write(VVEQGt("description"  , "CCcam-Line-%d" % ndx))
      f.write(VVEQGt("protocol"   , "cccam"))
      f.write(VVEQGt("device"    , "%s,%s" % (host, port)))
      f.write(VVEQGt("user"    , User))
      f.write(VVEQGt("password"   , Pass))
      f.write(VVEQGt("fallback"   , "1"))
      f.write(VVEQGt("group"    , "64"))
      f.write(VVEQGt("cccversion"   , "2.3.2"))
      f.write(VVEQGt("audisabled"   , "1"))
      f.write(VVEQGt("ccckeepalive"  , "1"))
      f.write("\n")
    tot = len(lst)
    FFSQn9(self, "Output = %d Reader%s in:\n\n%s" % (tot, FFEnJs(tot), outFile))
   else:
    FF8PJn(self, "No valid CCcam lines", 1500)
  else:
   FF8PJn(self, "%s not found" % path, 1500)
 def VV6WKa(self):
  CCXRxc.VVJ9VK(self, VVCJhW=self.VVgxAZ, VVuQkS=self.VVXsZs)
 def VVgxAZ(self, VVM2wn):
  ttl = "Processing ..."
  VVM2wn.VViN1g = ("", "Not found")
  dic = CCHa3c.VVEtPc()
  if dic : VVM2wn.VVqMKy(len(dic[1]) + 4)
  else : return
  lst1 = []
  uErr = []
  uNoLn = []
  for uNum, u in enumerate(dic[1], start=1):
   u = FFxmv7(u[1:-1])
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVkdWG(u.partition("/")[0] if VVpSLv else ttl)
   VVM2wn.VVwOHf(1)
   res, err = CChTrx.VVAHM2("https://%s" % u, timeout=4)
   if res:
    span = iSearch(r"(C: \S+ \d+ \S+ [^\s<]+)", res.text, IGNORECASE)
    if span : lst1.append(str(span.group(1)).strip().replace("c:", "C:"))
    else : uNoLn.append(u)
   elif err:
    uErr.append(u)
  lst2 = []
  u = FFxmv7(dic[2][1:-1])
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVkdWG((u + " (P1)") if VVpSLv else ttl)
  VVM2wn.VVwOHf(1)
  res, err = CChTrx.VVAHM2("https://%s" % u, timeout=2)
  if res:
   span = iSearch(r'<a href="(.+)">%s<\/a>' % FFG0BS("RnJlZSBDQ2NhbSBzZXJ2ZXJz"), res.text, IGNORECASE)
   if span:
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVkdWG((u + " (P2)") if VVpSLv else ttl)
    VVM2wn.VVwOHf(1)
    res, err = CChTrx.VVAHM2(span.group(1), timeout=2)
    if res:
     lst2 = iFindall(r"(C:\s+.+)#", res.text) or []
     lst2 = list(map(str.strip, list(map(str, lst2))))
     lst2.sort()
    elif err: uErr.append(u)
  elif err: uErr.append(u)
  if not lst2: uNoLn.append(u)
  lst3 = []
  u = FFxmv7(dic[3][1:-1])
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVkdWG(u  if VVpSLv else ttl)
  VVM2wn.VVwOHf(1)
  res, err = CChTrx.VVAHM2("https://%s" % u, timeout=2)
  if res:
   lst3 = iFindall(r"(C:\s+.+)<\/a>", res.text) or []
   lst3 = list(map(str.strip, list(map(str, lst3))))
   lst3.sort()
  elif err: uErr.append(u)
  if not lst3: uNoLn.append(u)
  if not lst1 and not lst2 and not lst3:
   VVM2wn.VViN1g = ("", "No lines found")
   return
  sep1 = "#" + " %s %s %s" % ("=" * 15, FFH0yd(), "=" * 15)
  sep2 = "#" + " " + "-" * 51
  lst = ["", sep1]
  lst.extend(lst1)
  if lst1 and lst2: lst.append(sep2)
  lst.extend(lst2)
  if lst1 or lst2: lst.append(sep2)
  lst.extend(lst3)
  totL = len(lst1) + len(lst2) + len(lst3)
  def VVhCni(p):
   patt = r"^#\s={10,}\s.+\s={10,}"
   fLines, totR  = [], 0
   oldLines = FF2iRW(p)
   Max = len(oldLines) - 1
   for ndx, ln in enumerate(oldLines):
    ln = str(ln).strip()
    if ndx < Max:
     nextL = oldLines[ndx + 1].strip()
     if   iMatch(patt, ln) and (iMatch(patt, nextL) or not nextL or nextL.startswith("#")) : continue
     elif (ln == sep2) and (not nextL or nextL == sep2 or iMatch(patt, nextL))    : continue
    if not ln or ln.startswith("#"):
     fLines.append(ln)
    else:
     Code = ln.partition("#")[0].strip()
     if not Code in lst : fLines.append(ln)
     elif Code   : totR += 1
   return fLines, totR
  def VVn19T(p, lines):
   fTxt = "\n".join(lines).strip()
   while "\n\n\n" in fTxt: fTxt = fTxt.replace("\n\n\n", "\n\n")
   with open(p, "w") as f: f.write("%s\n" % fTxt)
  f1 = CC6pkA.VV1FJX()
  fLines, totR1 = VVhCni(f1)
  fLines.extend(lst)
  VVn19T(f1, fLines)
  f2 = CC6pkA.VVMAxO()
  totR2 = 0
  if FFf0vs(f2):
   fLines, totR2 = VVhCni(f2)
   fLines.extend(lst)
   VVn19T(f2, fLines)
  c1 = VV6UAe
  ttl = lambda x: "%s:\n" % FFITtK(x, c1)
  txt1  = ttl("Updated Files")
  txt1 += "  %s%s\n" % (f1, ("   (Replaced : %s)" % totR1) if totR1 else "")
  if FFf0vs(f2): txt1 += "  %s%s\n" % (f2, ("   (Replaced : %s)" % totR2) if totR2 else "")
  if VVpSLv:
   txt = txt1
   if uErr:
    txt += "\n" + ttl("With Errors")
    txt += "  %s\n" % "\n  ".join(uErr)
   if uNoLn:
    txt += "\n" + ttl("With no Lines")
    txt += "  %s\n" % "\n  ".join(uNoLn)
   txt += "\n%s" % FFiN5A("Added Lines (%s)" % totL, VVnQYw)
   txt += "\n".join(lst)
  else:
   txt  = ttl("Added Lines")
   txt += "  %s\n\n" % totL
   txt += txt1
  VVM2wn.VViN1g = (txt, "")
 def VVXsZs(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VV9zbx:
   txt, err = VViN1g
   if err  : FFU9uk(self, err)
   elif not txt: FFU9uk(self, "Not found")
   else:
    FFyijw(self, txt)
    CC6pkA.VVBQLx(self.session)
 @FFHF2S()
 def VVlI4j(self, VV0ffr):
  VVJwgn = CC6pkA.VV9IQi(self, VV0ffr)
  if VVJwgn:
   VVJwgn.sort(key=lambda x: int(x[0]))
   if self.VVq527 and self.VVq527.startswith(VV0ffr):
    VVEyDE = ("Delete Reader" , BF(self.VV5Nbt, VV0ffr) , [])
    VV5CrJ = ("Toggle State"  , self.VVG8m6, [VV0ffr]     , "Changing State ...")
    VVnete = False
   else:
    VVEyDE = VV5CrJ = None
    VVnete = True
   bg = "#22000011"
   header   = ("No." , "State" , "Label" , "Description" , "Host", "Port", "Protocol", "User", "Password")
   widths   = (4  , 5    , 28    , 16   , 14 , 6   , 9   , 9  , 9   )
   VVgKQc  = (CENTER , CENTER , LEFT   , LEFT   , LEFT , CENTER, LEFT  , LEFT , LEFT  )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1800, height=1000, VV1Wwb=24, VVnete=VVnete, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVrpeX=True
     , VVVzvS="#22002030", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00664411", VVcv6F="#00444444", VVsOjr="#08442211")
 def VVX9A9(self, VV5ybN, VV0ffr):
  VVJwgn = CC6pkA.VV9IQi(self, VV0ffr)
  if VVJwgn : VV5ybN.VVxhz9(VVJwgn)
  else  : VV5ybN.cancel()
 def VV9IQi(self, VV0ffr):
  rFile = "%s%scam.server" % (self.VV90JV, VV0ffr)
  if FFf0vs(rFile):
   lst = CC6pkA.VVBMWO(rFile)
   if not lst: FFU9uk(self, "No readers found !")
   return lst
  else:
   FFbHk5(self, rFile)
   return []
 def VV5Nbt(self, VV0ffr, VV5ybN, title, txt, colList):
  num, stt, lbl, dscr, hst, prt, prot, usr, pas = colList
  FFHsPu(self, BF(CC6pkA.VVur65, VV5ybN, lbl, cbFnc=BF(self.VVX9A9, VV5ybN, VV0ffr)), "%s\n\nDelete ?" % lbl, title="Delete Reader")
 def VVG8m6(self, VV5ybN, VV0ffr):
  confFile = "%s%scam.conf" % (self.VV90JV, VV0ffr)
  readerState = VV5ybN.VVVWWJ(1)
  readerLabel = VV5ybN.VVVWWJ(2)
  if "off" in readerState.lower() : newState = "enable"
  else       : newState = "disable"
  urlAction = "&label=%s&action=%s" % (FFma3M(readerLabel), newState)
  uReq = CC6pkA.VVg0kS(self, VV0ffr, confFile, "readerlist", urlAction)
  if uReq:
   try:
    page = iUrlopen(uReq, timeout=4)
   except Exception as e:
    VV5ybN.VV8SQf()
    FFU9uk(self, "Cannot connect to SoftCAM !\n\nError = %s" % str(e))
    return
   self.VVX9A9(VV5ybN, VV0ffr)
  else:
   VV5ybN.VV8SQf()
 @staticmethod
 def VVg0kS(SELF, VV0ffr, confFile, urlPart, urlAction, typ="html"):
  if FFf0vs(confFile):
   lines = FF2iRW(confFile)
   user = "root"
   pwd  = port = ""
   if lines:
    webif = False
    for line in lines:
     line = line.strip().lower()
     if "[webif]" in line:
      webif = True
     if webif and "=" in line:
      if   line.startswith("httpuser"): user = line.split("=")[1].strip()
      elif line.startswith("httppwd") : pwd = line.split("=")[1].strip()
      elif line.startswith("httpport"): port = line.split("=")[1].strip()
   if not webif:
    FFU9uk(SELF, "Cannot connect to SoftCAM Web Interface !")
    return None
   elif not port:
    FFU9uk(SELF, "SoftCAM Web Port not found in file:\n\n%s" % confFile)
    return None
  else:
   FFbHk5(SELF, confFile)
   return None
  if not iRequest:
   FFU9uk(SELF, "Module not found\n\nurllib/urllib2")
   return None
  try:
   url = "http://127.0.0.1:%s/%scamapi.%s?part=%s%s" % (port, VV0ffr, typ, urlPart, urlAction)
   acceccManager = HTTPPasswordMgrWithDefaultRealm()
   acceccManager.add_password(None, url, user, pwd)
   handlers= HTTPDigestAuthHandler(acceccManager)
   opener = build_opener(HTTPHandler, handlers)
   install_opener(opener)
   return iRequest(url)
  except Exception as e:
   FFU9uk(SELF, "Error while preparing URL Request !\n\n %s" % str(e))
   return None
 @staticmethod
 def VVh0NH():
  VV90JV = "/etc/tuxbox/config/"
  VVq527 = None
  VVrQxz  = None
  camCommand = FFhWCj(r"lsof | grep 'oscam\|ncam' | tail -1 | awk '{print $2}'")
  if camCommand:
   camCmd = os.path.basename(camCommand).lower()
   if   camCmd.startswith("oscam") : VVq527 = "oscam"
   elif camCmd.startswith("ncam") : VVq527 = "ncam"
  if VVq527:
   tStr = os.path.basename(camCommand).lower()
   for path in iGlob("/etc/init.d/softcam.*"):
    _, _, camName = os.path.basename(path).lower().partition(".")
    if camName == tStr:
     fTxt = FF05rJ(path)
     span = iSearch(r"-config-dir\s(\/etc\/tuxbox.*?)\s", fTxt, IGNORECASE)
     if span:
      VV90JV = FFA4GT(span.group(1))
      var = "$CAMNAME"
      if var in VV90JV:
       span = iSearch(r'CAMNAME="(.+)"', fTxt, IGNORECASE)
       if span:
        VV90JV = VV90JV.replace(var, span.group(1))
      break
   else:
    path = FFhWCj(camCommand + " -V 2> /dev/null | grep -i configdir | awk '{print $2}'")
    path = FFA4GT(path)
    if VVrRHR(path):
     VV90JV = path
   tFile = FFA4GT(VV90JV) + VVq527 + ".conf"
   tFile = FFhWCj("FILE='%s'; [ -f $FILE ] && cat $FILE | grep -i LOGFILE | awk '{print $3}'" % tFile)
   if FFf0vs(tFile):
    VVrQxz = tFile
  return VV90JV, VVq527, VVrQxz, camCommand
 @staticmethod
 def VVFpRX(SELF=None):
  VV90JV, VVq527, VVrQxz, camCommand = CC6pkA.VVh0NH()
  VV0ffr = confFile = ""
  if VVq527:
   VV0ffr = "os" if "oscam" in VVq527 else "n"
   confFile = "%s%scam.conf" % (VV90JV, VV0ffr)
  elif SELF:
   FFU9uk(SELF, message="No active OSCam/NCam")
  return VV90JV, VVq527, VVrQxz, camCommand, VV0ffr, confFile
 @staticmethod
 def VVPEAX(SELF, part, act, typ="html"):
  VV90JV, VVq527, VVrQxz, camCommand, VV0ffr, confFile = CC6pkA.VVFpRX(SELF)
  return CC6pkA.VVg0kS(SELF, VV0ffr, confFile, part, act, typ=typ) if VVq527 else None
 @staticmethod
 def VVq7OL():
  VV90JV, VVq527, VVrQxz, camCommand, VV0ffr, confFile = CC6pkA.VVFpRX()
  return "%s%scam.server" % (VV90JV, VV0ffr) if VVq527 else ""
 @staticmethod
 def VVMAxO():
  VV90JV, VVq527, VVrQxz, camCommand, VV0ffr, confFile = CC6pkA.VVFpRX()
  return ("%sCCcam.cfg" % VV90JV) if VV90JV else ""
 @staticmethod
 def VV1FJX():
  return "/etc/CCcam.cfg"
 @staticmethod
 def VVbRTs():
  return (CC6pkA.VV1FJX(), CC6pkA.VVMAxO())
 @staticmethod
 def VVBMWO(rFile):
  lst  = []
  tag  = "[reader]"
  lines = FF2iRW(rFile)
  tagFound= False
  enable = label = description = url = port = protocol = User = password = ""
  onStr = "#f#1100ff00#" + "ON"
  offStr = "OFF"
  for ndx, line in enumerate(lines):
   if tag in line.lower() or ndx >= len(lines) - 1:
    if enable or label or description or url or port or protocol or User or password:
     if enable == "": enable = onStr
     lst.append((str(len(lst) + 1), enable, label, description, url, port, protocol, User, password))
    enable = label = description = url = port = protocol = User = password = ""
   elif "=" in line:
    key, _, val = line.partition("=")
    key, val = key.strip().lower(), val.strip()
    if   key == "label"   : label   = val
    elif key == "description" : description = val
    elif key == "protocol"  : protocol  = val
    elif key == "user"   : User   = val
    elif key == "password"  : password  = val
    elif key == "enable"  : enable = offStr if val == "0" else onStr
    elif key == "device"  :
     url, _, port = val.partition(",")
     url, port = url.strip(), port.strip()
  return lst
 @staticmethod
 @FFHF2S("Deleting ...")
 def VVur65(SELF, lbl, delCC=True, cbFnc=None):
  if delCC: CC6pkA.VVcvNr(lbl)
  uReq = CC6pkA.VVPEAX(SELF, "readerlist", "&label=%s&action=delete" % FFma3M(lbl), typ="json")
  if uReq:
   try:
    res = iUrlopen(uReq, timeout=4)
    if cbFnc: cbFnc()
   except:
    FFk1YE(SELF, "Cannot access SoftCam", 2000)
 @staticmethod
 def VVcvNr(dLbl):
  relatedReaders = []
  rFile = CC6pkA.VVq7OL()
  rLst = [(hst, prt, usr, pas) for num, stt, lbl, dscr, hst, prt, prot, usr, pas in CC6pkA.VVBMWO(rFile) if lbl==dLbl]
  for f in CC6pkA.VVbRTs():
   c, lines = 0, []
   for ln in FF2iRW(f):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)", ln.strip())
    if span and span.groups() in rLst:
     ln = "#" + ln
     c += 1
    lines.append(ln)
   if c > 0:
    with open(f, "w") as f:
     f.write("%s\n" % "\n".join(lines))
 @staticmethod
 def VVBQLx(session):
  cmd, name = CC6pkA.VVyxAR()
  if cmd:
   def VVjJzY(*args): CCAnLc.VVzv7h(session)
   CCqTV0().VVyeGQ("%s restart" % cmd, VVjJzY)
 @staticmethod
 def VVyxAR():
  try:
   c = os.path.realpath("/etc/init.d/softcam")
   if not c.endswith(".None"): return c, os.path.split(c)[1].partition(".")[2]
  except:
   pass
  return "", ""
 @staticmethod
 def VVFENe(session, VV0DK0):
  VV90JV, VVq527, VVrQxz, camCommand = CC6pkA.VVh0NH()
  if VVq527: session.open(CCHyHT, VV90JV=VV90JV, VVq527=VVq527, VVrQxz=VVrQxz, VV0DK0=VV0DK0)
  else  : FFZMNU(session, message="No active OSCam/NCam", title="Live Log")
 @staticmethod
 def VV9n4c(SELF):
  if iElem:
   return True
  else:
   FFU9uk(SELF, "Module not found:\n\nxml.etree")
   return False
 @staticmethod
 def VVcqIB(lst, i):
  t = CCHa3c.VVCDdv(900)
  if t and VVpSLv: lst.insert(i, (VV6UAe + t, "VV6WKa"))
  return lst
class CCPLX0(Screen):
 def __init__(self, session, VVnvtv):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 700, 650, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  self.VV90JV, VVq527, VVrQxz, camCommand = CC6pkA.VVh0NH()
  if   VVnvtv == "ncam" : self.prefix = "n"
  elif VVnvtv == "oscam" : self.prefix = "os"
  else     : self.prefix = ""
  VVXXzc = []
  if self.prefix == "":
   VVXXzc.append(("CCcam.cfg"         , "c_CCcam_cfg"  ))
   VVXXzc.append(("ecm.info"          , "c_ecm_info"  ))
  else:
   VVXXzc.append(("AutoRoll.Key"         , "x_AutoRoll_Key" ))
   VVXXzc.append(("constant.cw"         , "x_constant_cw" ))
   VVXXzc.append((self.prefix + "cam.ccache"      , "x_cam_ccache" ))
   VVXXzc.append((self.prefix + "cam.conf"      , "x_cam_conf"  ))
   VVXXzc.append((self.prefix + "cam.dvbapi"      , "x_cam_dvbapi" ))
   VVXXzc.append((self.prefix + "cam.provid"      , "x_cam_provid" ))
   VVXXzc.append((self.prefix + "cam.server"      , "x_cam_server" ))
   VVXXzc.append((self.prefix + "cam.services"     , "x_cam_services" ))
   VVXXzc.append((self.prefix + "cam.srvid2"      , "x_cam_srvid2" ))
   VVXXzc.append((self.prefix + "cam.user"      , "x_cam_user"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("SoftCam.Key / SoftCam.key"     , "x_SoftCam_Key" ))
   VVXXzc.append(("CCcam.cfg"         , "x_CCcam_cfg"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((self.prefix + "cam.log (last 100 lines)"  , "x_cam_log"  ))
   VVXXzc.append((self.prefix + "cam.log-prev (last 100 lines)" , "x_cam_log_prev" ))
   VVXXzc.append((self.prefix + "cam.pid"      , "x_cam_pid"  ))
  FFfmZP(self, VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  pathTmp = "/tmp/"
  if item is not None:
   if   item == "c_CCcam_cfg"  : FFGPHz(self, "/var/etc/CCcam.cfg")
   elif item == "c_ecm_info"  : FFGPHz(self, "/tmp/ecm.info")
   elif item == "x_AutoRoll_Key" : FFGPHz(self, self.VV90JV + "AutoRoll.Key")
   elif item == "x_constant_cw" : FFGPHz(self, self.VV90JV + "constant.cw")
   elif item == "x_cam_ccache"  : self.VV9i7p("cam.ccache")
   elif item == "x_cam_conf"  : self.VV9i7p("cam.conf")
   elif item == "x_cam_dvbapi"  : self.VV9i7p("cam.dvbapi")
   elif item == "x_cam_provid"  : self.VV9i7p("cam.provid")
   elif item == "x_cam_server"  : self.VV9i7p("cam.server")
   elif item == "x_cam_services" : self.VV9i7p("cam.services")
   elif item == "x_cam_srvid2"  : self.VV9i7p("cam.srvid2")
   elif item == "x_cam_user"  : self.VV9i7p("cam.user")
   elif item == "x_SEP"   : pass
   elif item == "x_SoftCam_Key" : self.VVPN5G()
   elif item == "x_CCcam_cfg"  : FFGPHz(self, self.VV90JV + "CCcam.cfg")
   elif item == "x_SEP"   : pass
   elif item == "x_cam_log"  : FFGPHz(self, pathTmp + self.prefix + "cam.log")
   elif item == "x_cam_log_prev" : FFGPHz(self, pathTmp + self.prefix + "cam.log-prev")
   elif item == "x_cam_pid"  : FFGPHz(self, pathTmp + self.prefix + "cam.pid")
   else       : self.close()
 def VV9i7p(self, fileName):
  FFGPHz(self, self.VV90JV + self.prefix + fileName)
 def VVPN5G(self):
  path = self.VV90JV + "SoftCam.Key"
  if FFf0vs(path) : FFGPHz(self, path)
  else    : FFGPHz(self, path.replace(".Key", ".key"))
class CCHyHT(Screen):
 def __init__(self, session, VV90JV="", VVq527="", VVrQxz="", VV0DK0=False):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1700, 950, 50, 30, 20, "#22002030", "#33000011", 25, VVZ3ZU=40)
  self.session   = session
  self.VVrQxz   = VVrQxz
  self.VV0DK0   = VV0DK0
  self.timer    = eTimer()
  self.VVdn13  = False
  self.Title    = "Live Log"
  self.elementTree  = None
  self.VV7FxT   = None
  self.VVZTVG  = False
  self.user    = "root"
  self.pwd    = ""
  self.port    = ""
  self.VV5ybN  = None
  self.period    = 3000
  if "oscam" in VVq527 : titleTxt, self.VV0ffr = "OSCam", "os"
  else     : titleTxt, self.VV0ffr = "NCam" , "n"
  self.confFile   = "%s%scam.conf" % (VV90JV, self.VV0ffr)
  if self.VV0DK0: self.Title = "  %s Status" % titleTxt
  else   : self.Title = "  %s Live Log" % titleTxt
  FFfmZP(self, self.Title, addScrollLabel=True)
  FFrvOP(self["keyRed"], "Stop")
  FFyNtd(self, {"red": self.VVy0fo})
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VVNhgp=False)
  FFE1T7(self)
  self["myBar"].instance.setHAlign(1)
  self.VVy0fo()
 def onExit(self):
  self.timer.stop()
 def VVjwbS(self):
  try: self.timer_conn = self.timer.timeout.connect(self.VVdvEP)
  except: self.timer.callback.append(self.VVdvEP)
  self.timer.start(self.period, False)
  self.VVdn13 = True
  self.VVdRLJ(True)
 def VVNX7L(self):
  self.timer.stop()
  self.VVdn13 = False
  try:
   self.timer.callback.remove(self.VVdvEP)
  except:
   pass
  self.VVdRLJ(False)
 def VVdRLJ(self, isOn):
  if isOn : title, redTxt, barTxt, txt = " (Running)" , "Stop" , "Waiting for update ..." , "Started"
  else : title, redTxt, barTxt, txt = ""   , "Start", ""      , "Stopped"
  if self.VV5ybN:
   self.VV5ybN.VVq4kA(self.Title + title)
   self.VV5ybN["keyRed"].setText(redTxt)
   FF8PJn(self.VV5ybN, txt, 800)
  else:
   self["myTitle"].setText(self.Title + title)
   self["keyRed"].setText(redTxt)
   FF8PJn(self, txt, 1000)
 def VVy0fo(self):
  if self.VVdn13:
   self.VVNX7L()
  else:
   self.VVjwbS()
   uReq = CC6pkA.VVg0kS(self, self.VV0ffr, self.confFile, "status", "")
   if uReq and CC6pkA.VV9n4c(self):
    self.VV7FxT, self.elementTree = uReq, iElem
    if self.VVZTVG:
     self.VVZTVG = False
     self["myLabel"].setText("Reading from SoftCAM Interface ...")
    FFDiNL(self.VVrzFe)
   else:
    self.close()
 def VVdvEP(self):
  if self.VVdn13:
   self.VVtYWW()
 def VVrzFe(self):
  self.VVtYWW()
 def VVtYWW(self):
  try:
   page = iUrlopen(self.VV7FxT, timeout=1).read()
   err = ""
  except iURLError as e:
   err = FFwBVl(e)
  except Exception as e:
   err = str(e)
  if err:
   self["myLabel"].setText(FFITtK("Cannot read from SoftCAM Interface !\n\nError = %s\n\nPlease activate Softcam." % err, VVcahY))
   self.VVZTVG = True
   self.VVNX7L()
   return
  camTxt = page.decode("UTF-8")
  lines = list(map(str, camTxt.splitlines()))
  if self.VV0DK0: ok = self.VVZe5h(lines)
  else   : ok = self.VVov7c(lines)
  txt = "Last Update : %s" % FFpe77()
  if self.VV5ybN: self.VV5ybN["myBar"].setText(txt)
  else     : self["myBar"].setText(txt)
  if not ok:
   FFU9uk(self, "No date from SoftCam.")
   self.VVNX7L()
   if self.VV5ybN: self.VV5ybN.cancel()
   self.close()
 def VVZe5h(self, lines):
  xmlTxt = '<?xml version="1.0" encoding="UTF-8"?>\n'
  tags = ("<status", "<client", "<request", "<times", "<connection", "</client", "</status")
  for line in lines:
   line = line.strip()
   if line.startswith(tags):
    xmlTxt += line
  parseError = False
  try:
   root = self.elementTree.fromstring(xmlTxt)
  except Exception as e:
   parseError = FFITtK("Error while parsing data elements !\n\nError = %s" % str(e), VVsm0W)
   self.VVZTVG = True
   self.VVNX7L()
  txt = ""
  if not parseError is False:
   txt = parseError
   self["myLabel"].setText(txt, VVPsQd=VVtU2A)
  else:
   VVJwgn = []
   for client in root.findall("client"):
    name  = client.get("name", "-")
    desc  = client.get("desc", "-")
    protocol = client.get("protocol", "-")
    conn  = client.find("connection")
    if not conn is None:
     ip  = conn.get("ip", "-")
     port = conn.get("port", "-")
     status = conn.text
    else:
     ip = port = status = "-"
    stCode, fg = self.VVaTdC(status)
    VVJwgn.append((name, ip, port, protocol, desc, "%s%s" % (fg, status)))
   if VVJwgn:
    VVJwgn.sort(key=lambda x: x[0].lower())
    if self.VV5ybN:
     self.VV5ybN.VVxhz9(VVJwgn, VVMbPmMsg=False)
    else:
     bg = "#22000011"
     title = self.Title.strip() + " (Running)" if self.VVdn13 else ""
     VVLj1d = self.VV2FIA
     VVsB8G = (""  , self.VVHcym , [])
     VVEyDE  = ("Stop"  , self.VVdBw3 , [])
     VVvrJb = ("Options" , self.VVMMCn, [])
     header = ("Label" , "Host", "Port", "Protocol", "Description" , "State" )
     widths = (32  ,  15 , 8  , 17  , 16   , 12  )
     align = (LEFT  ,  LEFT , CENTER, CENTER , LEFT   , CENTER )
     self.VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=align, VV1PTZ=widths, VV1Wwb=24, width=1700, height=950, VVLj1d=VVLj1d, VVsB8G=VVsB8G, VVEyDE=VVEyDE, VVvrJb=VVvrJb
            , VVVzvS="#22002030", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00664411", VVcv6F="#00444444", VVsOjr="#08442211")
    return True
   else:
    return False
 def VV2FIA(self, VV5ybN):
  VV5ybN.cancel()
  self.close()
 def VVHcym(self, VV5ybN, title, txt, colList):
  VV5ybN["myBar"].instance.setHAlign(1)
 def VVdBw3(self, VV5ybN, title, txt, colList):
  self.VVy0fo()
 def VVaTdC(self, st):
  st = st.upper()
  if   st in ["OK", "CONNECTED", "CARDOK"] or st.startswith(("ON")) : c = 0
  elif any(x in st for x in ("ERROR", "UNDEF", "UNKNOWN", "OFFLINE")) : c = 1
  elif st == "OFF"             : c = 2
  else                : c = 3
  return c, {0:"#f#0055ff55#", 1:"#f#00ff8000#", 2:"#f#00aa88ff#"}.get(c, "")
 def VVMMCn(self, VV5ybN, title, txt, colList):
  delLst, lblLst = [], []
  for lbl, hst, prt, Prot, Dsc, stt in VV5ybN.VVTq0J():
   if not Prot in ("http", "server", "dvbapi"): lblLst.append(lbl)
   stCode, fg = self.VVaTdC(stt)
   if stCode == 1: delLst.append(lbl)
  tmp = {x: lblLst.count(x) for x in lblLst}
  duplLst = []
  for lbl, cnt in tmp.items():
   if cnt > 1: duplLst.extend([lbl] * (cnt - 1))
  curLbl, hst, prt, curProt, Dsc, stt = colList
  c1, c2 = VVu50a , VVkLs0
  VVXXzc = []
  VVXXzc.append(("Delete Selected Reader", "delCur"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Delete Inactive Readers" , "badRdr", delLst))
  VVXXzc.append(FFwjWO("Delete Duplicate Readers" , "dupRdr", duplLst))
  if VVpSLv:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Delete Inactive Lines (from CCcam.cfg Files)" , "badCc", delLst))
  FFw2XU(self, BF(self.VVc3cj, VV5ybN, duplLst, delLst, curLbl, curProt), VVXXzc=VVXXzc, width=1000, title="Options", VVfP2Q=True)
 def VVc3cj(self, VV5ybN, duplLst, delLst, curLbl, curProt, item=None):
  if item:
   title, ref, ndx = item
   if   ref == "delCur": self.VV5eoP(VV5ybN, delLst, curLbl, curProt)
   elif ref == "badRdr": self.VV6Opp(VV5ybN, title, delLst, True)
   elif ref == "dupRdr": self.VV6Opp(VV5ybN, title, duplLst, False)
   elif ref == "badCc" : self.VVpYBt(delLst, title)
 def VVpYBt(self, delLst, title=""):
  def VVjJzY(fil):
   lines = []
   c = 0
   for ln in FF2iRW(fil):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)", ln)
    if span and "_".join(span.groups()) in delLst:
     c += 1
     continue
    else:
     lines.append(ln)
   if c > 0:
    with open(fil, "w") as f:
     f.write("%s\n" % "\n".join(lines))
   return c
  txt = ""
  for f in CC6pkA.VVbRTs():
   if FFf0vs(f):
    tot = VVjJzY(f)
    if tot: txt += "File\t: %s\nDeleted\t: %s\n\n" % (f, tot)
  if title:
   if txt:
    FFyijw(self, txt, title)
    CC6pkA.VVBQLx(self.session)
   else:
    FFSQn9(self, "No related lines in CCcam.cfg files.", title)
 def VV6Opp(self, VV5ybN, title, delLst, delC):
  if delC: self.VVpYBt(delLst)
  CCXRxc.VVJ9VK(self, VVCJhW=BF(self.VVGk1h, delLst), VVuQkS=BF(self.VV8m8Q, title))
 def VVGk1h(self, delLst, VVM2wn):
  totDel = totErr = 0
  VVM2wn.VVqMKy(len(delLst))
  VVM2wn.VViN1g = (totDel, totErr)
  for lbl in delLst:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVkdWG(lbl)
   VVM2wn.VVwOHf(1)
   page = None
   uReq = CC6pkA.VVg0kS(self, self.VV0ffr, self.confFile, "readerlist", "&label=%s&action=delete" % FFma3M(lbl), typ="json")
   if uReq:
    try: page = iUrlopen(uReq, timeout=4)
    except: pass
   if page : totDel += 1
   else : totErr += 1
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VViN1g = (totDel, totErr)
 def VV8m8Q(self, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  totDel, totErr = VViN1g
  txt = "Deleted : %s" % totDel
  if totErr: txt += "\n\nFailed : %s" % totErr
  if totDel: self.VVtYWW()
  FFSQn9(self, txt, title)
 def VV5eoP(self, VV5ybN, delLst, curLbl, curProt):
  fnc = BF(CC6pkA.VVur65, VV5ybN, curLbl, cbFnc=self.VVtYWW)
  if curProt in ("http", "server", "dvbapi") : FF8PJn(VV5ybN, "Cannot delete protocol=%s" % curProt, 2000)
  elif curLbl in delLst      : fnc()
  else          : FFHsPu(self, fnc, "%s\n\nDelete ?" % curLbl, title="Delete Active Reader")
 def VVov7c(self, lines):
  txt = ""
  for line in lines:
   line = line.strip()
   span = iSearch(r"^[0-9]{4}[-\/][0-9]{2}[-\/][0-9]{2}\s+", line, IGNORECASE)
   if span:
    line = "\n" + VVCBkQ + line[:19] + VVVAvR + line[19:]
    for preTxt in (" connecting to ", " from server ", " by ", "reader ", "server ", "(reader) "):
     if preTxt in line:
      if preTxt == " by " and " by WebIf" in line:
       line = line.replace("WebIf", VV6uFd + "WebIf" + VVVAvR)
      else:
       t1, t2, t3 = line.partition(preTxt)
       if t2:
        h1, h2, h3 = t3.partition(" ")
        line = t1 + t2 + VVi4ay + h1 + h2 + VVVAvR + h3
    span = iSearch(r"(.+:\s*)(found\s*)(\(\d+\s*ms\))(.+)", line, IGNORECASE)
    if span:
     line = "\n" + span.group(1) + VV8QGw + span.group(2) + VV6UAe + span.group(3) + VVVAvR + span.group(4)
    line = self.VVJfNi(line, VV6UAe, ("(webif)", ))
    line = self.VVJfNi(line, VV6UAe, ("(anticasc)", "(anticasc)", "(cache)", "(cccam)", "(chk)", "(client)", "(config)", "(dvbapi)", "(ecm)", "(emm)", "(emmcache)", "(emu)", "(main)", "(net)", "(newcamd)", "(reader)", "(stat)"))
    line = self.VVJfNi(line, VV8QGw, ("OSCam", "NCam", "log switched"))
    line = self.VVJfNi(line, VVu50a, (": not found", "failed", "rejected group", "usr/pwd invalid", "timeout", "no matching reader", "disconnected"))
    ndx = line.find(") - ")
    if ndx > -1:
     line = line[:ndx + 3] + VVaR8d + line[ndx + 3:] + VVVAvR
    txt += line + "\n"
  self["myLabel"].setText(txt, VVPsQd=VVtU2A)
  return bool(txt.strip())
 def VVJfNi(self, line, color, lst):
  for txt in lst:
   if txt in line:
    t1, t2, t3 = line.partition(txt)
    if t2:
     return t1 + color + t2 + VVVAvR + t3
  return line
class CCRex8(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 750, 1000, 50, 60, 30, "#10104060", "#10001A1F", 30)
  self.session  = session
  VVXXzc = []
  VVXXzc.append(("Backup Channels"    , "VVuGX0"   ))
  VVXXzc.append(("Restore Channels"    , "VVBZRj"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Backup SoftCAM Files"   , "VVtXNu" ))
  VVXXzc.append(("Restore SoftCAM Files"  , "VVsPbl" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Backup Tuner Settings"  , "bkupTuner"    ))
  VVXXzc.append(("Restore Tuner Settings"  , "restTuner"    ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Backup HotKeys Settings"  , "bkupHKeys"    ))
  VVXXzc.append(("Restore HotKeys Settings"  , "restHKeys"    ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Backup Enigma2 Settings File" , "VVPjNe"   ))
  VVXXzc.append(("Restore Enigma2 Settings File", "VVuqQv"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Backup Network Settings"  , "VVTer3"   ))
  VVXXzc.append(("Restore Network Settings"  , "VVaz4m"   ))
  if VVpSLv:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Backup FHD-Glass17 Skin" , "bkupFhdg17"    ))
   VVXXzc.append(("Restore FHD-Glass17 Skin" , "restFhdg17"    ))
  for i in range(0, len(VVXXzc), 3):
   VVXXzc[i] = (VVnQYw + VVXXzc[i][0], VVXXzc[i][1])
  if VVpSLv:
   c1, c2, c3, c4, c5 =VVcahY, VV8QGw, VVnQYw , VVi4ay, VV6UAe
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c1 + "Fix Data (%s)" % VVV71L , "VV6w19"   ))
   VVXXzc.append((c2 + "1- Create IPK"    , "VVCSwK1"  ))
   VVXXzc.append((c2 + "2- Create DEB"    , "VVCSwK2"  ))
   VVXXzc.append((c3 + "3- Create IPK (No Restart)" , "VVCSwK3"  ))
   VVXXzc.append((c3 + "4- Create DEB (No Restart)" , "VVCSwK4"  ))
   VVXXzc.append((c3 + "5- Create IPK (No Depend)" , "VVCSwK5"  ))
   VVXXzc.append((c3 + "6- Create DEB (No Depend)" , "VVCSwK6"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c4 + "Decode Crash Report"   , "VV3NQA" ))
   VVXXzc.append((c4 + "Show Windows Stats"   , "VVsos5" ))
   VVXXzc.append((c5 + "%s Simple Portal" % ("Disable" if CFG.simplePortal.getValue() else "Enable") , "VVW1ub" ))
  FFfmZP(self, title="Backup & Restore", VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "VVuGX0"  : self.VVuGX0()
   elif item == "VVBZRj"  : self.VV7LPn("channels_backup*.tar.gz", self.VVBZRj, isChan=True)
   elif item == "VVtXNu" : self.VVtXNu()
   elif item == "VVsPbl": self.VV7LPn("softcam_backup*.tar.gz", self.VVsPbl)
   elif item == "bkupTuner"   : self.VVGMX9("tuner_backup", ["config.Nims."])
   elif item == "restTuner"   : self.VV7LPn("tuner_backup*.backup", BF(self.VVbpf5, "tuner"), isTuner=True)
   elif item == "bkupHKeys"   : self.VVGMX9("hotkey_backup", ["config.misc.hotkey.", "config.misc.ButtonSetup."])
   elif item == "restHKeys"   : self.VV7LPn("hotkey_backup*.backup", BF(self.VVbpf5, "hotk"))
   elif item == "VVPjNe"  : self.VVPjNe()
   elif item == "VVuqQv"  : self.VV7LPn("settings_backup*.tar.gz", self.VVuqQv)
   elif item == "VVTer3"  : self.VVTer3()
   elif item == "VVaz4m"  : self.VV7LPn("network_backup*.tar.gz", self.VVaz4m)
   elif item == "bkupFhdg17"   : self.VVGMX9("fhdg17_skin_backup", ["config.plugins.setupGlass17."])
   elif item == "restFhdg17"   : self.VV7LPn("fhdg17_skin_backup*.backup", BF(self.VVbpf5, "fhdg17"))
   elif item == "VV6w19"   : FFHsPu(self, BF(FFHDdB, self.session, BF(CCRex8.VV6w19, self)), "Erase previous obf ?")
   elif item.startswith("VVCSwK") : self.VVCSwK(int(item[-1]))
   elif item == "VV3NQA" : self.VV3NQA()
   elif item == "VVsos5"  : CCRex8.VVsos5(self)
   elif item == "VVW1ub" : self.VVW1ub()
 def VVW1ub(self):
  FFDDwF(CFG.simplePortal, not CFG.simplePortal.getValue())
  self.close()
 @staticmethod
 def VVSYiv(SELF):
  OBF_Path = VVL26S + "OBF/"
  if FFf0vs(OBF_Path + "obf.py"):
   from sys import path as iPath
   iPath.append(OBF_Path)
   try: from imp import reload
   except: from importlib import reload
   try: from .OBF import obf
   except: import obf
   reload(obf)
   return obf
  else:
   FFbHk5(SELF, OBF_Path)
   return None
 @staticmethod
 def VVsos5(SELF):
  obf = CCRex8.VVSYiv(SELF)
  if obf:
   txt, title = obf.windowsStats()
   FFyijw(SELF, txt, title=title, VVUrKi="WinStat")
 @staticmethod
 def VV6w19(SELF):
  obf = CCRex8.VVSYiv(SELF)
  if obf:
   txt, err = obf.fixCode(VVL26S, VVsBow, VVV71L)
   if err : FFU9uk(SELF, err)
   else : FFyijw(SELF, txt, height=1050)
 def VVCSwK(self, mode):
  OBF_Path = VVL26S + "OBF/"
  files = iGlob("%s*main_final.py" % OBF_Path)
  if not files:
   FFU9uk(self, "Final File .py not found in:\n\n%s" % OBF_Path)
   return
  FF6usE("rm -f %s__pycache__/" % VVL26S)
  self.session.open(CC1Scx, path=VVL26S, VV0fbF=mode in (2, 4, 6), VVZCHT=mode in (3, 4), VVo5iH=mode not in (5, 6))
 def VV3NQA(self):
  path = "/tmp/OBF/"
  if not VVrRHR(path):
   FFU9uk(self, "Path not found:\n%s" % path)
   return
  files = iGlob("%s*.log" % path)
  if not files:
   FFU9uk(self, "No log files in:\n\n%s" % path)
   return
  codF, err = self.VVpmoF("%s*.list" % path)
  if err:
   FFbHk5(self, path + "*.list")
   return
  srcF, err = self.VVpmoF("%s*main_final.py" % path)
  if err:
   FFbHk5(self, path + "*.final.py")
   return
  VV5dDF = []
  for f in files:
   f = os.path.basename(f)
   VV5dDF.append((f, f))
  FFw2XU(self, BF(self.VV74Kj, path, codF, srcF), VVXXzc=VV5dDF)
 def VV74Kj(self, path, codF, srcF, item=None):
  if item:
   logF = path + item
   if not FFf0vs(logF) : FFbHk5(self, logF)
   else     : self.VVaoSs(logF, codF, srcF)
 @FFHF2S()
 def VVaoSs(self, logF, codF, srcF):
  lst  = []
  lines = FF2iRW(codF)
  for line in lines:
   line = line.split(":")[1]
   parts = line.split("->")
   lst.append((parts[1].strip(), parts[0].strip()))
  if not lst:
   FFU9uk(self, "No codes in : %s" % codF)
   return
  newLogF = logF.replace(".log", ".NEW.log")
  totLog  = self.VVC2Mj(lst, logF, newLogF)
  if totLog == 0:
   FFU9uk(self, "No match found in this version for:\n\n%s" % os.path.basename(logF))
   return
  newSrcF = srcF.replace(".py" , ".DBG.py")
  totSrc  = self.VVC2Mj(lst, srcF, newSrcF)
  txt = "Found\t: %s\nIn\t: %s\n\nFound\t: %s\nIn\t: %s\n\nNew Files\t:\n" % (totLog, logF, totSrc, srcF)
  if not totLog and not totSrc:
   txt += "None"
  else:
   if totLog: txt += "    %s\n" % newLogF
   if totSrc: txt += "    %s\n" % newSrcF
  FFyijw(self, txt)
 def VVpmoF(self, patt):
  tFiles = iGlob(patt)
  if not tFiles:
   return "", "*.list"
  f = tFiles[0]
  if not FFf0vs(f):
   return "", "Not found:\n\n"
  return f, ""
 def VVC2Mj(self, lst, f1, f2):
  txt = FF05rJ(f1)
  tot = 0
  for item in lst:
   if item[0] in txt:
    tot += 1
   txt = txt.replace(item[0], item[1])
  if tot > 0:
   with open(f2, "w") as f:
    f.write(txt)
  return tot
 def VVuGX0(self):
  path1 = VVHX6T
  path2 = "/etc/tuxbox/"
  VV5dDF = []
  VV5dDF.append("%s%s" % (path1, "*.tv"))
  VV5dDF.append("%s%s" % (path1, "*.radio"))
  VV5dDF.append("%s%s" % (path1, "*list"))
  VV5dDF.append("%s%s" % (path1, "*list_*"))
  VV5dDF.append("%s%s" % (path1, "lamedb*"))
  VV5dDF.append("%s%s" % (path2, "*.xml"))
  CCRex8.VVi1W0(self, VV5dDF, self.VV12da("channels_backup"), addTimeStamp=True)
 def VVtXNu(self):
  VV5dDF = []
  VV5dDF.append("/etc/tuxbox/config/")
  VV5dDF.append("/etc/tuxbox/scce/")
  VV5dDF.append("/etc/CCcam.*")
  VV5dDF.append("/usr/keys/")
  VV5dDF.append("/usr/scam/")
  VV5dDF.append("/etc/tuxbox/*cam*")
  VV5dDF.append("/etc/tuxbox/*Cam*")
  VV5dDF.append("/usr/local/etc/oscam*.*")
  VV5dDF.append("/usr/local/etc/ncam*.*")
  VV5dDF.append("/etc/oscam*.*")
  VV5dDF.append("/etc/ncam*.*")
  VV5dDF.append("/etc/uniqid")
  CCRex8.VVi1W0(self, VV5dDF, self.VV12da("softcam_backup"), addTimeStamp=True)
 def VVTer3(self):
  VV5dDF = []
  VV5dDF.append("/etc/hostname")
  VV5dDF.append("/etc/default_gw")
  VV5dDF.append("/etc/resolv.conf")
  VV5dDF.append("/etc/wpa_supplicant*.conf")
  VV5dDF.append("/etc/network/interfaces")
  VV5dDF.append("%snameserversdns.conf" % VVHX6T)
  CCRex8.VVi1W0(self, VV5dDF, self.VV12da("network_backup"), addTimeStamp=True)
 def VVPjNe(self):
  CCRex8.VVi1W0(self, [VVrRe3], self.VV12da("settings_backup"), addTimeStamp=True)
 def VVuqQv(self, path=None):
  if path:
   ques = "Overwrite %s File (and restart) ?" % VVrRe3
   img = CC6z2a.VVjIf8()
   if img:
    if not img.lower() in path.lower():
     ques = "This file is not labeled with your image name (%s)\n\n%s" % (FFITtK(img, VVaR8d), ques)
   FFHsPu(self, BF(self.VVtbGs, path), ques)
 def VVtbGs(self, path):
  path = FFmAG5() + path
  pathInTar = VVrRe3.lstrip("/")
  res = FFhWCj("tar -tf '%s' '%s'" % (path, pathInTar))
  if not res == pathInTar:
   FFU9uk(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if not FF6usE("cp -rf '%s' '%s.bak'" % (VVrRe3, VVrRe3)):
   FFU9uk(self, "Cannot backup the file:\n\n%s" % VVrRe3)
   return
  if not FF6usE("tar -C / -xf '%s' '%s'" % (path, pathInTar)):
   FFU9uk(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if FF6usE("tar -C / -xzf '%s%s'" % (FFmAG5(), path)):
   FFU9uk(self, "Cannot restore the file:\n\n%s" % VVrRe3)
   return
  FF4uzP(self, "echo 'Applying new settings ...'")
 def VV12da(self, fName):
  img = CC6z2a.VVjIf8()
  if img: fName = "%s_%s" % (fName, img)
  return fName
 def VVBZRj(self, fileName=None):
  if fileName:
   FFHsPu(self, BF(self.VVfP79, fileName), "Overwrite current channels ?")
 @FFHF2S("Restoring ...")
 def VVfP79(self, fileName):
  path = FFmAG5() + fileName
  if FFf0vs(path):
   if CCQdsv.VVHZ7y(path):
    VVAk7o , VVIPZs = CCAnLc.VVg5A0()
    VV5WDf, VVyiKw = CCAnLc.VVjPgr()
    cmd  = FFDTPf("cd %s" % VVHX6T)
    cmd += FFDTPf("rm -f *.tv *.radio *.del lamedb* whitelist blacklist satellites.xml %s %s" % (VVIPZs, VVyiKw))
    cmd += "tar -C / -xzf '%s'" % path
    ok = FF6usE(cmd)
    FFfve1()
    if ok: FFSQn9(self, "Channels Restored.")
    else : FFU9uk(self, "Error while restoring:\n\n%s" % fileName)
   else:
    FFU9uk(self, "Invalid tar file:\n\n%s" % path)
  else:
   FFbHk5(self, path)
 def VVsPbl(self, fileName=None):
  if fileName:
   FFHsPu(self, BF(self.VVG7On, fileName), "Overwrite SoftCAM files ?")
 def VVG7On(self, fileName):
  fileName = FFmAG5() + fileName
  txt = FFdV6p("tar -C / -xzf '%s'" % fileName)
  if txt : FFyijw(self, "Error while restoring SoftCam files from:\n\n%s\n\n%s\n\nError:\n\n%s" % (fileName, SEP, txt), isErr=True)
  else : FFSQn9(self, "SoftCam Files Restored.\n\n( You may need to restart your SoftCAM )")
 def VVaz4m(self, fileName=None):
  if fileName:
   FFHsPu(self, BF(self.VVxP9e, fileName), "Overwrite Network Settings (and REBOOT) ?")
 def VVxP9e(self, fileName):
  fileName = FFmAG5() + fileName
  if FFf0vs(fileName):
   cmd = "tar -C / -xzvf '%s';" % fileName
   cmd += "echo ''; echo 'REBOOTING ...';"
   cmd += "sleep 3; reboot"
   FFNQkI(self,  cmd)
  else:
   FFbHk5(self, fileName)
 def VV7LPn(self, pattern, callBackFunction, isTuner=False, isChan=False):
  title = FFQfhO()
  if VVrRHR(FFmAG5()):
   myFiles = FFYjQm(FFmAG5(), pattern)
   if len(myFiles) > 0:
    myFiles.sort(key=os.path.getmtime, reverse=True)
    VV5dDF = []
    for myFile in myFiles:
     fileName = os.path.basename(myFile)
     VV5dDF.append((fileName, fileName))
    if len(myFiles) > 1:
     title = title + " (Sorted by time)"
    if   isTuner  : VVBztL = ("Sat. List", self.VVjMrS)
    elif isChan and iTar: VVBztL = ("Bouquets Importer", CC9j6t.VVWA4N)
    else    : VVBztL = None
    VViDZz = ("Rename ", self.VV65iv)
    VVpuzu = self.VVMpRm
    FFw2XU(self, callBackFunction, title=title, width=1200, VVXXzc=VV5dDF, VVpuzu=VVpuzu, VVBztL=VVBztL, VViDZz=VViDZz, VVhuPZ=FFmAG5())
   else:
    FFU9uk(self, "No files found in:\n\n%s" % FFmAG5(), title)
  else:
   FFU9uk(self, "Path not found:\n\n%s" % FFmAG5(), title)
 def VVMpRm(self, VVZzW8, txt, ref, ndx):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, VV6UAe), y)
  txt  = ttl("File", txt)
  txt += ttl("Path", FFmAG5())
  txt += ttl("Note", FFITtK("%s can restore this file on any image." % VVryLp, VVnQYw))
  FFyijw(self, txt)
 def VV65iv(self, VVZzW8, fName):
  left = name = right = ""
  for prefix in ("channels_backup_", "softcam_backup_", "settings_backup_", "network_backup_"):
   ext = ".tar.gz"
   if fName.startswith(prefix) and fName.endswith(ext):
    left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
    break
  if not name:
   for prefix in ("tuner_backup_", "hotkey_backup_", "fhdg17_skin_backup_"):
    ext = ".backup"
    if fName.startswith(prefix) and fName.endswith(ext):
     left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
     break
  if not name:
   name = fName
  FFttdT(self, BF(self.VV3ZLq, VVZzW8, fName, left, name, right), defaultText=name, title="Rename: %s .. %s" % (left, right), message="New name:")
 def VV3ZLq(self, VVZzW8, fName, left, name, right, nName):
  if nName is not None:
   if not nName: left = left.rstrip("_")
   nName = left + nName + right
   bPath = FFmAG5()
   if   fName == nName    : FF8PJn(VVZzW8, "No change", 800)
   elif FFf0vs(bPath + nName) : FFU9uk(self, "Name already exists:\n\n%s" % nName)
   else       : FFHsPu(self, BF(self.VVtfwv, VVZzW8, bPath, fName, nName), "Rename to:\n\n%s" % nName, title=fName)
 def VVtfwv(self, VVZzW8, bPath, fName, nName):
  fPath = bPath + fName
  nPath = bPath + nName
  try:
   stat = os.stat(fPath)
   os.rename(fPath, nPath)
   os.utime(nPath, (stat.st_atime, stat.st_mtime))
   VVZzW8.VVPSDX((nName, nName))
   FFar20(VVZzW8, "Renamed", 800)
  except Exception as e:
   FFU9uk(self, str(e), title="Rename")
 def VVGMX9(self, filePrefix, grepLst):
  if not FFf0vs(VVrRe3):
   FFU9uk(self, "Cannot read settings file")
   return
  grep = r"\|".join(grepLst)
  lines = FFunRV("cat '%s' | grep '%s'" % (VVrRe3, grep))
  if not lines:
   FFU9uk(self, "No settings found")
  for line in lines:
   if not any(x in line for x in grepLst):
    FFU9uk(self, "\n".join(lines))
    return
  else:
   path = "%s%s%s_%s.backup" % (FFmAG5(), filePrefix, self.VV12da(""), FF6eWd())
   try:
    with open(path, "w") as f:
     f.write("%s\n" % "\n".join(lines))
    FFSQn9(self, "Result File:\n\n%s" % path)
   except Exception as e:
    FFU9uk(self, str(e))
 def VVbpf5(self, mode, path=None):
  if not path:
   return
  path = FFmAG5() + path
  if not FFf0vs(path):
   FFbHk5(self, path)
   return
  elif not FFf0vs(VVrRe3):
   FFbHk5(self, VVrRe3)
   return
  if   mode == "tuner" : subj, grepLst = "Tuner"  , [".Nims."]
  elif mode == "hotk"  : subj, grepLst = "Hotkeys" , [".hotkey.", ".ButtonSetup."]
  elif mode == "fhdg17": subj, grepLst = "FHDG17-Skin", [".setupGlass17."]
  lines = FF2iRW(path)
  lst1 = []
  for line in lines:
   if line.strip() and not line in lst1 and any(x in line for x in grepLst):
    lst1.append(line)
  if not lst1:
   FFU9uk(self, "Nothing to restore from:\n\n%s" % path)
   return
  lst2 = []
  if mode == "tuner":
   atvL = ("dvbs.", "dvbc.", "dvbt.", "atsc.")
   for line in lst1:
    span = iSearch(r"(\w+\.Nims\.\d+\.)(.+)", line)
    if span:
     if span.group(2).startswith(atvL): line = span.group(1) + span.group(2)[5:]
     else        : line = span.group(1) + "dvbs." + span.group(2)
     if not line in lst2:
      lst2.append(line)
   lst = lst1 + lst2
   if nimmanager.nim_slots:
    if "dvbs" in config.Nims[0].dict() : lst = [x for x in lst if any("." + y in x for y in atvL)]
    else        : lst = [x for x in lst if not any("." + y in x for y in atvL)]
  elif mode == "hotk":
   pli, atv = ".hotkey.", ".ButtonSetup."
   for line in lst1:
    if   atv in line: line = line.replace(atv, pli)
    elif pli in line: line = line.replace(pli, atv)
    if not line in lst2:
     lst2.append(line)
   lst = lst1 + lst2
   if CCRex8.VVSb5Y() : lst = [x for x in lst if atv in x]
   else          : lst = [x for x in lst if atv not in x]
  FFHsPu(self, BF(self.VVGBIW, lst, grepLst), "Overwrite %s settings (and restart) ?" % subj)
 def VVGBIW(self, lines, grepLst):
  tFile = "/tmp/ajp_tmp"
  try:
   with open(tFile, "w") as f:
    for line in FF2iRW(VVrRe3):
     if line.strip() and not any(x in line for x in grepLst):
      f.write("%s\n" % line)
    for ndx, line in enumerate(lines):
     f.write("%s%s" % (line, "" if ndx == len(lines) - 1 else "\n"))
  except Exception as e:
   FFU9uk(self, str(e))
   return
  cmd  = "echo 'Applying new settings ...';"
  cmd += "mv -f '%s' '%s'" % (tFile, VVrRe3)
  FF4uzP(self, cmd)
 @staticmethod
 def VVSb5Y():
  from sys import modules
  return "Screens.ButtonSetup" in modules
 def VVjMrS(self, selectionObj, path):
  if not path:
   return
  path = FFmAG5() + path
  if not FFf0vs(path):
   FFbHk5(self, path)
   return
  txt = FF05rJ(path)
  satList = []
  lst = iFindall(r".+[.](diseqc.?)[=](\d+)", txt, IGNORECASE)
  for sat in lst:
   diseqc = sat[0].upper()
   satNum = sat[1]
   satList.append((diseqc.replace("DISEQC", "DiSEqC-"), satNum))
  lst = iFindall(r".+[.]sat[.](\d+)[.](lnb[=].+)", txt, IGNORECASE)
  for sat in lst:
   satNum = sat[0]
   lnb  = sat[1].upper()
   satList.append((lnb.replace("LNB=", "LNB-"), satNum))
  if satList:
   satList = list(set(satList))
   satList.sort(key=lambda x: x[0])
   txt = ""
   for item in satList:
    txt += "%s\t%s\n" % (item[0], FF3CFU(item[1]))
   FFyijw(self, txt, title="Satellites List")
  else:
   FFU9uk(self, "Incorrect Tuner Backup file !\n\n(or missing info.)", title="  Satellites List")
 @staticmethod
 def VVi1W0(SELF, pathList, tarFileName, addTimeStamp=True):
  VV5dDF = []
  t = ""
  for path in pathList:
   if os.path.isfile(path):
    if FFf0vs(path):
     VV5dDF.append(path)
   elif os.path.isdir(path):
    if os.listdir(path):
     VV5dDF.append(path)
   else:
    VVhMyz  = os.path.dirname(path)
    fileName = os.path.basename(path)
    fileName = fileName.replace("*", ".*")
    if CCRex8.VVYkkT(VVhMyz, fileName):
     VV5dDF.append(path)
  if not VV5dDF:
   FFU9uk(SELF, "Files not found!")
  elif not VVrRHR(FFmAG5()):
   FFU9uk(SELF, "Path not found!\n\n%s" % FFmAG5())
  else:
   tarFileName = "%s%s" % (FFmAG5(), tarFileName)
   if addTimeStamp:
    tarFileName = "%s_%s" % (tarFileName, FF6eWd())
   tarFileName += ".tar.gz"
   filesLine = ""
   for f in VV5dDF:
    filesLine += "%s " % f
   failed = "Process failed !"
   cmd  = "echo 'Collecting files ...';"
   cmd += "tar -czf '%s' %s 2> /dev/null;" % (tarFileName, filesLine)
   cmd += "if [ -f '%s' ]; then "   % tarFileName
   cmd += " chmod 644 '%s';"    % tarFileName
   cmd += " echo -e '\nDONE\n';"
   cmd += " echo -e '\nResult File:\n%s\n' %s;" % (tarFileName, FF0VVA(tarFileName, VV8QGw))
   cmd += " echo '';"
   cmd += "else"
   cmd += " echo -e '\n%s\n' %s;"   % (failed, FF0VVA(failed, VV8QGw))
   cmd += "fi;"
   FFyWVZ(SELF, cmd, VV4v81=True)
 @staticmethod
 def VVYkkT(Dir, patt):
  lst = []
  if Dir:
   exp = iCompile(patt)
   for root, dirs, files in os.walk(Dir):
    for f in files:
     if exp.match(f) is not None:
      lst.append((root, f))
  return lst
class CC9j6t():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.Title   = "Bouquets Importer"
  self.fileName  = ""
  self.filePath  = ""
  self.instance  = None
  self.isZip   = False
  self.cbFnc   = None
 @staticmethod
 def VVWA4N(SELF, fName):
  bi = CC9j6t(SELF)
  bi.instance = bi
  bi.VVX2Bv(fName)
 @staticmethod
 def VVLTQG(SELF, cbFnc=None):
  bi = CC9j6t(SELF)
  bi.instance = bi
  bi.cbFnc = cbFnc
  bi.VVVDmW()
 def VVX2Bv(self, fName):
  self.fileName = fName
  self.filePath = FFmAG5() + fName
  self.isZip   = fName.endswith(".zip")
  if FFf0vs(self.filePath): self.VV2Wk9()
  else      : self.VVlTRe(self.filePath)
 def VVqIBc(self, txt) : FFU9uk(self.SELF, txt, title=self.Title)
 def VVqUOx(self, txt)  : FF8PJn(self, txt, 1500)
 def VVlTRe(self, path) : FFbHk5(self.SELF, path, title=self.Title)
 def VVVDmW(self):
  if VVrRHR(FFmAG5()):
   lst = FFYjQm(FFmAG5(), "channels_backup*.tar.gz")
   if iZip: lst.extend(self.VVA1Gl())
   if len(lst) > 0:
    VVXXzc = []
    for item in lst:
     item = os.path.basename(item)
     txt = FFITtK(item, VV6UAe) if item.endswith(".zip") else item
     VVXXzc.append((txt, item))
    VVXXzc.sort(key=lambda x: x[1].lower())
    FFw2XU(self.SELF, self.VVMCgN, VVnojT=3, title=self.Title, width=1200, VVXXzc=VVXXzc, VVhuPZ=FFmAG5(), VVVzvS="#22111111", VVhHWW="#22111111")
   else:
    self.VVqIBc("No valid backup files found in:\n\n%s" % FFmAG5())
  else:
   self.VVqIBc("Backup Directory not found:\n\n%s" % FFmAG5())
 def VVMCgN(self, fName=None):
  if fName:
   self.VVX2Bv(fName)
  else:
   if self.instance: del self.instance
 def VVA1Gl(self):
  files = FFYjQm(FFmAG5(), "*.zip")
  lst = []
  try:
   for path in files:
    bakFile = os.path.basename(path)
    with iZip.ZipFile(path) as zipF:
     dbFound = bFound = False
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == "lamedb" : dbFound = True
      if fName.endswith(".tv"): bFound = True
      if dbFound and bFound:
       lst.append(bakFile)
       break
  except:
   pass
  return lst
 def VVV8td(self, lines):
  lst = []
  for line in lines:
   span = iSearch(r".+(userbouquet\..+\.(tv|radio))", line, IGNORECASE)
   if span:
    lst.append(span.group(1))
  return lst
 def VV2Wk9(self):
  CCXRxc.VVJ9VK(self.SELF, VVmj1O="Reading Bouquets ...", titleBg="#22003344", bodyBg="#22001122"
      , VVCJhW  = self.VVzgKL
      , VVuQkS = self.VVtRwF)
 def VVzgKL(self, VVM2wn):
  lines, err = CC9j6t.VVwFdX(self.filePath, "bouquets.tv")
  if err:
   self.VVqIBc(err)
   return
  bTvSortLst  = self.VVV8td(lines)
  lines, err = CC9j6t.VVwFdX(self.filePath, "bouquets.radio")
  if err:
   self.VVqIBc(err)
   return
  bRadSortLst = self.VVV8td(lines)
  if not VVM2wn or VVM2wn.isCancelled:
   return
  self.VVJwgn = []
  self.subBouquets = {}
  if self.filePath.endswith(".zip"):
   with iZip.ZipFile(self.filePath) as zipF:
    zInfLst = zipF.infolist()
    VVM2wn.VVqMKy(len(zInfLst))
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VVkdWG(fName)
     VVM2wn.VVwOHf(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      with zipF.open(zipInfo.filename) as f:
       row, bnbLst, err = self.VVXhHg(f, mode, len(self.VVJwgn), zipInfo.filename, "-", False)
       if err:
        return
       tName = os.path.basename(row[11])
       parenB = row[1]
       if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
       elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
       self.VVJwgn.append(row)
       lst = []
       for fPath in bnbLst:
        for zipInfo in zipF.infolist():
         if fPath == os.path.basename(zipInfo.filename):
          with zipF.open(zipInfo.filename) as f:
           row, bnbLst, err = self.VVXhHg(f, mode, len(self.VVJwgn), zipInfo.filename, parenB, True)
           if err:
            return
           lst.append(row)
       if lst:
        self.subBouquets[tName] = lst
  else:
   with iTar.open(self.filePath) as tar:
    members = tar.getmembers()
    VVM2wn.VVqMKy(len(members))
    for mem in members:
     fName = os.path.basename(mem.name)
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VVkdWG(fName)
     VVM2wn.VVwOHf(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      f = tar.extractfile(mem)
      row, bnbLst, err = self.VVXhHg(f, mode, len(self.VVJwgn), mem.name, "-", False)
      if err:
       return
      tName = os.path.basename(row[11])
      parenB = row[1]
      if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
      elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
      self.VVJwgn.append(row)
      lst = []
      for fPath in bnbLst:
       for mem in tar.getmembers():
        if fPath == os.path.basename(mem.name):
         f = tar.extractfile(mem.name)
         row, bnbLst, err = self.VVXhHg(f, mode, len(self.VVJwgn), mem.name, parenB, True)
         if err:
          return
         lst.append(row)
      if lst:
       self.subBouquets[tName] = lst
 def VVtRwF(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if self.VVJwgn:
   self.VVJwgn.sort(key=lambda x: int(x[0]))
   for ndx, item in enumerate(self.VVJwgn): self.VVJwgn[ndx][0] = str(ndx + 1)
   for key, lst in self.subBouquets.items():
    for ndx, row in enumerate(self.VVJwgn):
     if key == os.path.basename(row[11]):
      self.VVJwgn = self.VVJwgn[:ndx+1] + lst + self.VVJwgn[ndx+1:]
      break
   for ndx, item in enumerate(self.VVJwgn): self.VVJwgn[ndx][0] = str(ndx + 1)
   VVpaQ6 = "#11000600"
   VVzH0q = self.VVZRdA
   VVI3Oq  = ("Show Services"  , self.VVOEO3  , [])
   VV4dTm = (""     , self.VV40yt, [])
   VV5CrJ = ("Import to System" , self.VVFHTK  , [])
   VVbQ6N = ("Multi-Select"  , self.VVqDtK, [])
   header   = ("Num" , "Bouquet Name", "Parent Bouquet" , "Mode", "Items" , "DVB" , "IPTV", "S.Relay" , "Local" , "Marker" , "Bouquet" , "File")
   widths   = (7  ,  36   , 0.01    , 7  , 7   , 7  , 7  , 7   , 7   , 7   , 8   ,  0.01 )
   VVgKQc  = (CENTER ,  LEFT   , LEFT    , CENTER, CENTER , CENTER, CENTER, CENTER , CENTER , CENTER , CENTER ,  LEFT )
   tbl = FFdCaM(self.SELF, None, title=self.Title, header=header, VV5dDF=self.VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=24, height=1000, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVzH0q=VVzH0q, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVylFd=1, VV7VIQ=CFG.lastFindServers, VVVzvS=VVpaQ6, VVhHWW=VVpaQ6, VVpaQ6=VVpaQ6, VVI4UA="#00004455", VVcv6F="#0a282828")
   tbl.VVIl4g(BF(self.VVZRdA, tbl))
  else:
   self.VVqIBc("No valid bouquets in:\n\n%s" % os.path.basename(self.filePath))
 def VVFHTK(self, VV5ybN, title, txt, colList):
  if VV5ybN["keyGreen"].getVisible():
   cnt = 0
   if VV5ybN.VVbbT0:
    rows = VV5ybN.VVwKf5()
    for ndx, totBnb in enumerate(VV5ybN.VVaOdg(10)):
     if VV5ybN.VVAkKb(ndx) and totBnb.isdigit() and int(totBnb) > 0:
      VV5ybN.VVxgrd(ndx, mode=0, movDn=False)
      cnt += 1
   if cnt == 0:
    if VV5ybN.VVbbT0:
     tot = VV5ybN.VVQrKf()
     ques = "Import %s Bouquet%s" % (FFITtK(tot, VV8QGw), FFEnJs(tot))
    else:
     bName = VV5ybN.VVqY3Q()[1]
     ques = "Import Bouquet ?\n\n%s" % bName
    FFHsPu(self.SELF, BF(self.VVXEyd, VV5ybN, self.filePath), ques, title=self.Title)
   else:
    FFk1YE(VV5ybN, "Fixed Selections : %s" % cnt, 2000)
 def VVZRdA(self, VV5ybN):
  VV5ybN["keyGreen"].hide()
  if VV5ybN.VVbbT0:
   if VV5ybN.VVQrKf() > 0:
    VV5ybN["keyGreen"].show()
  else:
   totBnb = VV5ybN.VVqY3Q()[10]
   if not (totBnb.isdigit() and int(totBnb) > 0):
    VV5ybN["keyGreen"].show()
 def VV40yt(self, VV5ybN, title, txt, colList):
  totBnb = VV5ybN.VVqY3Q()[10]
  if totBnb.isdigit() and int(totBnb) > 0:
   c1, c2 = VVcahY, VV6UAe
   txt += "\n%sNote:\n" % c1
   txt += "%s- This bouquet includes %s%s%s Sub-Bouquet%s.\n" % (c2, c1, totBnb, c2, FFEnJs(int(totBnb)))
   txt += "- Its-Sub-Bouquets will follow it in the list (in yellow) if exist in the backup file."
  FFyijw(self.SELF, txt, title=title)
 def VVqDtK(self, VV5ybN, title, txt, colList):
  CCZALl(self.SELF, VV5ybN, addSep=False, setsOk=True).VVejOk(None, None, width=700)
 def VVOEO3(self, VV5ybN, title, txt, colList):
  if FFf0vs(self.filePath):
   num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName = VV5ybN.VVqY3Q()
   CCXRxc.VVJ9VK(self.SELF, VVmj1O= "Reading Services ...", titleBg="#22003344", bodyBg="#22001122"
       , VVCJhW  = BF(self.VVUCWV, bName, fName)
       , VVuQkS = BF(self.VVVyOV, VV5ybN, bName))
  else:
   FF8PJn(VV5ybN, "Cannot open file !", 1500)
 def VVUCWV(self, bName, fName, VVM2wn):
  lines, err = CC9j6t.VVwFdX(self.filePath, "lamedb")
  if err:
   self.VVqIBc(err)
   return
  dbServLst = CCAnLc.VVlZjh(lines, mode=10)
  lines, err = CC9j6t.VVwFdX(self.filePath, os.path.basename(fName))
  if err:
   self.VVqIBc(err)
   return
  if not VVM2wn or VVM2wn.isCancelled: return
  patt = iCompile(r"1:64:(?:[a-f0-9]+:){8}:(.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|(?:[a-f0-9]+:){10}http.+:(.+)"
      r"|(?:[a-f0-9]+:){10}(\/.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|((?:[a-f0-9]+:){10})(?:$|:.+)"
      , IGNORECASE)
  VVM2wn.VVqMKy(len(lines))
  VVJwgn = []
  bnbFound = False
  for line in lines:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   iSleep(0.0005)
   if line.startswith("#SERVICE "):
    span = patt.search(line)
    if span:
     g1, g2, g3, g4, g5, g6 = span.groups()
     if   g1: VVJwgn.append((g1.strip(), "Marker"))
     elif g2: VVJwgn.append((g2 or "-", "Sub-Bouquet"))
     elif g3: VVJwgn.append((g3.strip() or "-", "Stream Relay" if FFOr4F(line) else "IPTV"))
     elif g4: VVJwgn.append((os.path.basename(g4.strip() or "-"), "Local Media"))
     elif g5: VVJwgn.append((g5 or "-", "Sub-Bouquet"))
     elif g6:
      dbCode = CCAnLc.VVpaww(g6)
      for dbCode1, name, prov in dbServLst:
       if dbCode1.upper() in dbCode:
        VVJwgn.append((name.strip() or "-", FFkz1q(g6, False)))
        break
     if any((g2, g5)):
      bnbFound = True
     if not VVM2wn or VVM2wn.isCancelled: return
     if VVJwgn:
      VVM2wn.VVkdWG(VVJwgn[len(VVJwgn) - 1][0])
  if bnbFound:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVqMKy(len(VVJwgn))
   VVM2wn.VVJyCy(0)
   for ndx, item in enumerate(VVJwgn):
    name, descr = item
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVkdWG(name)
    VVM2wn.VVwOHf(1)
    if iMatch(r".+\.tv", name, IGNORECASE):
     lines, err = CC9j6t.VVwFdX(self.filePath, os.path.basename(name))
     if lines and not err:
      span = iSearch(r"#NAME\s+(.+)", lines[0], IGNORECASE)
      if span:
       bName = span.group(1).strip()
       if bName:
        VVJwgn[ndx] = (bName, descr)
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VViN1g = VVJwgn
 def VVVyOV(self, VV5ybN, bName, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g:
   VVpaQ6 = "#11001122"
   bName = iSub(r"\s{4,}" ," .. " , bName)
   header  = ("Service", "Type")
   widths  = (80  , 20 )
   VVgKQc = (LEFT  , CENTER)
   FFdCaM(self.SELF, None, title="Services in : %s" % bName, header=header, VV5dDF=VViN1g, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVVzvS=VVpaQ6, VVhHWW=VVpaQ6, VVpaQ6=VVpaQ6, VVI4UA="#11550033", VV7VIQ=CFG.lastFindServers)
  elif not VV9zbx:
   pass
  else:
   FF8PJn(VV5ybN, "No valid services !", 1500)
 def VVXhHg(self, f, mode, sequence, fPath, parentB, isSubB):
  bName = ""
  totItem = totDVB = totMrk = totBnb = totIptv = totSRelay = totLoc = 0
  bnbLst = []
  for line in f:
   try:
    line = str(line.decode()).strip()
   except:
    self.VVqIBc("Encoding Error in the archived file:\n\n%s" % fPath)
    return [], [], "File Encoding Error"
   if line.startswith("#SERVICE "):
    totItem +=1
    if   iMatch(r".+1:64:(?:[A-Fa-f0-9]+:){8}:.+", line)    : totMrk += 1
    elif FFOr4F(line)           : totSRelay += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}http.+:.+", line, IGNORECASE) : totIptv += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}\/.+", line)     : totLoc += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}(?:$|:.+)", line)    : totDVB += 1
    else:
     span = iSearch(r'.+1:7:.+FROM BOUQUET\s+"(.+)".+', line, IGNORECASE)
     if span:
      totBnb += 1
      bnbLst.append(span.group(1))
   elif line.startswith("#NAME "):
    bName = line[6:]
  chColor = lambda x: str(x) if x else "#f#00666666#" + str(x)
  bMode = "TV" if mode == "tv" else "Radio"
  if   totBnb : fg, totBnb  = "#f#00ff5522#" , str(totBnb)
  elif isSubB : fg, totBnb  = "#f#00ffffbb#" , "Sub-B."
  else  : fg, totBnb = ""    , chColor(totBnb)
  row = [str(2000001 + sequence), fg + bName, parentB, fg + bMode, "#f#00ff88ff#" + str(totItem), chColor(totDVB), chColor(totIptv), chColor(totSRelay), chColor(totLoc), chColor(totMrk), fg + totBnb, fPath]
  return row, bnbLst, ""
 def VVXEyd(self, VV5ybN, archPath):
  title = "Import Bouquets"
  tvBouquetFile  = VVHX6T + "bouquets.tv"
  radBouquetFile = VVHX6T + "bouquets.radio"
  for f in (tvBouquetFile, radBouquetFile):
   if not FFf0vs(f):
    FFbHk5(self.SELF, f, title=title)
    return
  isMulti = VV5ybN.VVbbT0
  if isMulti : rows = VV5ybN.VVwKf5()
  else  : rows = [VV5ybN.VVqY3Q()]
  CCXRxc.VVJ9VK(self.SELF, VVmj1O=title, titleBg="#22003344", bodyBg="#22001122", totBars=2
      , VVCJhW  = BF(self.VVCXNl, VV5ybN, rows, archPath, tvBouquetFile, radBouquetFile, title)
      , VVuQkS = BF(self.VVNyRB, title) )
 def VVCXNl(self, VV5ybN, rows, archPath, tvBouquetFile, radBouquetFile, title, VVM2wn):
  totTP = totServ = totTv = totRad = totMissTP = totMissServ = totMissSRelay = totAllServ = 0
  totBouq = len(rows)
  VVM2wn.VVqMKy(totBouq)
  VVM2wn.VVFO1V(totBouq)
  VVM2wn.VViN1g = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
  bList = []
  totAllServ = 0
  if FFf0vs(archPath):
   for num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName in rows:
    if not VVM2wn or VVM2wn.isCancelled:
     return
    VVM2wn.VVkdWG(bName)
    VVM2wn.VVwOHf(1)
    totAllServ += int(totItem)
    newFile = os.path.basename(fName)
    span = iSearch(r".+\.(.+)\.(tv|radio)", newFile, IGNORECASE)
    if span : fNamePart, fNameExt = span.group(1), span.group(2)
    else : fNamePart, fNameExt = "bouquet", "tv"
    newFile = "userbouquet.%s.%s" % (fNamePart, fNameExt)
    bPath = VVHX6T + newFile
    num  = 0
    while FFf0vs(bPath):
     num += 1
     newFile = "userbouquet.%s_%d.%s" % (fNamePart, num, fNameExt)
     bPath = VVHX6T + newFile
    CC9j6t.VVV5hz(archPath, fName, VVHX6T, newFile)
    if FFf0vs(bPath):
     bList.append(newFile)
  if not VVM2wn or VVM2wn.isCancelled:
   return
  if bList:
   FFxGSn(tvBouquetFile)
   FFxGSn(radBouquetFile)
   for bFile in bList:
    if bFile.endswith("tv") : mainBFile, totTv = tvBouquetFile , totTv  + 1
    else     : mainBFile, totRad = radBouquetFile, totRad + 1
    with open(mainBFile, "a") as f:
     f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
   if not VVM2wn or VVM2wn.isCancelled:
    return
   VVM2wn.VViN1g = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
   totTP, totServ, totMissTP, totMissServ, totMissSRelay = self.VVWXsM(archPath, bList, VVM2wn)
   VVM2wn.VViN1g = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 def VVNyRB(self, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  FFfve1()
  totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay = VViN1g
  c1, c2 = VV6UAe, VVcahY
  txt  = FFITtK("Added:\n", VV6UAe)
  txt += "Bouquets\t: %d     (%d TV , %d Radio)\n" % (totBouq, totTv, totRad)
  txt += "Services\t: %d\n" % totAllServ
  if totTP or totServ:
   txt += "\n"
   txt += FFITtK("Imported to lamedab:\n", VV6UAe)
   if totTP : txt += "Transponders\t: %d\n" % totTP
   if totServ : txt += "Services\t: %d\n"  % totServ
  if any((totMissTP, totMissServ, totMissSRelay)):
   txt += "\n"
   txt += FFITtK("Missing from archived lamedb:\n", VVcahY)
   if totMissTP : txt += "Transponders\t: %d\n" % totMissTP
   if totMissServ : txt += "Services\t: %d"  % totMissServ
   if totMissSRelay : txt += "Stream Relay\t: %d" % totMissSRelay
  FFyijw(self.SELF, txt, title=title, width=1000)
  if self.cbFnc:
   self.cbFnc()
 def VVWXsM(self, archPath, bList, VVM2wn):
  VVAk7o, err = CCAnLc.VVhMtJ(self.SELF, VVw9e0=False)
  if err:
   return 0, 0, 0, 0
  dbServIDs = CCAnLc.VVTO22(VVAk7o, mode=11)
  if not dbServIDs:
   return 0, 0, 0, 0
  newDbServIDs = set()
  newDbTpIDs  = set()
  newStreamRelayChNames = set()
  for bFile in bList:
   if not VVM2wn or VVM2wn.isCancelled:
    return
   VVM2wn.VVkdWG(bFile)
   VVM2wn.VVoreX(1)
   lines = FF2iRW(VVHX6T + bFile)
   for line in lines:
    span = iSearch(r"((?:[A-Fa-f0-9]+:){10}$)", line, IGNORECASE)
    if span:
     VVDhju = span.group(1)
     dbCode = CCAnLc.VVpaww(VVDhju)
     if not dbCode in dbServIDs:
      newDbServIDs.add(dbCode)
      newDbTpIDs.add(CCAnLc.VVdLD0(VVDhju))
    else:
     span = iSearch(r"(?:[A-Fa-f0-9]+:){10}https?(?::|%3a)\/\/(?:(?:127|0)\.\d+\.\d+\.\d+|localhost)(?::|%3a)\d+\/(.+)\/pid(\d+):", line, IGNORECASE)
     if span:
      newStreamRelayChNames.add(" PID ".join(span.groups()))
  dbServIDs = None
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVkdWG("Updating lamedb (Stage-1) ...")
  tFile = ""
  if any((newDbServIDs, newDbTpIDs, newStreamRelayChNames)) and FFf0vs(archPath):
   dbName = "lamedb"
   tFile = "/tmp/%s.tmp" % dbName
   fName = CC9j6t.VVIak5(archPath, dbName)
   CC9j6t.VVV5hz(archPath, fName, "/tmp/", dbName + ".tmp")
  newTPLines = set()
  newServLines= set()
  dbTpData = CCAnLc.VVTO22(VVAk7o, mode=0)
  dbServData = CCAnLc.VVTO22(VVAk7o, mode=10)
  if newDbTpIDs:
   for item in CCAnLc.VVTO22(tFile, mode=0):
    if item[0].upper() in newDbTpIDs and not item in dbTpData:
     newTPLines.add(item)
  if newDbServIDs:
   for item in CCAnLc.VVTO22(tFile, mode=10):
    if item[0].upper() in newDbServIDs and not item in dbServData:
     newServLines.add(item)
  totMissSRelay = len(newStreamRelayChNames)
  if newStreamRelayChNames:
   for item in CCAnLc.VVTO22(tFile, mode=14):
    for VVeZBd in newStreamRelayChNames:
     if VVeZBd.lower() == item[1].lower():
      totMissSRelay = 0
      if not item in dbServData:
       newServLines.add(item)
       tp = CCAnLc.VVCPVx(item[0])
       if not tp in dbTpData:
        newTPLines.add(tp)
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVkdWG("Updating lamedb (Stage-2) ...")
  totMissTP = 0
  totMissServ = 0
  lst = CCAnLc.VVTO22(tFile, mode=1)
  for dbCode in newDbTpIDs:
   if not lst or not dbCode in lst:
    totMissTP += 1
  lst = CCAnLc.VVTO22(tFile, mode=11)
  for dbCode in newDbServIDs:
   if not lst or not dbCode in lst:
    totMissServ += 1
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVkdWG("Updating lamedb (Stage-3) ...")
  FFqlCI(tFile)
  totServ = totTP = 0
  if newTPLines or newServLines:
   isServ = isTP = False
   tmpDbFile = VVAk7o + ".tmp"
   lines   = FF2iRW(VVAk7o)
   with open(tmpDbFile, "w") as f:
    for line in lines:
     sLine = line.strip()
     if   sLine == "transponders": isTP, isServ = True, False
     elif sLine == "services" : isTP, isServ = False, True
     elif sLine == "end":
      if isTP:
       for item in (newTPLines):
        totTP += 1
        for L in item:
         f.write(L + "\n")
      elif isServ:
       for item in (newServLines):
        totServ += 1
        for L in item:
         f.write(L + "\n")
     f.write(line + "\n")
   FF6usE("mv -f '%s' '%s'" % (tmpDbFile, VVAk7o))
  return totTP, totServ, totMissTP, totMissServ, totMissSRelay
 @staticmethod
 def VVIak5(path, fName):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    for zipInfo in zipF.infolist():
     if os.path.basename(zipInfo.filename) == fName:
      return zipInfo.filename
  else:
   with iTar.open(path) as tar:
    for mem in tar.getmembers():
     if os.path.basename(mem.name) == fName:
      return mem.name
  return ""
 @staticmethod
 def VVV5hz(path, fName, newPath, newFile):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    zipInfo = zipF.getinfo(fName)
    zipInfo.filename = newFile
    zipF.extract(zipInfo, newPath)
  else:
   with iTar.open(path) as tar:
    mem = tar.getmember(fName)
    mem.name = newFile
    tar.extract(mem, path=newPath)
 @staticmethod
 def VVwFdX(path, subFile):
  lines = []
  try:
   if path.endswith(".zip"):
    with iZip.ZipFile(path) as zipF:
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == subFile:
       with zipF.open(zipInfo.filename) as f:
        lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   else:
    with iTar.open(path) as tar:
     for mem in tar.getmembers():
      fName = os.path.basename(mem.name)
      if fName == subFile:
       f = tar.extractfile(mem)
       lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   return [str(x.strip()) for x in lines], ""
  except:
   return [], "Error while reading the archived file:\n\n%s" % subFile
class CCNcvI():
 def __init__(self):
  self.VVTsVA   = "Package Creator"
  self.VVydYx   = "ajpanel_package_"
  self.VVe4Q3  = FFmAG5()
  self.VVPBti   = ""
  self.VVTWQg   = ""
  self.VVBwj6   = ""
  self.VVnRkV   = None
  self.VV09ay   = None
  self.VVAdnF = ""
  self.VVdjM1  = ""
  self.VVVmWX = ""
  self.VVAaea = ""
  self.VVo32o = ""
  self.VVDwJU = ""
  self.VVsNRl()
 def VVsNRl(self):
  self.projPkg   = ""
  self.projVer   = ""
  self.projArch   = ""
  self.VVBwj6sSize  = 0
  self.projTotalDirs  = 0
  self.projTotalFiles  = 0
  self.projAct_postInst = 0
  self.projAct_postRm  = 0
 @FFHF2S()
 def VVx9pc(self):
  FFoSpw()
  self.VVe4Q3 = FFsiHs()
  lst = FFi2MT(self.VVe4Q3)
  VVXXzc = []
  if lst:
   for path in lst:
    if path.startswith(self.VVydYx):
     prName = os.path.basename(path)
     VVXXzc.append((prName, prName))
  if VVXXzc:
   VVXXzc.sort(key=lambda x: x[1].lower())
   VV5LxL = self.VV59kG
   VVBztL = ("Add new project", self.VVOaTN)
   VVI6TY= ("Delete Project" , self.VVtobA)
   self.VVnRkV = FFw2XU(self, None, VVXXzc=VVXXzc, width=1100, VV5LxL=VV5LxL, VVBztL=VVBztL, VVI6TY=VVI6TY, VVnojT=5, VVVzvS="#22111133", VVhHWW="#22111133")
  else:
   FFHsPu(self, self.VVTRca, "No projects found !\n\n Create new project ?", title=self.VVTsVA)
 def VVTRca(self)    : FFTSvN(self, BF(self.VVym6d))
 def VVOaTN(self, VVZzW8, item) : FFTSvN(self.VVnRkV, BF(self.VVym6d))
 def VVym6d(self):
  err, _ = self.VVw8hs(0)
  if err:
   self.VVqeTb(err)
  else:
   c = 0
   while True:
    c += 1
    name = "project_%d" % (c)
    if not VVrRHR("%s%s%s" % (self.VVe4Q3, self.VVydYx, name)):
     break
   self.VVEvPw(name)
 def VVEvPw(self, name, cbFnc=None):
  FFttdT(self, cbFnc or self.VVKCpD, defaultText=name, title="New Project Name", message="Enter project name")
 def VVKCpD(self, name):
  if name and name.strip():
   path = "%s%s%s" % (self.VVe4Q3, self.VVydYx, name)
   if VVrRHR(path):
    FFHsPu(self, BF(self.VVEvPw, name), "Project directory already exists !\n\n Change name ?", title=self.VVTsVA)
   else:
    err = FFsnOK(path)
    if err:
     self.VVqeTb("Cannot create project directory !\n\n %s" % err)
    else:
     item = os.path.basename(path)
     if self.VVnRkV: self.VVnRkV.VVgjzO((item, item), isSort=True)
     else   : self.VVx9pc()
 def VVtobA(self, VVZzW8, path):
  if path:
   path = self.VVe4Q3 + path
   if VVrRHR(path):
    totDir, totFile, totLink = FFhWIm(path)
    FFHsPu(self, BF(self.VVE0vE, path), "Project directory contains %d items.\n\n%s\n\nDelete ?" %(totDir + totFile + totLink, path), title=self.VVTsVA)
 def VVE0vE(self, path):
  if FF6usE("rm -rf '%s'" % path):
   self.VVnRkV.VVBvIe()
 def VV59kG(self, item=None):
  if item:
   VVZzW8, txt, Dir, ndx = item
   self.VVsNRl()
   self.VVPBti = os.path.basename(Dir)[len(self.VVydYx):]
   self.VVTWQg = "%s%s/" % (self.VVe4Q3, Dir)
   self.VVBwj6 = "%s%s.cfg"  % (self.VVTWQg, self.VVPBti)
   self.VVAdnF = self.VVTWQg + "control"
   self.VVdjM1  = self.VVTWQg + "prerm"
   self.VVVmWX = self.VVTWQg + "postrm"
   self.VVAaea = self.VVTWQg + "preinst"
   self.VVo32o = self.VVTWQg + "postinst"
   if not FFf0vs(self.VVAdnF):
    err, lst = self.VVw8hs(2)
    if err:
     self.VVqeTb(err)
     return
    pkg = FFJQht(self.VVPBti, r"_").lower()
    with open(self.VVAdnF, "w") as f:
     for line in lst:
      f.write("%s\n" % (line[1].replace("xx1", pkg).replace("xx2", self.VVPBti)))
   if not FFf0vs(self.VVBwj6):
    with open(self.VVBwj6, "w") as f:
     sep = "#" * 80
     f.write("%s\n" % sep)
     f.write("%s Project\t: %s\n" % ("#", self.VVPBti))
     f.write("%s Started\t: %s\n" % ("#", FFpe77()))
     f.write("%s\n" % sep)
   if FFf0vs(self.VVBwj6): self.VVfVhT(VVZzW8)
   else      : self.VVqeTb("Cannot create project file:\n\n%s" % self.VVBwj6)
 def VVfVhT(self, VVZzW8=None, jmpDict=None):
  FFTSvN(VVZzW8 or self.VV09ay or self, BF(self.VVwGCE, jmpDict))
 def VVwGCE(self, jmpDict):
  self.VVsNRl()
  pkgRows, ctrlRows, actnRows, fileRows, unknRows = [], [], [], [], []
  tLst = []
  if FFf0vs(self.VVAdnF):
   for lineNdx, line in enumerate(FF2iRW(self.VVAdnF)):
    line = line.strip()
    if ":" in line:
     subj, val, rem = self.VVcQ8x(line)
     if   subj in tLst: rem = FFITtK("Duplicate Field", VVcahY)
     elif val == ""  : rem = FFITtK("No Value", VVcahY)
     tLst.append(subj)
     pkgRows.append((str(lineNdx), "Control", subj, val, "", rem, ""))
  if not pkgRows:
   self.VVqeTb('Invalid "control" file:\n\n%s' % self.VVAdnF)
   return
  for path in (self.VVAaea, self.VVo32o, self.VVdjM1, self.VVVmWX):
   size = val = ""
   if FFf0vs(path):
    val = path
    sz = FFX42v(path)
    if sz > -1: size = CCQdsv.VVAcha(sz, mode=4)
    else   : size = FFITtK("Size error", VVcahY)
   ctrlRows.append(("", "Script", os.path.basename(path), val, size, "", ""))
  lines = list(map(str.strip, FF2iRW(self.VVBwj6)))
  pathsLst = []
  for line in lines:
   if line.startswith("/"):
    pathsLst.append(line)
  pathsAnalysis = CCiFfa.VVcUk4(pathsLst)
  for lineNdx, line in enumerate(lines):
   lineNdx = str(lineNdx)
   if line and not line.startswith("#"):
    validF = size = rem = ""
    if line.startswith("/"):
     path, fName, typ, size, rem, validF = self.VVfNiY(line, fileRows, pathsAnalysis)
     fileRows.append((lineNdx, "Resource", typ or "Unknown", path, size, rem, validF))
    else:
     Title, val = self.VVMFkA(line)
     if Title: actnRows.append((lineNdx, "Action", Title, val, size, rem, validF))
     else : unknRows.append((lineNdx, "?", "-", line, size, FFITtK("Unknown value", VVcahY), validF))
  for ndx, row in enumerate(actnRows):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   rem = ""
   if   FFf0vs(self.VVo32o) and Title == "postinst" : rem = "Ignored (if custom postinst)"
   elif FFf0vs(self.VVVmWX  ) and Title == "postrm" : rem = "Ignored (if custom postrm)"
   if rem:
    actnRows[ndx] = (lineNdx, Section, Title, Value, Size, FFITtK(rem, VVcahY), ValidF)
  actnRows.sort(key=lambda x: x[2].lower())
  fileRows.sort(key=lambda x: (x[2].lower(), x[3].lower()))
  unknRows.sort(key=lambda x: x[3].lower())
  VVJwgn = pkgRows
  VVJwgn.extend(actnRows)
  VVJwgn.extend(ctrlRows)
  VVJwgn.extend(fileRows)
  VVJwgn.extend(unknRows)
  cDict = {"Control":"", "Action":"0c302636", "Script":"0a28281a", "Resource":"1100385a", "?":"11550000"}
  for ndx, row in enumerate(VVJwgn):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   color = cDict.get(Section, "")
   if color:
    if ValidF: Remarks = "%s%s" % (FFITtK("Valid", VV8QGw), " ... " + Remarks if Remarks else "")
    VVJwgn[ndx] = (lineNdx, "#b#%s#" % color + Section, Title, Value, Size, "#b#0a0b0b1b#" + Remarks, ValidF)
  if self.VV09ay:
   self.VV09ay.VVxhz9(VVJwgn, VVK0Fc=BF(self.VVDZYK, jmpDict) if jmpDict else None, isSort=False)
  else:
   bg = "#15000000"
   title = "%s : %s" % (self.VVTsVA, self.VVPBti)
   VV4dTm = (""     , self.VVMHd2   , [])
   VVi7Cl = (""     , self.VVKKmw   , [])
   VVEyDE = ("Create Package"  , self.VVuwxU , [])
   VVbQ6N = ("Post Install Action", self.VVmezD, [])
   VVvrJb = ("Edit File"   , self.VVyY8Z  , [])
   header  = ("lineNdx", "Section" , "Title" , "Value / Path", "Size", "Remarks" , "ValidF")
   widths  = (0  , 9   , 11  , 48   , 10 , 22  , 0   )
   VVgKQc = (CENTER , CENTER , LEFT  , LEFT   , CENTER, LEFT  , CENTER )
   self.VV09ay = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1850, height=1040, VV1Wwb=26, VV4dTm=VV4dTm, VVi7Cl=VVi7Cl, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVylFd=2
         , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00664411", VVcv6F="#00444444", VVsOjr="#08442211")
   self.VV09ay.VVIl4g(self.VVEcjB)
 def VVDZYK(self, jmpDict, VV5ybN, title, txt, colList):
  self.VV09ay.VVdP7o(jmpDict)
 def VVEcjB(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VV09ay.VVqY3Q()
  if Section == "Control":
   txt = '"control" File'
  elif Section == "Script" :
   txt = "Script File"
   if Value.startswith("/") and FFf0vs(Value):
    txt = "Script File"
   else:
    self.VV09ay["keyBlue"].hide()
    return
  else:
   txt = "Project File"
  self.VV09ay["keyBlue"].show()
  self.VV09ay["keyBlue"].setText("Edit %s" % txt)
 def VVcQ8x(self, line):
  def VVjJzY(patt, val, Len):
   if len(val) < Len   : return FFITtK("Length error" , VVcahY)
   elif not iMatch(patt, val) : return FFITtK("Invalid format" , VVcahY)
   else      : return ""
  subj, _, val = line.partition(":")
  val, rem = val.strip(), ""
  if   not self.projPkg  and subj == "Package"  : self.projPkg, rem = val, VVjJzY(r"^[a-z]+[a-z0-9+-_.]+$", val, 2)
  elif not self.projVer  and subj == "Version"  : self.projVer, rem = val, VVjJzY(r"^[a-zA-Z0-9_+-.~]*$" , val, 1)
  elif not self.projArch and subj == "Architecture": self.projArch = val
  return subj, val, rem
 def VVfNiY(self, path, fileRows, pathsAnalysis):
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = pathsAnalysis
  rem = note = validF = targetType = ""
  size = "-"
  isCtrl = False
  fName = os.path.basename(path)
  typ = FFzhsp(path)
  path = FFHP0y(path)
  c1 = VVcahY
  if   typ == "Mount"     : rem = "Not allowed"
  elif not typ      : rem = "Cannot be accessed"
  elif FFA4GT(path) in rmDirLst: rem = "Ignored (child exists)"
  else:
   for item in fileRows:
    if item[3].strip() == path:
     rem = "Duplicate"
     break
  if rem:
   rem = FFITtK(rem, c1)
   return path, fName, typ, size, rem, validF
  sz = -1
  skipSz = False
  if typ == "Directory":
   sz = FFT3Nn(path)
  elif typ == "SymLink":
   targetPath = os.path.realpath(path)
   targetType = FFzhsp(targetPath)
   if  targetType == "Mount"  : skipSz, rem = True, FFITtK("Not allowed", c1)
   elif targetType == "Directory" : sz = FFT3Nn(targetPath)
   elif targetType == "File"  : sz = FFX42v(targetPath)
   else       : sz, rem = FFX42v(path), FFITtK("Invalid", c1)
   note = "%s%s%s" % (note, " ... " if note else "", "Linked to : %s" % targetPath)
  elif typ == "File":
   sz = FFX42v(path)
  if not skipSz:
   if sz > -1:
    validF = "" if rem else "1"
    if validF:
     if "Directory" in (typ, targetType) : self.projTotalDirs  += 1
     if "File" in (typ, targetType)  : self.projTotalFiles += 1
     self.VVBwj6sSize += sz
    size = CCQdsv.VVAcha(sz, mode=4)
   else:
    size = FFITtK("Size error", c1)
  rem = "%s%s%s" % (rem, " ... " if rem else "", note)
  return path, fName, typ, size, rem, validF
 def VVMFkA(self, line):
  Title = val = ""
  actDict = {"restart":1, "reboot":2 }
  span = iSearch(r"postinst\s*=\s*(.+)", line, IGNORECASE)
  if span:
   act = span.group(1).lower()
   self.projAct_postInst = actDict.get(act, 0)
   Title, val = "postinst", "%s after the package is installed" % act.capitalize()
  else:
   span = iSearch(r"postrm\s*=\s*(.+)", line, IGNORECASE)
   if span:
    act = span.group(1).lower()
    self.projAct_postRm = actDict.get(act, 0)
    Title, val = "postrm", "%s after the package is removed" % act.capitalize()
  return Title, val
 def VVyY8Z(self, VV5ybN, title, txt, colList):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  if   Section == "Control": path, lineNdx = self.VVAdnF, int(lineNdx)
  elif Section == "Script" : path, lineNdx = Value, 0
  else      : path, lineNdx = self.VVBwj6, int(lineNdx)
  if FFf0vs(path) : CCAvJY(self, path, VVuQkS=self.VVxBga, VVSkE3=lineNdx)
  else    : FFbHk5(self, path)
 def VVxBga(self, fileChanged):
  if fileChanged:
   self.VVfVhT()
 def VVqeTb(self, txt):
  FFU9uk(self, txt, title=self.VVTsVA)
 def VVMHd2(self, VV5ybN, title, txt, colList):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  c = VV6UAe
  s  = FFiN5A("Current Row", c)
  s += title + "\n"
  s += txt + "\n"
  s += FFiN5A("Project", c)
  s += tab("File Name", self.VVBwj6)
  s += tab("Valid Dirs", self.projTotalDirs)
  s += tab("Valid Files", self.projTotalFiles)
  s += tab("Total Size", CCQdsv.VVAcha(self.VVBwj6sSize))
  FFyijw(self, s, title="Project Info", width=1600)
 def VVKKmw(self, VV5ybN, title, txt, colList):
  c1, c2, c3, c4, c5 = VVnQYw, VVkLs0, VV6UAe, VVcahY, VV8QGw
  allRes, invRes, unkRes = self.VV0GPW()
  totAll = len(allRes)
  totInv = len(invRes)
  totAllTxt = ("(Total=%d)" % totAll) if allRes else ""
  totInvTxt = ("(Total=%d)" % totInv) if invRes else ""
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  canDel = False
  if Section != "Script" and Title not in ("Package", "Version", "Description", "Maintainer", "Architecture"):
   canDel = True
  canAddPkg, depTitle = False, ""
  if Section == "Control" and Title in ("Breaks", "Built-Using", "Conflicts", "Depends", "Enhances", "Pre-Depends", "Provides", "Recommends", "Replaces", "Suggests"):
   canAddPkg, depTitle = True , VVVAvR + '\tFor : "%s"' % Title
  VVXXzc = []
  VVXXzc.append((c1 + "Add Resource Files/Dirs"       , "addFiles"))
  VVXXzc.append((c1 + "Import Files/Dirs List from an Installed Package", "pkgFiles"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Import Control File (control/preinst/prerm/postinst/postrm)" , "ctrlFMan" ))
  VVXXzc.append((c3 + "Import Control Data from an Installed Package"    , "ctrlImprt" ))
  VVXXzc.append((c3 + "Add Control Field"           , "ctrlField" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Add Binary Package%s"  % depTitle  , "addDep" , canAddPkg, c2 ))
  VVXXzc.append(FFwjWO("Remove Binary Package%s" % depTitle  , "delDep" , canAddPkg, c2 ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Change Package Name"  , "pkgNam" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Delete All Resources %s"  % totAllTxt , "delAllRes" , totAll > 0, c4))
  VVXXzc.append(FFwjWO("Delete Invalid Resources %s" % totInvTxt , "delInval" , totInv > 0, c4))
  VVXXzc.append(FFwjWO("Delete Current Row"      , "delRow"  , canDel , c4))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO('Undo Last "control" File Changes'   , "ctrlUndo" , FFf0vs(self.VVAdnF + ".bak"), c5))
  VVXXzc.append(FFwjWO("Undo Last Project File Changes"   , "projUndo" , FFf0vs(self.VVBwj6 + ".bak")  , c5))
  FFw2XU(self, BF(self.VVWJbO, Title), VVXXzc=VVXXzc, width=1050, height=1000, title="Options", VVVzvS="#11001122", VVhHWW="#11001122", VVfP2Q=True)
 def VVWJbO(self, fldTitle, item=None):
  if item:
   ques, item, ndx = item
   ques = FFes9J(ques)
   if   item == "addFiles" : self.VV0YfJ()
   elif item == "pkgFiles" : self.VVr1Vs(self.VV09ay, "Import Files/Dirs", self.VVUIsf)
   elif item == "ctrlFMan" : self.VVYMtf()
   elif item == "ctrlImprt": self.VVr1Vs(self.VV09ay, "Import 'control' data", self.VVYiCk)
   elif item == "ctrlField": self.VVa7rD()
   elif item == "addDep" : self.VVXrhw(self.VV09ay, fldTitle)
   elif item == "delDep" : self.VVd3lm(fldTitle)
   elif item == "pkgNam" : self.VVKQm6()
   elif item == "delAllRes": self.VV4Vjb(ques, 1)
   elif item == "delInval" : self.VV4Vjb(ques, 2)
   elif item == "delRow" : self.VVgoUK()
   elif item == "ctrlUndo" : self.VV90bv(self.VVAdnF)
   elif item == "projUndo" : self.VV90bv(self.VVBwj6)
 def VV0YfJ(self):
  Dir = CFG.lastPkgProjDir.getValue()
  self.session.openWithCallback(self.VV2ac5, BF(CCQdsv, mode=CCQdsv.VVIaIN, VV82pi=Dir, VVrlSM=True))
 def VV2ac5(self, path):
  if path:
   if isinstance(path, list):
    lines = "\n".join(path)
    path = path[0]
   else:
    lines = path
   FFDDwF(CFG.lastPkgProjDir, FF5AKn(path, True))
   self.VV2Y6R(lines, 2)
 @FFHF2S(par=1)
 def VVUIsf(self, VV5ybN, title, txt, colList):
  pkg = colList[0]
  lst = FFunRV(r"%s | grep -E '^\/'" % (FFiD2M(VVWBay, pkg)))
  if lst : FFHsPu(self, BF(self.VVjTC0, VV5ybN, lst), "Add %s Files/Dirs to project ?" % len(lst), title="Import Control Fields")
  else : self.VVqeTb("No files/dirs found in package:\n\n%s" % pkg)
 def VVjTC0(self, VV5ybN, lst):
  VV5ybN.cancel()
  self.VV2Y6R("\n".join(lst), 2)
 def VVYMtf(self):
  Dir = FF5AKn(CFG.lastPkgProjDir.getValue(), False)
  self.session.openWithCallback(self.VVFqH7, BF(CCQdsv, VVmysg="pkgCtrl", VV82pi=Dir))
 def VVFqH7(self, path):
  if path:
   FFDDwF(CFG.lastPkgProjDir, path)
   fName = os.path.basename(path)
   FFyxsN(self.VVAdnF)
   if FF6usE("cp -f '%s' '%s'" % (path, self.VVTWQg + fName)):
    self.VVfVhT()
    self.VV09ay.VVdP7o({1:"Script", 2:fName})
 def VV90bv(self, File):
  if FF6usE("mv -f '%s.bak' '%s'" % (File, File)):
   self.VVfVhT()
  else:
   self.VVqeTb("Process Failed !")
 @FFHF2S(par=1)
 def VVYiCk(self, VV5ybN, title, txt, colList):
  pkg = colList[0]
  lines = []
  for line in FFunRV(FFiD2M(VV2z4R, pkg)):
   span = iSearch(r"^([A-Z].+):\s*.+", line)
   if span and span.group(1) in ("Package", "Version", "Depends", "Section", "Architecture", "Maintainer", "Source", "Description"):
    lines.append(line)
  if lines: FFHsPu(self, BF(self.VVKaPf, VV5ybN, lines), "Replace current fields ?", title="Import Control Fields")
  else : self.VVqeTb("Cannot import from this package:\n\n%s" % pkg)
 def VVKaPf(self, VV5ybN, lines):
  VV5ybN.cancel()
  FFyxsN(self.VVAdnF)
  with open(self.VVAdnF, "w") as f:
   for line in lines:
    f.write(line.strip() + "\n")
  self.VVfVhT(jmpDict={1:"Control", 2:"Package"})
 def VV0GPW(self):
  allRes, invRes, unkRes = [], [], []
  for ndx, row in enumerate(self.VV09ay.VVTq0J()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if lineNdx.isdigit():
    if Section == "Resource":
     allRes.append(int(lineNdx))
     if not ValidF: invRes.append(int(lineNdx))
    if Section == "?": unkRes.append(int(lineNdx))
  allRes.extend(unkRes)
  invRes.extend(unkRes)
  return sorted(allRes), sorted(invRes), sorted(unkRes)
 def VV4Vjb(self, ques, mode):
  allRes, invRes, unkRes = self.VV0GPW()
  if   mode == 1: lst = allRes
  elif mode == 2: lst = invRes
  if lst : FFHsPu(self, BF(self.VVD3gI, lst), "%s ?" % ques, title=self.VVTsVA)
  else : FF8PJn(self.VV09ay, "Nothing to delete", 2000)
 def VVD3gI(self, ndxLst):
  if FFf0vs(self.VVBwj6):
   lines = FF2iRW(self.VVBwj6)
   FFyxsN(self.VVBwj6)
   with open(self.VVBwj6, "w") as f:
    for ndx, line in enumerate(lines):
     if not ndx in ndxLst:
      f.write("%s\n" % line)
   self.VVfVhT()
  else:
   FFbHk5(self, self.VVBwj6, title=self.VVTsVA)
 def VVgoUK(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VV09ay.VVqY3Q()
  if    Section == "Control" : file = self.VVAdnF
  else      : file = self.VVBwj6
  if Section == "Control" : FFyxsN(self.VVAdnF)
  else     : FFyxsN(self.VVBwj6)
  lineNum = int(self.VV09ay.VVqY3Q()[0]) + 1
  FF6usE("sed -i .bak -e '%dd' '%s'" % (lineNum, file))
  self.VVfVhT()
 def VV2Y6R(self, line, jmp):
  if FFf0vs(self.VVBwj6):
   FFyxsN(self.VVBwj6)
   FFxGSn(self.VVBwj6)
   with open(self.VVBwj6, "a") as f:
    f.write("%s\n" % line)
   if   jmp == 1: jmpDict = {1:"Action" , 2:line.split("=")[0]}
   elif jmp == 2: jmpDict = {1:"Resource" , 3:line.strip().rstrip("/")}
   else   : jmpDict = None
   self.VVfVhT(jmpDict=jmpDict)
  else:
   FFbHk5(self, self.VVBwj6, title=self.VVTsVA)
 def VVmezD(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(FFwjWO("No-Action after installation" , "instNon", self.projAct_postInst != 0))
  VVXXzc.append(FFwjWO("Restart after installation" , "instRes", self.projAct_postInst != 1))
  VVXXzc.append(FFwjWO("Reboot after installation"  , "instReb", self.projAct_postInst != 2))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("No-Action after removal" , "rmNon", self.projAct_postRm != 0))
  VVXXzc.append(FFwjWO("Restart after removal" , "rmRes", self.projAct_postRm != 1))
  VVXXzc.append(FFwjWO("Reboot after removal"  , "rmReb", self.projAct_postRm != 2))
  FFw2XU(self, self.VV19D4, VVXXzc=VVXXzc, title="Action (after the package is installed/removed)")
 def VV19D4(self, item=None):
  if item:
   if   item == "instNon" : self.VVOxIO("postinst", 0)
   elif item == "instRes" : self.VVOxIO("postinst", 1)
   elif item == "instReb" : self.VVOxIO("postinst", 2)
   elif item == "rmNon" : self.VVOxIO("postrm", 0)
   elif item == "rmRes" : self.VVOxIO("postrm", 1)
   elif item == "rmReb" : self.VVOxIO("postrm", 2)
 def VVOxIO(self, subj, val):
  if FFf0vs(self.VVBwj6):
   lines = FF2iRW(self.VVBwj6)
   FFyxsN(self.VVBwj6)
  else:
   lines = []
  inFile = False
  with open(self.VVBwj6, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if not iMatch(r"%s\s*=.+" % subj, line, IGNORECASE) : f.write(line + "\n")
    else            : inFile = True
  if val > 0: self.VV2Y6R("%s=%s" % (subj, {1:"restart", 2:"reboot"}.get(val, "")), 1)
  elif inFile: self.VVfVhT()
 def VVKQm6(self):
  pkg = FFJQht(self.VVPBti, r"_").lower()
  VVXXzc = []
  VVXXzc.append((pkg, pkg))
  VVXXzc.append(VVzg1X)
  for s in ("extensions", "systemplugins", "", "skins", "picons", "softcams", "", "drivers", "security", "settings"):
   if s:
    name = "enigma2-plugin-%s-%s" % (s, pkg)
    c = VV6UAe if name == self.projPkg else ""
    VVXXzc.append((c + name, name))
   else:
    VVXXzc.append(VVzg1X)
  FFw2XU(self, self.VVZ7H1, VVXXzc=VVXXzc, title="Package Name")
 def VVZ7H1(self, item=None):
  if item:
   self.VVZjRb("Package", item)
 @FFHF2S(par=1)
 def VVXrhw(self, VV09ay, fldTitle):
  lst = set()
  for path in CCJFyo.VVpH53():
   if FFf0vs(path):
    with open(path, "r") as f:
     for line in f:
      if line.startswith(("Package")):
       lst.add(line.split(":", 1)[1].strip())
  if lst:
   VVXXzc = []
   for item in lst: VVXXzc.append((item, item))
   VVXXzc.sort(key=lambda x: x[0].lower())
   VVZzW8 = FFw2XU(self, BF(self.VVN9H7, fldTitle), VVXXzc=VVXXzc, width=1100, title="Add Binary Package")
   if self.VVDwJU:
    VVZzW8.VVeehB(self.VVDwJU)
  else:
   self.VVqeTb("Cannot read dependencies list !")
 def VVN9H7(self, fldTitle, item=None):
  if item:
   lst = []
   self.VVDwJU = item
   if FFf0vs(self.VVAdnF):
    for line in FF2iRW(self.VVAdnF):
     line = line.strip()
     if line.startswith("%s:" % fldTitle):
      pkgs = line[len(fldTitle) + 1:].strip()
      if pkgs:
       lst = list(map(str.strip, pkgs.split(",")))
      break
   if not item in lst:
    lst.append(item)
    self.VVZjRb("%s" % fldTitle, ", ".join(lst))
   else:
    FF8PJn(self.VV09ay, "Already added", 1500)
 def VVd3lm(self, fldTitle):
  lst = []
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VV09ay.VVqY3Q()
  lst = list(map(str.strip, Value.split(",")))
  if lst:
   VVXXzc = []
   for item in lst: VVXXzc.append((item, item))
   FFw2XU(self, BF(self.VVuTuf, fldTitle, lst), VVXXzc=VVXXzc, title="Remove Dependency")
  else:
   self.VVqeTb("No dependencies to remove !")
 def VVuTuf(self, fldTitle, lst, item=None):
  if item:
   for ndx, dep in enumerate(lst):
    if dep == item:
     del lst[ndx]
     break
   if lst:
    self.VVZjRb(fldTitle, ", ".join(lst))
   else:
    FFyxsN(self.VVAdnF)
    FF6usE("sed -i '/%s:*/d' '%s'" % (fldTitle, self.VVAdnF))
    self.VVfVhT(jmpDict={1:"Control", 2:fldTitle})
 def VVZjRb(self, subj, val):
  lines = FF2iRW(self.VVAdnF) if FFf0vs(self.VVAdnF) else []
  inFile = False
  FFyxsN(self.VVAdnF)
  with open(self.VVAdnF, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if line.startswith(subj + ":"):
     line = "%s: %s" % (subj, val)
     inFile = True
    f.write(line + "\n")
   if not inFile:
    f.write("%s: %s\n" % (subj, val))
  self.VVfVhT(jmpDict={1:"Control", 2:subj})
 def VVa7rD(self):
  err, lst = self.VVw8hs(3, onlyName=True)
  if err:
   self.VVqeTb(err)
  else:
   curFields = []
   for ndx, row in enumerate(self.VV09ay.VVTq0J()):
    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
    if Section == "Control":
     curFields.append(Title)
   lst.sort(key=lambda x: x[0].lower())
   VVXXzc = []
   for item in lst:
    if not item[0] in curFields:
     VVXXzc.append((item[0], item[1]))
   if VVXXzc : FFw2XU(self, self.VVQaa0, VVXXzc=VVXXzc, title="Control Fields", VVfP2Q=True)
   else  : self.VVqeTb("All fields are added.")
 def VVQaa0(self, item=None):
  if item:
   if FFf0vs(self.VVAdnF):
    txt, line, ndx = item
    FFyxsN(self.VVAdnF)
    FFxGSn(self.VVAdnF)
    with open(self.VVAdnF, "a") as f:
     f.write("%s\n" % line)
    self.VVfVhT(jmpDict={1:"Control", 2:txt})
   else:
    FFbHk5(self, self.VVAdnF, title=self.VVTsVA)
 def VVw8hs(self, mode, excl="", onlyName=False):
  path = "%sajpanel_pkg" % VV30Jg
  if not FFf0vs(path) : return "Missing 'control' Template File !", []
  elif mode == 0   : return "", []
  reqLst1, optLst1 , optLst2 = [], [], []
  for line in FF2iRW(path):
   line = line.strip()
   if line and not line.startswith("#"):
    span = iSearch(r"(.{3})(\d):(.+):\s*(.*)", line)
    if span:
     typ, seq, name, val = span.group(1), span.group(2), span.group(3), span.group(4)
     if not excl or excl.startswith("%s:", fld):
      item = ((name, "%s: %s" %(name, val)))
      if   typ == "REQ" and seq == "1": reqLst1.append(item)
      elif typ == "OPT" and seq == "1": optLst1.append(item)
      elif typ == "OPT" and seq == "2": optLst2.append(item)
  if   mode == 1: lst = reqLst1
  elif mode == 2: lst = reqLst1 + optLst1
  else    : lst = reqLst1 + optLst1 + optLst2
  return "", lst
 def VVuwxU(self, VV5ybN, title, txt, colList):
  for ndx, row in enumerate(self.VV09ay.VVTq0J()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if Section == "Control" and Remarks:
    self.VV09ay.VV43d2(ndx)
    FF8PJn(self.VV09ay, "Check %s\n( %s )" % (Title, FFes9J(Remarks)), 1500)
    return
  VVXXzc = []
  VVXXzc.append(("Create .ipk", "ipk"))
  VVXXzc.append(("Create .deb", "deb"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Create .tar.gz  (ignore control files)", "tar"))
  FFw2XU(self, self.VVpJRW, VVXXzc=VVXXzc, width=700, title=self.VVTsVA)
 def VVpJRW(self, typ=None):
  if typ:
   fnc = BF(self.VVhUxS, self.VV09ay, typ)
   if self.projTotalDirs + self.projTotalFiles > 0:
    fnc()
   elif typ == "tar":
    self.VVqeTb("No Dirs/Files found !\n\nYou need to add at least 1 directory or 1 file to the project !")
    return
   else:
    FFHsPu(self, fnc, "No directories/files included in this package.\n\nContinue ?", title=self.VVTsVA)
 @FFHF2S(par=1)
 def VVhUxS(self, VV09ay, typ):
  if   not self.projPkg : err = "Package"
  elif not self.projVer : err = "Version"
  elif not self.projArch : err = "Architecture"
  else     : err = ""
  if err:
   self.VVqeTb('Parameter "%s" not found !' % err)
   return
  pyTxt = ""
  if typ == "tar":
   tName, ext, arch = self.VVPBti, "tar.gz" , ""
  else:
   tName, ext, arch = self.projPkg , typ  , "_" + self.projArch
   if   "py2" in self.VVPBti.lower() : pyTxt = "_py2"
   elif "py3" in self.VVPBti.lower() : pyTxt = "_py3"
  outFile = "%s%s_%s%s%s.%s" % (FFsiHs(), tName, self.projVer, arch, pyTxt, ext)
  projDir = "/tmp/__%s/" % VVryLp
  FF6usE("rm -rf '%s'"  % projDir)
  if not typ == "tar":
   if not FF6usE("mkdir -p '%s'" % projDir):
    self.VVqeTb("Cannot create tmp files:\n\n%s" % projDir)
    return
  ctrlLst = []
  resFiles = []
  for ndx, row in enumerate(self.VV09ay.VVTq0J()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if   Section == "Control": ctrlLst.append("%s: %s" % (Title, Value))
   elif ValidF     : resFiles.append(Value)
  if typ == "tar":
   CCiFfa.VVxgmd(self, pType=typ, pName=self.VVPBti, outFile=outFile, resFiles=resFiles)
   return
  cFile = "%scontrol" % projDir
  try:
   with open(cFile, "w") as f:
    for line in ctrlLst:
     f.write("%s\n" % line)
  except:
   self.VVqeTb("Cannot create 'control' file:\n\n%s" % cFile)
   return
  fName = ("prerm"     ,"preinst"      ,"postrm"     , "postinst"     )
  srcF  = (self.VVdjM1  , self.VVAaea   , self.VVVmWX  , self.VVo32o  )
  line  = ("Removing package : xx ...", "Installing Package : xx ..." , "Package removed (xx)." , "Installation completed (xx)" )
  act   = (0       , 0        , self.projAct_postRm  , self.projAct_postInst   )
  def VVjJzY(act):
   if   act == 1: return "echo 'RESTARTING GUI ...'\n%s\n" % CCNqUU.VV301r()
   elif act == 2: return "echo 'REBOOTING DEVICE ...'\nsleep 3; reboot\n"
   else   : return "echo 'You may need to Restart GUI.'\n"
  cntrlFiles = [cFile]
  for fName, srcF, line, act in zip(fName, srcF, line, act):
   dstF = os.path.join(projDir, fName)
   cntrlFiles.append(dstF)
   if FFf0vs(srcF):
    FF6usE("cp -f '%s' '%s'" % (srcF, dstF))
   else:
    with open(dstF, "w") as f:
     f.write("#!/bin/bash\n")
     f.write("echo '%s'\n" % line.replace("xx", self.projPkg))
     f.write(VVjJzY(act) if srcF in (self.VVo32o, self.VVVmWX) else "")
     f.write("exit 0\n")
  CCiFfa.VVxgmd(self, pType=typ, pName=self.VVPBti, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, cbFnc=BF(self.VVKVlu, projDir))
 def VVKVlu(self, projDir):
  FF6usE("rm -rf '%s'"  % projDir)
class CC1Scx(Screen):
 def __init__(self, session, path, VV0fbF, VVZCHT=False, VVo5iH=False):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVJlYA=False)
  self.session    = session
  self.Path     = FFA4GT(path)
  self.VVgFpv   = path
  self.VV9cNu   = ""
  self.VVhqJT   = ""
  self.VV0fbF    = VV0fbF
  self.VVZCHT   = VVZCHT
  self.VVo5iH   = VVo5iH
  self.VVZ0Yc    = ""
  self.VVXbnX  = ""
  self.VVV971    = False
  self.VV1W2B  = False
  self.origPackageName  = ""
  self.VVAup2   = 0
  self.VVuFQs  = "enigma2-plugin-extensions-"
  self.VVr93p  = "enigma2-plugin-systemplugins-"
  self.VVKNx1 = "enigma2-"
  self.VV920p  = 0
  self.VVSgOd  = 1
  self.VVq1HM  = 2
  self.tbl     = None
  self.allOk     = False
  self.grnBtn     = True
  if VVrRHR(self.Path + "DEBIAN") or VV0fbF : self.VVTNTl = "DEBIAN"
  else           : self.VVTNTl = "CONTROL"
  self.controlPath = self.Path + self.VVTNTl
  self.controlFile = self.controlPath + "/control"
  self.preinstFile = self.controlPath + "/preinst"
  self.postinstFile = self.controlPath + "/postinst"
  self.prermFile  = self.controlPath + "/prerm"
  self.postrmFile  = self.controlPath + "/postrm"
  self.newControlPath = ""
  if VV0fbF : self.packageExt = ".deb"
  else  : self.packageExt = ".ipk"
  self.Title = "Create Package (%s)" % self.packageExt
  FFfmZP(self)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVrXuk()
 @FFHF2S()
 def VVrXuk(self):
  self.VVrTTX(True)
  self.VVuSsA(True)
 def VV8RUy(self, state):
  if self.tbl:
   if self.grnBtn : self.tbl["keyGreen"].show()
   else   : self.tbl["keyGreen"].hide()
 def VVuSsA(self, VV1V0y=False):
  cLst, pkgName, ok = self.VVLXM8(self.controlFile)
  self.allOk = ok
  if not cLst:
   FFU9uk(self, "Cannot read control file:\n\n%s" % self.controlFile, title=self.Title)
   self.cancel()
   return
  if pkgName:
   txt = ""
   if self.VVV971:
    if   self.VVZCHT  : txt = "_no_restart"
    elif not self.VVo5iH : txt = "_no_depends"
   pkgName = "%s%s%s" % (pkgName, txt, self.packageExt)
   self.VVhqJT = self.VV9cNu + pkgName
   self.VV1W2B = True
   errTxt = ""
  else:
   self.VVhqJT  = ""
   self.VV1W2B = False
  if VV1V0y:
   if   pkgName.startswith(self.VVuFQs) : self.VVgFpv = VVSaol + self.VVZ0Yc + "/"
   elif pkgName.startswith(self.VVr93p) : self.VVgFpv = VVBSnt + self.VVZ0Yc + "/"
   else            : self.VVgFpv = self.Path
  lst = []
  if self.VVV971 : fg = "#f#00ff80ff#"
  else    : fg = ""
  bg = "#b#00000000#"
  lst.append((bg + "Source Path" , fg + self.Path      , ""))
  lst.append((bg + "Installation" , fg + "#f#00ffff88#" + self.VVgFpv, ""))
  lst.append((bg + "Package File" , "#f#0000ff00#" + self.VVhqJT  , ""))
  lst.append((bg + "Control File" , "#f#00777777#" + self.controlFile  , ""))
  if self.grnBtn:
   if   self.VVAup2 == 1: act = "Add commands to %s after installation." % FFITtK("Restart GUI" , VVcahY)
   elif self.VVAup2 == 2: act = "Add commands to %s after installation." % FFITtK("Reboot Device", VVcahY)
   else      : act = "No action."
   lst.append((bg + "Post Install" , bg + act, ""))
  lst.extend(cLst)
  if self.tbl:
   self.tbl.VVxhz9(lst, isSort=False)
  elif lst:
   if self.VV0fbF: bg, typ = "#0a002a3a", "DEB"
   else   : bg, typ = "#0a002a2a", "IPK"
   VVLj1d = self.VViIlh
   VVEyDE = ("Create %s" % typ , self.VV400T , [])
   VV5CrJ = ("Post Install"  , self.VVB3yw , [])
   VVbQ6N = ("Installation Path" , self.VV9t06  , [])
   VVvrJb = ("Change Version"  , self.VVllcK  , [])
   header  = ("Field" , "Value" , "Remarks" )
   widths  = (15  , 67  , 18  )
   self.tbl = FFdCaM(self, None, title=self.Title, header=header, VV5dDF=lst, width=1800, height=1000, VV1PTZ=widths, VV1Wwb=30, VVLj1d=VVLj1d, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV4HrS=2
        , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg
        , VVcv6F="#00333333", VVI4UA="#06443333", VVsOjr="#0a332244")
   self.VVfJqu()
 def VVfJqu(self):
  for ndx, (field, val, rem) in enumerate(self.tbl.VVTq0J()):
   if rem:
    self.tbl.VV43d2(ndx)
    break
 def cancel(self):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VViIlh(self, VV5ybN):
  if self.newControlPath:
   if self.VVV971:
    self.VVp6eD()
   else:
    txt  = "Control Files were created in:\n%s\n\n" % FFITtK(self.newControlPath, VVVAvR)
    txt += FFITtK("Keep these files ?", VVaR8d)
    FFHsPu(self, self.cancel, txt, callBack_No=self.VVp6eD, title="Create Package", VVys8X=True)
  else:
   self.cancel()
 def VVp6eD(self):
  FF6usE("rm -rf '%s'" % self.newControlPath)
  self.cancel()
 def VVLXM8(self, cPath):
  pkg, ver, dsc, arc = "Package", "Version", "Description", "Architecture"
  dic = {}
  for line in FF2iRW(cPath):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip(), val.strip()
    if subj: dic[subj] = val
   elif iMatch(r"^\s+\S", line):
    line = line.strip()
    if line and dsc in dic:
     dic[dsc] = " - ".join((dic[dsc], line))
  pkgPatt = r"^[a-z]+[a-z0-9+-_.]+$"
  verPatt = r"^[a-zA-Z0-9_+-.~]*$"
  lenErr = "Must be > 1 char"
  frmErr = "Format error"
  lst = []
  pName =  pVer = pArc = ""
  ok = True
  for subj in (pkg, ver, dsc, arc):
   val = dic.get(subj, "")
   err = ""
   if val:
    if subj == pkg:
     pName = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(pkgPatt, val): err = frmErr
    elif subj == ver:
     pVer = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(verPatt, val): err = frmErr
    elif subj == arc:
     pArc = val
   else:
    err = "Missing value"
   lst.append((subj, val, ("#f#00ff8000#" if err else "") + err))
   if ok and err:
    ok = False
  for k, v in dic.items():
   if not k in (pkg, ver, dsc, arc):
    lst.append((k, v, ""))
  pkgName = ""
  if all((pName, pVer, pArc)):
   pkgName = "%s_%s_%s" % (pName, pVer, pArc)
   pkgName = pkgName.replace(" ", "")
  return lst, pkgName, ok
 def VVrTTX(self, VV1V0y):
  self.VVZ0Yc   = FFVUvT(self.Path)
  self.VVZ0Yc   = "_".join(self.VVZ0Yc.split())
  self.VVXbnX = self.VVZ0Yc.lower()
  self.VVV971 = FFQC8W(self.VVZ0Yc, self.Path)
  if self.VVV971 and self.VVXbnX.endswith(VVAH7M.lower()):
   self.VVXbnX += "el"
  if self.VVV971 : self.VV9cNu = FFmAG5()
  else    : self.VV9cNu = FFsiHs()
  self.VV9cNu = FFA4GT(self.VV9cNu)
  if not VVrRHR(self.controlPath):
   FF6usE("mkdir '%s'" % self.controlPath)
   self.newControlPath = self.controlPath
  else:
   self.newControlPath = ""
  mode = self.VVGoo4()
  if FFf0vs(self.controlFile):
   lines = FF2iRW(self.controlFile)
   for line in lines:
    if line.strip().startswith("Package") and line.count(":") == 1:
     self.origPackageName = line.split(":")[1].strip()
     break
  else:
   if self.VVV971 : version, description, maintainer = VVsBow , VVk74U, "AMAJamry - " + CC8MwG.VVQInW()
   else    : version, description, maintainer = "v1.0"   , self.VVZ0Yc , self.VVZ0Yc
   txt = ""
   txt += "Package: %s\n"  % self.VVl6ki(mode)
   txt += "Version: %s\n"  % version
   txt += "Description: %s\n" % description
   txt += "Maintainer: %s\n" % maintainer
   txt += "Architecture: all\n"
   txt += "Priority: optional\n"
   txt += "Section: base\n"
   txt += ("Homepage: %s\n" % CC8MwG.VVQInW()) if self.VVV971 else ""
   if self.VVV971 and self.VVo5iH:
    txt += "Recommends: xz (>= 5), zip, p7zip, unrar, bzip2, ffmpeg, python-requests | python3-requests, python-imaging | python3-pillow, ar (>= 2) | enigma2-plugin-extensions-opkg-tools | binutils\n"
   with open(self.controlFile, "w") as f:
    f.write(txt)
  if self.VVV971 : t = VVryLp
  else    : t = self.VVZ0Yc
  self.VVePVX(self.prermFile, "echo 'Removing package : %s ...'\n" % t)
  if self.VVV971 : txt = (r'find %s \( -name "*.pyo" -o -name "*.pyc" \) -type f -delete' % self.Path) + "\n"
  else    : txt = ""
  self.VVePVX(self.postrmFile, txt + "echo 'Package removed.'\n")
  if self.VVV971 : self.VVePVX(self.preinstFile, "echo 'Installing %s (%s) ...'\n" % (VVryLp, VVsBow))
  else    : self.VVePVX(self.preinstFile, "echo 'Installing Package : %s ...'\n" % self.VVZ0Yc)
  if VV1V0y and not mode == self.VV920p:
   self.VVAup2 = 1
  txt = self.VVu1ss(0 if self.VVZCHT else self.VVAup2)
  canChange = True
  self.grnBtn = True
  if FFf0vs(self.postinstFile):
   fText = FF05rJ(self.postinstFile).strip()
   if txt.strip() == fText:
    canChange = False
   else:
    for action in range(3):
     if fText.strip() == self.VVu1ss(action).strip():
      break
    else:
     canChange = False
     self.grnBtn = False
  if canChange:
   with open(self.postinstFile, "w") as f:
    f.write(txt)
  FF6usE("chmod 755 '%s' '%s' '%s' '%s' " % (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile))
 def VVePVX(self, path, lines):
  if not FFf0vs(path):
   with open(path, "w") as f:
    f.write("#!/bin/bash\n")
    f.write(lines)
    f.write("exit 0\n")
 def VVu1ss(self, action):
  sep  = "echo '%s'\n" % SEP
  txt = "#!/bin/bash\n" + sep
  if action == 0:
   txt += "echo '--- FINISHED ---'\n"
   txt += sep
   txt += "echo 'You may need to Restart GUI.'\n"
  elif action == 1:
   txt += "echo 'RESTARTING GUI ...'\n"
   txt += sep
   txt += "%s\n" % CCNqUU.VV301r()
  elif action == 2:
   txt += "echo 'REBOOTING DEVICE ...'\n"
   txt += sep
   txt += "sleep 3; reboot\n"
  else:
   return ""
  txt += "exit 0\n"
  return txt
 def VVB3yw(self, VV5ybN, title, txt, colList):
  if self.tbl["keyGreen"].getVisible():
   VVXXzc = []
   VVXXzc.append(("No Action" , "noAction" ))
   VVXXzc.append(("Restart GUI" , "VVuMqi" ))
   VVXXzc.append(("Reboot Device", "rebootDev" ))
   FFw2XU(self, self.VVKm0E, title="Package Installation Option (after completing installation)", VVXXzc=VVXXzc)
 def VVKm0E(self, item=None):
  if item is not None:
   if   item == "noAction"  : self.VVAup2 = 0
   elif item == "VVuMqi" : self.VVAup2 = 1
   elif item == "rebootDev" : self.VVAup2 = 2
   self.VVrTTX(False)
   self.VVuSsA()
 def VV9t06(self, VV5ybN, title, txt, colList):
  rootPath = FFITtK("/%s/" % self.VVZ0Yc, VV6UAe)
  VVXXzc = []
  VVXXzc.append(("Current Path"       , "toCurrent"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Extension Path"   , "toExtensions" , not self.VVgFpv.startswith(VVSaol)))
  VVXXzc.append(FFwjWO("System Plugins Path"  , "toSystemPlugins" , not self.VVgFpv.startswith(VVBSnt)))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Package Name in Root : %s" % rootPath , "toRootPath"  ))
  VVXXzc.append(('Root "/"'        , "toRoot"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Pick Path with File Manager ..."  , "toOthers"  ))
  FFw2XU(self, self.VVCYf5, title="Installation Path", VVXXzc=VVXXzc)
 def VVCYf5(self, item=None):
  if item is not None:
   if   item == "toCurrent"  : self.VVXqtM(FF5AKn(self.Path, True))
   elif item == "toExtensions"  : self.VVXqtM(VVSaol)
   elif item == "toSystemPlugins" : self.VVXqtM(VVBSnt)
   elif item == "toRootPath"  : self.VVXqtM("/")
   elif item == "toRoot"   : self.VVXqtM("/", False)
   elif item == "toOthers"   : self.session.openWithCallback(self.VV4RLk, BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=FFmAG5()))
 def VV4RLk(self, path):
  if len(path) > 0:
   self.VVXqtM(path)
 def VVXqtM(self, parent, withPackageName=True):
  if withPackageName : self.VVgFpv = parent + self.VVZ0Yc + "/"
  else    : self.VVgFpv = "/"
  mode = self.VVGoo4()
  FF6usE(r"sed -i '/Package/c\Package: %s' %s" % (self.VVl6ki(mode), self.controlFile))
  self.VVuSsA()
 def VVllcK(self, VV5ybN, title, txt, colList):
  if FFf0vs(self.controlFile):
   lines = FF2iRW(self.controlFile)
   version = ""
   for line in lines:
    if ":" in line:
     parts = line.split(":")
     key  = parts[0].strip()
     val  = parts[1].strip()
     if key == "Version":
      version = val
      break
   if version : FFttdT(self, self.VVJ8OM, title="Change Package Version", defaultText=version, message="Enter Version:")
   else  : FFU9uk(self, "Version not found or incorrectly set !")
  else:
   FFbHk5(self, self.controlFile)
 def VVJ8OM(self, VVAQKp):
  if VVAQKp:
   version, color = self.VVroyx(VVAQKp, False)
   if color == VVi4ay:
    FF6usE(r"sed -i '/Version:/c\Version: %s' %s" % (VVAQKp, self.controlFile))
    self.VVuSsA()
   else:
    FFU9uk(self, "Incorrect Version Syntax !\n\nAllowed characters : letter, digits and _+-.~")
 def VVl6ki(self, mode):
  prefix, name = "", ""
  package = self.origPackageName or self.VVXbnX
  if package.startswith(self.VVKNx1):
   span = iSearch(r"(.+-)(.+)", package)
   if span:
    prefix, name = span.group(1).strip(), span.group(2)
  if not name:
   prefix, name = self.VVKNx1, package
  prefix = iSub(r"([^a-z0-9+-.]+)", r"-", prefix)
  name = iSub(r"([^a-z0-9+-.]+)", r"-", name)
  if   mode == self.VVSgOd : prefix = self.VVuFQs
  elif mode == self.VVq1HM : prefix = self.VVr93p
  return (prefix + name).lower()
 def VVGoo4(self):
  if   self.VVgFpv.startswith(VVSaol) : return self.VVSgOd
  elif self.VVgFpv.startswith(VVBSnt) : return self.VVq1HM
  else            : return self.VV920p
 def VVroyx(self, val, isPackage):
  if   isPackage : pattern = r"^[a-z]+[a-z0-9+-_.]+$"
  else   : pattern = r"^[a-zA-Z0-9_+-.~]*$"
  if iMatch(pattern, val) and len(val) >= 2 : return val, VVi4ay
  else          : return val, VVsm0W
 def VV400T(self, VV5ybN, title, txt, colList):
  if not self.VV1W2B:
   FFU9uk(self, "Please fix Control File errors first.")
   return
  obfVars = obfErr = None
  if self.VVV971:
   obfVars, obfErr = self.VVb2F2()
  parent  = FF5AKn(self.VVgFpv, True)
  newPath  = parent[1:]
  symlink  = parent[1:] + self.VVZ0Yc
  symlinkTo = FFHP0y(self.Path)
  instPathInfo=  (self.VVgFpv, parent, newPath, symlink, symlinkTo)
  pType  = "deb" if self.VV0fbF else "ipk"
  pName  = self.VVZ0Yc
  outFile  = self.VVhqJT
  resFiles = [self.Path]
  cntrlFiles = [self.controlFile]
  for f in (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile):
   if FFf0vs(f):
    cntrlFiles.append(f)
  CCiFfa.VVxgmd(self, pType=pType, pName=pName, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, instPathInfo=instPathInfo, cbFnc=BF(self.VV0Mgz, obfVars, obfErr))
 def VV0Mgz(self, obfVars, obfErr):
  if obfVars:
   err = obfErr
   if not err:
    myP, obfP = obfVars
    if not FF6usE("mv -f '%splugin.py' '%s'" % (obfP, myP)): err = "Cannot restore plug"
    if not FF6usE("mv -f '%smain.py' '%s'" % (obfP, myP)): err = "Cannot restore main"
   if err:
    FFU9uk(self, err, title="OBF Error")
 def VVb2F2(self):
  myP  = VVL26S
  obfP = "%sOBF/" % VVL26S
  plug = "%splugin.py" % myP
  main = "%smain.py" % myP
  lst  = iGlob("%s*main_final.py" % obfP)
  obfVars = (myP, obfP)
  if not VVrRHR(obfP) : return obfVars, "No OBF Dir"
  if not len(lst) == 1 : return obfVars, "No OBF File"
  if not FFf0vs(plug) : return obfVars, "No plug File"
  if not FFf0vs(main) : return obfVars, "No main File"
  if not FF6usE("cp -f '%s' '%s' '%s'" % (plug, main, obfP)) : return obfVars, "Cannot copy to OBF"
  if not FF6usE("cp -f %s*main_final.py '%s'" % (obfP, plug)): return obfVars, "Cannot OBF to main"
  if not FF6usE("rm -f '%s'" % main)       : return obfVars, "Cannot del main"
  return obfVars, ""
class CCiFfa(Screen):
 def __init__(self, session, title="", pType="", pName="", outFile="", cntrlFiles="", resFiles=None, instPathInfo="", cbFnc=None):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1400, 900, 50, 30, 20, "#11302020", "#0a001010", 30)
  self.session   = session
  self.Title    = title or "Package Maker (%s)" % pName
  self.pType    = pType
  self.pName    = pName
  self.outFile   = outFile
  self.cntrlFiles   = cntrlFiles
  self.resFiles   = resFiles
  self.instPathInfo  = instPathInfo
  self.cbFnc    = cbFnc
  if pType == "deb": self.tarParam, self.tarExt = "-cJf", ".tar.xz"
  else    : self.tarParam, self.tarExt = "-czf", ".tar.gz"
  self.isTar    = pType == "tar"
  self.totalObj   = len(resFiles)
  self.VVUrKi = "packaging_result"
  self.tmpDir    = "/tmp/_%s/" % VVryLp
  self.dataDir   = self.tmpDir + "DATA/"
  self.controlDir   = self.tmpDir + "CONTROL/"
  self.debBinFile   = self.tmpDir + "debian-binary"
  self.controlFile  = self.tmpDir + "control" + self.tarExt
  self.resLstFile   = self.tmpDir + "resLst"
  self.allInRoot   = False
  self.VVgFpv  = ""
  FFfmZP(self, self.Title, addScrollLabel=True)
  FFyNtd(self, { "ok": self.VVqIgX })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VVUrKi=self.VVUrKi)
  self["myLabel"].appendText("Process started ...")
  FFDiNL(self.VVvLhv)
 def VVqIgX(self):
  pass
 def VV98tz(self, txt):
  self["myLabel"].appendText(txt + "\n")
 def VVd68C(self, txt="FAILED"):
  self.VV98tz(FFITtK("\n%s\n\nProcess Stopped !" % txt, VVcahY))
  self.VV9ppD()
 def VV9ppD(self):
  self.VVfGC0()
  if self.cbFnc:
   self.cbFnc()
 def VVfGC0(self, txt="FAILED"):
  FF6usE("rm -rf '%s'"  % self.tmpDir)
 def VVvLhv(self):
  self.VV98tz("Checking Resources ...")
  if self.totalObj > 1:
   self.resFiles, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = CCiFfa.VVcUk4(self.resFiles)
   txt = ".. Valid Resources List\t: %s\n" % len(self.resFiles)
   if errLst  : txt += ".. Invalid Files/Dirs\t: %s\n... %s\n" % (len(errLst), FFITtK("\n... ".join(errLst), VVgzFX, VVVAvR))
   if totDuplDir : txt += ".. Removed Duplicate Dirs\t: %s\n"  % totDuplDir
   if totDuplFil : txt += ".. Removed Duplicate File\t: %s\n"  % totDuplFil
   if mntLst  : txt += ".. Removed Mount Paths\t: %s\n"   % len(mntLst)
   if rmDirLst  : txt += ".. Ignored dirs (child listed)\t: %s" % len(rmDirLst)
   self.VV98tz(FFITtK(txt.rstrip("\n"), VVVAvR))
   if not self.resFiles:
    self.VVd68C("No valid resources")
    return
  elif self.totalObj == 1 and not FFf0vs(self.resFiles[0]):
   self.VVd68C("Invalid or unreachable file/dir:\n%s" % self.resFiles[0])
   return
  self.VVfGC0()
  FFqlCI(self.outFile)
  self.VV98tz("Creating working dirs ...")
  if not FF6usE("mkdir -p '%s'"  % self.tmpDir):
   self.VVd68C("Cannot create working dir.")
   return
  if not self.isTar:
   if not FF6usE("mkdir -p '%s'" % self.controlDir):
    self.VVd68C("Cannot create /tmp/ dir.")
    return
   if self.instPathInfo:
    VVgFpv, parent, newPath, symlink, symlinkTo = self.instPathInfo
    newPath  = self.dataDir + newPath
    symlink  = self.dataDir + symlink
    symlinkTo = symlinkTo
    self.allInRoot = VVgFpv == "/"
    self.VVgFpv = VVgFpv.rstrip("/")
    if not FF6usE("mkdir -p '%s'" % newPath):
     self.VVd68C("Cannot create full path.")
     return
    if not FF6usE("ln -sf '%s' '%s';" % (symlinkTo, symlink)):
     self.VVd68C("Cannot create resources link.")
     return
   self.VV98tz("Creating debian-binary file ...")
   if not FF6BfM("echo '2.0' > '%s'" % self.debBinFile):
    self.VVd68C("Cannot create bin file.")
    return
   lst = self.cntrlFiles
   for f in lst:
    if not FF6usE("cp -f '%s' '%s'" % (f, self.controlDir)):
     self.VVd68C("Cannot read file:\n%s" % f)
     return
    newF = os.path.join(self.controlDir, os.path.basename(f))
    FFxGSn(newF)
    if not FF6usE("chmod 755 '%s'" % newF):
     self.VVd68C("Cannot chmod file:\n%s" % newF)
     return
   self.VV98tz("Archiving control files ...")
   cmd  = "cd '%s';" % self.controlDir
   cmd += "tar %s '%s' ./*;" % (self.tarParam, self.controlFile)
   if not FF6usE(cmd):
    self.VVd68C("Cannot archive control files.")
    return
  self.VV98tz("Archiving data files ...")
  if self.totalObj > 1:
   self.resFiles.sort(key=lambda x: x[0].lower())
   with open(self.resLstFile, "w") as resF:
    for item in self.resFiles:
     item = item.lstrip("/")
     if item:
      resF.write("%s\n" % item)
  FFDiNL(self.VVph06)
 def VVph06(self):
  if self.isTar: dataFile = self.outFile
  else   : dataFile = self.tmpDir + "data" + self.tarExt
  tarExclude = "--exclude CONTROL --exclude DEBIAN --exclude __pycache__"
  if FFQC8W(self.pName, self.outFile):
   tarExclude += " --exclude OBF --exclude *.pyo --exclude *.pyc"
  if self.instPathInfo:
   self.tarParam = self.tarParam.replace("-c", "-ch")
   cmd = "cd '%s';" % self.dataDir
   if self.allInRoot:
    cmd += "tar -C '%s' %s %s '%s' ./" % (self.resFiles[0], tarExclude, self.tarParam, dataFile)
   else:
    cmd += "tar %s %s '%s' '.%s'" % (tarExclude, self.tarParam, dataFile, self.VVgFpv)
  else:
   if self.totalObj > 1:
    cmd = "tar -C / %s %s '%s' -T '%s'" % (tarExclude, self.tarParam, dataFile, self.resLstFile)
   elif self.totalObj == 1:
    cmd = "tar -C / %s %s '%s' '%s'" % (tarExclude, self.tarParam, dataFile, self.resFiles[0].lstrip("/"))
   else:
    cmd = ""
  if cmd:
   resp = FFunRV(cmd)
   if resp:
    self.VVd68C(FFITtK("\n".join(resp), VVu50a, VVcahY))
    return
  else:
   if not FF6usE("cp -f '%sdata%s' '%s'" % (VV30Jg, self.tarExt, self.tmpDir)):
    self.VVd68C("Cannot copy temporary data.%s" % self.tarExt)
    return
  if not self.isTar:
   self.VV98tz("Creating %s ..." % self.pType.upper())
   arResp = FFunRV("ar -r '%s' '%s' '%s' '%s';" % (self.outFile, self.debBinFile, self.controlFile, dataFile))
   if len(arResp) > 1 or not FFf0vs(self.outFile):
    self.VVd68C(FFITtK("\n".join(arResp), VVu50a, VVcahY))
    return
  self.VV9ppD()
  self.VV98tz("Done.\n\nResult:\n%s\n" % FFITtK(self.outFile, VV8QGw))
 @staticmethod
 def VVcUk4(lst):
  lines = list(map(str.strip, lst))
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst = [], [], [], [], [], []
  for item in lst:
   item = item.strip()
   if   os.path.ismount(item) : mntLst.append(item)
   elif os.path.isdir(item) : dirLst.append(FFA4GT(item))
   elif os.path.isfile(item) : filLst.append(item)
   else       : errLst.append(item)
  totDir = len(dirLst)
  dirLst = list(set(dirLst))
  totDuplDir = totDir - len(dirLst)
  totFil = len(filLst)
  filLst = list(set(filLst))
  totDuplFil = totFil - len(filLst)
  cleanLst.extend(list(set(filLst)))
  for tDir in dirLst:
   for fil in cleanLst:
    if fil.startswith(tDir):
     rmDirLst.append(tDir)
     break
   else:
    cleanLst.append(tDir)
  cleanLst.sort(key=lambda x: x.lower())
  return cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil
 @staticmethod
 def VVxgmd(SELF, **kwargs):
  if CCJFyo.VVwabH(SELF):
   SELF.session.open(CCiFfa, **kwargs)
class CCJFyo(Screen, CCNcvI):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 850, 900, 50, 40, 30, "#221a001a", "#22110011", 30)
  self.session   = session
  self.lastListAllRow  = -1
  self.lastRemoveAllRow = -1
  self.lastRemoveExtRow = -1
  self.lastPickedRow  = -1
  self.holdPkgColor  = "#f#00ff8800#"
  self.instPkgColor  = "#f#0000ff00#"
  CCNcvI.__init__(self)
  c1, c2, c3, c4 = VVnQYw, VVkLs0, VVCBkQ, VV6UAe
  VVXXzc = []
  VVXXzc.append((c1 + "Plugins Browser"        , "pluginsBrowser"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Download/Install Packages (from feeds)"  , "downloadInstallPackages" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Remove Packages (show all)"     , "VV0RnUsAll"  ))
  VVXXzc.append((c3 + "Remove Packages (Plugins/SoftCams/Skins)" , "removePluginSkinSoftCAM" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Update Packages List from Feeds"    , "VViLrr"  ))
  VVXXzc.append((c2 + "Upgradable Packages"       , "VV8mD7" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c4 + "Package Creator (ipk/deb/tar)"    , "packageCreator"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c4 + "Generate Packages.gz (from ipk/deb directory)", "VVh33b"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Packaging Tool"         , "VVNCLZ"   ))
  VVXXzc.append(("Active Feeds"          , "VVnwcY"   ))
  FFfmZP(self, title="Plugins Tools", VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "pluginsBrowser"    : CCF1F0.VVvLoF(self.session)
   elif item == "downloadInstallPackages"  : FFTSvN(self, BF(self.VVHZpt, 0))
   elif item == "VV0RnUsAll"   : FFTSvN(self, BF(self.VVHZpt, 1))
   elif item == "removePluginSkinSoftCAM"    : FFTSvN(self, BF(self.VVHZpt, 2))
   elif item == "VViLrr"   : CCJFyo.VViLrr(self)
   elif item == "VV8mD7"  : self.VV8mD7()
   elif item == "packageCreator"    : self.VVx9pc()
   elif item == "VVh33b"   : self.VVh33b()
   elif item == "VVNCLZ"    : self.VVNCLZ()
   elif item == "VVnwcY"    : self.VVnwcY()
   else          : self.close()
 @FFHF2S()
 def VVnwcY(self):
  VVJwgn = []
  totAll = 0
  for path in CCJFyo.VVpH53():
   tot = 0
   with open(path, "r") as f:
    for line in f:
     if line.startswith("Package"):
      tot += 1
      totAll += 1
   if tot:
    VVJwgn.append((os.path.basename(path), str(tot)))
  if VVJwgn:
   VVcIOx = "Total Packages = %s" % totAll
   VVJwgn.sort(key=lambda x: x[0].lower())
   header  = ("Feed","Packages")
   widths  = (82  , 18  )
   VVgKQc = (LEFT  , CENTER )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1000, VV1Wwb=26, VVcIOx=VVcIOx, VV4HrS=2)
  else:
   self.VVqeTb("Cannot read packages list !")
 def VV8mD7(self, VV5ybN=None):
  FFTSvN(VV5ybN or self, BF(self.VVzgYW, VV5ybN))
 def VVzgYW(self, VV5ybN):
  fLst, feedDic, instDic = self.VVNGBS()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if CCJFyo.VVHtSt(ver, ver1) < 0:
     if hold : hold, c1 = "Yes", self.holdPkgColor
     else : hold = c1 = ""
     lst.add((c1 + pkg, c1 + ver, c1 + ver1, c1 + hold))
  if lst:
   VVJwgn = list(lst)
   VVJwgn.sort(key=lambda x: FF2xYM(x[0]).lower())
   if VV5ybN:
    VV5ybN.VVxhz9(VVJwgn, isSort=False)
   else:
    bg = "#20110011"
    VV5CrJ = ("Upgrade"  , self.VV9Hag   , [])
    VVbQ6N = ("Package Info." , self.VVPKqo    , [])
    VVvrJb = ("Hold Update" , self.VVQugx , [])
    header  = ("Package", "Current Version" , "New Version" , "Hold Upd." )
    widths  = ( 40  , 25    , 25   , 10   )
    VVgKQc = ( LEFT , LEFT    , LEFT   , CENTER  )
    tbl = FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1700, VV1Wwb=26, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindPackages, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00114455")
    tbl.VVIl4g(BF(self.VVX2qs, tbl))
  else:
   FFk1YE(self, "Nothing to upgrade", 1500)
   if VV5ybN: VV5ybN.cancel()
 def VV9Hag(self, VV5ybN, title, txt, colList):
  pkg, curV, newVer, holdState = VV5ybN.VVqY3Q()
  if holdState:
   FF8PJn(VV5ybN, "Change Hold State first", 1000)
  else:
   cmd = FFiD2M(VVUWS4, pkg)
   FFNQkI(self, cmd, title="Installing : %s" % pkg, VVUYyP=BF(self.VV8mD7, VV5ybN))
 @FFHF2S(par=1)
 def VVQugx(self, VV5ybN, title, txt, colList):
  pkg, curV, newVer, holdState = VV5ybN.VVqY3Q()
  cmd = FFiD2M(VVeaGm if holdState else VVsKJh, pkg)
  FF6usE(cmd)
  holdLst = self.VV0Yp8(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VV5ybN.VVULq3((c1 + pkg, c1 + curV, c1 + newVer, c1 + holdState))
  self.VVX2qs(VV5ybN)
 def VVX2qs(self, VV5ybN):
  pkg, curV, newVer, holdState = VV5ybN.VVqY3Q()
  VV5ybN["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 def VVh33b(self):
  if CCJFyo.VVwabH(self):
   self.session.openWithCallback(self.VVxmEU, BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=CFG.lastFeedPkgsDir.getValue()))
 @FFHF2S()
 def VVxmEU(self, path):
  title = "Feed Packages.gz Creator"
  if len(path) > 0:
   FFDDwF(CFG.lastFeedPkgsDir, path)
   files = []
   lst = iGlob(path + "*.ipk")
   totIpk = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = iGlob(path + "*.deb")
   totDeb = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = None
   if len(files) > 0:
    files.sort(key=lambda x: x[0].lower())
   else:
    FFU9uk(self, "No ipk/deb files found in:\n\n%s" % path)
    return
   pFile = os.path.join(path, "Packages")
   gFile = "%s.gz" % pFile
   tFile = os.path.join(path, "Packages.stamps")
   with open(pFile, "w") as pF:
    with open(tFile, "w") as tF:
     for fName in files:
      fPath = os.path.join(path, fName)
      txt, mTime = CCJFyo.VVRvXn(fPath)
      pF.write("%s\n" % txt)
      tF.write("%s\n" % mTime)
   FFqlCI(gFile)
   os.system("gzip -k '%s'" % pFile)
   c = VVnQYw
   txt  = "%s: %s\n" % (FFITtK("Processed Files:", c), len(files))
   txt += "  ipk   : %s\n" % totIpk
   txt += "  deb  : %s\n" % totDeb
   txt += "\n%s\n" % FFITtK("Output Files:", c)
   txt += "  %s\n" % pFile
   txt += "  %s\n" % gFile
   txt += "  %s" % tFile
   FFyijw(self, txt)
 def VVNCLZ(self):
  pkg = FFpr6N()
  aptT = "apt - Advanced Package Tool" if FFsGnd("apt") else ""
  txt = {"ipkg": "Itsy", "opkg": "Open", "dpkg": "Debian"}.get(pkg, "")
  txt = "%s - %s Package Management System" % (pkg, txt) if txt else ""
  txt += "%s%s" % ("\n\nand\n\n" if txt and aptT else "", aptT)
  FFSQn9(self, txt or "No packaging tools found!")
 def VVHZpt(self, mode, Filter="", VV5ybN=None):
  fdPath = Filter[5:] if Filter.startswith("feed=") else ""
  fLst, feedDic, instDic = self.VVNGBS(fdPath)
  if fdPath and not feedDic:
   FFk1YE(VV5ybN, "No packages !", 1200)
   return
  if mode == 0: dic = feedDic.copy()
  else  : dic = instDic.copy()
  feedDic = instDic = None
  if mode == 2:
   words = ("extensions", "systemplugins", "softcams", "skin")
   for pkg in list(dic):
    if not pkg.startswith("enigma2-plugin-") and not any(x in pkg for x in words):
     del dic[pkg]
  if mode == 0 and Filter and not fdPath:
   word = Filter.lower()
   if word.endswith("s"): word = word[:-1]
   for pkg in list(dic):
    if not word in pkg:
     del dic[pkg]
   if not dic:
    FFk1YE(VV5ybN, "Not found", 1500)
    return
  VV5dDF = []
  for pkg, (ver, dsc, inst, hold) in dic.items():
   holdT = instT = c1 = ""
   if   hold    : c1, holdT = self.holdPkgColor, "Yes"
   elif inst and mode == 0 : c1, instT = self.instPkgColor, "Yes"
   VV5dDF.append((c1+ pkg, c1 + ver, c1 + dsc, c1 + instT, c1 + holdT))
  if VV5dDF:
   VV5dDF.sort(key=lambda x: FF2xYM(x[0]).lower())
  else:
   FFU9uk(self, "No packages found!")
   return
  if mode == 0:
   c1 = VVkLs0
   if Filter and not Filter == "All":
    if fdPath: title = "Feed = %s" % os.path.basename(fdPath)
    else  : title = "Filter = %s" % Filter
    title = "Download/Install ... %s" % FFITtK(title, c1)
   else:
    title = FFITtK("Download/Install Packages (from feeds)", c1)
  if VV5ybN:
   VV5ybN.VVxhz9(VV5dDF, title, VVMbPmMsg=False, isSort=False)
   self.VVPYEK(mode, VV5ybN)
  else:
   if mode == 0:
    VVuyvr = self.lastListAllRow
    VVLj1d = self.VVtrPV
    VVEyDE = ("Install" , self.VVJNwL     , [])
    VV5CrJ = ("Download" , self.VVqre7     , [])
    VVvrJb = ("Filter"  , BF(self.VVMM8t, fLst) , [])
    width = 1800
    widths = (43, 18, 32, 7, 0)
   else:
    if mode == 1:
     VVuyvr  = self.lastRemoveAllRow
     VVLj1d = self.VViHz0
    else:
     VVuyvr  = self.lastRemoveExtRow
     VVLj1d = self.VVwQZp
    VVEyDE = ("Uninstall" , self.VV0RnU        , [])
    VV5CrJ = None
    VVvrJb = ("Hold Update", BF(self.VVWeBN, mode), [])
    width = 1550
    widths = (55, 35, 0, 0, 10)
   bg = "#11191111"
   VVbQ6N = ("Package Info." , self.VVPKqo  , [])
   header   = ("Package", "Version" , "Description" , "Inst." , "Hold Upd." )
   VVgKQc  = (LEFT  , LEFT  , LEFT   , CENTER , CENTER  )
   tbl = FFdCaM(self, None, header=header, VV5dDF=VV5dDF, VV1PTZ=widths, VVgKQc=VVgKQc, width=width, height=1000, VV1Wwb=26, VVLj1d=VVLj1d, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVuyvr=VVuyvr, VV7VIQ=CFG.lastFindPackages
      , VVVzvS="#22110011", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00004444", VVcv6F="#00333333")
   if mode != 0:
    tbl.VVIl4g(BF(self.VVPYEK, mode, tbl))
 def VVMM8t(self, fLst, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("All Packages", "All"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Feed ...", "fdPath"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("enigma2-plugin-extensions" , "enigma2-plugin-extensions" ))
  VVXXzc.append(("enigma2-plugin-systemplugins" , "enigma2-plugin-systemplugins"))
  VVXXzc.append(VVzg1X)
  for word in ("Alsa", "Dream", "Drivers", "Enigma", "Extensions", "Feeds", "Firmware", "Fonts", "GLibc", "GStreamer", "Kernel", "Lib", "Linux", "Locale", "Modules", "Network", "Octagon", "PIcons", "Perl", "Pkg", "Plugin", "Python", "Samba", "Settings", "Skin", "SoftCam", "SystemPlugins", "Tools", "Util", "Zip"):
   VVXXzc.append((word, word))
  FFw2XU(self, BF(self.VVMach, fLst, VV5ybN), VVXXzc=VVXXzc, title="Select Filter")
 def VVMach(self, fLst, VV5ybN, item=None):
  if item:
   def VVjJzY(txt):
    if txt: FFTSvN(VV5ybN, BF(self.VVHZpt, 0, Filter=txt, VV5ybN=VV5ybN), title="Filtering ...")
   if item == "fdPath":
    lst = [(os.path.basename(f), "feed=%s" % f) for f in fLst]
    if lst : FFw2XU(self, VVjJzY, VVXXzc=lst, title="Select Feed")
    else : FF8PJn(VV5ybN, "Not feed list", 2000)
   else:
    VVjJzY(item)
 def VVNGBS(self, fdPath=""):
  fLst, feedDic = CCJFyo.VVSkKg(fdPath)
  instDic = CCJFyo.VVdjd4()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if not dsc:
    if pkg in feedDic: newDsc = feedDic[pkg][1]
    else    : newDsc = self.VV9Ina(pkg)
    if newDsc:
     instDic[pkg] = (ver, newDsc, inst, hold)
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if ver == ver1:
     feedDic[pkg] = (ver1, dsc1, inst, hold)
  return fLst, feedDic, instDic
 @staticmethod
 def VVSkKg(fdPath):
  if fdPath: fLst = [fdPath]
  else  : fLst = CCJFyo.VVpH53()
  return fLst, CCJFyo.VVquA8(fLst)
 @staticmethod
 def VVdjd4():
  fLst = [CCJFyo.VVEv5i()]
  return CCJFyo.VVquA8(fLst)
 def VV0Yp8(self, toFind=""):
  dic = CCJFyo.VVdjd4()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in dic.items():
   if hold:
    if toFind:
     if pkg == toFind:
      return [(pkg, ver)]
    else:
     lst.add((pkg, ver))
  return lst
 @staticmethod
 def VVquA8(fLst):
  dic = {}
  tab = lambda line: line.partition(":")[2].strip()
  for path in fLst:
   try:
    with open(path, "r") as f:
     pkg = ver = dsc = sta = ""
     for line in f:
      if ":" in line:
       line = line.strip()
       if   line.startswith("Package")  : pkg = tab(line)
       elif line.startswith("Version")  : ver = tab(line)
       elif line.startswith("Status")   : sta = tab(line)
       elif line.startswith("Description") : dsc = tab(line)
      elif iMatch(r"^\s+\S", line):
       dsc = " - ".join((dsc, line.strip()))
      elif not line.strip():
       staL = sta.lower()
       hold = "hold" in staL
       inst = "installed" in staL and not "not-installed" in staL
       if pkg: dic[pkg] = (ver, dsc, inst, hold)
       pkg = ver = dsc = sta = ""
   except:
    pass
  return dic
 @staticmethod
 def VVpH53():
  dirs = set()
  span = iSearch(r"option\s+lists_dir\s+(\/.+\/.+)", FF05rJ("/etc/opkg/opkg.conf"))
  if span and VVrRHR(span.group(1)): dirs.add(span.group(1))
  for s in ("apt", "opkg", "ipkg"):
   path = "/var/lib/%s/lists" % s
   if VVrRHR(path): dirs.add(path)
  files = []
  for d in dirs: files.extend(iGlob(FFA4GT(d) + "*"))
  files = [f for f in files if os.path.isfile(f) and not f.endswith("/status")]
  files.sort()
  return files
 @staticmethod
 def VVEv5i():
  for p in ("lib", "lib64"):
   p = "/var/%s/dpkg/status" % p
   if FFf0vs(p):
    return p
  span = iSearch(r"option\s+status_file\s+(\/.+\/.+)", FF05rJ("/etc/opkg/opkg.conf"))
  if span and VVrRHR(span.group(1)):
   return span.group(1)
  else:
   for s in ("opkg", "ipkg"):
    path = "/var/lib/%s/status" % s
    if FFf0vs(path):
     return path
  return ""
 def VV9Ina(self, pkg):
  dsc = ""
  for s in ("opkg", "ipkg"):
   fil = "/var/lib/%s/info/%s.control" % (s, pkg)
   if FFf0vs(fil):
    for line in FF2iRW(fil):
     if ":" in line:
      line = line.strip()
      if   line.startswith("Description") : dsc = line.partition(":")[2].strip()
      elif line and line.startswith(" ") : dsc += " - " + line.strip()
  return dsc
 def VVtrPV(self, VV5ybN):
  self.lastListAllRow = VV5ybN.VVfkJL()
  VV5ybN.cancel()
 def VViHz0(self, VV5ybN):
  self.lastRemoveAllRow = VV5ybN.VVfkJL()
  VV5ybN.cancel()
 def VVwQZp(self, VV5ybN):
  self.lastRemoveExtRow = VV5ybN.VVfkJL()
  VV5ybN.cancel()
 def VV0Ykl(self, VV5ybN):
  self.lastPickedRow  = VV5ybN.VVfkJL()
  VV5ybN.cancel()
 @FFHF2S(par=2)
 def VVWeBN(self, mode, VV5ybN, title, txt, colList):
  pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
  cmd = FFiD2M(VVeaGm if holdState else VVsKJh, pkg)
  FF6usE(cmd)
  holdLst = self.VV0Yp8(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VV5ybN.VVULq3((c1 + pkg, c1 + ver, c1 + desc, c1 + inst, c1 + holdState))
  self.VVPYEK(mode, VV5ybN)
 def VVPYEK(self, mode, VV5ybN):
  if mode in (1, 2):
   pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
   VV5ybN["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 @FFHF2S(par=1)
 def VVr1Vs(self, VV09ay, grnTxt, grnFnc):
  instDic = CCJFyo.VVdjd4()
  VV5dDF = [(pkg, ver) for pkg, (ver, dsc, inst, hold) in instDic.items()]
  if not VV5dDF:
   self.VVqeTb("Cannot read installed packages !")
   return
  VV5dDF.sort(key=lambda x: x[0].lower())
  VVLj1d = self.VV0Ykl
  VV5CrJ = (grnTxt   , grnFnc     , [])
  VVbQ6N = ("Package Info." , self.VVPKqo , [])
  header = ("Package", "Version" )
  widths = (65  , 35  )
  FFdCaM(self, None, title=grnTxt, header=header, VV5dDF=VV5dDF, VV1PTZ=widths, VV1Wwb=30, VVLj1d=VVLj1d, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVuyvr=self.lastPickedRow, VV7VIQ=CFG.lastFindPackages
    , VVVzvS="#22110011", VVhHWW="#22191111", VVpaQ6="#22191111", VVI4UA="#00003030", VVcv6F="#00333333")
 def VVPKqo(self, VV5ybN, title, txt, colList):
  FFTSvN(VV5ybN, BF(CCJFyo.VVeFdT, self, colList[0]))
 def VV0RnU(self, VV5ybN, title, txt, colList):
  pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
  if holdState: FF8PJn(VV5ybN, "Change Hold State first", 1000)
  else  : self.VVoiOH(VV5ybN)
 def VVoiOH(self, VV5ybN):
  VVXXzc = []
  VVXXzc.append(("Remove Package"        , "remove_ExistingPackage" ))
  VVXXzc.append(("Remove Package (force remove)"    , "remove_ForceRemove"  ))
  VVXXzc.append(("Remove Package (ignore failed dependencies)" , "remove_IgnoreDepends" ))
  FFw2XU(self, BF(self.VV6MkL, VV5ybN)  , VVXXzc=VVXXzc)
 def VV6MkL(self, VV5ybN, item):
  if item:
   pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
   if   item == "remove_ExistingPackage" : cmdOpt = VVfSvc
   elif item == "remove_ForceRemove"  : cmdOpt = VVpt2P
   elif item == "remove_IgnoreDepends"  : cmdOpt = VVcXNB
   FFHsPu(self, BF(self.VVXxZg, VV5ybN, cmdOpt, pkg), "Remove Package ?\n\n%s" % pkg)
 def VVXxZg(self, VV5ybN, cmdOpt, pkg):
  cmd = FFiD2M(cmdOpt, pkg)
  if cmd : FFNQkI(self, cmd, VVUYyP=BF(self.VVVkUP, VV5ybN, pkg))
  else : FFD8hf(self)
 def VVVkUP(self, VV5ybN, pkg):
  if not CCJFyo.VV36XM(pkg):
   VV5ybN.VVE3Oz()
   if VV5ybN.VVJPu5() == 0:
    VV5ybN.cancel()
  FFq7xa()
 def VVJNwL(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("Install Package"        , "install_CheckVersion" ))
  VVXXzc.append(("Install Package (force reinstall)"   , "install_ForceReinstall" ))
  VVXXzc.append(("Install Package (force overwrite)"   , "install_ForceOverwrite" ))
  VVXXzc.append(("Install Package (force downgrade)"   , "install_ForceDowngrade" ))
  VVXXzc.append(("Install Package (ignore failed dependencies)" , "install_IgnoreDepends" ))
  FFw2XU(self, BF(self.VVRRSx, VV5ybN), VVXXzc=VVXXzc)
 def VVRRSx(self, VV5ybN, item):
  if item:
   pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
   if   item == "install_CheckVersion"  : cmdOpt = VVUWS4
   elif item == "install_ForceReinstall" : cmdOpt = VVV8Uu
   elif item == "install_ForceOverwrite" : cmdOpt = VVEY1Y
   elif item == "install_ForceDowngrade" : cmdOpt = VV6Aie
   elif item == "install_IgnoreDepends" : cmdOpt = VVWy79
   FFHsPu(self, BF(self.VVos8L, pkg, VV5ybN, cmdOpt), "Install Package ?\n\n%s" % pkg)
 def VVos8L(self, pkg, VV5ybN, cmdOpt):
  cmd = FFiD2M(cmdOpt, pkg)
  if cmd : FFNQkI(self, cmd, VVUYyP=BF(self.VV2FHi, pkg, VV5ybN), VVTHJE=True)
  else : FFD8hf(self)
 def VV2FHi(self, pkg, VV5ybN):
  FFq7xa()
  if CCJFyo.VV36XM(pkg):
   c1 = self.instPkgColor
   pkg, ver, desc, inst, holdState = VV5ybN.VVqY3Q()
   row = (c1 + pkg.strip(), c1 + ver.strip(), c1 + desc.strip(), c1 + "Yes", c1 + holdState)
   VV5ybN.VVULq3(row)
 def VVqre7(self, VV5ybN, title, txt, colList):
  pkg = colList[0]
  FFHsPu(self, BF(self.VVzG2V, pkg), "Download Package ?\n\n%s" % pkg)
 def VVzG2V(self, pkg):
  if CChg05.VVIg8w():
   iCmd = FFiD2M(VV2z4R, pkg)
   dCmd = FFiD2M(VVEEmk, pkg)
   dest = FFJOWV()
   if iCmd and dCmd:
    cTxt = lambda x, fg: " echo -e '\n%s' %s;" % (x, FF0VVA(x, fg))
    cmd  = "echo -e 'Downloading : %s';" % pkg
    cmd += "FILE1=$(%s '%s' | grep Filename | awk '{print $2}');" % (iCmd, pkg)
    cmd += 'if [ -z "$FILE1" ]; then'
    cmd += " echo -e '\nPackage : %s\n';" % pkg
    cmd += " echo -e $FILE1"
    cmd +=    cTxt("Not available on feed (update packages list and try again.)", VVsm0W)
    cmd += "else"
    cmd += " cd '%s';" % dest
    cmd +=   FFDTPf(' rm -f "$FILE1"')
    cmd += " %s;" % dCmd
    cmd += ' if [ -f "%s$FILE1" ]; then' % dest
    cmd +=    cTxt("Downloaded to:", VV8QGw)
    cmd += '  echo "%s$FILE1";' % dest
    cmd += ' fi;'
    cmd += 'fi;'
    FFpL0U(self, cmd, VVo6GU=[VVsm0W, "error:", "collected errors:", "failed", "not found"], VVTHJE=True)
   else:
    FFD8hf(self)
  else:
   FFU9uk(self, "No internet connection !")
 @staticmethod
 def VViLrr(SELF):
  cmd = FFKA8e(VVtAyn)
  if cmd : FFNQkI(SELF, cmd, VVTHJE=True, title="Available Packages List Upadate")
  else : FFD8hf(SELF)
 @staticmethod
 def VVY854(path):
  pkg = err = ""
  if VVrRHR(path):
   for line in FFunRV(FFiD2M(VV6GVy, "*%s*" % path)):
    span = iSearch(r"(.+) - |(.+):", line)
    if span:
     pkg = span.group(1) or span.group(2)
     break
   if not pkg:
    err = "No package info !"
  else:
   err = "Path not found !"
  return pkg, err
 @staticmethod
 def VVeFdT(SELF, package, title=""):
  title = title or package
  fileExt = ""
  txt = instTime = ""
  c1 = VVUPyu
  info1 = []
  info2 = []
  infoCmd = FFiD2M(VV2z4R, package)
  if not infoCmd:
   FFD8hf(SELF, title=title)
   return
  info0 = FFunRV(infoCmd, trim=False)
  if package.startswith("/") and info0:
   title = os.path.basename(package)
   info1 = info0
   for line in info0:
    line = line.strip()
    fld, _, val = line.partition(":")
    if fld == "Package" and val:
     fileExt = os.path.splitext(package)[1].strip(".").upper()
     package = val.strip()
     if CCJFyo.VV36XM(package):
      info2 = FFunRV(FFiD2M(VV2z4R, package), trim=False)
     break
  else:
   info2 = info0
  if info1:
   txt += FFiN5A("%s File Info" % (fileExt or "Package"), c1)
   txt += CCJFyo.VVFz1F(info1)[2] + "\n"
  if info2:
   txt1, txt2, txt3, instTime = CCJFyo.VVFz1F(info2)
   if txt1 and txt2:
    txt += FFiN5A("Package Version", c1)
    txt += txt1 + "\n"
    txt += FFiN5A("Installed Version", c1) + "\n"
    txt += txt2 + "\n"
   else:
    txt += FFiN5A("System Info", c1)
    txt += txt3 + "\n"
  if not info1 and not info2:
   txt += FFiN5A("Package Info", c1)
   txt += "No package information !\n\n"
  isInst = CCJFyo.VV36XM(package)
  txt += FFiN5A("Package State", c1)
  txt += "  %s" % (FFITtK("Installed", VVnQYw) if isInst else FFITtK("Not Installed", VVcahY))
  txt += "\t%s\n\n" % instTime
  if isInst:
   files = FFunRV(FFiD2M(VVWBay, package) + " | grep -e '^/'")
   files.sort()
   txt += FFiN5A("Resources", c1)
   if files: txt += "\n".join(files)
   else : txt += "  None"
  FFyijw(SELF, txt, title=title, width=1700, height=1000, VV1Wwb=28, VVNYa4=30, titleBg="#11000022", VVpaQ6="#11000a11", VVUrKi=package)
 @staticmethod
 def VVFz1F(info):
  instTime = lastFld  = ""
  pkgCount = 0
  lines1 = []
  lines2 = []
  lines = lines1
  color = VV6UAe
  for line in info:
   fld, sep, val = line.partition(":")
   if sep:
    fld, val = fld.strip(), val.strip()
    if fld == "Package":
     pkgCount += 1
     if pkgCount > 1:
      lines = lines2
      color = VVnQYw
    elif fld == "Installed-Time":
     tm = val.strip()
     if tm.isdigit():
      instTime = FFMYsv(float(tm), wDay=True)
    lastFld = fld
   else:
    if lastFld == "Conffiles":
     val = fld.strip()
     Len = len(lines)
     last = Len - 1
     if Len > 0 and lines[last] == (lines[last][0], ""):
      lines[last] = (lines[last][0], val)
      continue
    else:
     val = fld
    fld = ""
   fld = fld.strip()
   if fld or val.strip():
    if fld: fld = FFITtK(fld, color)
    lines.append((fld, val))
  txt1 = ""
  for fld, val in lines1:
   txt1 += "%s\t: %s\n" % (fld, val)
  txt2 = ""
  for fld, val in lines2:
   txt2 += "%s\t: %s\n" % (fld, val)
  txt3 = txt1
  if txt2:
   txt3 += "\n%s\n" % SEP + txt2
  return txt1, txt2, txt3, instTime
 @staticmethod
 def VVmOIe():
  return FF6usE("if [[ \"$(ar -V 2> /dev/null | grep 'GNU ar')\" ]]; then exit 0; else exit 1; fi")
 @staticmethod
 def VV36XM(pkg):
  instDic = CCJFyo.VVdjd4()
  return pkg in instDic
 @staticmethod
 def VVwabH(SELF):
  if not CCJFyo.VVmOIe():
   FFHsPu(SELF, BF(FFNQkI, SELF, FFkDck(), title="Installing 'ar'"), "'ar' package is required.\n\nInstall ?")
   return False
  else:
   pFound, pBBox = FFzyl2("xz")
   if not pFound   : title, ques = "Install 'xz'", "'xz' package is required.\n\nInstall ?"
   elif pFound and pBBox : title, ques = "Upgrade 'xz'", "Found BusyBox xz. A higher version is required.\n\nUpgrade ?"
   else     : return True
   FFHsPu(SELF, BF(FFNQkI, SELF, FFlMQJ(), title=title), ques, title=title)
   return False
 @staticmethod
 def VVRvXn(path):
  txt = mTime = ""
  if FFf0vs(path):
   fName = os.path.basename(path)
   isDeb = os.path.splitext(fName)[1] == ".deb"
   if isDeb: ext, tarP = "xz", "J"
   else : ext, tarP = "gz", "z"
   txt += FFdV6p("ar -p '%s' control.tar.%s | tar %sxO ./control" % (path, ext, tarP))
   txt += "\n"
   txt += "Size: %s\n" % FFX42v(path)
   txt += "Filename: %s\n" % fName
   txt += "MD5sum: %s\n" % FFhWCj("md5sum '%s' | cut -b-32" % path)
   txt += "SHA256sum: %s\n" % FFhWCj("sha256sum '%s' | cut -b-64"  % path)
   mTime = "%s %s" % (FFhWCj("stat -c%%Y '%s'" % path), fName)
  return txt, mTime
 @staticmethod
 def VVHtSt(ver1, ver2):
  def VVjJzY(x):
   if   x == '~' : return -1
   elif x.isdigit(): return 0
   elif not x  : return 0
   elif x.isalpha(): return ord(x)
   else   : return ord(x) + 256
  def VV6ezJ(val, ref):
   while val or ref:
    first_diff = 0
    while (val and not val[0].isdigit()) or (ref and not ref[0].isdigit()):
     vc = VVjJzY(val[0]) if val else 0
     rc = VVjJzY(ref[0]) if ref else 0
     if vc != rc:
      return vc - rc
     val = val[1:]
     ref = ref[1:]
    val = val.lstrip('0')
    ref = ref.lstrip('0')
    while val and ref and val[0].isdigit() and ref[0].isdigit():
     if not first_diff:
      first_diff = ord(val[0]) - ord(ref[0])
     val = val[1:]
     ref = ref[1:]
    if val and val[0].isdigit() : return 1
    if ref and ref[0].isdigit() : return -1
    if first_diff    : return first_diff
   return 0
  return VV6ezJ(ver1, ver2)
 @staticmethod
 def VVhhmr(curVer, webVer):
  webVer = webVer.strip().replace("version=", "")
  tab = lambda x: iSub(r"[^\d\.]", "", x.replace("_", "."))
  cur, web = tab(curVer), tab(webVer)
  upd = CCJFyo.VVHtSt(cur, web) < 0
  return curVer.replace("v", ""), webVer, upd
class CCYl55():
 def VVgxjc(self, isRef, onlyEpg=False):
  self.shareIsRef   = isRef
  self.onlyEpg   = onlyEpg
  self.shareFilePrefix = "ajpanel_share_%s_" % ("ref" if self.shareIsRef else "data")
  self.shareFilePath  = ""
  FFgqIf()
  self.VV9o9A()
 def VV9o9A(self):
  files = FFYjQm(FFW675(), self.shareFilePrefix + "*.xml")
  if files:
   files.sort()
   VVXXzc = []
   for fil in files:
    VVXXzc.append((os.path.basename(fil), fil))
   if self.shareIsRef : VVVzvS, VVhHWW = "#22221133", "#22221133"
   else    : VVVzvS, VVhHWW = "#22003344", "#22002233"
   VVBztL  = ("Add new File", self.VVVAnE)
   FFw2XU(self, self.VVox61, VVXXzc=VVXXzc, width=1100, VVBztL=VVBztL, VVhuPZ="", VVnojT=4, VVVzvS=VVVzvS, VVhHWW=VVhHWW)
  else:
   FFHsPu(self, self.VVs8wl, "No files found.\n\nCreate a new file ?")
 def VVs8wl(self):
  path = self.VVrrMM()
  if FFf0vs(path) : self.VV9o9A()
  else    : FF8PJn(self, "Cannot create file", 1500)
 def VVVAnE(self, VVZzW8, path):
  path = self.VVrrMM()
  VVZzW8.VVgjzO((os.path.basename(path), path), isSort=True)
 def VVrrMM(self):
  path = "%s%s%s.xml" % (FFW675(), self.shareFilePrefix, FF6eWd())
  with open(path, "w") as f:
   f.write('<?xml version="1.0" encoding="utf-8"?>\n<share>\n\n\t<ch>\n\t\t<name1>Channel-1</name1>  <ref1>5001:0:1:22:22:22:22:0:0:0</ref1>\n\t\t<name2>Channel-2</name2>  <ref2>4097:0:1:22:22:22:22:0:0:0</ref2>\n\t</ch>\n\n</share>')
  return path
 @FFHF2S()
 def VVox61(self, path=None):
  if not path: return
  if not FFf0vs(path):
   FFbHk5(self, path)
   return
  elif not CCQdsv.VVz66T(self, path, FFQfhO()):
   return
  else:
   self.shareFilePath = path
  if not CC6pkA.VV9n4c(self):
   return
  tree = CCAnLc.VVgNVP(self, self.shareFilePath)
  if not tree:
   return
  refLst = CC41Tt.VVH0nc()
  def VVEQGt(VVDhju):
   if   FFPNoO(VVDhju): return FFITtK("DVB", VVnQYw)
   elif VVDhju in refLst     : return FFITtK("IPTV", VVnQYw)
   else         : return ""
  VVJwgn= []
  errColor= "#f#00ffaa55#"
  num  = 1
  dupl = 0
  for ch in tree.getroot():
   ok, srcName, srcRef, dstName, dstRef = self.VV0o0L(ch)
   if ok:
    srcTxt = VVEQGt(srcRef)
    dstTxt = VVEQGt(dstRef)
    srcName, dstName = srcName.strip(), dstName.strip()
    skip = False
    for num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1 in VVJwgn:
     if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
      dupl += 1
      break
    else:
     if  srcRef == dstRef : remark, c1, c2 = "4", errColor, errColor
     elif srcTxt and dstTxt : remark, c1, c2 = "0", ""  , ""
     elif dstTxt    : remark, c1, c2 = "1", errColor, ""
     elif srcTxt    : remark, c1, c2 = "2", ""  , errColor
     else     : remark, c1, c2 = "3", errColor, errColor
     c3 = "#f#0000ff00#" if remark == "0" else errColor
     VVJwgn.append((c3 + str(num), c1 + srcName, c1 + srcRef, c1 + srcTxt, c2 + dstName, c2 + dstRef, c2 + dstTxt, remark))
     num += 1
  refLst = None
  if VVJwgn:
   if self.shareIsRef : VVVzvS, VVhHWW, optTxt = "#1a221133", "#1a221133", "Share Reference"
   else    : VVVzvS, VVhHWW, optTxt = "#1a003344", "#1a002233", "Copy EPG" if self.onlyEpg else "Copy EPG/PIcons"
   VVsB8G = (""    , BF(self.VV81I1, dupl) , [])
   VV4dTm = (""    , self.VVthGb    , [])
   VVEyDE = ("Delete Entry" , self.VVN9qp   , [])
   VV5CrJ = ("Add Entry"  , self.VVDt7v , [])
   VVbQ6N = (optTxt   , self.VVtPvK  , [])
   header  = ("Num" , "Source" , "Source Ref." ,"Type" , "Destination" , "Dest. Ref." , "Type", "Remark" )
   widths  = (8  , 25  , 15   , 6  , 25   , 15   , 6  , 0   )
   VVgKQc = (CENTER , LEFT  , LEFT   ,CENTER , LEFT   , LEFT   , CENTER, CENTER )
   VV5ybN = FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=24, VVsB8G=VVsB8G, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVrpeX=True, VVylFd=1, VV7VIQ=CFG.lastFindServices
         , VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVhHWW, VVI4UA="#0a000000")
  else:
   FFU9uk(self, "No valid sharing data found in:\n\n%s" % self.shareFilePath)
 def VV81I1(self, dupl, VV5ybN, title, txt, colList):
  if dupl:
   VV5ybN.VVjSys("Skipped %d duplicate%s" % (dupl, FFEnJs(dupl)), 2000)
 def VVthGb(self, VV5ybN, title, txt, colList):
  def VVEQGt(key, val): return "%s\t: %s\n" % (key, val or FFITtK("?", VVu50a))
  Keys = VV5ybN.VVBMP2()
  Vals = VV5ybN.VVqY3Q()
  txt = ""
  for i in range(len(Keys) - 1):
   txt += VVEQGt(Keys[i], Vals[i])
   if i in (0, 3, 6):
    txt += "\n"
  remark = colList[7]
  txt1 = "Remarks\t: "
  c1, c2 = VV8QGw, VVu50a
  if   remark == "0": txt1 += c1 + "Valid"
  elif remark == "1": txt1 += c2 + "Source channel is not in system"
  elif remark == "2": txt1 += c2 + "Destination channel is not in system"
  elif remark == "3": txt1 += c2 + "Both channels are not in system"
  elif remark == "4": txt1 += c2 + "Both channels have same Reference"
  FFyijw(self, txt + txt1, title=title)
 def VV0o0L(self, chElem):
  srcName = chElem.find("name1")
  srcRef  = chElem.find("ref1")
  dstName = chElem.find("name2")
  dstRef  = chElem.find("ref2")
  patt = r"((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))"
  if srcName is not None and srcRef is not None and dstName is not None and dstRef is not None:
   lst = [srcName.text or "", srcRef.text or "", dstName.text or "", dstRef.text or ""]
   for i, text in enumerate(lst):
    lst[i] = str(text.encode("UTF-8").decode())
   srcName, srcRef, dstName, dstRef = lst
   span = iSearch(patt, srcRef)
   if span:
    srcRef = span.group(1).upper()
    span = iSearch(patt, dstRef)
    if span:
     dstRef = span.group(1).upper()
     return True, srcName.strip(), srcRef.strip(":"), dstName.strip(), dstRef.strip(":")
  return False, "", "", "", ""
 def VVN9qp(self, VV5ybN, title, txt, colList):
  if VV5ybN.VVfkJL() == 0 and VV5ybN.VVJPu5() == 1:
   isLast, ques = True, "This is the last entry.\n\nDelete File ?"
  else:
   isLast, ques = False, "Delete current row ?"
  FFHsPu(self, BF(self.VVQYCU, isLast, VV5ybN), ques)
 def VVQYCU(self, isLast, VV5ybN):
  if isLast:
   FFqlCI(self.shareFilePath)
   VV5ybN.cancel()
  else:
   num, srcName, srcRef, srcType, dstName, dstRef, dstType, remark = VV5ybN.VVqY3Q()
   if self.VVpGAn(srcName, srcRef, dstName, dstRef):
    VV5ybN.VVE3Oz()
    VV5ybN.VVZkXQ()
    FFar20(VV5ybN, "Deleted", 500)
   else:
    FF8PJn(VV5ybN, "Cannot delete from file", 2000)
 def VVDt7v(self, VV5ybN, title, txt, colList):
  if self.shareIsRef : self.VVEfdg(VV5ybN)
  else    : FFw2XU(self, BF(self.VVd7D9, VV5ybN), VVXXzc=[("DVB to IPTV", "iptv"), ("DVB to DVB", "dvb")], width=600, title="Source and Destination")
 def VVd7D9(self, VV5ybN, item):
  if item:
   if   item == "iptv" : fnc = self.VVEfdg(VV5ybN)
   elif item == "dvb" : fnc = self.VVlCxT(VV5ybN)
 @FFHF2S("Loading Services ...", par=1)
 def VVlCxT(self, VV5ybN):
  lst, err = CCAnLc.VV0Bni(self, CCAnLc.VVSyjB)
  if not lst:
   FFU9uk(self, "No DVB Services !")
   return
  lst = [(VVeZBd, VVDhju + ":", sat) for VVeZBd, chProv, sat, VVDhju in lst]
  lst.sort(key=lambda x: x[0].lower())
  chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV5ybN.VVTq0J()]
  VVLZ0ZLst = []
  try:
   bg = "#11001100"
   self.session.open(CCxMMu, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to DVB Channel", mnuTitle2="Destination Channel", mnuTitle3="Source", blueTitle="Add Entry"
       , blueFnc=BF(self.VVT4k7, VV5ybN, VVLZ0ZLst), delFnc=None
       , widths2=(70, 0, 30), aligns2=(LEFT, LEFT, CENTER), tBg=bg, bBg=bg, bg1=bg, bg2=bg)
  except:
   pass
 @FFHF2S("Loading Services ...", par=1)
 def VVEfdg(self, VV5ybN):
  lst = CCYl55.VVLvsw()
  if not lst:
   FFU9uk(self, "No IPTV Services !")
   return
  lst = [(name, ref + ":") for name, bouquet, url, ref in lst]
  chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV5ybN.VVTq0J()]
  VVLZ0ZLst = [r + ":" for r in CC41Tt.VVH0nc()]
  try:
   self.session.open(CCxMMu, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to IPTV Channel", mnuTitle2="IPTV Chan Name", mnuTitle3="IPTV Reference", blueTitle="Add Entry"
       , blueFnc=BF(self.VVT4k7, VV5ybN, VVLZ0ZLst), delFnc=None
       , widths2=(60, 40), fonts2=(0, 1))
  except:
   pass
 @FFHF2S(par=3)
 def VVT4k7(self, VV5ybN, VVLZ0ZLst, bindCls):
  c1  = VVnQYw
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVB9V9()
  srcName, srcRef, srcTxt = d["name"]  , d["VVDhju10"].rstrip(":"), ""
  dstName, dstRef, dstTxt = d["mnuTxt"], d["mnuRef"].rstrip(":")  , ""
  if   FFPNoO(srcRef)  : srcTxt = FFITtK("DVB", c1)
  elif srcRef.rstrip(":") + ":" in VVLZ0ZLst : srcTxt = FFITtK("IPTV", c1)
  if   FFPNoO(dstRef)  : dstTxt = FFITtK("DVB", c1)
  elif dstRef.rstrip(":") + ":" in VVLZ0ZLst : dstTxt = FFITtK("IPTV", c1)
  if srcRef == dstRef:
   FFk1YE(bindCls, "Cannot add (same Reference)", 2000)
  else:
   for ndx, (num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1) in enumerate(VV5ybN.VVTq0J()):
    if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
     FFU9uk(self, "Already added in row Num-%d" % (ndx + 1))
     break
   else:
    if self.VV9TVN(srcName, srcRef, dstName, dstRef):
     VV5ybN.VVRcvb((str(VV5ybN.VVJPu5() + 1), srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, "0"))
     FFRuJP(bindCls, "Saved", 800)
     bindCls.VVfUel((d["VVDhju10"], d["mnuRef"], d["mnuTxt"]))
    else:
     FFk1YE(bindCls, "Cannot edit XML File", 2000)
 @staticmethod
 def VVLvsw():
  VVJwgn = []
  files  = CCSB3R.VVt2XK()
  patt  = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+(.+)"
  if files:
   for path in files:
    txt = FF05rJ(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVzhkp = span.group(1)
    else : VVzhkp = ""
    VVzhkp_lCase = VVzhkp.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVDhju = match.group(1).upper().strip(":")
     url  = match.group(2).strip()
     VVeZBd = match.group(3).strip()
     VVJwgn.append((VVeZBd, VVzhkp, url, VVDhju))
  return VVJwgn
 def VV9TVN(self, srcName, srcRef, dstName, dstRef):
  tree = CCAnLc.VVgNVP(self, self.shareFilePath)
  if not tree:
   return False
  root = tree.getroot()
  ch = iElem.Element("ch")
  root.append(ch)
  name  = iElem.SubElement(ch, "name1")
  ref   = iElem.SubElement(ch, "ref1")
  name.text = srcName
  ref.text = srcRef
  name  = iElem.SubElement(ch, "name2")
  ref   = iElem.SubElement(ch, "ref2")
  name.text = dstName
  ref.text = dstRef
  self.VVP906(tree, root)
  return True
 def VVpGAn(self, srcName1, srcRef1, dstName1, dstRef1):
  tree = CCAnLc.VVgNVP(self, self.shareFilePath)
  if not tree:
   return False
  tableLst = [srcName1, srcRef1, dstName1, dstRef1]
  found = False
  root = tree.getroot()
  for ch in root:
   ok, srcName, srcRef, dstName, dstRef = self.VV0o0L(ch)
   if ok and [srcName, srcRef, dstName, dstRef] == tableLst:
    root.remove(ch)
    found = True
  if found:
   self.VVP906(tree, root)
  return found
 def VVP906(self, tree, root, withComments=True):
  xmlTxt = iElem.tostring(root)
  txt  = CCAnLc.VV0X7v(xmlTxt)
  parser = CCAnLc.CC1gyC()
  if withComments : parser = iElem.XMLParser(target=parser)
  else   : parser = None
  root = iElem.fromstring(txt, parser=parser)
  tree._setroot(root)
  tree.write(self.shareFilePath, encoding="UTF-8")
 def VVtPvK(self, VV5ybN, title, txt, colList):
  if self.onlyEpg:
   self.VVuiZN(VV5ybN, "epg")
  else:
   if self.shareIsRef:
    FFHsPu(self, BF(self.VVo3wT, VV5ybN), "Copy all References from Source to Destination ?")
   else:
    VVXXzc = []
    VVXXzc.append(("Copy EPG\t (All List)" , "epg"  ))
    VVXXzc.append(("Copy Picons\t (All List)" , "picon" ))
    FFw2XU(self, BF(self.VVuiZN, VV5ybN), VVXXzc=VVXXzc, width=1000)
 def VVuiZN(self, VV5ybN, item=None):
  if item:
   if   item == "epg" : fnc, txt = self.VV2ws9  , "EPG"
   elif item == "picon": fnc, txt = self.VVKCRx , "PIcons"
   title = "Copy %s" % txt
   tot   = VV5ybN.VVJPu5()
   FFHsPu(self, BF(fnc, VV5ybN, title), "Overwrite %s for %d Service%s ?" % (FFITtK(txt, VVaR8d), tot, FFEnJs(tot)), title=title)
 @FFHF2S(par=1)
 def VVo3wT(self, VV5ybN):
  files = CCSB3R.VVt2XK()
  totChange = 0
  if files:
   for path in files:
    txt = FF05rJ(path)
    toSave = False
    for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV5ybN.VVTq0J():
     if remark == "0":
      srcPart = ":".join(srcRef.split(":")[1:]) + ":"
      dstPart = ":".join(dstRef.split(":")[1:]) + ":"
      txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]))%s(.+\/\/.+:%s\s?\n#DESCRIPTION.+\n)" % (dstPart, dstName), r"\g<1>%s\2" % srcPart, txt, IGNORECASE)
      if tot:
       toSave = True
       totChange += tot
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
  if totChange > 0:
   FFfve1()
  tot = VV5ybN.VVJPu5()
  skp = tot - totChange
  txt  = "Processed\t: %d\n" % tot
  txt += "Changed\t: %d\n"  % totChange
  if skp > 0: txt += "Skipped\t: %d\n"  % skp
  FFyijw(self, txt)
 @FFHF2S(par=1)
 def VVKCRx(self, VV5ybN, title):
  if not iCopyfile:
   FFU9uk(self, "Module not found:\n\nshutil", title=title)
   return
  pPath = CCUNc6.VVQ490()
  totFound = totDone = totSame = totErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV5ybN.VVTq0J():
   srcPng = pPath + srcRef.replace(":", "_") + ".png"
   dstPng = pPath + dstRef.replace(":", "_") + ".png"
   if FFf0vs(srcPng):
    totFound += 1
    if srcPng == dstPng:
     totSame += 1
    else:
     try:
      iCopyfile(srcPng, dstPng)
      totDone += 1
     except:
      totErr += 1
  txt  = "Services\t: %d\n" % VV5ybN.VVJPu5()
  txt += "Found\t: %d\n" % totFound
  txt += "Copied\t: %d"  % totDone
  if totSame: txt += "\nSame Ref.\t: %d" % totSame
  if totErr : txt += "\nErrors\t: %d"  % totErr
  FFyijw(self, txt, title=title)
 @FFHF2S(par=1)
 def VV2ws9(self, VV5ybN, title):
  txt, err = CCfClD.VV9ua2(VV5ybN, title)
  if err : FFU9uk(self, err, title=title)
  else : FFyijw(self, txt, title=title)
 class CC1gyC(iElem.TreeBuilder):
  def comment(self, data):
   self.start(iElem.Comment, {})
   self.data(data)
   self.end(iElem.Comment)
 @staticmethod
 def VVgNVP(SELF, path, withComments=True, title=""):
  try:
   if withComments:
    try:
     return iElem.parse(path, parser=iElem.XMLParser(target=CCAnLc.CC1gyC()))
    except:
     return iElem.parse(path)
  except Exception as e:
   CCYl55.VVKxON(SELF, path, str(e), title)
   return None
 @staticmethod
 def VVKxON(SELF, path, err, title=None):
  txt  = "%s\n%s\n\n" % (FFITtK("XML Parse Error in:", VVu50a), path)
  txt += "%s\n%s\n\n" % (FFITtK("Error:", VVu50a), str(err))
  FFyijw(SELF, txt, VVpaQ6="#11220000", titleBg="#11330000", title=title or FFQfhO().strip())
 @staticmethod
 def VV0X7v(xmlTxt):
  txt = iSub(r">[\n\s]*", ">" , xmlTxt.decode("UTF-8"))
  txt = iSub(r"([^12])>\s*<" , r"\1>\n<", txt)
  txt = iSub(r"ref1>\s*<name2", r"ref1>\n<name2", txt)
  txt = iSub(r"</ref2></ch>" , r"</ref2>\n</ch>\n", txt)
  txt = iSub(r"<ch>"   , r"\t<ch>", txt)
  txt = iSub(r"</ch>"   , r"\t</ch>", txt)
  txt = iSub(r"<name1>"  , r"\t\t<name1>", txt)
  txt = iSub(r"<name2>"  , r"\t\t<name2>", txt)
  txt = iSub(r"(<!-- .+ -->)" , r"\t\1\n", txt)
  txt = iSub(r"<share>"  , r"<share>\n", txt)
  return txt
class CCTLT7(Screen):
 def __init__(self, session, title):
  self.skin, self.VVuaAL = FFJH4U(VVMqR2, 600, 300, 30, 0, 0, "#22112211", "#0a223322", 35, VVZ3ZU=40)
  self.session  = session
  self.index   = 1
  self.totSec   = 0
  FFfmZP(self, title=title)
  FFrvOP(self["keyYellow"], "Reset")
  self["signTitle"] = Label("+/-")
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["sign"]  = Label("+")
  self["hour"]  = Label("00")
  self["min"]   = Label("00")
  self.list   = [self["sign"], self["hour"], self["min"]]
  FFewq4(self,
  {
   "ok" : self.VVRA23 ,
   "green" : self.VVRA23 ,
   "yellow": self.VVlsh3 ,
   "up" : self.VVY6L2  ,
   "down" : self.VVgn7U ,
   "left" : self.VVT8GX ,
   "right" : self.VVMljc ,
   "cancel": self.close
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFE1T7(self)
  self.VV1eHx()
 def VVRA23(self):
  sign = self["sign"].getText()
  hour = self["hour"].getText()
  min  = self["min"].getText()
  seconds = int(hour) * 3600 + int(min) * 60
  seconds *= 1 if sign == "+" else -1
  self.close(seconds)
 def VVlsh3(self):
  self["sign"].setText("+")
  self["hour"].setText("00")
  self["min"].setText("00")
 def VVY6L2(self)  : self.VVvSPh(1)
 def VVgn7U(self) : self.VVvSPh(-1)
 def VVT8GX(self) : self.VV1eHx(-1)
 def VVMljc(self) : self.VV1eHx(1)
 def VV1eHx(self, box=0):
  self.index += box
  if   self.index < 0     : self.index = len(self.list) - 1
  elif self.index > len(self.list) - 1: self.index = 0
  for obj in self.list: FFu0W6(obj, "#06405040")
  FFu0W6(self.list[self.index], "#0a225577")
 def VVvSPh(self, increment):
  if self.index == 0:
   sign = self.list[0].getText()
   if   sign == "+": sign = "-"
   elif sign == "-": sign = "+"
   self.list[0].setText(sign)
  else:
   if self.index == 1 : min, max, step = 0, 23, 1
   else    : min, max, step = 0, 45, 15
   val = int(self.list[self.index].getText()) + increment * step
   if val < min: val = max
   if val > max: val = min
   self.list[self.index].setText("%02d" % val)
class CC2EFP():
 def __init__(self, SELF, mode=0):
  self.SELF   = SELF
  self.Title   = "XML-TV Tools"
  self.xmltv_path  = FFmAG5() + "epg/"
  self.VV9cB4  = ""
  self.curChName  = ""
  self.curChTitle  = ""
  self.curPath  = ""
  self.curTotTags  = 0
  self.displayName = ""
  self.adjustedTime = 0
  self.curChanRefFile = self.xmltv_path + CFG.xmlTvChannelRefFile.getValue()
  self.skipLst  = ("hd+", "hd", "fhd+", "fhd", "4k", "tv", "hd_en", "beinsports.com", "elcienma", "elifeon", "jawwy", "ooredoo", "shahid", "sattv", "switch", "tod", "whatson")
  self.blackStar  = b"\xe2\x9c\xa6".decode("UTF-8")
  if mode == 0:
   CC2EFP.VVXkHv()
   self.VVU6wW(self.SELF)
  else:
   self.tbl = SELF
   if   mode == 1: CC2EFP.VVvG9h(SELF, cbf=self.VVmtyv, toTable=True)
   elif mode == 2: CC2EFP.VVvG9h(SELF)
   elif mode == 3: CC2EFP.VVW87i(SELF)
 @FFHF2S("Collecting Files ...", par=1)
 def VVU6wW(self, SELF, goToFile=None):
  lst = self.VVR10p()
  if lst:
   wTxt = "Reading names ..."
   bg = "#11001020"
   VV4dTm = (""      , self.VVRtXC    , [])
   VVEyDE = ("Delete File"   , self.VVjIxB   , [])
   VV5CrJ = ("XML File Channels"  , BF(self.VVKd25, False), [], wTxt)
   VVbQ6N = ("More Options"   , self.VVWSuN   , [])
   VVvrJb = ("EPG for Current Chan" , BF(self.VVKd25, True) , [], wTxt)
   header  = ("File" , "Size", "Type")
   widths  = (64  , 14 , 22 )
   VVgKQc = (LEFT  , CENTER, LEFT )
   self.tbl = FFdCaM(self.SELF, None, title=self.Title, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1600, VV1Wwb=28, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb
        , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#06554455", VVcv6F="#00333333")
  else:
   FFHsPu(self.SELF, BF(CCAFSK, self.SELF, BF(self.VVU6wW, self.SELF)), "No xml Files in:\n\n%s\n\nDownload ?" % self.xmltv_path, title=self.Title)
 def VVBNWr(self, newPath=None):
  if newPath:
   lst = self.VVR10p()
   if lst:
    self.tbl.VVxhz9(lst, VVK0Fc=BF(self.VVec7H, newPath), VVMbPmMsg=True)
 def VVec7H(self, newPath, VV5ybN, title, txt, colList):
  if newPath:
   self.tbl.VVp9iQ(0, os.path.basename(newPath))
 def VVR10p(self):
  lst = []
  for f in iGlob("%s*.xml" % self.xmltv_path):
   sz, typ = self.VVKSTK(f)
   if sz > -1:
    if   sz > 200000000 : c1 = "#f#00ff4000#"
    elif sz > 10000000 : c1 = "#f#00ff8033#"
    else    : c1 = "#f#00aaffaa#"
    lst.append((os.path.basename(f), c1 + CCQdsv.VVAcha(sz, mode=4), typ))
  if lst : return sorted(lst, key=lambda x: x[0].lower())
  else : return []
 def VVKSTK(self, path):
  sz = FFX42v(path)
  orng =   "#f#00ff8033#"
  if sz == -1:
   return sz, orng + "Not found"
  else:
   defF = CFG.xmlTvChannelRefFile.getValue()
   c1 = "#f#0055ff55#" if defF == os.path.basename(path) else "#f#00cccccc#"
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0:
      if   elem.tag == "tv"  : return sz, "#f#00888888#" + "Events"
      elif elem.tag == "channels" : return sz, c1 + "Reference"
      else      : return sz, orng + 'Unknown tag "%s"' % elem.tag
   except Exception as e:
    return sz, orng + str(e)[:50]
 def VVRtXC(self, VV5ybN, title, txt, colList):
  fName, szTxt, Type = VV5ybN.VVqY3Q()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, VVkLs0), y)
  txt  = ttl("File", fName)
  txt += ttl("Size", szTxt)
  txt += ttl("Type", Type)
  path = self.xmltv_path + fName
  if 1 < FFX42v(path) < 500:
   txt += ttl("File Contents", FF05rJ(path).strip())
  FFyijw(self.tbl, txt, title=title)
 def VVWSuN(self, VV5ybN, title, txt, colList):
  fName, szTxt, Type = VV5ybN.VVqY3Q()
  defF = CFG.xmlTvChannelRefFile.getValue()
  canView = defF and FFf0vs(self.xmltv_path + defF)
  self.curPath = self.xmltv_path + colList[0].strip()
  c1, c2, c3, c4 = VVnQYw, VV6UAe, VVkLs0, VVaR8d
  VVXXzc = []
  VVXXzc.append((c1 + "Change Current Channel"   , "zap"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VVXXzc.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Download XML-TV File"   , "dlnd" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c1 + "Analyze Selected XML File Tags" , "chk" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("View Channel-Reference Table" , "refTable", canView, c4))
  VVXXzc.append((    "Set Channel-Reference File" , "refPick" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Chain References to File Channels", "bind" , "Events" in Type , c1))
  FFw2XU(self.tbl, self.VVNRmU, VVXXzc=VVXXzc, width=950, VVnojT=3, title="XML File Options", VVVzvS="#11110022", VVhHWW="#11110022", VVlIBH="#08663300")
 def VVNRmU(self, item):
  if   item == "zap"  : CCAnLc.VVLTHQ()
  elif item == "curEv" : CC2EFP.VVvG9h(self.tbl, cbf=self.VVmtyv, toTable=True)
  elif item == "saveCur" : CC2EFP.VVvG9h(self.tbl, cbf=self.VVBNWr)
  elif item == "saveGrp" : CC2EFP.VVW87i(self.tbl, cbf=self.VVBNWr)
  elif item == "dlnd"  : CCAFSK(self.tbl, self.VVBNWr)
  elif item == "chk"  : self.VVRzhb(self.curPath)
  elif item == "refTable" : self.VVqKsq(self.tbl)
  elif item == "refPick" : self.VVFQuN()
  elif item == "bind"  : CC2EFP.VV8Rg6(self.tbl, self.curPath)
 @FFHF2S(par=1)
 def VVqKsq(self, tbl):
  title = "Channel-Reference File (Error)"
  refLst, err = self.VVDHKS(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FFHsPu(self.tbl, self.VVFQuN, "%s\n\nOpen a new file ?" % (err), title=title)
   return
  elif not refLst:
   FFHsPu(self.tbl, self.VVFQuN, "No records in:\n%s\n\nOpen a new file ?" % (os.path.basename(self.curChanRefFile)), title=title)
   return
  refLst = [(nm, rf, CCAnLc.VV5llI(rf, unknown="")) for nm, rf in refLst]
  bg = "#0a202020"
  refLst.sort(key=lambda x: x[0].lower())
  header   = ("Channel Name", "Reference" , "Source" )
  widths   = (46    , 42   , 12  )
  VVgKQc  = (LEFT    , LEFT   , CENTER )
  FFdCaM(self.tbl, None, title=CFG.xmlTvChannelRefFile.getValue(), header=header, VV5dDF=refLst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1600, VV1Wwb=28, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a805000", VVcv6F="#00333333")
 def VVFQuN(self):
  title = "Channel-Reference File"
  defF = CFG.xmlTvChannelRefFile.getValue()
  lst = []
  for fName, szTxt, Type in self.tbl.VVTq0J():
   if "Reference" in Type:
    lst.append((FFITtK(fName, VV8QGw) if fName == defF else fName, fName))
  if lst : FFw2XU(self.tbl, self.VVn29n, VVXXzc=sorted(lst, key=lambda x: x[1].lower()), title=title, width=1400)
  else : self.VVqIBc("No Channel-Reference files in:\n\n%s" % self.xmltv_path, title=title)
 def VVn29n(self, fName):
  if fName:
   if self.xmltv_path + fName == self.xmltv_path + CFG.xmlTvChannelRefFile.getValue():
    FFk1YE(self.tbl, "No change", 1000)
   else:
    FFDDwF(CFG.xmlTvChannelRefFile, fName)
    FFk1YE(self.tbl, "Saved", 800, isGrn=True)
    defF = CFG.xmlTvChannelRefFile.getValue()
    for ndx, (fName, szTxt, Type) in enumerate(self.tbl.VVTq0J()):
     if "Reference" in Type:
      if fName == defF: color = "#0055ff55"
      else   : color = "#00cccccc"
      self.tbl.VVgyd0(ndx, 2, 8, FFEIV2(color))
      self.tbl.VVgyd0(ndx, 2, 9, FFEIV2(color))
 def VVXbCR(self):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self.tbl)
  if VVeZBd and VVDhju:
   self.VV9cB4 = VVDhju
   self.curChName = VVeZBd
   self.curChTitle = "Current Ch. : %s" % FFITtK(self.curChName, VVi4ay)
   return True
  else:
   self.VVqIBc("Cannot get current channel data.")
   return False
 def VVjIxB(self, VV5ybN, title, txt, colList):
  fName = colList[0].strip()
  FFHsPu(self.tbl, BF(self.VVnVeQ, VV5ybN, self.xmltv_path + fName), "Delete:\n\n%s" % fName, title=self.Title)
 def VVnVeQ(self, VV5ybN, path):
  FFqlCI(path)
  if FFf0vs(path):
   FF8PJn(self.tbl, "Not deleted", 1000)
  else:
   VV5ybN.VVE3Oz()
   if VV5ybN.VVJPu5() == 0:
    VV5ybN.cancel()
 def VVKd25(self, isCurChan, VV5ybN, title, txt, colList):
  self.curPath = self.xmltv_path + colList[0].strip()
  if isCurChan and not self.VVXbCR():
   return
  self.VVmQWH(self.curPath)
  if self.curTotTags == -1:
   return
  chLst, err = self.VVx40H(self.curPath)
  if not err:
   if isCurChan: self.VVA0v9(chLst)
   else  : self.VVnsgw(chLst)
  VV5ybN.VV8SQf()
 def VVA0v9(self, chLst):
  if self.VVXbCR():
   CC8MwG.VVlTg2(self.tbl, CFG.xmlTvNameCompRatio, "Name Similarity Ratio (%)", cbFnc=BF(self.VVVAyI, self.tbl, chLst), isSave=True)
 @FFHF2S("Filtering names ...", par=1)
 def VVVAyI(self, tbl, chLst):
  mRatio  = CFG.xmlTvNameCompRatio.getValue()
  VV9cB4 = self.VV9cB4.rstrip(":").upper()
  curName  = self.curChName.lower()
  lst   = []
  for name, chId, VVDhju, iconUrl, isIcon, isRef in chLst:
   if VVDhju == VV9cB4:
    lst.append((name, chId, "100", iconUrl, isIcon))
   else:
    tName = name.lower().replace(self.blackStar, "")
    span = iSearch(r".+[|:]\s*(.+)", tName)
    if span:
     tName = span.group(1) or name
    tName = " ".join([x for x in tName.split() if x not in self.skipLst])
    ratio = CCUNc6.VVZ29q(curName, tName)
    if ratio > mRatio:
     lst.append((name, chId, str(ratio), iconUrl, isIcon))
  if lst:
   bg = "#0a102020"
   tName = "Closest Name ( > %s%% )" % mRatio
   lst.sort(key=lambda x: int(x[2]), reverse=True)
   VV4dTm = ("", self.VVmX0F  , [])
   VVI3Oq  = ("", self.VVQv7G , [], "Checking file ...")
   VVcIOx   = "OK = Filter New Events"
   header  = (tName, "ID" , "Ratio" , "iconUrl" , "PIcon" )
   widths  = (88 , 0  , 0   , 0   , 12  )
   VVgKQc = (LEFT , LEFT , CENTER , CENTER , CENTER )
   FFdCaM(self.tbl, None, title=self.curChTitle, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1200, VV1Wwb=30, VV4dTm=VV4dTm, VVI3Oq=VVI3Oq, VVcIOx=VVcIOx, VV4HrS=2
     , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a805000", VVcv6F="#00333333")
  else:
   self.VVqIBc("No %s%% similar name in:\n\n%s" % (mRatio, os.path.basename(self.curPath)), title=self.curChName)
  self.tbl.VV8SQf()
 def VVmX0F(self, VV5ybN, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VV5ybN.VVqY3Q()
  CCISy5.VVIXmT(self.tbl, VVjex7=CCISy5.VVQZSA, title=title, params=(txt, iconUrl))
 def VVnsgw(self, chLst):
  refLst, err = self.VVDHKS(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FFHsPu(self.tbl, self.VVFQuN, "%s\n\nOpen a new file ?" % (err), title="Channel-Reference File (error)")
   return
  refDict = dict(refLst)
  lst = []
  for name, chId, VVDhju, iconUrl, isIcon, isRef in chLst:
   if not VVDhju and chId in refDict:
    VVDhju, isRef = refDict[chId], "Yes"
   lst.append((name, chId, VVDhju, iconUrl, isIcon, isRef))
  bg = "#0a302a20"
  lst.sort(key=lambda x: x[0].lower())
  VVzH0q = self.VVHbhf
  VV4dTm = (""      , self.VVeFRk    , [])
  VV5CrJ = ("Import EPG (Auto)"  , self.VVV97d , [])
  VVbQ6N = ("Multi-Select"   , self.VVon1t   , [])
  VVvrJb = ("Filter EPG to File"  , self.VVTadE  , [])
  header   = ("Channel", "ID" , "VVDhju" , "iconUrl" , "PIcon" , "Ref.")
  widths   = (80  , 0  , 0   , 0   , 10  , 10 )
  VVgKQc  = (LEFT  , CENTER, CENTER , CENTER , CENTER , CENTER)
  FFdCaM(self.tbl, None, title=os.path.basename(self.curPath), header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1300, VV1Wwb=30, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVzH0q=VVzH0q
    , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00005566", VVcv6F="#00333333")
 def VVeFRk(self, VV5ybN, title, txt, colList):
  name, chId, VVDhju, iconUrl, isIcon, isRef = VV5ybN.VVqY3Q()
  sat = CCAnLc.VV5llI(VVDhju, unknown="")
  txt  = "Channel\t: %s\n" % name
  if VVDhju : txt += "Reference\t: %s\n" % VVDhju
  if sat  : txt += "Source\t: %s\n" % sat
  if iconUrl : txt += "\n%s:\n%s" % (FFITtK("Icon URL", VV6UAe), iconUrl)
  CCISy5.VVIXmT(self.tbl, VVjex7=CCISy5.VVQZSA, title=title, params=(txt, iconUrl))
 def VVon1t(self, VV5ybN, title, txt, colList):
  CCZALl(self.SELF, VV5ybN, addSep=False).VVejOk(None, None, width=700)
 def VVHbhf(self, VV5ybN):
  VV5ybN.VVcilR()
  VV5ybN.VVtMif()
  if VV5ybN.VVbbT0:
   VV5ybN.VVCGR5("OK = Select")
   if VV5ybN.VVQrKf():
    VV5ybN.VVW6Cx()
    VV5ybN.VV7swH()
  else:
   VV5ybN.VVCGR5("")
   VV5ybN.VVW6Cx()
   VV5ybN.VV7swH()
 def VVTadE(self, VV5ybN, title, txt, colList):
  if VV5ybN["keyBlue"].getVisible():
   if VV5ybN.VVbbT0 : tot = VV5ybN.VVQrKf()
   else        : tot = 1
   FFHsPu(self.tbl, BF(self.VVbi1w, VV5ybN), "Save data for %s selected channel%s to file ?" % (FFITtK(tot, VV8QGw), FFEnJs(tot)), title=self.curChTitle)
 def VVbi1w(self, VV5ybN):
  CCXRxc.VVJ9VK(self.tbl, VVmj1O="Reading events ...", VV9L2m=CCXRxc.VVE4fR
      , VVCJhW  = BF(self.VV2FG4, VV5ybN)
      , VVuQkS = self.VVdflJ )
 def VV2FG4(self, VV5ybN, VVM2wn):
  self.tmpPath = ""
  totTags = self.VVI8C3(self.curPath, VVM2wn)
  if totTags == -1:
   return
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVqMKy(totTags)
  self.tmpTitle = "Filter EPG to File"
  self.tmpTotCh = self.tmpTotEv = self.tmpTotValid = self.tmpTotRep = 0
  if VV5ybN.VVbbT0 : rows = VV5ybN.VVwKf5()
  else        : rows = [VV5ybN.VVqY3Q()]
  idLst = [x[1] for x in rows]
  if not CC2EFP.VVBTvD(self.tbl, self.Title):
   return
  tName = FFFoIQ(rows[0][0], r"-").replace(" ", "_")
  totCh = len(rows)
  if totCh > 1:
   tName += "_(+%s_other%s)" % (totCh - 1, FFEnJs(totCh - 1))
  self.tmpPath = "%s_%s_%s.xml" % (self.curPath[:-4], tName, FF6eWd())
  self.tmpFileFooter = "</tv>\n"
  progLst = set()
  with open(self.tmpPath, "w") as f:
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Filter">\n' % (VVryLp, VVsBow))
   try:
    for event, elem in iElem.iterparse(self.curPath, events=("end", )):
     if not VVM2wn or VVM2wn.isCancelled:
      return
     VVM2wn.VVwOHf(1)
     if elem.tag == "programme":
      prId = FFOW7Q(elem, "channel")
      if prId in idLst:
       self.tmpTotEv += 1
       start = FFOW7Q(elem, "start")
       stop  = FFOW7Q(elem, "stop")
       if start and stop:
        tmpId = (start, stop, prId)
        if tmpId in progLst:
         self.tmpTotRep +=1
        else:
         self.tmpTotValid += 1
         progLst.add(tmpId)
         f.write(FFqNZM(elem)+ "\n")
      elem.clear()
     elif elem.tag == "channel":
      if FFOW7Q(elem, "id") in idLst:
       self.tmpTotCh += 1
       f.write(FFqNZM(elem) + "\n")
      elem.clear()
     if self.tmpTotCh:
      totValid = FFITtK(self.tmpTotValid, VV8QGw if self.tmpTotValid else VVsm0W)
      if not VVM2wn or VVM2wn.isCancelled:
       return
      VVM2wn.VVkdWG("Channels: %s        Events: %s     Valid: %s" % (self.tmpTotCh, self.tmpTotEv, totValid))
   except Exception as e:
    self.VVbx8U(str(e), title=self.tmpTitle)
    VVM2wn.VVNQHr()
    return
   f.write(self.tmpFileFooter)
   self.tmpFileFooter = ""
 def VVdflJ(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if threadErr or self.tmpTotEv == 0:
   FFqlCI(self.tmpPath)
   if self.tmpTotEv == 0:
    FFU9uk(self.tbl, "No valid events.", title=self.tmpTitle)
  else:
   note = ""
   if self.tmpFileFooter:
    note = FFITtK("\n\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVcahY)
    with open(self.tmpPath, "a") as f:
     f.write(self.tmpFileFooter)
   repTxt = FFITtK("   ( Repeated Event Time : %s )" % self.tmpTotRep, VVcahY) if self.tmpTotRep else ""
   txt  = "Channels\t: %s\n" % self.tmpTotCh
   txt += "Found Events\t: %s%s\n" % (self.tmpTotEv, repTxt)
   txt += "Filtered Events\t: %s\n\n" % self.tmpTotValid
   txt += "%s\n%s" % (FFITtK("Output File:", VV8QGw), self.tmpPath)
   txt += note
   FFyijw(self.tbl, txt, title=self.tmpTitle)
   self.VVBNWr(self.tmpPath)
 def VVRzhb(self, path):
  CCXRxc.VVJ9VK(self.tbl, VV9L2m=CCXRxc.VVE4fR
      , VVCJhW  = self.VVGSOV
      , VVuQkS = self.VVm5QM)
 def VVGSOV(self, VVM2wn):
  VVM2wn.VViN1g = {}
  totTags = self.VVI8C3(self.curPath, VVM2wn)
  if totTags == -1:
   return
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVkdWG("Validating XML Tags ...")
  VVM2wn.VVqMKy(totTags)
  tDict = {}
  try:
   for event, elem in iElem.iterparse(self.curPath, events=("end", )):
    if not VVM2wn or VVM2wn.isCancelled:
     return
    VVM2wn.VVwOHf(1)
    tDict[elem.tag] = tDict.get(elem.tag, 0) + 1
    elem.clear()
  except Exception as e:
   VVM2wn.VViN1g["xErr"] = str(e)
   return
  if tDict:
   lst = [(key, val) for key, val in tDict.items()]
   lst.sort(key=lambda x: x[0].lower())
   c1 = VV6UAe
   txt  = FFITtK("File:\n", c1)
   txt += "%s\n\n" % self.curPath
   txt += FFITtK("XML Tags (total = %s):\n" % totTags, c1)
   for key, val in lst:
    txt += "%s\t: %s\n" % (key, val)
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VViN1g["txt"] = txt
   VVM2wn.VViN1g["ttl"] = "XML Tags Validation : %sOK" % VV8QGw
  else:
   VVM2wn.VViN1g["err"] = "No xml tags in:\n\n%s" % self.curPath
 def VVm5QM(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if   "err"  in VViN1g : self.VVqIBc(VViN1g["err"])
  elif "xErr" in VViN1g : self.VVbx8U(VViN1g["xErr"])
  elif "txt"  in VViN1g : FFyijw(self.tbl, VViN1g["txt"], height=1050, title=VViN1g["ttl"])
 def VVmQWH(self, path):
  fName = os.path.basename(path)
  sz = FFX42v(path)
  if sz > -1:
   return True
  else:
   FFbHk5(self.tbl, path, title=self.Title)
   return False
 def VVI8C3(self, path, VVM2wn):
  infPath = path + ".tot_tags"
  try: sz, mTm = FFX42v(path), os.path.getmtime(path)
  except: sz, mTm = -1, 0
  if not self.VVmQWH(path):
   FFqlCI(infPath)
   return -1
  try:
   tot = self.VVGf8K(path, infPath, sz, mTm)
   if tot:
    return tot
   else:
    tot = 0
    with ioOpen(path, "r", encoding="UTF-8") as f:
     for line in f:
      tot += line.count("</") + line.count("/>")
      if not VVM2wn or VVM2wn.isCancelled:
       return -1
      VVM2wn.VVkdWG("Counting Tags : %s" % tot)
     self.VV7wT8(path, infPath, tot, sz, mTm)
     return tot
  except Exception as e:
   self.VVbx8U(str(e))
   FFqlCI(infPath)
   return -1
 def VV7wT8(self, path, infPath, tot, sz, mTm):
  try:
   with open(infPath, "w") as f:
    f.write("%s,%s,%s" % (int(sz), mTm, tot))
  except:
   pass
 def VVGf8K(self, path, infPath, sz, mTm):
  try:
   sz1, mTm1, tot = FF05rJ(infPath).strip().split(",")
   if (str(sz), str(mTm)) == (sz1, mTm1):
    return int(tot)
  except:
   pass
  FFqlCI(infPath)
  return 0
 @staticmethod
 def VVDHKS(path):
  if not CFG.xmlTvChannelRefFile.getValue(): return [], "This requires Channel-Reference File."
  elif not FFf0vs(path)     : return [], ("File not found:\n%s" % path)
  else          : return CC2EFP.VVRGDf(path)
 @staticmethod
 def VVRGDf(path):
  lst = set()
  err = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "channels":
     err = "Invalid Channel-Reference File !"
     break
    elif elem.tag == "channel":
     chId = FFOW7Q(elem, "id")
     if chId:
      VVDhju = FFMX7D(elem)
      span = iSearch(r"^((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))", VVDhju)
      if span:
       lst.add((chId, span.group(1).upper()))
    elem.clear()
  except Exception as e:
   err = str(e)
  return list(lst), err
 def VVx40H(self, path, VVqUOx=True):
  lst = set()
  err = err1 = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     err = "Not XML-TV Format:\n\n%s" % path
     break
    elif elem.tag == "channel":
     chId = FFOW7Q(elem, "id")
     if chId:
      name = FFgrDd(elem, "display-name")
      if name:
       VVDhju = FFgrDd(elem, "reference").rstrip(":").upper()
       iconUrl = FF8Prx(elem, "icon", "src")
       isIcon = "Yes" if iconUrl else ""
       isRef = "Yes" if VVDhju else ""
       lst.add((name, chId, VVDhju, iconUrl, isIcon, isRef))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   err1 = str(e)
  if not lst:
   err = "No channel names in:\n\n%s" % os.path.basename(self.curPath)
  if VVqUOx:
   if   err : self.VVqIBc(err)
   elif err1: self.VVbx8U(err1)
  return lst, err or err1
 def VVvUQe(self, chIdSet, VVM2wn):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  tabLst = lambda x, y: tab(x, " , ".join(y))
  now  = int(iTime())
  try:
   chan = ""
   for event, elem in iElem.iterparse(self.curPath, events=("start", )):
    if not VVM2wn or VVM2wn.isCancelled:
     return
    VVM2wn.VVwOHf(1)
    if elem.tag == "programme":
     self.tmpTotEv += 1
     chan = FFOW7Q(elem, "channel")
     if chan in chIdSet:
      startTS = self.VVawZs(FFOW7Q(elem, "start"))
      stopTS  = self.VVawZs(FFOW7Q(elem, "stop"))
      if startTS and stopTS and stopTS > startTS:
       dur = stopTS - startTS
       if startTS > now or now < startTS + dur:
        self.tmpTotNew += 1
        director = writer = producer = actor = rating = ""
        Title = FFgrDd(elem, "title")
        descSh = FFgrDd(elem, "sub-title")
        descLng = FFgrDd(elem, "desc")
        Date = FFgrDd(elem, "date")
        country = FFgrDd(elem, "country")
        cat  = FFwcNq(elem, "category")
        episode = FFwcNq(elem, "episode-num")
        iconUrl = FF8Prx(elem, "icon", "src")
        cred = elem.find("credits")
        if not cred is None:
         director= FFwcNq(cred, "director")
         writer = FFwcNq(cred, "writer")
         producer= FFwcNq(cred, "producer")
         actor = FFwcNq(cred, "actor")
        rate = elem.find("rating")
        if not rate is None:
         rSys = FF8Prx(elem, "rating", "system")
         rating = FFgrDd(rate, "value") + ((" (%s)" % rSys) if rSys else "")
        desc = ""
        if Date  : desc += tab("Date", Date)
        if country : desc += tab("Country", country)
        if rating : desc += tab("Rating", rating)
        if cat  : desc += tabLst("Category", cat)
        if episode : desc += tabLst("Episode", episode)
        if director : desc += tabLst("Director", director)
        if writer : desc += tabLst("Writer", writer)
        if producer : desc += tabLst("Producer", producer)
        if actor : desc += tabLst("Actors", actor)
        if desc  : descLng = "%s\n\n%s" % (desc.rstrip(), descLng)
        startTxt= FFMYsv(startTS).replace(" ", "   ")
        startTS = str(int(startTS))
        durTxt = FF79L2(dur)
        dur  = str(int(dur))
        isDesc = "Yes" if desc else ""
        isIcon = "Yes" if iconUrl else ""
        yield chan, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon)
       else:
        self.tmpTotOld += 1
        yield None, None
    elif elem.tag == "channel":
     pass
    if elem.tag != "tv":
     elem.clear()
  except Exception as e:
   self.tmpTotErr = str(e)
   yield chan, None
 def VVQv7G(self, VV5ybN, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VV5ybN.VVqY3Q()
  self.displayName = name
  CCXRxc.VVJ9VK(self.tbl, VV9L2m=CCXRxc.VVE4fR
      , VVCJhW  = BF(self.VVkT1R, {chId})
      , VVuQkS = self.VVJF8h )
  VV5ybN.VV8SQf()
 def VVkT1R(self, chIdSet, VVM2wn):
  self.curTotTags = self.VVI8C3(self.curPath, VVM2wn)
  if self.curTotTags == -1:
   return
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVkdWG("Reading Events ...")
  VVM2wn.VVqMKy(self.curTotTags)
  VVM2wn.VViN1g = set()
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = 0
  self.tmpTotErr = ""
  for retChId, row in self.VVvUQe(chIdSet, VVM2wn):
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if self.tmpTotErr:
    self.VVbx8U(self.tmpTotErr)
    VVM2wn.VVNQHr()
    return
   elif row:
    VVM2wn.VViN1g.add(row)
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFITtK(self.tmpTotNew, VV8QGw if self.tmpTotNew else VVsm0W))
   VVM2wn.VVkdWG(txt)
 def VVJF8h(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if threadErr:
   pass
  elif VViN1g:
   self.VVmtyv(FFITtK(self.displayName, VVaR8d), VViN1g)
  elif VV9zbx:
   if self.tmpTotOld: txt = "No new event.\n\nFound %s expired event%s." % (self.tmpTotOld, FFEnJs(self.tmpTotOld))
   else     : txt = "No valid events data !"
   self.VVqIBc(txt, title=self.curChName)
 def VVmtyv(self, VVeZBd, evLst):
  if not self.VVXbCR():
   return
  title = "EPG for : %s" % VVeZBd
  evLst = sorted(list(evLst), key=lambda x: int(x[1]))
  VV4dTm = (""      , self.VVqlv1    , [])
  VV5CrJ = ("Import All Events"  , self.VVgL41 , [])
  VVbQ6N = ("Reset Times"   , self.VVkQ5g   , [])
  VVvrJb = ("Adjust All Start Time" , self.VVSe4z  , [])
  header  = ("Start Time" , "start" ,"Duration" , "dur" , "Title" , "Summary" , "desc", "iconUrl" , "Descr." , "Poster" )
  widths  = (20   , 0   , 10  , 0  , 30  , 26  , 0  , 0   , 7   , 7   )
  VVgKQc = (CENTER  , CENTER ,CENTER  , CENTER, LEFT  , LEFT  , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFdCaM(self.tbl, None, title=title, header=header, VV5dDF=evLst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1800, VV1Wwb=24, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb)
  tbl.VVcX7o()
 def VVqlv1(self, VV5ybN, title, txt, colList):
  startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = VV5ybN.VVqY3Q()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, VV6UAe), y)
  txt  = "Start Time\t: %s\n" % startTxt
  txt += "Duration\t: %s\n\n" % durTxt
  txt += ttl("Title", Title)
  if descSh : txt += ttl("Summary", descSh)
  if descLng: txt += ttl("Description", descLng)
  CCISy5.VVIXmT(self.tbl, VVjex7=CCISy5.VVQZSA, title=title, params=(txt, iconUrl))
 def VVgL41(self, VV5ybN, title, txt, colList):
  tot  = VV5ybN.VVJPu5()
  ques = "Add %s event%s to current channel from:\n\n%s" % (tot, FFEnJs(tot), FFITtK(self.displayName, VVaR8d))
  FFHsPu(self.tbl, BF(self.VVwWZM, VV5ybN), ques, title=self.curChTitle)
 @FFHF2S(par=1)
 def VVwWZM(self, VV5ybN):
  lst = []
  for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in VV5ybN.VVTq0J():
   lst.append((int(startTS), int(dur), Title, descSh, descLng, 1))
  totEv, totOK = CCfClD.VVDV4n(self.VV9cB4, lst)
  if totOK > 0:
   CCfClD.VVLWv9()
   CCAnLc.VVzv7h(self.tbl.session)
  txt = "Total Events\t: %s\n" % totEv
  txt += "Total Added\t: %s\n" % totOK
  FFyijw(self.tbl, txt, title=self.curChName)
 def VVV97d(self, VV5ybN, title, txt, colList):
  title = "Import EPG (Auto)"
  if VV5ybN.VVbbT0 : rows = VV5ybN.VVwKf5()
  else        : rows = [VV5ybN.VVqY3Q()]
  totRef = 0
  for name, chId, VVDhju, iconUrl, isIcon, isRef in rows:
   if VVDhju: totRef += 1
  totSel = len(rows)
  if totRef:
   ques = "Selected channels = %s ( %s with Reference )\n\nImport events for %s channel%s ?" % (totSel, totRef, totRef, FFEnJs(totRef))
   FFHsPu(self.tbl, BF(self.VVAb6X, title, rows), ques, title=title)
  else:
   s = FFEnJs(totSel)
   self.VVqIBc("No Reference%s for the selected channel%s in:\n\n%s" % (s, s, CFG.xmlTvChannelRefFile.getValue()), title=title)
 def VVAb6X(self, title, rows):
  CCXRxc.VVJ9VK(self.tbl, VVmj1O="Reading events ...", VV9L2m=CCXRxc.VVE4fR
      , VVCJhW  = BF(self.VVRuoC, title, rows)
      , VVuQkS = BF(self.VVm4j9, title) )
 def VVRuoC(self, title, rows, VVM2wn):
  totTags = self.VVI8C3(self.curPath, VVM2wn)
  if totTags == -1:
   return
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVqMKy(totTags)
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = self.tmpTotAdd = self.tmpTotNoRef = self.tmpTotCh = self.tmpTotChDone = 0
  self.tmpTotErr = ""
  chIdSet = set()
  refDict = {}
  for name, chId, VVDhju, iconUrl, isIcon, isRef in rows:
   if iMatch(r"^([A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+)", VVDhju):
    chIdSet.add(chId)
    refDict[chId] = VVDhju
    self.tmpTotCh += 1
   else:
    self.tmpTotNoRef += 1
  if not chIdSet:
   self.VVqIBc("Channel Reference not found in file.", title=title)
   return
  lst = []
  doneCh = set()
  oldChId = newChId = ""
  for retChId, row in self.VVvUQe(chIdSet, VVM2wn):
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if self.tmpTotErr:
    self.VVbx8U(self.tmpTotErr)
    VVM2wn.VVNQHr()
    return
   elif row:
    if not VVM2wn or VVM2wn.isCancelled:
     return
    doneCh.add(retChId)
    self.tmpTotChDone = len(doneCh)
    VVDhju = refDict.get(retChId, "")
    startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = row
    lst = [(int(startTS), int(dur), Title, descSh, descLng, 1)]
    totEv, totOK = CCfClD.VVDV4n(VVDhju, lst)
    self.tmpTotAdd += totOK
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFITtK(self.tmpTotNew, VV8QGw if self.tmpTotNew else VVsm0W))
   VVM2wn.VVkdWG(txt)
 def VVm4j9(self, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if threadCounter > 0:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = ""
   txt += tab("Channels", self.tmpTotCh)
   txt += tab("Processed", self.tmpTotChDone)
   txt += "\n"
   if self.tmpTotNoRef: txt += tab("No Reference", self.tmpTotNoRef)
   txt += tab("Total Events", self.tmpTotNew + self.tmpTotOld)
   txt += tab("Added Events", self.tmpTotAdd)
   if self.tmpTotOld: txt += tab("Old Events", self.tmpTotOld)
   if not threadCounter == threadTotal:
    txt += FFITtK("\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVcahY)
   FFyijw(self.tbl, txt, title=title, width=1500)
   if self.tmpTotAdd > 0:
    CCfClD.VVLWv9()
    CCAnLc.VVzv7h(self.tbl.session)
 def VVSe4z(self, VV5ybN, title, txt, colList):
  self.tbl.session.openWithCallback(BF(self.VVNvv5, VV5ybN), CCTLT7, "Adjust Event Start Time")
 @FFHF2S(par=1)
 def VVNvv5(self, VV5ybN, sec=None):
  if sec is not None:
   if sec == 0:
    newSec = -self.adjustedTime
    self.adjustedTime = 0
   else:
    newSec = sec
    self.adjustedTime += sec
   lst = []
   for ndx, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon) in enumerate(VV5ybN.VVTq0J()):
    startTS = int(startTS) + newSec
    startTxt =  FFMYsv(startTS).replace(" ", "   ")
    lst.append((startTxt, str(startTS), durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon))
   VV5ybN.VVxhz9(lst)
   if self.adjustedTime:
    VV5ybN.VV2K4r()
    VV5ybN["keyYellow"].setText("Reset Times ( %s %s )" % ("-" if self.adjustedTime < 0 else "+", FF79L2(abs(self.adjustedTime))))
   else:
    VV5ybN.VVcX7o()
 def VVkQ5g(self, VV5ybN, title, txt, colList):
  self.VVNvv5(VV5ybN, 0)
 def VVawZs(self, tm):
  try:
   span = iSearch(r"(\d{14})(?:\s+([+-])(\d\d)(\d\d))*", tm)
   if span:
    dateTime, sign, hh,mm = span.groups()
    tStamp = mktime(datetime.strptime(dateTime, "%Y%m%d%H%M%S").timetuple())
    if sign and hh and mm:
     gmt = (int(hh) * 3600 + int(mm) * 60)
     if sign == "-":
      gmt *= -1
     tStamp -= gmt
    return tStamp - iTimezone
  except:
   pass
  return 0
 def VVqIBc(self, err, title=""):
  FFU9uk(self.tbl, err, title=title or self.Title)
 def VVbx8U(self, err, title=""):
  CCYl55.VVKxON(self.tbl, os.path.basename(self.curPath), str(err), title=title or self.Title)
 @staticmethod
 def VVcYgg(timeStamp):
  return datetime.fromtimestamp(timeStamp + iTimezone).strftime("%Y%m%d%H%M%S +0000")
 @staticmethod
 def VVwe4e(txt):
  return txt.replace("&", "&#38;")
 @staticmethod
 def VVILpl(txt):
  d = { "&lt;" : "<" , "&#60;": "<"
   , "&gt;" : ">" , "&#62;": ">"
   , "&apos;" : "'" , "&#39;": "'", "&#x27;": "'"
   , "&quot;" : '"' , "&#34;": '"'
   , "&amp;" : "&" , "&#38;": "&"
   , "&nbsp;" : " "
   , "&#09;" : "\t"
   , "&#10;" : "\n"
   , "&#13;" : "\n"
   , "&#91;" : "["
   , "&#93;" : "]"
   , "&#124;" : "|"
   }
  for key, val in d.items():
   if key in txt:
    txt = txt.replace(key, val)
  return txt
 @staticmethod
 def VVBTvD(SELF, title=""):
  path = FFmAG5() + "epg/"
  if FF6usE("mkdir -p '%s'" % path):
   return path
  else:
   FFU9uk(SELF, "Cannot create EPG directory:\n\n%s" % path, title=title or FFQfhO().strip())
   return ""
 @staticmethod
 def VVXkHv():
  path = FFmAG5() + "epg/"
  fName = "ajpanel_channels.xml"
  refF = path + fName
  if not FFf0vs(refF) and FF6usE("mkdir -p '%s'" % path):
   with open(refF, "w") as f:
    f.write('<?xml version="1.0" encoding="utf-8"?>\n<channels>\n</channels>\n')
 @staticmethod
 @FFHF2S()
 def VVvG9h(SELF, cbf=None, toTable=False):
  title = "Read Current Channel EPG" if toTable else "Seve Current Channel Events"
  VVqUOx = lambda x: FFU9uk(SELF, x, title=title)
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(SELF)
  if not VVeZBd or not VVDhju:
   VVqUOx("Cannot get current channel data.")
   return
  ec, inst = CCfClD.VV6iPd()
  if not inst:
   VVqUOx("Cannot access EPG Cache !")
   return
  try:
   evList = inst.lookupEvent([CCfClD.VVpNTp, (VVDhju.rstrip(":"), 0, -1, -1)])
  except:
   evList = []
  if not evList:
   FFU9uk(SELF, "No EPG.", title=VVeZBd)
   return
  lst = []
  for start, dur, Title, descrS, descrL, pc, genre in evList:
   startTxt= FFMYsv(start).replace(" ", "   ")
   startTS = str(int(start))
   durTxt = FF79L2(dur)
   if descrS == "Not Applicable":
    descrS = ""
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   lst.append((startTxt, startTS, FF79L2(dur), str(int(dur)), Title, descrS, descrL, "", "Yes" if descrL else "", ""))
  if toTable:
   cbf(FFITtK(VVeZBd, VV8QGw), lst)
   return
  epgDir = CC2EFP.VVBTvD(SELF, title)
  if not epgDir:
   return
  tName = FFFoIQ(VVeZBd, r"-").replace(" ", "_")
  path = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, tName, FF6eWd())
  with open(path, "w") as f:
   if not VVDhju.endswith(":"): VVDhju += ":"
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVryLp, VVsBow))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name></channel>\n' % (VVeZBd, VVeZBd))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VVeZBd, VVeZBd, VVDhju))
   for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in lst:
    end = int(startTS) + int(dur)
    start = CC2EFP.VVcYgg(int(startTS))
    stop  = CC2EFP.VVcYgg(end)
    f.write('<programme start="%s" stop="%s" channel="%s">\n'   % (start, stop, VVeZBd))
    f.write('\t<title lang="en">%s</title>\n'      % CC2EFP.VVwe4e(Title))
    if descSh: f.write('\t<sub-title lang="en">%s</sub-title>\n' % CC2EFP.VVwe4e(descSh))
    f.write('\t<desc lang="en">%s</desc>\n'       % CC2EFP.VVwe4e(descLng))
    f.write('</programme>\n')
   f.write("</tv>\n")
  tot = len(evList)
  FFSQn9(SELF, "Saved %d event%s to:\n\n%s\n%s" % (tot, FFEnJs(tot), epgDir, os.path.basename(path)), title=VVeZBd)
  if cbf: cbf(path)
 @staticmethod
 @FFHF2S()
 def VVW87i(SELF, cbf=None):
  title = "Save EPG to File"
  VVqUOx = lambda x: FFU9uk(SELF, x, title=title)
  ec, inst = CCfClD.VV6iPd()
  if not inst:
   VVqUOx("Cannot access EPG Cache !")
   return
  srvLst = CC41Tt.VVSaEJ()
  if not srvLst:
   VVqUOx("No services found in:\n\n%s" % rootSrc)
   return
  srvLst.sort(key=lambda x: x[1].lower())
  srvLst = [[VVeZBd, VVDhju.rstrip(":"), 0] for x, (VVDhju, VVeZBd) in enumerate(srvLst)]
  epgDir = CC2EFP.VVBTvD(SELF, title)
  if not epgDir:
   return
  VVDhju, refName, rootRef, rootName, inBouquet, rootSrc = CCdo8n.VVe8dV()
  path  = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, FFFoIQ(rootName or rootSrc, r"_"), FF6eWd())
  tPath = "/tmp/ajp_xmltv"
  totChk = totCh = totEv = totPc = totGenre = 0
  with open(tPath, "w") as f:
   for ndx, (VVeZBd, VVDhju, flag) in enumerate(srvLst):
    totChk += 1
    try:
     evList = inst.lookupEvent([CCfClD.VVpNTp, (VVDhju.rstrip(":"), 0, -1, -1)])
    except:
     evList = []
    if evList:
     srvLst[ndx][2] = 1
     totCh += 1
     totEv += len(evList)
     for start, dur, Title, descrS, descrL, pc, genre in evList:
      end = start + dur
      start = CC2EFP.VVcYgg(start)
      stop  = CC2EFP.VVcYgg(end)
      f.write('<programme start="%s" stop="%s" channel="%s">\n' % (start, stop, VVeZBd))
      f.write('\t<title lang="en">%s</title>\n'    % CC2EFP.VVwe4e(Title))
      if descrS and not "Not Applicable" in descrS:
       f.write('\t<sub-title lang="en">%s</sub-title>\n' % CC2EFP.VVwe4e(descrS))
      f.write('\t<desc lang="en">%s</desc>\n'     % CC2EFP.VVwe4e(descrL))
      if pc:
       for Sys, val in pc:
        totPc += 1
        f.write('\t<rating system="%s"><value>%s</value></rating>\n' % (Sys.strip(), val))
      if genre:
       for item in genre:
        totGenre += 1
        f.write('\t<category lang="en">%s</category>\n' % str(item))
      f.write('</programme>\n')
  if totEv:
   err = ""
   try:
    with open(path, "w") as f:
     f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
     f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVryLp, VVsBow))
     for VVeZBd, VVDhju, flag in srvLst:
      if flag:
       if not VVDhju.endswith(":"): VVDhju += ":"
       f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VVeZBd, VVeZBd, VVDhju))
     with open(tPath, "r") as tmpf:
      for line in tmpf.readlines():
       f.write(line)
     f.write("</tv>\n")
    tab = lambda x, y: "%s\t: %s\n" % (x, y)
    txt  = ""
    txt += tab("Group", rootSrc)
    txt += tab("Name", rootName or rootSrc)
    txt += "\n"
    txt += tab("Channels", totCh)
    txt += tab("Events", totEv)
    if totGenre : txt += tab("Category", totGenre)
    if totPc : txt += tab("P. Control", totPc)
    txt += "\n%s\n%s" % (FFITtK("Output File:", VV8QGw), path)
    FFyijw(SELF, txt, title=title, width=1500)
    if cbf: cbf(path)
   except Exception as e:
    FFqlCI(path)
    VVqUOx("Error during data export:\n\n%s" % str(e))
  else:
   FFU9uk(SELF, "No EPG from %s channel%s in:\n\n%s" % (totChk, FFEnJs(totChk), rootName or rootSrc), title=VVeZBd)
  FFqlCI(tPath)
 @staticmethod
 def VVrf6A(path):
  lst = set()
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     return [], "File is not XML-TV Format:\n%s" % FFITtK(path, VVsm0W)
     break
    elif elem.tag == "channel":
     chId = FFOW7Q(elem, "id")
     name = FFgrDd(elem, "display-name")
     if chId and name:
      lst.add((name, chId))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   return [], str(e)
  return sorted(list(lst)), ""
 @staticmethod
 @FFHF2S("Validating Files ...")
 def VV8Rg6(SELF, epgF):
  title = "Chain Channel Reference to XML-TV Channel Name"
  epgDir = CC2EFP.VVBTvD(SELF, title)
  if epgDir: outF = epgDir + "ajpanel_channels.xml"
  else  : return
  if FFf0vs(outF):
   chkLst, err = CC2EFP.VVRGDf(outF)
   if err:
    CCYl55.VVKxON(SELF, outF, err, title=title)
    return
   else:
    chkLst = [(ref + ":", id, id) for id, ref in chkLst]
  else:
   chkLst = []
  lst, err = CC2EFP.VVrf6A(epgF)
  if err:
   CCYl55.VVKxON(SELF, outF, err, title=title)
  else:
   try:
    SELF.session.open(CCxMMu, lst, chkLst=chkLst, srcPath=epgF, dstPath=outF
        , title=title, mnuTitle2="XMLTV Display Name", mnuTitle3="XMLTV Channel ID", blueTitle="Add Entry"
        , blueFnc=CC2EFP.VVDezF, delFnc=CC2EFP.VVVvxt)
   except:
    pass
 @staticmethod
 @FFHF2S()
 def VVDezF(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVB9V9()
  if not d["VVDhju10"]:
   FFk1YE(bindCls, "Invalid Reference !", 800)
   return
  line = '\t<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (d["source"], d["mnuRef"], d["VVDhju10"], d["name"])
  try:
   if FFf0vs(outF):
    txt = FF05rJ(outF)
    with open(outF, "w") as f:
     f.write(txt.replace("</channels>", "").strip() + "\n%s\n</channels>\n" % line)
   else:
    with open(outF, "w") as f:
     f.write('<?xml version="1.0" encoding="utf-8"?>\n')
     f.write('<channels>\n\n')
     f.write(line)
     f.write('\n</channels>\n')
   FFRuJP(bindCls, "Saved", 800)
   bindCls.VVfUel((d["VVDhju10"], d["mnuRef"], d["mnuTxt"]))
  except Exception as e:
   CCYl55.VVKxON(bindCls, outF, e, title=title)
 @staticmethod
 @FFHF2S()
 def VVVvxt(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVB9V9()
  try:
   lines = FF2iRW(outF, keepends=True)
   with open(outF, "w") as f:
    for line in lines:
     if not d["mnuRef"] in line and not d["VVDhju10"] in line:
      f.write(line)
   FFRuJP(bindCls, "Deleted", 800)
   bindCls.VVhfBZ((d["VVDhju10"], d["mnuRef"], d["mnuTxt"]))
  except Exception as e:
   CCYl55.VVKxON(bindCls, outF, e, title=title)
class CCxMMu(ChannelSelectionBase):
 def __init__(self, session, VVXXzc, chkLst=None, srcPath="", dstPath="", pickMode=0, perc1=50, aligns2=None, widths2=None, fonts2=None, title="", mnuTitle1="", mnuTitle2="", mnuTitle3="", blueTitle="", blueFnc=None, delFnc=None, tBg="#11001122", bBg="#11001122", tBg1="#11220000", tBg2="#11220000", bg1="#11001122", bg2="#11001122"):
  self.skin, self.VVuaAL = FFJH4U(VVJy40, 1800, 1000, 30, 10, 10, tBg, bBg, 30, VVZ3ZU=40, VV1fgG=2, VVZ5LV={"perc1": perc1, "perc2": widths2[0] if widths2 else 50, "tbg1": tBg1, "tbg2": tBg2, "bg1": bg1, "bg2": bg2})
  self.session  = session
  self.VVXXzc  = VVXXzc
  self.chkLst   = chkLst or []
  self.srcPath  = srcPath
  self.dstPath  = dstPath
  self.pickMode  = pickMode
  self.aligns2  = aligns2
  self.widths2  = widths2
  self.fonts2   = fonts2
  self.Title   = title or "Chain Channel Reference"
  self.mnuTitle1  = mnuTitle1 or "Source Channels"
  self.mnuTitle2  = mnuTitle2
  self.mnuTitle3  = mnuTitle3
  self.blueTitle  = blueTitle or "Add Selection to file"
  self.blueFnc  = blueFnc
  self.delFnc   = delFnc
  self.bg2   = bg2
  self.totRows  = 18
  self.VVwOMI  = 40
  self.curMenu  = 1
  self.VV1Wwb  = int(self.VVwOMI * 0.82)
  self.cursCur  = "#08885500"
  self.cursNorm  = "#08223333"
  self.curRef   = ""
  self.cancelTime  = 0
  self.added   = False
  self.lastChannel = self.VVK5zr()
  self.tpData   = CCAAmm()
  self.isVti   = CC6z2a.VVOCgj()
  FFfmZP(self, title=self.Title)
  self["myMenu"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTitle1"] = Label(self.mnuTitle1)
  self["myTitle2"] = Label(self.mnuTitle2)
  self["myTitle3"] = Label(self.mnuTitle3)
  self["myFrm1"]  = Label()
  self["myFrm2"]  = Label()
  FFrvOP(self["keyRed"] , "Group = Favourite")
  FFrvOP(self["keyGreen"] , "Show Chains")
  FFrvOP(self["keyYellow"], "Find Close Name")
  FFrvOP(self["keyBlue"] , self.blueTitle)
  if self.pickMode == 0: self["keyBlue"].hide()
  self["keyGreen"].hide()
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
  ChannelSelectionBase.__init__(self, session)
  self.bouquet_mark_edit = 0
  FFewq4(self,
  {
   "ok"  : self.VVTOku  ,
   "cancel" : self.cancel  ,
   "info"  : self.VVDgxq ,
   "menu"  : self.VV0MdO ,
   "tv"  : self.VVpp82,
   "red"  : self.VVPPff ,
   "green"  : self.VVDI8Q,
   "yellow" : self.VVcYzc,
   "blue"  : self.VVVifg ,
   "down"  : self.VVgn7U  ,
   "up"  : self.VVY6L2   ,
   "left"  : self.VVT8GX  ,
   "right"  : self.VVMljc  ,
   "pageUp" : self.VVeXT6  ,
   "chanUp" : self.VVeXT6  ,
   "pageDown" : self.VVNZhV ,
   "chanDown" : self.VVNZhV ,
   "next"  : self.VVlHxC  ,
   "last"  : self.VVEqam
  }, name="ChannelSelectBaseActions", prio=-2)
  FFewq4(self, {})
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  FFE1T7(self)
  obj  = self["myMenu"]
  objL = obj.l
  self.VViPim()
  FFTDN6(obj, bg=self.cursNorm)
  objL.setFont(0, gFont(VVQVcT, self.VV1Wwb))
  objL.setFont(1, gFont(VVQVcT, int(self.VV1Wwb * 0.7)))
  objL.setItemHeight(self.VVwOMI)
  obj.setList(self.VVAHuF())
  obj.setList(obj.list)
  obj  = self["list"]
  objL = obj.l
  self.setTvMode()
  self.showFavourites()
  obj.setMode(1)
  self.VVfKxg()
  FFTDN6(obj, bg=self.cursCur)
  obj.onSelectionChanged.append(self.VVduWZ)
  objL.setItemHeight(self.VVwOMI)
  try:
   objL.setColor(objL.eventForeground, parseColor("#00ffffaa"))
   objL.setItemsDistances(15)
  except:
   pass
  objL.setColor(objL.serviceEventProgressbarColor, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarColorSelected, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarBorderColor, parseColor("#00ffffff"))
  self.VVi53j()
  self.VVGuDh()
 def onExit(self):
  self["list"].onSelectionChanged = []
 def VV0MdO(self):
  VVXXzc = []
  VVXXzc.append(("Go to Current Playing Channel" , "cur" ))
  VVXXzc.append(("Go to Original Playing Channel" , "orig"))
  if self.chkLst:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Next Chained Service"  , "chain0"))
   VVXXzc.append(("Previous Chained Service" , "chain1"))
  if self.delFnc:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Delete Selected Chain", "del" , self.VVsF8o(), VVcahY))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Exit  (or double-Cancel)", "exit"))
  FFw2XU(self, self.VVFJs1, title="Options", VVXXzc=VVXXzc)
 def VVFJs1(self, item):
  if item:
   if   item == "cur"  : self.VV8cI1(False)
   elif item == "orig"  : self.VV8cI1(True)
   elif item == "chain0" : self.VVzyTP()
   elif item == "chain1" : self.VVVlQm()
   elif item == "del"  : self.VV64x5()
   elif item == "exit"  : self.close()
 def VVTOku(self):
  if self.curMenu == 1:
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
    if not len(self.servicelist.getList()):
     self.keyGoUp()
     FF8PJn(self, "No Services", 500)
    self.VVfKxg()
    serv = self.session.nav.getCurrentlyPlayingServiceReference()
    if serv:
     try: self.setCurrentSelectionAlternative(serv)
     except: self.setCurrentSelection(serv)
   elif serv.flags == 0:
    FF5deK(self.session, self.curRef)
    FFb7ob(self, "Cancel to go back to table")
  self.VVGuDh()
 def VV64x5(self):
  self.delFnc(self)
  self.VVGuDh()
 def cancel(self):
  serv = self.getCurrentSelection()
  if iTime() - self.cancelTime < 0.6:
   self.close()
  elif self.curMenu == 2:
   self.VVT8GX()
  elif len(self.servicePath) <= 1:
   FF8PJn(self, "Double Cancel to exit", 500)
   self.cancelTime = iTime()
  else:
   self.keyGoUp()
   self.VVfKxg()
   self.VVGuDh()
   self.cancelTime = iTime()
 def VVDgxq(self):
  lst= []
  d  = self.VVB9V9()
  def VVjJzY(x, y):
   if y: lst.append((c + x, y))
  c, s = "#b#11440044#", "Source Channel - "
  VVjJzY(s + "Name"  , d["name"])
  VVjJzY(s + "Reference" , "" if "ORDER BY" in d["noPhpRef"] else d["noPhpRef"])
  VVjJzY(s + "Source" , d["source"] + (" (%s)" % d["satLong"]) if d["satLong"] else "")
  VVjJzY(s + "Path"  , d["path"])
  VVjJzY(s + "Parent" , d["rootName"])
  VVjJzY(s + "ParentPath", d["rootPath"])
  c, s = "#b#11001122#", "Destination Channel - "
  VVjJzY(s + "Row Number", "%d of %d" % (d["mnuRowNum"], len(self.VVXXzc)))
  VVjJzY(s + self.mnuTitle2, d["mnuTxt"])
  VVjJzY(s + self.mnuTitle3, d["mnuRef"])
  VVjJzY(s + "Source File", self.srcPath)
  VVjJzY(s + "Output File", self.dstPath)
  FFdCaM(self, None, title=self.Title, VV5dDF=lst, VV1PTZ=(40, 60), width=1700, VV1Wwb=28, VVI4UA="#0a333333", VVcv6F="#00333333", VV4HrS=1)
 def VVDI8Q(self):
  if self["keyGreen"].getVisible():
   self.VV5FAF()
 def VVVifg(self):
  if self["keyBlue"].getVisible():
   if self.added:
    FFk1YE(self, "Already Added.", 1000)
   else:
    self.blueFnc(self)
    self.VVduWZ()
 def VVY6L2(self):
  if self.curMenu == 1: self.moveUp()
  else    : self["myMenu"].up()
  self.VVGuDh()
 def VVgn7U(self):
  if self.curMenu == 1: self.moveDown()
  else    : self["myMenu"].down()
  self.VVGuDh()
 def VVeXT6(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageUp)
  else    : self["myMenu"].pageUp()
  self.VVGuDh()
 def VVNZhV(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageDown)
  else    : self["myMenu"].pageDown()
  self.VVGuDh()
 def VVEqam(self):
  if self.curMenu == 1: self["list"].moveToPrevMarker()
  else    : self["myMenu"].moveToIndex(0)
 def VVlHxC(self):
  if self.curMenu == 1: self["list"].moveToNextMarker()
  else    : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVT8GX(self):
  if self.curMenu == 2:
   self.curMenu = 1
   self.VVGuDh()
 def VVMljc(self):
  if self.curMenu == 1:
   self.curMenu = 2
   self.VVGuDh()
 def VVK5zr(self):
  root = None
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   root = InfoBar.instance.servicelist.getRoot()
  return serv, root
 def VV8cI1(self, isOrig):
  if isOrig: serv, root = self.lastChannel
  else  : serv, root = self.VVK5zr()
  if serv and root:
   try:
    self.enterPath(root)
    self.servicelist.setCurrent(serv)
   except:
    try:
     self.showAllServices()
     self.servicelist.setCurrent(serv)
    except:
     pass
   self.VVfKxg()
   self.VVT8GX()
   d = self.VVB9V9()
   self["keyRed"].setText("Group = %s" % d["gName"])
  else:
   FF8PJn(self, "Not found", 800)
 @FFHF2S()
 def VVcYzc(self):
  d = self.VVB9V9()
  lst = [item[0] for item in self.VVXXzc]
  lst.extend([item[1] for item in self.VVXXzc])
  bestLst = self.iClosest(d["name"], lst, 1, 0.6)
  if bestLst : self.VVnWPb(bestLst[0])
  else  : FFk1YE(self, "Not found.", 500)
 def VVnWPb(self, id):
  for ndx, item in enumerate(self.VVXXzc):
   txt = item[0]
   ref = item[1]
   if txt == id or ref == id:
    self["myMenu"].moveToIndex(ndx)
    self.VVGuDh()
    break
 def VVqN9p(self):
  return [item[0] for item in self.chkLst]
 @FFHF2S()
 def VVzyTP(self):
  refs = self.VVqN9p()
  cNdx = self.servicelist.getCurrentIndex()
  lst = self.servicelist.getList()
  for ndx, serv in enumerate(lst):
   if ndx > cNdx and serv and serv.toString() in refs:
    self.servicelist.moveToIndex(ndx)
    self.VVGuDh()
    break
  else:
   FFk1YE(self, "Not found", 1000)
 @FFHF2S()
 def VVVlQm(self):
  refs = self.VVqN9p()
  cNdx = self.servicelist.getCurrentIndex()
  if cNdx > 0:
   lst = self.servicelist.getList()
   for ndx in range(cNdx-1, -1, -1):
    serv = lst[ndx]
    if serv and serv.toString() in refs:
     self.servicelist.moveToIndex(ndx)
     self.VVGuDh()
     return
  FFk1YE(self, "Not found", 1000)
 def VV5FAF(self):
  d = self.VVB9V9()
  lst = []
  lst2 = []
  for srcRef, dstRef, dstName in self.chkLst:
   if d["VVDhju10"] == srcRef:
    txt1 = FFITtK(dstName, VVVAvR)
    for ndx, item in enumerate(self.VVXXzc):
     mTxt = item[0]
     mRef = item[1]
     if (mTxt, mRef) == (dstName,  dstRef):
      txt1 = FFITtK(item[0], VVnQYw) + FFITtK("  (%s)" % item[1], VVgzFX)
      lst.append((txt1, (ndx, dstName)))
      break
    else:
     lst2.append((txt1, (-1, dstName)))
  if lst or lst2:
   lst.sort(key=lambda x: x[0].lower())
   lst2.sort(key=lambda x: x[0].lower())
   if lst and lst2 : lst.append(VVzg1X)
   if lst2   : lst.extend(lst2)
   title = "Item%s Linked to : %s" % (FFEnJs(len(lst)), FFITtK(d["name"], VVnQYw))
   FFw2XU(self, self.VVUwpZ, VVXXzc=lst, width=1300, VVnojT=3, title=title, VVVzvS="#11001122", VVhHWW="#11001122", VVlIBH="#11330000")
  else:
   FF8PJn(self, "Not found", 800)
 def VVUwpZ(self, item):
  if not item: return
  if item[0] == -1:
   FFU9uk(self, "Not found in current list.\n\nProbably added from another list.", item[1])
  else:
   self["myMenu"].moveToIndex(item[0])
   self.VVMljc()
   self.VVGuDh()
 def VVGuDh(self):
  if self.VVsF8o() : tBg, cBg, self.added = "#00ff8000", "#00ff0000", True
  else        : tBg, cBg, self.added = "#00ffffff", self.cursCur, False
  FFcfsH(self["myTitle1"], tBg)
  FFcfsH(self["myTitle2"], tBg)
  FFcfsH(self["myTitle3"], tBg)
  if self.curMenu == 1:
   CCBUJe(self, self["list"])
   FFTDN6(self["list"], bg=cBg)
   FFTDN6(self["myMenu"], bg=self.cursNorm)
  else:
   CCBUJe(self, self["myMenu"])
   FFTDN6(self["list"], bg=self.cursNorm)
   FFTDN6(self["myMenu"], bg=cBg)
  for obj in ("list", "myMenu"):
   inst = self[obj].instance
   inst.setSelectionEnable(0)
   inst.setSelectionEnable(1)
 def VVfUel(self, item):
  self.chkLst.append(item)
  self.VVGuDh()
 def VVhfBZ(self, item):
  self.chkLst.remove(item)
  self.VVGuDh()
 def VVsF8o(self):
  d = self.VVB9V9()
  return (d["VVDhju10"], d["mnuRef"], d["mnuTxt"]) in self.chkLst
 def VVB9V9(self):
  serv = self.getCurrentSelection()
  d = {"name": "", "rootName": "", "VVDhju": "", "VVDhju10": "", "noPhpRef": "", "rootRef": "", "gName": "", "source": "", "satLong": "", "path": "", "rootPath": ""}
  ndx, txt, ref = self.VVIdwT()
  d["mnuRowNum"], d["mnuTxt"], d["mnuRef"] = ndx + 1, txt, ref
  if serv:
   VVDhju   = serv.toString()
   path   = CC5Hkx.VVyhp8(VVDhju, mode=1)
   if "ORDER BY" in path: path = ""
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", VVDhju)
   if span  : d["VVDhju10"] = span.group(1)
   if not path : d["satLong"]   = FFkz1q(VVDhju, True)
   d["VVDhju"] = VVDhju
   d["name"]  = FFCbnj(VVDhju)
   d["source"]  = CCAnLc.VV5llI(VVDhju, unknown="")
   d["noPhpRef"]= iSub(r"[&?]mode=.+end=", r"", VVDhju, flags=IGNORECASE)
   d["path"]  = path
   rootRef   = self.getRoot().toString()
   rootPath  = CC5Hkx.VVyhp8(rootRef, mode=1)
   if "ORDER BY" in rootPath: rootPath = ""
   gNum, gName  = self.VVla1H(rootRef)
   d["rootRef"] = rootRef
   d["rootName"]= FFCbnj(rootRef)
   d["gName"]  = gName
   d["rootPath"]= rootPath
  return d
 def VVIdwT(self):
  ndx = self["myMenu"].l.getCurrentSelectionIndex()
  txt = self.VVXXzc[ndx][0]
  ref = self.VVXXzc[ndx][1]
  return ndx, txt, ref
 def VVpp82(self):
  try:
   if   self.mode == 0: self.setRadioMode()
   elif self.mode == 1: self.setTvMode()
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
   rootRef = self["list"].getRoot().toString()
   gNum, gName = self.VVla1H(rootRef)
   self.VVGl5N(gNum)
   self.VVGuDh()
  except:
   pass
  self.VVi53j()
 def VVi53j(self):
  self["myTitle"].setText("  %s \t\t %s" % (self.Title, FFITtK("Radio" if self.mode == 1 else "TV", VVgzFX)))
 def VVla1H(self, VVDhju):
  if   "(satellitePosition == " in VVDhju: return 2, "Satellite"
  elif "Current transponder" in VVDhju : return 2, "Transponder"
  elif "(provider == " in VVDhju   : return 3, "Provider"
  elif "FROM BOUQUET" in VVDhju   : return 4, "Favourite"
  else         : return 1, "ALL"
 def VVPPff(self):
  FFw2XU(self, self.VVGl5N, width=500, VVXXzc=[("All", 1), ("Satellites", 2), ("Provider", 3), ("Favourites", 4)], title="Channels Group")
 def VVGl5N(self, g):
  if g:
   if   g == 1: self.showAllServices()
   elif g == 2: self.showSatellites()
   elif g == 3: self.showProviders()
   elif g == 4: self.showFavourites()
   self.VVfKxg()
   self.VVGuDh()
   self["keyRed"].setText("Group = " + {1:"All", 2:"Satellites", 3:"Provider", 4:"Favourites", }.get(g, "?"))
 def VVAHuF(self):
  totCol = len(self.VVXXzc[0])
  align = self.aligns2 or [LEFT] * totCol
  font = self.fonts2 or [0] * totCol
  fg  = [FFEIV2("#00ffffff")] * totCol
  fg[1] = FFEIV2("#00666666")
  bg  = FFEIV2(self.bg2)
  sFg  = [FFEIV2("#00ffffff")] * totCol
  sFg[1] = FFEIV2("#00888888")
  w  = self["myMenu"].instance.size().width()
  if self.widths2 : widths = [w * r / 100 for r in self.widths2]
  else   : widths = [w  // totCol] * totCol
  rows  = []
  for rNdx, row in enumerate(self.VVXXzc):
   cols = [rNdx]
   posX = 0
   for cNdx, txt in enumerate(row):
    gap = (0 if align[cNdx] == CENTER else 8)
    cols.append(CCzs7U.VVuz47( posX + gap, 0
              , widths[cNdx] - gap, self.VVwOMI
              , font[cNdx]
              , align[cNdx] | RT_VALIGN_CENTER
              , txt
              , fg[cNdx]
              , bg
              , sFg[cNdx]
              , None
              , 0
              , None
              ))
    posX += widths[cNdx]
   rows.append(cols)
  return rows
 def VViPim(self):
  inst = self["myMenu"].instance
  sz = inst.size()
  w, h = sz.width(), sz.height()
  self.VVwOMI = h // self.totRows
  diff = h % self.totRows
  if diff:
   for obj in ("list", "myMenu", "myFrm1", "myFrm2"):
    inst = self[obj].instance
    w, h = inst.size().width(), inst.size().height()
    inst.resize(eSize(*(w, h - diff)))
   inst = self.instance
   w, h = inst.size().width(), inst.size().height()
   inst.resize(eSize(*(w, h - diff)))
   screenSize = getDesktop(0).size()
   inst.move(ePoint((screenSize.width() - w) // 2, (screenSize.height() - h) // 2))
   for name in ("keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine"):
    obj = self[name]
    inst = obj.instance
    pos = obj.getPosition()
    obj.instance.move(ePoint(pos[0], pos[1] - diff))
 def VVfKxg(self):
  obj = self["list"]
  objL= obj.l
  objL.setItemHeight(self.VVwOMI)
  numFontSz = int(self.VVwOMI * 0.45)
  objL.setElementFont(objL.celServiceNumber, gFont(VVQVcT, numFontSz))
  objL.setElementFont(objL.celServiceName, gFont(VVQVcT, self.VV1Wwb))
  objL.setElementFont(objL.celServiceInfo, gFont(VVQVcT, int(self.VVwOMI * 0.60)))
  if self.isVti:
   return
  try:
   inst = obj.instance
   numW = self.VVaqtC(inst, gFont(VVQVcT, numFontSz), inst.size(), "0000").width()
   rowW = inst.size().width() - 30
   nameW = rowW - (numW + obj.fieldMargins + obj.progressBarWidth + obj.fieldMargins)
   serv = self.getCurrentSelection()
   objL.setElementPosition(objL.celServiceNumber, eRect(0, 0, numW, self.VVwOMI))
   if serv and serv.flags == 0 : left = numW + obj.fieldMargins
   else      : left = 10
   objL.setElementPosition(objL.celServiceName, eRect(left, 0, nameW, self.VVwOMI))
   objL.setElementPosition(objL.celServiceEventProgressbar, eRect(rowW - obj.progressBarWidth, 0, obj.progressBarWidth, self.VVwOMI))
  except:
   pass
 def VVaqtC(self, instance, font, targetSize, txt):
  from enigma import eLabel
  return eLabel.calculateTextSize(font, txt, targetSize)
 def VVduWZ(self):
  self["keyBlue"].hide()
  serv = self.getCurrentSelection()
  if serv and serv.flags == 0:
   self.curRef = serv.toString()
   txt = CCAnLc.VV5llI(self.curRef, unknown="")
   tpTxt = self.tpData.VVklm3(self.curRef)
   if tpTxt: txt += " (%s)" % tpTxt
   if txt : txt += " - "
   txt = (txt + self.curRef).strip()
   if len(txt) > 61: txt = txt[:61] + ".."
   if self.pickMode in (0, 2): self["keyBlue"].show()
  else:
   self.curRef = ""
   txt = self.mnuTitle1
   if self.pickMode in (1, 2): self["keyBlue"].show()
  self["myTitle1"].setText(txt)
  self.VVGuDh()
  if self.VVB9V9()["VVDhju10"] in self.VVqN9p():
   self["keyGreen"].show()
  else:
   self["keyGreen"].hide()
class CCAFSK():
 def __init__(self, SELF, cbf=None):
  self.SELF  = SELF
  self.cbf  = cbf
  self.Title  = "Download XML-TV File"
  self.urlsPath = FFmAG5() + "ajpanel_epg_source"
  self.dstPath = FFmAG5() + "epg/"
  self.tbl  = None
  self.lastPath = ""
  if not FFf0vs(self.urlsPath):
   FFbHk5(self.SELF, self.urlsPath, title=self.Title)
   return
  self.epgDir = CC2EFP.VVBTvD(SELF, self.Title)
  if not self.epgDir:
   return
  lst = self.VVfLyX()
  if lst:
   if self.tbl:
    self.tbl.VVxhz9(lst)
   else:
    lst.sort(key=lambda x: x[0].lower())
    bg = "#11112233"
    VVLj1d = self.VVy3za
    VV5CrJ = ("Download", self.VVkXzy, [])
    header  = ("File", "URL", "Exists" )
    widths  = (28  , 64 , 8   )
    VVgKQc = (LEFT  , LEFT , CENTER )
    self.tbl = FFdCaM(self.SELF, None, title=self.Title, header=header, VV5dDF=lst, VV1PTZ=widths, VVgKQc=VVgKQc, width=1700, VV1Wwb=26, VVLj1d=VVLj1d, VV5CrJ=VV5CrJ, VVVzvS="#00004455", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a665533", VVcv6F="#00333333", VVsOjr="#00552222")
  else:
   FFU9uk(self.SELF, "No valid URLs in:\n\n%s" % path, title=self.Title + " (xml/gz/xz)" )
 def VVy3za(self, VV5ybN):
  if self.lastPath and self.cbf:
   self.cbf(self.lastPath)
  VV5ybN.cancel()
 def VVfLyX(self):
  lst = []
  for url in FF2iRW(self.urlsPath):
   url = url.strip()
   if not url.startswith("#") and url.endswith((".gz", ".xz", ".xml")) and not url.endswith((".tar.gz", ".tar.xz")):
    fName = os.path.basename(url)
    if fName.endswith((".gz", ".xz")) : fName = fName[:-3]
    if not fName.endswith(".xml")  : fName += ".xml"
    lst.append((fName, url, "Yes" if FFf0vs(self.dstPath + fName) else ""))
  return lst
 def VVkXzy(self, VV5ybN, title, txt, colList):
  fName, url, exist = VV5ybN.VVqY3Q()
  for ext, tool in {".gz": "gzip", ".xz":"xz"}.items():
   if url.endswith(ext) and not FFsGnd(tool):
    FFU9uk(self.tbl, 'Please install "%s" to handle the "%s" files.' % (tool, ext), title=self.Title)
    return
  ques = "Download%s:\n\n%s" % (" (%s)" % FFITtK("and overwrite", VVcahY) if FFf0vs(self.epgDir + fName) else "", fName)
  FFHsPu(self.tbl, BF(self.VV0DTk, self.tbl, url, fName), ques, title=self.Title)
 @FFHF2S("Downloading ...", par=1, clearMsg=False)
 def VV0DTk(self, tbl, url, fName):
  path, err = FFEyUQ(url, os.path.basename(url), timeout=3, tmpPath=self.epgDir)
  if path:
   self.VVeXxM(self.tbl, path)
  else:
   FFU9uk(self.tbl, "Download Error:\n\n%s" % err, title=self.Title)
   FF8PJn(self.tbl)
 @FFHF2S("Extracting ...", par=1)
 def VVeXxM(self, tbl, path):
  if path.endswith((".gz", ".xz")):
   txt = FFdV6p("%s -fd '%s'" % ("gzip" if path.endswith("gz") else "xz", path))
   if not txt:
    src = path[:-3]
    path = src
    if not path.endswith(".xml"):
     path = src + ".xml"
    if not FF6usE("mv -f '%s' '%s'" % (src, path)):
     FFU9uk(self.tbl, "Cannot rename the downloaded file:\n\n%s" % src, title=self.Title)
     return
   else:
    FFU9uk(self.tbl, "Cannot extract:\n%s\n\n( %s )" % (path, txt), title=self.Title)
    return
  self.lastPath = path
  FFar20(self.tbl, "Downloaded")
  try:
   fName, url, exist = self.tbl.VVqY3Q()
   self.tbl.VVULq3((fName, url, FFITtK("New", VV8QGw)))
  except:
   pass
class CCfClD(Screen, CCYl55):
 VVdhoM  = "BDTSE"
 VVpNTp  = "BDTSEPW"
 VVqVjW   = "save"
 VVdMNr   = "load"
 VV4Uf2  = "flushEPG"
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 1000, 1000, 50, 40, 30, "#22110011", "#22110022", 30)
  self.session  = session
  c1, c2, c3, c4, c5 = VVnQYw, VV6UAe, VVnQYw, VVi4ay, VVcahY
  valid, path, sz, szTxt, modTm = CCfClD.VVQBKV()
  qUrl, VVu69c, VVLZ0Z = CCSB3R.VVxAMw(self)
  VVXXzc = []
  VVXXzc.append((c1 + "XML-TV Tools", "xmltvTools"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VVXXzc.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "EPG Events Counter"    , "evCount" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c4 + "Cache File Info.", "inf"))
  VVXXzc.append(VVzg1X)
  fTxt = " (%s)" % os.path.basename(path) if valid else ""
  VVXXzc.append(FFwjWO("Save EPG to File%s" % fTxt , self.VVqVjW, valid))
  VVXXzc.append(FFwjWO("Load EPG from File%s" % fTxt , self.VVdMNr, valid))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c5 + "Delete EPG (from RAM only)", self.VV4Uf2))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVeXRs", qUrl or "chCode" in VVLZ0Z))
  VVXXzc.append(("Copy EPG between Channels (from xml file)", "copyEpg" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Translate Current Channel EPG", "VV1uLO"))
  FFfmZP(self, title="EPG Tools", VVXXzc=VVXXzc)
  self.onShown.append(self.VVvFMs)
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "xmltvTools"   : CC2EFP(self)
   elif item == "curEv"    : CC2EFP(self, mode=1)
   elif item == "saveCur"    : CC2EFP(self, mode=2)
   elif item == "saveGrp"    : CC2EFP(self, mode=3)
   elif item == "evCount"    : self.VVI1Gh()
   elif item == "inf"     : self.VVHhCO()
   elif item in (self.VVqVjW, self.VVdMNr, self.VV4Uf2):
    reset = item == self.VVdMNr
    FFHsPu(self, BF(self.VVwwKG, item, reset), VVYjCX="Continue ?")
   elif item == "VVeXRs": CCSB3R.VVeXRs(self)
   elif item == "copyEpg"    : self.VVgxjc(False, onlyEpg=True)
   elif item == "VV1uLO" : self.VV1uLO()
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 @FFHF2S()
 def VVwwKG(self, act, reset=False):
  ok = CCfClD.VVhqh6(act)
  if ok:
   if reset:
    CCAnLc.VVzv7h(self.session)
   FFSQn9(self, "Done")
  else:
   FFSQn9(self, "Failed!")
 def VVHhCO(self):
  title = "EPG Cache File"
  valid, path, sz, szTxt, modTm = CCfClD.VVQBKV()
  if path:
   if valid: txt = "File Path\t: %s\n\nFile Size\t: %s\n\nModified\t: %s\n" % (path, szTxt or "?", modTm)
   else : txt = "System Settings: %s\n\n%s" % (path, FFITtK("File not found (check System EPG settings).", VVcahY))
   FFyijw(self, txt, title=title)
  else:
   FFU9uk(self, "Cannot read Path Settings !", title=title)
 @FFHF2S()
 def VVI1Gh(self):
  title = "EPG Events Counter"
  ec, inst = CCfClD.VV6iPd()
  if not inst:
   FFU9uk(self, "Cannot access EPG Cache !", title=title)
   return
  lst = CCAnLc.VVLOo7("1:7:")
  lst = [(n, r.rstrip(":"), FFkz1q(r, False)) for r, n in lst]
  lst2 = CC41Tt.VV57Su()
  lst.extend([(n, r.rstrip(":"), "IPTV") for r, n in lst2])
  lst2 = None
  VVJwgn = []
  totEv = 0
  for n, r, t in lst:
   evList = inst.lookupEvent([CCfClD.VVdhoM, (r.rstrip(":"), 0, -1, -1)])
   tot = len(evList)
   if tot:
    totEv += tot
    VVJwgn.append((n, r, t, str(tot)))
  if VVJwgn:
   title += FFITtK("  ( Total Events = %s )" % totEv, VVVAvR)
   bg = "#0a112525"
   VVJwgn.sort(key=lambda x: x[0].lower())
   header  = ("Name" , "Reference" , "Source" , "EPG Events" )
   widths  = (40  , 40   , 8   , 12   )
   VVgKQc = (LEFT  , LEFT   , CENTER , CENTER )
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VVnete=True, width=1800, height=950, VV1PTZ=widths, VV1Wwb=28
         , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg)
  else:
   FFU9uk(self, "No channels with cached EPG !", title=title)
 def VV1uLO(self):
  title = "Translate Current Channel EPG"
  bg = "#11101010"
  VVI3Oq  = (""   , BF(self.VV0eX9, title, True) , [])
  VV5CrJ = ("Start"  , BF(self.VV0eX9, title, False), [])
  VVvrJb = ("Language" , self.VVJNGH         , [])
  widths  = (50 , 50 )
  VVgKQc = (LEFT , CENTER)
  FFdCaM(self, None, title=title, VV5dDF=self.VVgR4s(), VVgKQc=VVgKQc, VV1PTZ=widths, width=900, VVcCjD=20, VV1Wwb=30, VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VVvrJb=VVvrJb, VV4HrS=2
    , VVVzvS="#11201010", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#00004455", VVcv6F=bg)
 def VVgR4s(self):
  ch = dict(self.VV2D2s())
  VVJwgn = []
  VVJwgn.append(("Event Name Language" , ch.get(CFG.epgLangTitle.getValue(), "")))
  VVJwgn.append(("Description Language", ch.get(CFG.epgLangDescr.getValue(), "")))
  return VVJwgn
 def VVJNGH(self, VV5ybN, title, txt, colList):
  ndx = VV5ybN.VVfkJL()
  title = colList[0]
  confItem = CFG.epgLangTitle if ndx == 0 else CFG.epgLangDescr
  CC8MwG.VVlTg2(self, confItem, title, lst=self.VV2D2s(), cbFnc=BF(self.VVK6Zj, VV5ybN), isSave=True)
 def VVK6Zj(self, VV5ybN):
  for ndx, row in enumerate(self.VVgR4s()):
   VV5ybN.VVZmhU(ndx, row)
  FFar20(VV5ybN, "Saved", 600)
 def VV2D2s(self):
  lst = [("", "DISABLED")]
  for line in FF2iRW("%sajpanel_lang" % VV30Jg):
   span = iSearch(r"\s*(.+)\s*,\s*(.+)\s*", line)
   if span:
    lst.append((span.group(1), span.group(2)))
  return lst
 def VV0eX9(self, Title, isAsk, VV5ybN, title, txt, colList):
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  if not (tVal or dVal):
   FF8PJn(VV5ybN, "Change Language", 700)
  else:
   VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
   VVDhju, evList, err = CCfClD.VVIZxI(VVDhju)
   fnc = BF(self.VVHQRM, Title, VVDhju, evList, VV5ybN)
   if   err : FFU9uk(self, err, title=Title)
   elif isAsk : FFHsPu(self, fnc, "Start ?", title=Title)
   else  : fnc()
 def VVHQRM(self, title, VVDhju, evList, VV5ybN):
  CCXRxc.VVJ9VK(self, VVmj1O=title, titleBg="#22003344", bodyBg="#22001122"
      , VVCJhW  = BF(self.VVGHX1, evList)
      , VVuQkS = BF(self.VVZfwT, VV5ybN, title, VVDhju))
 def VVGHX1(self, evList, VVM2wn):
  totEv = len(evList)
  newLst = []
  totErrName = totErrShort = totErrLong = totSkip = 0
  VVM2wn.VVqMKy(totEv)
  VVM2wn.VViN1g = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
  lang = CFG.epgLangDescr.getValue()
  for ev in evList:
   trName, trShort, trLong, errName, errShort, errLong = CCfClD.VV0JgF(*ev[2:5])
   totErrName  += errName
   totErrShort += errShort
   totErrLong  += errLong
   if not VVM2wn or VVM2wn.isCancelled:
    return
   VVM2wn.VVwOHf(1)
   VVM2wn.VVq2H3(len(newLst), ev[2] if len(ev[2]) < 22 else ev[2][:22] + " ...")
   name1, short1, long1 = ev[2:5]
   if (name1, short1, long1) != (trName, trShort, trLong):
    item = list(ev)
    item[2], item[3], item[4] = trName, trShort, trLong
    item.append(1)
    newLst.append(tuple(item))
   else:
    totSkip += 1
   VVM2wn.VViN1g = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
 def VVZfwT(self, VV5ybN, title, VVDhju, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  newLst, totEv, totErrName, totErrShort, totErrLong, totSkip = VViN1g
  if newLst: totEv, totOK = CCfClD.VVDV4n(VVDhju, newLst)
  else  : totOK = 0
  if totOK:
   CCfClD.VVLWv9()
   CCAnLc.VVzv7h(self.session)
  txt  = "Events\t: %d\n"  % totEv
  txt += "Processed\t: %d\n" % len(newLst)
  txt += "Changed\t: %d\n" % totOK
  if totSkip : txt += "Skipped\t: %d \t... Same language\n" % totSkip
  if any((totErrName, totErrShort, totErrLong)):
   txt += "\nErrors:\n"
   if totErrName : txt += "  Event Name\t: %d\n" % totErrName
   if totErrShort: txt += "  Description\t: %d\n" % totErrShort
   if totErrLong : txt += "  Description\t: %d\n" % totErrLong
  FFyijw(self, txt, title=title)
  VV5ybN.cancel()
 @staticmethod
 def VV0JgF(eName, eShort, eLong):
  eName, eShort, eLong = eName.strip(), eShort.strip(), eLong.strip()
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  lang, lst, resLst, errLst = (tVal, dVal, dVal), (eName, eShort, eLong), ["", "", ""], [0, 0, 0]
  def VVEQGt(ndx):
   if lst[ndx] and lang[ndx]:
    txt, err = CCfClD.VVMR9P(lst[ndx], lang[ndx])
    resLst[ndx], errLst[ndx] = txt, 1 if err else 0
  thLst = []
  for ndx in range(3):
   th = iThread(name="ajp_%d" % ndx, target=BF(VVEQGt, ndx))
   th.start()
   thLst.append(th)
  for th in thLst: th.join()
  trName, trShort, trLong = resLst[0] or eName, resLst[1] or eShort, resLst[2] or eLong
  errName, errShort, errLong = errLst
  return trName, trShort, trLong, errName, errShort, errLong
 @staticmethod
 def VVMR9P(txt, toLang):
  txt = txt.strip()
  if txt:
   qUrl = "%s%s&q=%s" % ("=lt&otua=ls&?m/moc.elgoog.etalsnart//:sptth"[::-1], toLang, FFma3M(txt))
   txt, err = CCSB3R.VVEL0f(qUrl, timeout=1, allowDocType=True)
   if err:
    return "", err
   else:
    txt = FF0rS9(txt)
    ndx  = txt.find('<div class="result-container">')
    if ndx > -1:
     txt = txt[ndx + 30:]
     ndx  = txt.find("</div>")
     if ndx > -1:
      return str(CCfClD.VVTcrt(txt[:ndx])).strip(), ""
   return "", "Could not translate"
  else:
   return "", "Nothing to translate"
 @staticmethod
 def VVQBKV():
  path = szTxt = modTm = ""
  valid = sz = 0
  try: path = config.misc.epgcache_filename.getValue()
  except: pass
  if FFf0vs(path):
   valid = 1
   sz = FFX42v(path)
   szTxt = CCQdsv.VVAcha(sz) if sz > -1 else ""
   modTm = FFMYsv(os.path.getmtime(path))
  return valid, path, sz, szTxt, modTm
 @staticmethod
 def VV6iPd():
  try:
   from enigma import eEPGCache
   return eEPGCache, eEPGCache.getInstance()
  except:
   return None, None
 @staticmethod
 def VVLWv9():
  CCfClD.VVhqh6(CCfClD.VVqVjW)
 @staticmethod
 def VVhqh6(act):
  ec, inst = CCfClD.VV6iPd()
  if inst and hasattr(ec, act):
   try:
    exec("inst.%s()" % act)
    return True
   except:
    pass
  return False
 @staticmethod
 def VVIZxI(VVDhju):
  ec, inst = CCfClD.VV6iPd()
  if inst:
   try:
    evList = inst.lookupEvent([CCfClD.VVdhoM, (VVDhju.rstrip(":"), 0, -1, 20160)])
    if evList: return VVDhju, evList, ""
    else  : return VVDhju, [], "No System EPG"
   except:
    return VVDhju, [], "EPG Read-Error !"
  else:
   return VVDhju, [], "Cannot read EPG Cache !"
 @staticmethod
 def VVDV4n(VVDhju, events, longDescDays=0):
  ec, inst = CCfClD.VV6iPd()
  totEv, totOK, fnc = 0, 0, None
  if inst:
   if   hasattr(ec, "importEvents"): fnc = inst.importEvents
   elif hasattr(ec, "importEvent") : fnc = inst.importEvent
  if fnc:
   for data in events:
    totEv += 1
    try:
     if longDescDays and data[0] > iTime() + 86400 * longDescDays:
      data = data[:4] + ("",) + data[5:]
     fnc(VVDhju, (data,))
     totOK += 1
    except:
     pass
  return totEv, totOK
 @staticmethod
 def VVk1vV(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   ec, inst = CCfClD.VV6iPd()
   if ec:
    event = inst.lookupEventTime(serv, -1, 0)
    if event:
     return CCfClD.VVC3RI(event)
   try:
    info = eServiceCenter.getInstance().info(serv)
    event = info and info.getEvent(serv)
    if event:
     return CCfClD.VVC3RI(event)
   except:
    pass
   VVeZBd = serv.getName()
   if VVeZBd:
    return [VVeZBd] + [""] * 6
  return [CCaZ62(SELF.session).VVeZBd] + [""] * 6
 @staticmethod
 def VVZ1cH(SELF):
  fPath, fDir, fName = CCQdsv.VVZTzJ(SELF)
  if fName:
   return os.path.splitext(fName)[0]
  evName, evTime, evDur, evShort, evDesc, genre, PR = CCfClD.VVk1vV(SELF)
  s = CCaZ62(SELF.session)
  if s.isDvb:
   return evName if any((evTime, evDur, evShort, evDesc, genre, PR)) else ""
  elif " >> " in s.VVeZBd:
   ev = s.VVeZBd.partition(" >> ")[2].strip()
   if ev: return ev
  return evName
 @staticmethod
 def VVC3RI(event):
  evName = event.getEventName().strip()    or ""
  evTime = event.getBeginTime()      or ""
  evDur = event.getDuration()      or ""
  evShort = event.getShortDescription().strip()  or ""
  evDesc = event.getExtendedDescription().strip() or ""
  genre, PR = CCfClD.VV4o9J(event)
  return evName, evTime, evDur, evShort, evDesc, genre, PR
 @staticmethod
 def VVwpm8(VVDhju):
  service = eServiceReference(VVDhju)
  evLst = []
  if service:
   ec, inst = CCfClD.VV6iPd()
   try:
    if inst:
     for evNum in range(2):
      event = inst.lookupEventTime(service, -1, evNum)
      evName, evTime, evDur, evShort, evDesc, genre, PR = CCfClD.VVC3RI(event)
      evEnd = evPos = evRem = evCom = 0
      evTimeTxt = evPosTxt = evDurTxt = evEndTxt = evRemTxt = evComTxt = ""
      if evTime and evDur:
       evEnd = evTime + evDur
       evTimeTxt = FFMYsv(evTime)
       evEndTxt  = FFMYsv(evEnd)
       evDurTxt  = FF79L2(evDur)
       now = int(iTime())
       if now > evTime and now < evEnd:
        evPos = now - evTime
        evPosTxt = FF79L2(evPos)
        evRem = evEnd - now
        evRemTxt = FF79L2(evRem)
       elif now < evTime:
        evCom = evTime - now
        evComTxt = FF79L2(evCom)
      evLst.append((evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt))
   except:
    pass
  return evLst
 @staticmethod
 def VV4o9J(event):
  genre = PR = ""
  try:
   genre  = CCfClD.VVvCUI(event.getGenreData().getLevel1(), event.getGenreData().getLevel2())
   age = event.getParentalData().getRating()
   PR  = CCfClD.VVyiVp(age)
  except:
   pass
  return genre, PR
 @staticmethod
 def VVyiVp(age):
  if   age == 0 : return "Undefinded (all ages)"
  elif age > 15 : return "Rated by broadcaster (%d)" % age
  else   : return "Minimum Age = %d years" % (age + 3)
 @staticmethod
 def VVvCUI(L1, L2):
  if   L1 <= 0  : return "Undefined Content"
  elif L1 >= 15  : return "User Defined Genre"
  elif L1 > 12  : return "Unlisted Genre"
  else:
   MG, SG = CCfClD.VVrXG7()
   if MG and SG:
    key = "%d,%d" % (L1, L2)
    if key in SG   : return SG[key].title()
    elif L1 - 1 < len(MG) : return MG[L1 - 1] .title()
    else     : return "Unknown Genre"
   else:
    return ""
 @staticmethod
 def VVrXG7():
  path = VV30Jg + "_sup_genre"
  MG = SG = ""
  if FFf0vs(path):
   MG = iFindall(r"\d,0;(\w+\s?\w+)", FF05rJ(path), IGNORECASE)
   SG = iFindall(r"(\d+,\d+);(.+)", FF05rJ(path), IGNORECASE)
   if SG: SG = dict(SG)
  return MG, SG
 @staticmethod
 def VV9ua2(VV5ybN, title):
  ec, inst = CCfClD.VV6iPd()
  if not inst:
   return "", "Cannot access EPG Cache !"
  totFound = totEvents = totSuccess = totInvalid = totEvErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV5ybN.VVTq0J():
   if remark == "0":
    try:
     evList = inst.lookupEvent([CCfClD.VVdhoM, (srcRef.rstrip(":"), 0, -1, 20160)])
    except:
     totEvErr += 1
     evList = []
    if evList:
     totFound += 1
     lst = []
     for item in evList:
      lst.append((item[0], item[1], item[2], item[3], item[4], 1))
     totEv, totOK = CCfClD.VVDV4n(dstRef, lst)
     totEvents += totEv
     totSuccess += totOK
   else:
    totInvalid += 1
  if totSuccess > 0:
   CCfClD.VVLWv9()
   CCAnLc.VVzv7h(VV5ybN.session)
  txt  = "Services\t: %d\n"  % VV5ybN.VVJPu5()
  txt += "Invalid Ref.\t: %s\n" % totInvalid
  txt += "With Events\t: %d\n\n" % totFound
  txt += "Found Events\t: %d\n" % totEvents
  txt += "Copied Events\t: %d\n" % totSuccess
  if totEvErr:
   txt += "EPG Errors\t: %d" % totEvErr
  return txt, ""
 @staticmethod
 def VVu9S1(VVDhju):
  ec, inst = CCfClD.VV6iPd()
  if inst and VVDhju:
   try:
    return inst.lookupEvent([CCfClD.VVpNTp, (VVDhju.rstrip(":"), 0, -1, -1)])
   except:
    pass
  return []
 @staticmethod
 def VVpLAz(info, VVDhju):
  evLst = []
  if info:
   for evNum in range(2):
    try:
     ev = info.getEvent(evNum)
     evLst.append(CCfClD.VVC3RI(ev))
    except:
     pass
  if not evLst and VVDhju:
   serv = eServiceReference(VVDhju)
   ec, inst = CCfClD.VV6iPd()
   if serv and inst:
    for evNum in range(2):
     try:
      ev = inst.lookupEventTime(serv, -1, evNum)
      evLst.append(CCfClD.VVC3RI(ev))
     except:
      pass
  if not evLst and VVDhju:
   try:
    serv = eServiceReference(VVDhju)
    info = serv and eServiceCenter.getInstance().info(serv)
    if info:
     ev = info.getEvent(serv)
     evLst.append(CCfClD.VVC3RI(ev))
   except:
    pass
  return evLst
 @staticmethod
 def VVTHDW(evList, totTr=0):
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2= lambda x, y: "%s\t:\n%s\n" % (x, y) if y else ""
  sep = FFITtK("_" * 33 + "\n", VVgzFX)
  now = iTime()
  epg = ""
  for evNum, (start, dur, Title, descrS, descrL, pc, genre)in enumerate(evList, start=1):
   startTxt = endTxt = durTxt = ""
   isCurEv = False
   try:
    startTxt= FFMYsv(start).replace(" ", "   ")
    endTxt = FFMYsv(start + dur).replace(" ", "   ")
    durTxt = FF79L2(dur)
    isCurEv = start < now and (start + dur) > now
   except:
    pass
   descrS = str(descrS).strip()
   if descrS == "Not Applicable":
    descrS = ""
   descrL = str(descrL).strip()
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   Title2 = lang = ""
   if totTr > 0 and evNum <= totTr:
    trName, trShort, trLong, errName, errShort, errLong = CCfClD.VV0JgF(Title, descrS, descrL)
    descrS, descrL = trShort, trLong
    if Title and trName and Title != trName:
     Title2 = FFITtK(trName, VV6UAe)
     lang = " (%s)" % CFG.epgLangDescr.getValue().upper()
   if isCurEv : evFg, descrFg, txt = VVcahY , VVkLs0, "     (CURRENT EVENT)"
   else  : evFg, descrFg, txt = VVHFlX , VVVAvR  , ""
   epg += sep
   epg += tab("Event"   , FFITtK(str(evNum) + txt, evFg))
   epg += tab("Start"   , startTxt)
   epg += tab("Title"   , FFITtK(Title, VV6UAe) if Title else "")
   epg += tab("Title" + lang , FFITtK(Title2, VV6UAe) if Title2 else "")
   epg += tab("Start"   , startTxt)
   epg += tab("End"   , endTxt)
   epg += tab("Duration"  , durTxt)
   epg += tab2("Summary"  , FFITtK(descrS, VVVAvR) if descrS else "")
   epg += tab2("Description" , FFITtK(descrL, descrFg) if descrL else "")
  return epg
 @staticmethod
 def VVTcrt(txt):
  try:
   from HTMLParser import HTMLParser
   return HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html.parser
   return html.parser.HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html
   return html.unescape(txt)
  except:
   pass
  return txt
class CCAnLc(Screen, CCYl55):
 VVg33i  = 0
 VVy7Ye = 1
 VVacfv  = 2
 VVE5s3  = 3
 VVSyjB = 4
 VVXIul = 5
 VVV48d = 6
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 1000, 1040, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session   = session
  self.filterObj    = None
  self.VVnUmB = None
  self.lastfilterUsed  = None
  self.servFilterInFilter = False
  VVXXzc = self.VV4L9C()
  FFfmZP(self, VVXXzc=VVXXzc, title="Services/Channels")
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self["myMenu"].setList(self.VV4L9C())
  FFTDN6(self["myMenu"])
  FFbm8U(self)
 def VV4L9C(self):
  VVXXzc = []
  c = VVnQYw
  VVXXzc.append((c + "Open Player Bar"         , "openPlayer"   ))
  VVXXzc.append((c + "Open Signal Monitor"        , "openSignal"   ))
  VVXXzc.append((c + "Current Service Information"      , "currentServiceInfo" ))
  VVXXzc.append(VVzg1X)
  c = VV6UAe
  VVXXzc.append((c + "Services (Lock, Hide, Delete, Add to Fav)"  , "VVjOBo" ))
  VVXXzc.append((c + "Services (Transponders)"       , "VVbdh2"))
  VVXXzc.append((VVu50a + "More tables ..."     , "VVE04Q"  ))
  c = VVkLs0
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Import Bouquets from Backup Files"  , "VVLTQG", iTar, c ))
  VVXXzc.append((c + 'Export Services to "channels.xml"'    , "VVp4is"       ))
  VVXXzc.append((c + "Copy EPG/PIcons between Channels (from xml file)" , "copyEpgPicons"       ))
  c = VVCBkQ
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c + "Satellites Services Cleaner"      , "VVIfYZ"  ))
  VVXXzc.append((c + "Invalid Services Cleaner"       , "VVU6Xn" ))
  c = VVCBkQ
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c + "Delete Channels with no names"     , "VVGDoS" ))
  VVXXzc.append((c + "Delete Empty Bouquets"       , "VVyJc6"  ))
  VVXXzc.append(VVzg1X)
  VVAk7o, VVIPZs = CCAnLc.VVg5A0()
  if FFf0vs(VVAk7o):
   enab = FFf0vs(VVIPZs)
   if enab: VVXXzc.append(("Enable Hidden Services List"    , "enableHiddenChannels" ))
   else   : VVXXzc.append(("Disable Hidden Services List"   , "disableHiddenChannels" ))
  VVXXzc.append(("Reset Parental Control Settings"      , "VVsujF" ))
  VVXXzc.append(("Reload Channels and Bouquets"       , "VVZel2" ))
  return VVXXzc
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "openPlayer"      : CC2lVw.VVbVSZ(self.session)
   elif item == "openSignal"      : FFNSo6(self.session, reopen=True)
   elif item == "currentServiceInfo"    : CCISy5.VVIXmT(self, VVjex7=CCISy5.VVn7qY)
   elif item == "VVjOBo"   : self.VVjOBo()
   elif item == "VVbdh2"  : self.VVbdh2()
   elif item == "VVE04Q"    : self.VVE04Q()
   elif item == "VVLTQG" : CC9j6t.VVLTQG(self)
   elif item == "VVp4is"     : self.VVp4is()
   elif item == "copyEpgPicons"     : self.VVgxjc(False)
   elif item == "VVIfYZ"    : self.VVIfYZ()
   elif item == "VVU6Xn"   : self.VVU6Xn()
   elif item == "VVGDoS"   : self.VVGDoS()
   elif item == "VVyJc6"    : self.VVyJc6(self)
   elif item == "enableHiddenChannels"    : self.VV4ysX(True)
   elif item == "disableHiddenChannels"   : self.VV4ysX(False)
   elif item == "VVsujF"   : FFHsPu(self, self.VVsujF, "Reset and Restart ?")
   elif item == "VVZel2"     : CCAnLc.VVZel2(self)
 def VVE04Q(self):
  VVXXzc = []
  VVXXzc.append(("Services (IDs)"       , "VVCQNb"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Services (Parental-Control List)"   , "VVsPkF" ))
  VVXXzc.append(("Services (Hidden List)"     , "VVTyCa"  ))
  VVXXzc.append(("Services with PIcons for the System"  , "VVUsWh1"  ))
  VVXXzc.append(("Services without PIcons for the System" , "VVUsWh2"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Transponders (Statistics)"    , "TranspondersStats"  ))
  VVXXzc.append(("Satellites.xml (Statistics)"    , "VVQqqj"  ))
  FFw2XU(self, None, VVXXzc=VVXXzc, title="Service Information", VV5LxL=self.VVwXGn)
 def VVwXGn(self, item):
  if item:
   VVZzW8, txt, ref, ndx = item
   if   ref == "VVCQNb" : self.VVCQNb(VVZzW8, txt)
   elif ref == "VVsPkF" : self.VVsPkF(VVZzW8, txt)
   elif ref == "VVTyCa"  : self.VVTyCa(VVZzW8, txt)
   elif ref == "VVUsWh1"  : self.VVUsWh(VVZzW8, txt, True)
   elif ref == "VVUsWh2"  : self.VVUsWh(VVZzW8, txt, False)
   elif ref == "TranspondersStats"   : self.VVZ9HU(VVZzW8, txt)
   elif ref == "VVQqqj"  : self.VVQqqj(VVZzW8, txt)
 def VVp4is(self):
  VVXXzc = []
  VVXXzc.append(("All DVB-S/C/T Services", "all"))
  VVXXzc.extend(CC41Tt.VV5FZT())
  FFw2XU(self, self.VVhS55, VVXXzc=VVXXzc, title="", VVfP2Q=True)
 @FFHF2S()
 def VVhS55(self, item=None):
  if item:
   txt, ref, ndx = item
   if ref == "all" : lst = CCAnLc.VVLOo7("1:7:")
   else   : lst = FFaKV3(eServiceReference(ref))
   if lst:
    tot = len(lst)
    if tot > 0:
     rows = []
     for r, n in lst:
      sat = CCAnLc.VV5llI(r)
      rows.append('<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (sat, n, r, n))
     if rows:
      rows.sort()
      fPath = "%schannels_%s.xml" % (FFg1mx(), FF6eWd())
      with open(fPath, "w") as f:
       f.write('<?xml version="1.0" encoding="utf-8"?>\n')
       f.write('<channels>\n\n')
       for row in rows: f.write(row)
       f.write('\n</channels>\n')
      FFSQn9(self, "Saved %d service%s to:\n\n%s" % (tot, FFEnJs(tot), fPath))
      return
   FF8PJn(self, "No Services found !", 1500)
 @staticmethod
 @FFHF2S()
 def VVZel2(SELF):
  FFfve1()
  FFSQn9(SELF, "Finished\n\nReloaded Channels and Bouquets")
 @FFHF2S()
 def VVjOBo(self):
  self.VVnUmB = None
  self.lastfilterUsed  = None
  self.filterObj   = CCrT1G(self)
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVg33i)
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VVI3Oq  = ("Zap"   , self.VVKvuJ     , [])
   VV4dTm = (""    , self.VV2G9g , [])
   VVbQ6N = ("Options"  , self.VVrXqY , [])
   VV5CrJ = ("Current Service", self.VVmNzR , [])
   VVvrJb = ("Filter"   , self.VVxRSL  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Sat.", "Reference" , "PC"  , "Hidden" )
   widths   = (24  , 20  , 9  , 34   , 6   , 7   )
   VVgKQc  = (LEFT  , LEFT  , CENTER, LEFT    , CENTER , CENTER )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindServices)
 @FFHF2S()
 def VVbdh2(self):
  self.VVnUmB = None
  self.lastfilterUsed  = None
  self.filterObj   = CCrT1G(self)
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVy7Ye)
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VVI3Oq  = ("Zap"   , self.VVKvuJ      , [])
   VV4dTm = (""    , self.VV2G9g  , [])
   VV5CrJ = ("Current Service", self.VVmNzR  , [])
   VVbQ6N = ("Options"  , self.VV0RkR , [])
   VVvrJb = ("Filter"   , self.VVk8ci  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Type", "Ref.", "Sat.", "Transponder" , "Freq." , "Pol.", "FEC" , "SR" )
   widths   = (25  , 24  , 14 , 0.01 , 9  , 0.02   , 8   , 5  , 7  , 8  )
   VVgKQc  = (LEFT  , LEFT  , CENTER, CENTER, CENTER, CENTER   , CENTER , CENTER, CENTER, CENTER)
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindServices)
 def VVrXqY(self, VV5ybN, title, txt, colList):
  servName = colList[0].strip()
  VVDhju  = colList[3].strip()
  pcState  = colList[4].strip()
  hidState = colList[5].strip()
  mSel = CCZALl(self, VV5ybN, setsOk=True, setsBlue=True)
  VVXXzc = []
  isMulti = VV5ybN.VVbbT0
  c1 = VVu50a
  if isMulti:
   VVBVvG = VV5ybN.VVaOdg(3)
   tot = len(VVBVvG)
   if VVBVvG:
    VVXXzc.append(("Add Selection to Parental Control"  , "VVnM9w1" ))
    VVXXzc.append(("Remove Selection from Parental Control" , "VVnM9w2" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append(("Add Selection to Hidden Services"   , "VVqYRK1" ))
    VVXXzc.append(("Remove Selection from Hidden Services" , "VVqYRK2" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c1 + "Delete %s service%s" % (tot, FFEnJs(tot)), "VVW1W4"))
    VVXXzc.append(VVzg1X)
  else:
   pc = pcState == "No"
   hid = hidState == "No"
   VVXXzc.append(FFwjWO("Add to Parental Control"  , "VVU3Sy1" , pc  ))
   VVXXzc.append(FFwjWO("Remove from Parental Control" , "VVU3Sy2" , not pc ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Add to Hidden Services"  , "VV3zGK1" , hid  ))
   VVXXzc.append(FFwjWO("Remove from Hidden Services" , "VV3zGK2" , not hid ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c1 + "Delete Selected Service"    , "VVW1W4"     ))
   VVXXzc.append(VVzg1X)
  cbFncDict = { "VVU3Sy1" : BF(self.VVU3Sy, VV5ybN, VVDhju, True)
     , "VVU3Sy2" : BF(self.VVU3Sy, VV5ybN, VVDhju, False)
     , "VV3zGK1" : BF(self.VV3zGK, VV5ybN, VVDhju, True)
     , "VV3zGK2" : BF(self.VV3zGK, VV5ybN, VVDhju, False)
     , "VVnM9w1" : BF(self.VVnM9w, VV5ybN, True)
     , "VVnM9w2" : BF(self.VVnM9w, VV5ybN, False)
     , "VVqYRK1" : BF(self.VVqYRK, VV5ybN, True)
     , "VVqYRK2" : BF(self.VVqYRK, VV5ybN, False)
     , "VVW1W4"  : BF(self.VVW1W4, VV5ybN, isMulti, servName, VVDhju)
     }
  VVXXzc1, cbFncDict1 = CCAnLc.VVbh8T(self, VV5ybN, servName, 3)
  VVXXzc.extend(VVXXzc1)
  for key, val in cbFncDict1.items(): cbFncDict[key] = val
  mSel.VVejOk(VVXXzc, cbFncDict)
 def VV0RkR(self, VV5ybN, title, txt, colList):
  servName = colList[0]
  mSel = CCZALl(self, VV5ybN, setsOk=True, setsBlue=True)
  VVXXzc, cbFncDict = CCAnLc.VVbh8T(self, VV5ybN, servName, 3)
  mSel.VVejOk(VVXXzc, cbFncDict)
 @staticmethod
 def VVbh8T(SELF, VV5ybN, servName, VVrjf3):
  tot = VV5ybN.VVQrKf()
  if tot > 0:
   sTxt = FFITtK("%d Service%s" % (tot, FFEnJs(tot)), VV6UAe)
   VVXXzc = [("Add %s to Bouquet ..." % sTxt   , "addToBouquet_multi" )]
  else:
   servName = FFes9J(servName)
   if len(servName) > 20: servName = servName[:20] + ".."
   servName = FFITtK(servName, VV6UAe)
   VVXXzc = [('Add "%s" to Bouquet ...' % servName , "addToBouquet_one" )]
  cbFncDict = { "addToBouquet_multi" : BF(CCAnLc.VV6Ajf, SELF, VV5ybN, VVrjf3, True)
     , "addToBouquet_one" : BF(CCAnLc.VV6Ajf, SELF, VV5ybN, VVrjf3, False)
     }
  return VVXXzc, cbFncDict
 @staticmethod
 def VV6Ajf(SELF, VV5ybN, VVrjf3, isMulti):
  picker = CC41Tt(SELF, VV5ybN, "Add to Bouquet", BF(CCAnLc.VVh6id, VV5ybN, VVrjf3, isMulti))
 @staticmethod
 def VVh6id(VV5ybN, VVrjf3, isMulti):
  if isMulti : VVBVvG = VV5ybN.VVaOdg(VVrjf3)
  else  : VVBVvG = [VV5ybN.VVqY3Q()[VVrjf3]]
  chUrlLst = []
  for ref in VVBVvG:
   chUrlLst.append(ref)
  return chUrlLst
 def VVU3Sy(self, VV5ybN, VVDhju, isAddToBlackList):
  self.VVFKYV(VV5ybN, [VVDhju], isAddToBlackList)
 def VVnM9w(self, VV5ybN, isAddToBlackList):
  VVBVvG = VV5ybN.VVaOdg(3)
  if not VVBVvG:
   FFU9uk(self, "Nothing selected", title="Change Parental-Control State")
   return
  self.VVFKYV(VV5ybN, VVBVvG, isAddToBlackList)
 @FFHF2S(par=1, clearMsg=False)
 def VVFKYV(self, VV5ybN, VVBVvG, isAddToBlackList):
  for ndx, VVDhju in enumerate(VVBVvG):
   VVDhju = VVDhju.strip()
   if not VVDhju.endswith(":"):
    VVDhju += ":"
    VVBVvG[ndx] = VVDhju
  changed = False
  if isAddToBlackList:
   if isAddToBlackList:
    with open(VVlCrP, "a") as f:
     for VVDhju in VVBVvG:
      f.write(VVDhju + "\n")
      changed = True
  elif FFf0vs(VVlCrP):
   lines = FF2iRW(VVlCrP)
   if lines:
    for VVDhju in VVBVvG:
     while VVDhju in lines:
      ndx = lines.index(VVDhju)
      lines[ndx] = ""
      changed = True
    if changed:
     with open(VVlCrP, "w") as f:
      for line in lines:
       if line:
        f.write(line + "\n")
  if changed:
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   isMulti = VV5ybN.VVbbT0
   if isMulti:
    self.VVwbVS(VV5ybN, len(VVBVvG))
   else:
    if VVDhju.endswith(":"):
     VVDhju = VVDhju[:-1]
    self.VVNonM(VV5ybN, VVDhju)
    VV5ybN.VV8SQf()
  else:
   VV5ybN.VVjSys("No changes")
 @FFHF2S(par=1)
 def VV3zGK(self, VV5ybN, VVDhju, isHide):
  title = "Change Hidden State"
  if FFPNoO(VVDhju):
   ret = FFYzNS(VVDhju, isHide)
   if ret : self.VVNonM(VV5ybN, VVDhju)
   else : FFU9uk(self, "Cannot Hide/Unhide this channel.", title=title)
  else:
   FFU9uk(self, "Cannot Hide/Unhide this channel.\n\n(Invalid transponder)", title=title)
 def VVNonM(self, VV5ybN, VVDhju):
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVg33i, VVpqim=[3, [VVDhju], False])
  done = False
  if VVJwgn:
   data = VVJwgn[0]
   if data[3] == VVDhju:
    done = VV5ybN.VVULq3(data)
  if not done:
   self.VVpWWI(VV5ybN, VV5ybN.VVIdZ2(), self.VVg33i)
 def VVwbVS(self, VV5ybN, totRefCodes):
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVg33i, VVpqim=self.VVnUmB)
  VV5ybN.VVxhz9(VVJwgn, VVK0Fc=BF(self.VVw1Ht, totRefCodes))
 def VVw1Ht(self, totRefCodes, VV5ybN, title, txt, colList):
  VV5ybN.VVUVWk()
  FFRuJP(VV5ybN, "%d Processed" % totRefCodes, 1000)
 @FFHF2S(par=1, clearMsg=False)
 def VVqYRK(self, VV5ybN, isHide):
  VVBVvG = VV5ybN.VVaOdg(3)
  if not VVBVvG:
   FFU9uk(self, "Nothing selected", title="Change Hidden State")
   return
  totChanges = 0
  for VVDhju in VVBVvG:
   ret = FFYzNS(VVDhju, isHide, skipReload=True)
   if ret:
    totChanges += 1
  if totChanges > 0:
   FFfve1(True)
   self.VVwbVS(VV5ybN, len(VVBVvG))
  else:
   VV5ybN.VVjSys("No changes")
 def VVW1W4(self, VV5ybN, isMulti, servName, VVDhju):
  c1 = VVsm0W
  if isMulti:
   refLst = VV5ybN.VVaOdg(3)
   tot = len(refLst)
   ques = "Delete %s service%s ?" % (FFITtK(str(tot), c1), FFEnJs(tot))
  else:
   refLst, ques = [VVDhju], c1 + servName
  FFHsPu(self, BF(self.VV1a5W, VV5ybN, refLst), ques, title="Delete Services")
 @FFHF2S("Deleting ...", par=1, clearMsg=False)
 def VV1a5W(self, VV5ybN, refLst):
  totDb, totBouqF, totBouqLn, err = CCAnLc.VVRUpK(self, refLst)
  if err:
   FFU9uk(self, err, title="Delete Services")
  elif any((totDb, totBouqF, totBouqLn)):
   if len(refLst) == VV5ybN.VVJPu5():
    self.VVnUmB = self.lastfilterUsed = None
    self.VVwbVS(VV5ybN, len(refLst))
    VV5ybN.VVq4kA("Filter = All")
   else:
    self.VVwbVS(VV5ybN, len(refLst))
  else:
   FF8PJn(VV5ybN, "No change", 1000)
 def VVxRSL(self, VV5ybN, title, txt, colList):
  inFilterFnc = BF(self.VVvPnb, VV5ybN) if self.VVnUmB else None
  self.filterObj.VVxr3c(1, VV5ybN, 2, BF(self.VVH6ck, VV5ybN), inFilterFnc=inFilterFnc)
 def VVH6ck(self, VV5ybN, item):
  self.VVGCNu(VV5ybN, False, item, 2, self.VVg33i)
 def VVvPnb(self, VV5ybN, VVZzW8, item):
  self.VVGCNu(VV5ybN, True, item, 2, self.VVg33i)
 def VVk8ci(self, VV5ybN, title, txt, colList):
  inFilterFnc = BF(self.VVfWt8, VV5ybN) if self.VVnUmB else None
  self.filterObj.VVxr3c(2, VV5ybN, 4, BF(self.VV724R, VV5ybN), inFilterFnc=inFilterFnc)
 def VV724R(self, VV5ybN, item):
  self.VVGCNu(VV5ybN, False, item, 4, self.VVy7Ye)
 def VVfWt8(self, VV5ybN, VVZzW8, item):
  self.VVGCNu(VV5ybN, True, item, 4, self.VVy7Ye)
 def VVh01i(self, VV5ybN, title, txt, colList):
  inFilterFnc = BF(self.VVJEbS, VV5ybN) if self.VVnUmB else None
  self.filterObj.VVxr3c(0, VV5ybN, 4, BF(self.VVWUEg, VV5ybN), inFilterFnc=inFilterFnc)
 def VVWUEg(self, VV5ybN, item):
  self.VVGCNu(VV5ybN, False, item, 4, self.VVacfv)
 def VVJEbS(self, VV5ybN, VVZzW8, item):
  self.VVGCNu(VV5ybN, True, item, 4, self.VVacfv)
 def VVGCNu(self, VV5ybN, isInFilter, item, satCol, mode):
  self.servFilterInFilter = isInFilter
  if self.lastfilterUsed and self.lastfilterUsed == [item, satCol, mode]:
   return
  self.lastfilterUsed = [item, satCol, mode]
  if   item.startswith("__s__") : col, words, title = satCol, item[5:] , item[5:]
  elif item.startswith("__w__") : col, words, title = 0  , item[5:] , item[5:]
  elif item == "parentalControl" : col, words, title = 4  , "Yes"  , "Parental Control"
  elif item == "hiddenServices" : col, words, title = 5  , "Yes"  , "Hidden Services"
  elif item == "selectedTP"  :
   tp = VV5ybN.VVVWWJ(5)
   col, words, title = 5  , tp , tp
  elif item == "emptyTP"   : col, words, title = 6  , "-"  , "Channels with no Transponder"
  elif item == "radio"   : col, words, title = 3  , ""  , "Radio Services"
  elif item == "streamRelay"  : col, words, title = 3  , ""  , "Stream Relay Services"
  else       : col, words, title = None , "All"  , "All"
  title = "Filter = %s" % title
  if len(title) > 55:
   title = title[:55] + ".."
  if col is None:
   self.VVnUmB = None
  elif item == "radio":
   words = ["1:0:2:", "1:0:7:", "1:0:A:"]
   self.VVnUmB = [col, words, True]
  elif item == "streamRelay":
   words = CCAnLc.VV6meg()
   if not words:
    FF8PJn(VV5ybN, "Not found", 1000)
    self.lastfilterUsed = None
    return
   self.VVnUmB = [col, words, False]
  else:
   words, asPrefix = CCrT1G.VVYDJw(words)
   self.VVnUmB = [col, words, asPrefix]
  if words: FFTSvN(VV5ybN, BF(self.VVpWWI, VV5ybN, title, mode), clearMsg=False)
  else : FF8PJn(VV5ybN, "Incorrect filter", 2000)
 def VVpWWI(self, VV5ybN, title, mode):
  VVJwgn, err = CCAnLc.VV0Bni(self, mode, VVpqim=self.VVnUmB, VVAomI=False)
  if self.servFilterInFilter:
   lst = []
   for row in VV5ybN.VVTq0J():
    try:
     ndx = VVJwgn.index(tuple(list(map(str.strip, row))))
     lst.append(VVJwgn[ndx])
    except:
     pass
   VVJwgn = lst
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VV5ybN.VVxhz9(VVJwgn, title)
  else:
   FF8PJn(VV5ybN, "Not found!", 1500)
   self.lastfilterUsed = None
 def VVxIry(self, title, VV5dDF, VVI3Oq=None, VV4dTm=None, VVEyDE=None, VV5CrJ=None, VVbQ6N=None, VVvrJb=None):
  VV5CrJ = ("Current Service", self.VVmNzR, [], )
  header  = ("Name" , "Provider", "Sat.", "Reference" )
  widths  = (29  , 27  , 9  , 35   )
  VVgKQc = (LEFT  , LEFT  , CENTER, LEFT    )
  FFdCaM(self, None, title=title, header=header, VV5dDF=VV5dDF, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindServices)
 def VVmNzR(self, VV5ybN, title, txt, colList):
  self.VVA4mR(VV5ybN)
 def VVzPoQ(self, VV5ybN, title, txt, colList):
  self.VVA4mR(VV5ybN, True)
 def VVA4mR(self, VV5ybN, isFromDetails=False):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  if VVDhju:
   if isFromDetails:
    VVDhju  = VVDhju.upper()
    parts  = VVDhju.split(":")
    Namespace = parts[6].zfill(8)
    SID   = parts[3].zfill(4)
    TSID  = parts[4].zfill(4)
    ONID  = parts[5].zfill(4)
    colDict  = { 0:VVeZBd, 5:Namespace, 6:SID, 7:TSID, 8:ONID }
    VV5ybN.VVdP7o(colDict, VVqUOx=True)
   else:
    VV5ybN.VVp9iQ(3, VVDhju, True)
   return
  FFU9uk(self, "Cannot read current Reference Code !")
 @FFHF2S(par=1)
 def VVCQNb(self, obj, title):
  self.VVnUmB = None
  self.lastfilterUsed  = None
  self.filterObj   = CCrT1G(self)
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVacfv)
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VV4dTm = (""    , self.VVlQtc , []      )
   VV5CrJ = ("Current Service", self.VVzPoQ  , []      )
   VVvrJb = ("Filter"   , self.VVh01i   , [], "Loading Filters ..." )
   VVI3Oq  = ("Zap"   , self.VVZSDp      , []      )
   header   = ("Name" , "Provider", "Type-Val", "Type" , "Sat.", "Namespace" ,"SID" , "TSID", "ONID" )
   widths   = (24  , 22  , 0   , 16  , 9  , 11   , 6  , 6  , 6    )
   VVgKQc  = (LEFT  , LEFT  , CENTER , CENTER , CENTER, CENTER  , CENTER, CENTER, CENTER )
   FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindServices)
 def VVlQtc(self, VV5ybN, title, txt, colList):
  VVDhju = self.VVZsxc(colList)
  self.VVqXNp(VV5ybN, title, txt + "Reference\t: %s" % VVDhju, colList[0], VVDhju)
 def VV2G9g(self, VV5ybN, title, txt, colList):
  self.VVqXNp(VV5ybN, title, txt, colList[0], colList[3])
 def VVqXNp(self, VV5ybN, title, txt, VVeZBd, VVDhju):
  rowNum = "Row: %s/%s" % (VV5ybN.VVfkJL() + 1, VV5ybN.VVJPu5())
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVzSKQ, params=(VVDhju, VVeZBd, rowNum, txt))
 def VVKvuJ(self, VV5ybN, title, txt, colList):
  CC2lVw.VVbVSZ(self.session, VV7GTU=colList[3], zapFnc=BF(self.VVLqHD, VV5ybN, 0))
 def VVZSDp(self, VV5ybN, title, txt, colList):
  CC2lVw.VVbVSZ(self.session, VV7GTU=self.VVZsxc(colList), zapFnc=BF(self.VVLqHD, VV5ybN, 1))
 def VVLqHD(self, VV5ybN, mode, val):
  if val == 1 : VV5ybN.VVVMkx()
  else  : VV5ybN.VVycmo()
  colList = VV5ybN.VVqY3Q()
  if mode == 1: VVDhju = self.VVZsxc(colList)
  else  : VVDhju = colList[3]
  return VVDhju
 def VVZsxc(self, colList):
  VVeZBd, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID = colList
  VVDhju = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0"))
  VVDhju = VVDhju.replace("::", ":0:")
  return VVDhju
 @staticmethod
 def VVTO22(VVAk7o, mode=0):
  lines = FF2iRW(VVAk7o, encLst=["UTF-8"])
  return CCAnLc.VVlZjh(lines, mode)
 @staticmethod
 def VVlZjh(lines, mode):
  lst = []
  header = "transponders" if mode < 10 else "services"
  if header in lines:
   lines = lines[lines.index(header) + 1:]
   if "end" in lines:
    lines = lines[:lines.index("end")]
    if len(lines) % 3 == 0:
     for i in range(0, len(lines), 3):
      if   mode in (0, 10): lst.append((lines[i], lines[i + 1], lines[i + 2]))
      elif mode in (1, 11): lst.append(lines[i].upper())
      elif mode in (2, 12): lst.append(lines[i + 1])
      elif mode in (3, 13): lst.append(lines[i + 2])
      elif mode == 14:
       span = iSearch(r"(\S+)\s+(PID)\s+(\d+)", lines[i + 1], IGNORECASE)
       if span:
        lst.append((lines[i], " ".join(span.groups()), lines[i + 2]))
  return lst
 @staticmethod
 def VVoyTU(VVAk7o):
  lines = FF2iRW(VVAk7o, encLst=["UTF-8"])
  topPart = []
  for ln in lines:
   if ln.strip() == "transponders": break
   topPart.append(ln)
  endPart = []
  for ln in lines[::-1]:
   if ln.strip() == "end": break
   endPart.insert(0, ln)
  tpLst = CCAnLc.VVlZjh(lines, mode=0)
  srvLst = CCAnLc.VVlZjh(lines, mode=10)
  return topPart, tpLst, srvLst, endPart
 @staticmethod
 def VV3WrY(VVAk7o, topPart, tpLst, srvLst, endPart):
  with open(VVAk7o, "w") as f:
   for ln in topPart: f.write("%s\n" % ln)
   f.write("transponders\n")
   for item in tpLst: f.write("%s\n%s\n%s\n" % item)
   f.write("end\n")
   f.write("services\n")
   for item in srvLst: f.write("%s\n%s\n%s\n" % item)
   f.write("end\n")
   for ln in endPart: f.write("%s\n" % ln)
 @staticmethod
 def VV0Bni(SELF, mode, VVpqim=None, VVAomI=True, VVw9e0=True):
  VVAk7o, err = CCAnLc.VVhMtJ(SELF, VVw9e0)
  if err:
   return None, err
  asPrefix = False
  if VVpqim:
   filterCol = VVpqim[0]
   filterWords = VVpqim[1]
   asPrefix = VVpqim[2]
   filterWords = list(filterWords)
   for ndx, item in enumerate(filterWords):
    filterWords[ndx] = item.strip().lower()
  else:
   filterWords = None
  if mode == CCAnLc.VVg33i:
   blackList = None
   if FFf0vs(VVlCrP):
    blackList = FF2iRW(VVlCrP)
    if blackList:
     blackList = set(blackList)
  elif mode == CCAnLc.VVy7Ye:
   tp = CCAAmm()
  VVUg5o, VVgAfG = FFhJdE()
  if mode in (CCAnLc.VVXIul, CCAnLc.VVV48d):
   VVJwgn = {}
  else:
   VVJwgn = []
  tagFound = False
  with ioOpen(VVAk7o, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end":
      break
     lines.append(line)
     if len(lines) >= 3:
      chCode = lines[0].upper()
      VVeZBd = lines[1]
      chProv = lines[2]
      if chCode.count(":") > 4 and not "," in chCode:
       parts  = chCode.split(":")
       SID   = parts[0]
       NameSpace = parts[1]
       TSID  = parts[2]
       ONID  = parts[3]
       STYPE  = parts[4]
      else:
       SID = NameSpace = TSID = ONID = STYPE = SNUM = VVDhju = ""
      chProvOrig = chProv
      if ","  in chProv : chProv = chProv.split(",")[0].strip()
      if "p:" in chProv : chProv = chProv.split("p:")[1].strip()
      if len(VVeZBd) == 0 : VVeZBd = "-"
      if len(chProv) == 0 : chProv = "-"
      s = NameSpace.zfill(8)[:4]
      val = int(s, 16)
      sat = FFhCU0(val)
      try:
       sTypeInt = int(STYPE)
       servTypeHex = (hex(sTypeInt))[2:].upper()
      except:
       sTypeInt = 0
       servTypeHex = "0"
      if mode == CCAnLc.VVacfv:
       if sTypeInt in VVUg5o:
        STYPE = VVgAfG[sTypeInt]
       tRow = (VVeZBd, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID)
       if filterWords:
        tmp = tRow[filterCol].lower()
        if asPrefix:
         if any(tmp.startswith(x) for x in filterWords) : VVJwgn.append(tRow)
        elif any(x in tmp for x in filterWords)    : VVJwgn.append(tRow)
       else:
        VVJwgn.append(tRow)
      else:
       VVDhju = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0") )
       VVDhju = VVDhju.replace("::", ":0:")
       if mode == CCAnLc.VVXIul:
        VVJwgn[VVDhju.replace(":", "_")] = (VVeZBd, sat, 1)
       elif mode == CCAnLc.VVV48d:
        VVJwgn[VVeZBd] = VVDhju
       elif mode == CCAnLc.VVg33i:
        if blackList and VVDhju + ":" in blackList : isBlackList = "Yes"
        else          : isBlackList = "No"
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2 : hidStr = "Yes"
        else          : hidStr =  "No"
        tRow = (VVeZBd, chProv, sat, VVDhju, isBlackList, hidStr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVJwgn.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVJwgn.append(tRow)
        else:
         VVJwgn.append(tRow)
       elif mode == CCAnLc.VVy7Ye:
        if sTypeInt in VVUg5o:
         STYPE = VVgAfG[sTypeInt]
        freq, pol, fec, sr, syst = tp.VVFGh6(VVDhju)
        if not "-S" in syst:
         sat = syst
        if freq == "-" : tpStr = "-"
        else   : tpStr = sat + " " + freq + " " + pol + " " + fec + " " + sr
        tRow = (VVeZBd, chProv, STYPE, VVDhju, sat, tpStr, freq, pol, fec, sr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVJwgn.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVJwgn.append(tRow)
        else:
         VVJwgn.append(tRow)
       elif mode == CCAnLc.VVE5s3:
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2:
         VVJwgn.append((VVeZBd, chProv, sat, VVDhju))
       elif mode == CCAnLc.VVSyjB:
        VVJwgn.append((VVeZBd, chProv, sat, VVDhju))
      lines = []
    elif line == "services":
     tagFound = True
  if not VVJwgn and VVAomI:
   FFU9uk(SELF, "No services found!")
  return VVJwgn, ""
 @staticmethod
 def VVRUpK(SELF, refLst):
  VVAk7o, err = CCAnLc.VVhMtJ(None, VVw9e0=False)
  if err: return 0, 0, 0, err
  topPart, tpLst, srvLst, endPart = CCAnLc.VVoyTU(VVAk7o)
  if not all((tpLst, srvLst)): return 0, 0, 0, "Lamedb List error"
  refLst = [x.rstrip(":").upper() for x in refLst]
  oldLen = len(srvLst)
  srvLst = [(chCd, chNm, chPr) for chCd, chNm, chPr in srvLst if CCAnLc.VV3HD0(chCd) not in refLst]
  totDb = oldLen - len(srvLst)
  if totDb: CCAnLc.VV3WrY(VVAk7o, topPart, tpLst, srvLst, endPart)
  totBouqF, totBouqLn = CCAnLc.VVkTIq(refLst)
  if any((totDb, totBouqF, totBouqLn)): FFfve1()
  return totDb, totBouqF, totBouqLn, ""
 @staticmethod
 def VVkTIq(refLst):
  totF = totDel = 0
  for path in CC41Tt.VVyuHO():
   lines1, lines2 = FF2iRW(path), []
   if not lines1: continue
   for line in lines1:
    span = iSearch(r"#SERVICE\s+((?:[A-Fa-f0-9]+:){10})$", line)
    if span and span.group(1).rstrip(":").upper() in refLst:
     totDel += 1
    else:
     lines2.append(line)
   if lines1 != lines2:
    totF += 1
    with open(path, "w") as f:
     f.write("\n".join(lines2) + "\n")
  return totF, totDel
 @FFHF2S(par=1)
 def VVsPkF(self, obj, title):
  if FFf0vs(VVlCrP):
   lines = FF2iRW(VVlCrP)
   if lines:
    newRows = []
    VVJwgn, err = CCAnLc.VV0Bni(self, self.VVSyjB)
    if VVJwgn:
     lines = set(lines)
     for item in VVJwgn:
      VVDhju = item[3] + ":"
      if VVDhju in lines:
       newRows.append((item[0], item[1], item[2], VVDhju))
     if newRows:
      VVJwgn = newRows
      VVJwgn.sort(key=lambda x: x[0].lower())
      VV4dTm = ("", self.VV2G9g, [])
      VVI3Oq  = ("Zap", self.VVKvuJ    , [])
      self.VVxIry(title, VVJwgn, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm)
     else:
      FFyijw(self, "No matching Reference Code found !\n\nPC Lines\t: %d\nLameDB\t: %d" % (len(lines), len(VVJwgn)))
   else:
    FFSQn9(self, "No active Parental Control services.", FFQfhO())
  else:
   FFbHk5(self, VVlCrP)
 @FFHF2S(par=1)
 def VVTyCa(self, obj, title):
  VVJwgn, err = CCAnLc.VV0Bni(self, self.VVE5s3)
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VV4dTm = ("" , self.VV2G9g , [])
   VVI3Oq  = ("Zap", self.VVKvuJ     , [])
   self.VVxIry(title, VVJwgn, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm)
  elif err:
   pass
  else:
   FFSQn9(self, "No hidden services.", FFQfhO())
 @FFHF2S()
 def VVU6Xn(self):
  title = "Services unused in Tuner Configuration"
  VVAk7o, err = CCAnLc.VVhMtJ(self, title=title)
  if err:
   return
  nsLst = set()
  usedSats = CCAnLc.VVyj7r()
  for tuner in usedSats:
   for item in tuner[1]:
    ns = self.VVpUPT(str(item[0]))
    nsLst.add(ns)
  sysLst = CCAnLc.VVLOo7("1:7:")
  tpLst  = CCAnLc.VVTO22(VVAk7o, mode=1)
  VVJwgn = []
  for VVDhju, VVeZBd in sysLst:
   servID = CCAnLc.VVpaww(VVDhju)
   tpID = CCAnLc.VVdLD0(VVDhju)
   refNs = VVDhju.split(":")[6].zfill(8)[:4]
   if not tpID in tpLst or not refNs in nsLst:
    VVJwgn.append((VVeZBd, FFkz1q(VVDhju, False), VVDhju, servID))
  if VVJwgn:
   VVJwgn.sort(key=lambda x: x[0].lower())
   VVbQ6N = ("Options"   , BF(self.VVUdwW, title), [])
   header   = ("Name" , "Media" , "Reference" , '"lamedb" Code' )
   widths   = (55  , 10  , 0    , 35    )
   VVgKQc  = (LEFT  , CENTER , LEFT   , CENTER   )
   FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVbQ6N=VVbQ6N, VVVzvS="#0a001122", VVhHWW="#0a001122", VVpaQ6="#0a001122", VVI4UA="#00004455", VVcv6F="#0a333333", VVsOjr="#11331100", VV7VIQ=CFG.lastFindServices)
  else:
   FFSQn9(self, "No invalid service found !", title=title)
 def VVUdwW(self, Title, VV5ybN, title, txt, colList):
  mSel = CCZALl(self, VV5ybN)
  isMulti = VV5ybN.VVbbT0
  if isMulti : txt = "Remove %s Services" % FFITtK(VV5ybN.VVQrKf(), VVu50a)
  else  : txt = "Remove : %s" % FFITtK(VV5ybN.VVqY3Q()[0], VVu50a)
  VVXXzc = [(txt, "del")]
  cbFncDict = {"del": BF(self.VVdgq6, VV5ybN, Title)}
  mSel.VVejOk(VVXXzc, cbFncDict)
 @FFHF2S(par=1)
 def VVdgq6(self, VV5ybN, title):
  VVAk7o, err = CCAnLc.VVhMtJ(self, title=title)
  if err:
   return
  isMulti = VV5ybN.VVbbT0
  skipLst = []
  if isMulti : skipLst = VV5ybN.VVaOdg(3)
  else  : skipLst = [VV5ybN.VVqY3Q()[3]]
  tpLst = CCAnLc.VVTO22(VVAk7o, mode=0)
  servLst = CCAnLc.VVTO22(VVAk7o, mode=10)
  tmpDbFile = VVAk7o + ".tmp"
  lines   = FF2iRW(VVAk7o)
  skip = False
  with open(tmpDbFile, "w") as f:
   for line in lines:
    tLine = line.strip()
    if tLine == "services":
     skip = True
     f.write(line + "\n")
     for item in servLst:
      if not item[0].upper() in skipLst:
       for L in item:
        f.write(L + "\n")
    elif skip and tLine == "end":
     skip = False
    if not skip:
     f.write(line + "\n")
  FF6usE("mv -f '%s' '%s'" % (tmpDbFile, VVAk7o))
  VVJwgn = []
  for row in VV5ybN.VVTq0J():
   if not row[3] in skipLst:
    VVJwgn.append(row)
  FFfve1()
  FFyijw(self, "Removed Services : %d" % len(skipLst), title="Remove Services")
  if VVJwgn:
   VV5ybN.VVxhz9(VVJwgn, title)
   VV5ybN.VVUVWk()
  else:
   VV5ybN.cancel()
 @FFHF2S(par=1)
 def VVZ9HU(self, obj, title):
  VVAk7o, err = CCAnLc.VVhMtJ(self)
  if err:
   return
  totT, totC, totA, totS, totS2, satList = self.VVkmet(VVAk7o)
  txt = FFITtK("Total Transponders:\n\n", VVi4ay)
  txt += "   DVB-S    Satellite\t: %d \n"  % totS
  txt += "   DVB-S2  Satellite\t: %d\n"  % totS2
  txt += "   DVB-T    Terrestrial\t: %d\n" % totT
  txt += "   DVB-C    Cable\t: %d\n"   % totC
  txt += "   DVB-A    ATSC\t: %d\n"   % totA
  if satList and len(satList) > 0:
   txt += FFITtK("\nSatellite Transponders (Total=%d):\n\n" % (totS + totS2), VVi4ay)
   uniqSat = []
   for sat in satList:
    if not sat in uniqSat:
     uniqSat.append(sat)
   uniqSat.sort(key=lambda x: int(x))
   for item in uniqSat:
    txt += "   %s\t: %d\n" % (FFOg1j(item), satList.count(item))
  FFyijw(self, txt, title)
 def VVkmet(self, VVAk7o):
  totT = totC = totA = totS = totS2 = 0
  satList = []
  tagFound = False
  with ioOpen(VVAk7o, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end"    : break
     elif line.startswith("t")  : totT += 1
     elif line.startswith("c")  : totC += 1
     elif line.startswith("a")  : totA += 1
     elif line.startswith("s"):
      c = line.count(":")
      if   c > 9: totS2 += 1
      elif c > 5: totS  += 1
      if c > 5:
       satList.append(line.split(":")[4])
    elif line == "transponders":
     tagFound = True
  return totT, totC, totA, totS, totS2, satList
 @FFHF2S(par=1)
 def VVQqqj(self, obj, title):
  p1 = "/etc/enigma2/satellites.xml"
  p2 = "/etc/tuxbox/satellites.xml"
  if   FFf0vs(p1) : path = p1
  elif FFf0vs(p2) : path = p2
  else    : path = ""
  if not path:
   FFbHk5(self, "%s\n.. or ..\n%s" % (p1, p2), title=title)
   return
  elif not CCQdsv.VVz66T(self, path, title):
   return
  if not CC6pkA.VV9n4c(self):
   return
  tree = CCAnLc.VVgNVP(self, path, title=title)
  if not tree:
   return
  VVJwgn = []
  root  = tree.getroot()
  totTpColor = "#f#00FFFF55#"
  for sat in root.findall("sat"):
   name = str(sat.get("name", "").encode("UTF-8").decode())
   pos  = sat.get("position", "")
   totTp = len(sat)
   hor = ver = cirL = cirR = unk = 0
   dvbS = dvbS2 = dvbUnk = 0
   for tp in sat.findall("transponder"):
    pol = tp.get("polarization")
    if   pol == "0" : hor += 1
    elif pol == "1" : ver += 1
    elif pol == "2" : cirL += 1
    elif pol == "3" : cirR += 1
    Sys = tp.get("system")
    if   Sys == "0" : dvbS += 1
    elif Sys == "1" : dvbS2 += 1
   try:
    posNum = int(pos)
    if posNum == 1801:
     posCalc = "180.1E"
    else:
     if posNum < 0:
      posNum += 3600
     posCalc = FFhCU0(posNum)
   except:
    posCalc = "?"
    pos  = "-9999"
   if " " in name : posXml, name = name.split(" ", 1)
   else   : posXml = posCalc
   bg = "" if posCalc.endswith("W") else "#b#00003333#"
   VVJwgn.append((bg + name, pos, posXml, posCalc, totTpColor + str(totTp), str(hor), str(ver), str(cirL), str(cirR), str(dvbS), str(dvbS2)))
  if VVJwgn:
   VVJwgn.sort(key=lambda x: int(x[1]))
   VV5CrJ = ("Current Satellite", BF(self.VV5WxN, 3), [])
   header   = ("Satellite" , "Pos #" , "xml Pos" , "Position", "TP" , "Hor" , "Ver" , "Circ-L" , "Circ-R" , "DVB-S" , "DVB-S2" )
   widths   = (36    , 8   , 0   , 10  , 6  , 5  , 5  , 7   , 7   , 8   , 8   )
   VVgKQc  = (LEFT   , CENTER , CENTER , CENTER , CENTER, CENTER, CENTER, CENTER , CENTER , CENTER , CENTER )
   FFdCaM(self, None, title=path, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=25, VV3dKD=1, VV5CrJ=VV5CrJ, VV7VIQ=CFG.lastFindSatName)
  else:
   FFU9uk(self, "No data found !", title=title)
 def VV5WxN(self, satCol, VV5ybN, title, txt, colList):
  sat = FFkz1q(CCaZ62(self.session).VVDhju, False)
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   if sat == row[satCol].strip():
    VV5ybN.VV43d2(ndx)
    break
  else:
   FF8PJn(VV5ybN, "Not in list", 1500)
 @FFHF2S()
 def VVIfYZ(self):
  satLst = nimmanager.getSatList()
  if not satLst:
   FFU9uk(self, "No Satellites found !")
   return
  usedSats = CCAnLc.VVyj7r()
  VVJwgn = []
  for sat in satLst:
   tunerLst = []
   for tuner, sats in usedSats:
    if sat in sats:
     tunerLst.append(tuner)
   tunerLst.sort()
   tuners = " , ".join(tunerLst) if tunerLst else ""
   posVal = sat[0]
   if posVal > 1800: posTxt = str(posVal - 3600)
   else   : posTxt = str(posVal)
   VVJwgn.append((sat[1], posTxt, FFhCU0(sat[0]), tuners, str(posVal)))
  if VVJwgn:
   VVpaQ6 = "#11222222"
   VVJwgn.sort(key=lambda x: int(x[1]))
   VV5CrJ = ("Current Satellite" , BF(self.VV5WxN, 2) , [])
   VVbQ6N = ("Options"   , self.VVd3W0  , [])
   header   = ("Satellite" , "Pos #" , "Position", "Tuners" , "posVal" )
   widths   = ( 50    , 10  , 10  , 30  , 0   )
   VVgKQc  = ( LEFT  , CENTER , CENTER , CENTER , CENTER )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=28, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVVzvS=VVpaQ6, VVhHWW=VVpaQ6, VVpaQ6=VVpaQ6, VVI4UA="#0a884400", VV7VIQ=CFG.lastFindSatName)
  else:
   FFU9uk(self, "No data found !")
 def VVd3W0(self, VV5ybN, title, txt, colList):
  mSel = CCZALl(self, VV5ybN)
  isMulti = VV5ybN.VVbbT0
  if isMulti : txt = "Remove ALL Services on %s Satellites" % FFITtK(VV5ybN.VVQrKf(), VVu50a)
  else  : txt = "Remove ALL Services on : %s" % FFITtK(VV5ybN.VVqY3Q()[0], VVu50a)
  VVXXzc = []
  VVXXzc.append((txt, "deleteSat"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Delete Empty Bouquets", "VVyJc6"))
  cbFncDict = { "deleteSat"   : BF(self.VVnbeO, VV5ybN)
     , "VVyJc6" : BF(self.VVyJc6, VV5ybN)
     }
  mSel.VVejOk(VVXXzc, cbFncDict)
 @FFHF2S(par=1)
 def VVnbeO(self, VV5ybN):
  posLst = []
  isMulti = VV5ybN.VVbbT0
  posLst = []
  if isMulti : posLst = VV5ybN.VVaOdg(4)
  else  : posLst = [VV5ybN.VVqY3Q()[4]]
  nsLst = []
  for pos in posLst:
   nsLst.append(self.VVpUPT(pos))
  db = eDVBDB.getInstance()
  if db:
   for pos in posLst:
    db.removeServices(-1, -1, -1, int(pos))
  totCh, totBoq = self.VVjTSV(nsLst)
  FFfve1(True)
  FFyijw(self, "Deleted Satellites:\n%d\n\nDeleted Services:\n%d\n\nCleaned Bouquets:\n%d" % (len(posLst), totCh, totBoq), title="Delete Satellites")
 def VVyJc6(self, winObj):
  title = "Delete Empty Bouquets"
  FFHsPu(self, BF(self.VV7uui, winObj, title), "Delete bouquets with no services ?", title=title)
 @FFHF2S(par=1)
 def VV7uui(self, winObj, title):
  bList = CC41Tt.VVXlbB()
  bNames = []
  if bList:
   fList = []
   for bName, bRef in bList:
    bFile = CC41Tt.VV790N(bRef)
    bPath = VVHX6T + bFile
    FFqlCI(bPath)
    bNames.append(bName)
    fList.append(bFile)
   if fList:
    for fil in ("bouquets.tv", "bouquets.radio"):
     path = VVHX6T + fil
     if FFf0vs(path):
      lines = FF2iRW(path)
      newLines = []
      for line in lines:
       for bFile in fList:
        if bFile in line:
         break
       else:
        newLines.append(line)
      if newLines:
       with open(path, "w") as f:
        f.write("\n".join(newLines) + "\n")
   FFfve1(True)
  if bNames: txt = "%s\n\n%s" % (FFITtK("Deleted Bouquets:", VV6UAe), "\n".join(bNames))
  else  : txt = "No empty bouquets."
  FFyijw(self, txt, title=title)
 def VVpUPT(self, pos):
  pos = int(pos.strip())
  if pos < 0:
   pos += 3600
  return ("%04x" % pos).upper()
 def VVjTSV(self, nsLst):
  totCh = totBoq = 0
  files = iGlob("%suserbouquet.*.tv" % VVHX6T)
  for srcF in files:
   if FFf0vs(srcF):
    lines = FF2iRW(srcF)
    newLines = []
    found = False
    for line in lines:
     span = iSearch(r"#SERVICE\s+((?:[A-Za-z0-9]+:){10})$", line, IGNORECASE)
     if span:
      ns = FFC21b(span.group(1))
      if ns in nsLst:
       found = True
       totCh += 1
       continue
     newLines.append(line)
    if found and newLines:
     totBoq += 1
     with open(srcF, "w") as f:
      f.write("\n".join(newLines) + "\n")
  return totCh, totBoq
 @FFHF2S(par=1)
 def VVUsWh(self, VVZzW8, title, isWithPIcons):
  piconsPath = CCUNc6.VVQ490()
  if VVrRHR(piconsPath):
   totalPicons = 0
   for fName, fType in CCUNc6.VVaXg8(piconsPath):
    if fName:
     totalPicons +=1
   if totalPicons > 0:
    VVJwgn, err = CCAnLc.VV0Bni(self, self.VVSyjB)
    if VVJwgn:
     channels = []
     for (VVeZBd, chProv, sat, VVDhju) in VVJwgn:
      fName = VVDhju.replace(":", "_") + ".png"
      pFile = FFrhwJ(piconsPath, fName)
      if isWithPIcons:
       if pFile:
        channels.append((VVeZBd, chProv, sat, VVDhju))
      else:
       if not pFile:
        channels.append((VVeZBd, chProv, sat, VVDhju))
     totalServices = len(VVJwgn)
     totalFound  = len(channels)
     if isWithPIcons:
      totalWithPIcons  = totalFound
      totalMissingPIcons = totalServices - totalWithPIcons
     else:
      totalMissingPIcons = totalFound
      totalWithPIcons  = totalServices - totalMissingPIcons
     def VVEQGt(key, val):
      return "%s\t\t: %s\n" % (key, str(val))
     txt = ""
     txt += VVEQGt("PIcons Path"  , piconsPath)
     txt += VVEQGt("Total PIcons" , totalPicons)
     txt += "\n"
     txt += VVEQGt("Total services" , totalServices)
     txt += VVEQGt("With PIcons"  , totalWithPIcons)
     txt += VVEQGt("Missing PIcons" , totalMissingPIcons)
     if totalFound == 0:
      FFyijw(self, txt)
     else:
      VV4dTm     = (""      , self.VV2G9g , [])
      if isWithPIcons : VVvrJb = ("Export Current PIcon", self.VVIK3x    , [])
      else   : VVvrJb = None
      VVbQ6N     = ("Statistics", FFyijw, [txt])
      VVI3Oq      = ("Zap", self.VVKvuJ, [])
      channels.sort(key=lambda x: x[0].lower())
      self.VVxIry(title, channels, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb)
   else:
    FFU9uk(self, "No picons found in path:\n\n%s" % piconsPath)
  else:
   FFU9uk(self, "PIcons path not found.\n\n%s" % piconsPath)
 def VVIK3x(self, VV5ybN, title, txt, colList):
  png, path = CCUNc6.VVJkx7(colList[3], colList[0])
  if path:
   CCUNc6.VVBH30(self, png, path)
 @staticmethod
 def VVg5A0():
  VVAk7o  = "%slamedb" % VVHX6T
  VVIPZs = "%slamedb.disabled" % VVHX6T
  return VVAk7o, VVIPZs
 @staticmethod
 def VVjPgr():
  VV5WDf  = "%slamedb5" % VVHX6T
  VVyiKw = "%slamedb5.disabled" % VVHX6T
  return VV5WDf, VVyiKw
 def VV4ysX(self, isEnable):
  VVAk7o, VVIPZs = CCAnLc.VVg5A0()
  if isEnable and not FFf0vs(VVIPZs):
   FFSQn9(self, "Already enabled.")
  elif not isEnable and not FFf0vs(VVAk7o):
   FFU9uk(self, "LameDB File not found!")
  else:
   if isEnable : word = "Enable"
   else  : word = "Disable"
   FFHsPu(self, BF(self.VVSjZW, isEnable), "%s Hidden Channels ?" % word)
 def VVSjZW(self, isEnable):
  VVAk7o , VVIPZs = CCAnLc.VVg5A0()
  VV5WDf, VVyiKw = CCAnLc.VVjPgr()
  cmd = ""
  if isEnable:
   word = "Enabled"
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVIPZs, VVIPZs, VVAk7o)
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVyiKw, VVyiKw, VV5WDf)
  else:
   word = "Disabled"
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVAk7o  , VVAk7o , VVIPZs)
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VV5WDf , VV5WDf, VVyiKw)
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVIPZs, VVAk7o )
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVyiKw, VV5WDf)
  ok = FF6usE(cmd)
  FFfve1()
  if ok: FFSQn9(self, "Hidden List %s" % word)
  else : FFU9uk(self, "Error while restoring:\n\n%s" % fileName)
 def VVsujF(self):
  cmd = ""
  cmd += "echo -e 'Reading current settings ...';"
  cmd += "cat %s | grep -v 'config.ParentalControl' > /tmp/settings_my_tmp.txt;" % VVrRe3
  cmd += "echo -e 'Applying new settings ...';"
  cmd += "mv /tmp/settings_my_tmp.txt %s" % VVrRe3
  FF4uzP(self, cmd)
 @FFHF2S()
 def VVGDoS(self):
  VVAk7o, err = CCAnLc.VVhMtJ(self)
  if err:
   return
  tmpFile = "/tmp/ajp_lamedb"
  FFqlCI(tmpFile)
  totChan = totRemoved = 0
  lines = FF2iRW(VVAk7o, keepends=True)
  with open(tmpFile, "w") as f:
   servFound = False
   servLines = []
   for line in lines:
    if servFound:
     if line.strip() == "end":
      f.write(line)
      break
     else:
      servLines.append(line)
      if len(servLines) == 3:
       if len(servLines[1].strip()) > 0:
        totChan += 1
        f.write(servLines[0])
        f.write(servLines[1])
        f.write(servLines[2])
       else:
        totRemoved += 1
       servLines = []
    else:
     f.write(line)
     if line.strip() == "services":
      servFound = True
  if totRemoved:
   FFHsPu(self, BF(self.VV2bCA, tmpFile, VVAk7o, totRemoved, totChan)
      , "Delete %d servce%s (out of %d service%s) ?" % (totRemoved, FFEnJs(totRemoved), totChan, FFEnJs(totChan))
      , callBack_No=BF(self.VVJhmG, tmpFile))
  else:
   FFyijw(self, "Total Channels\t: %d\nWith no names\t: %d" % (totChan, totRemoved))
 @FFHF2S()
 def VV2bCA(self, tmpFile, VVAk7o, totRemoved, totChan):
  FF6usE("mv -f '%s' '%s'" % (tmpFile, VVAk7o))
  FFfve1()
  FFyijw(self, "Total Channels\t: %d\nTotal Removed\t: %d" % (totChan, totRemoved))
 def VVJhmG(self, tmpFile):
  FFqlCI(tmpFile)
 @staticmethod
 def VVhMtJ(SELF, VVw9e0=True, title=""):
  VVAk7o, VVIPZs = CCAnLc.VVg5A0()
  if   not FFf0vs(VVAk7o)       : err = "File not found !\n\n%s" % VVAk7o
  elif not CCQdsv.VVz66T(SELF, VVAk7o) : err = "'lamedb' file is not in 'UTF-8' Encoding !"
  else             : err = ""
  if err and VVw9e0:
   FFU9uk(SELF, err, title=title)
  return VVAk7o, err
 @staticmethod
 def VVdLD0(VVDhju):
  _, flg, _, _, tsid, nid, ns, _, _, _ = VVDhju.rstrip(":").split(":")
  if flg == "0": return (":".join([ns.zfill(8), tsid.zfill(4), nid.zfill(4)])).upper()
  else   : return ""
 @staticmethod
 def VVpaww(VVDhju):
  _, flg, st, sid, tsid, nid, ns, _, _, _ = VVDhju.rstrip(":").split(":")
  if flg == "0": return (":".join([sid.zfill(4), ns.zfill(8), tsid.zfill(4), nid.zfill(4), str(int(st, 16)), "0", "0"])).upper()
  else   : return ""
 @staticmethod
 def VV3HD0(chCode):
  if chCode.count(":") > 4 and not "," in chCode:
   parts = chCode.split(":")
   SID  = parts[0].lstrip("0")
   NS  = parts[1].lstrip("0")
   TSID = parts[2].lstrip("0")
   ONID = parts[3].lstrip("0")
   STYPE = parts[4]
   try: sTyp = (hex(int(STYPE)))[2:].upper()
   except: sTyp = "0"
   return ("1:0:%s:%s:%s:%s:%s:0:0:0" % (sTyp, SID, TSID, ONID, NS)).replace("::", ":0:").upper()
  else:
   return ""
 @staticmethod
 def VVCPVx(lameDbServId):
  return ":".join(lameDbServId.rstrip(":").split(":")[1:4]).upper()
 @staticmethod
 def VVLOo7(servTypes):
  VVTQSe  = eServiceCenter.getInstance()
  VVeRD1   = '%s ORDER BY name' % servTypes
  VVr82X   = eServiceReference(VVeRD1)
  VVRBkR = VVTQSe.list(VVr82X)
  if VVRBkR: return VVRBkR.getContent("CN", False)
  else     : return []
 @staticmethod
 def VVyj7r():
  slotSats = []
  for slot in nimmanager.nim_slots:
   if slot.frontend_id is not None:
    lst = nimmanager.getSatListForNim(slot.frontend_id)
    if lst:
     slotSats.append((slot.getSlotName(), lst))
  return slotSats
 @staticmethod
 def VVzv7h(session):
  serv = session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   shown = InfoBar.instance.shown
   session.nav.stopService()
   session.nav.playService(serv)
   if not shown: InfoBar.instance.hide()
 @staticmethod
 def VV6w46():
  inst = InfoBar.instance
  return inst and hasattr(inst, "checkStreamrelay") or hasattr(inst, "ToggleStreamrelay")
 @staticmethod
 def VVXSpe():
  try:
   host = config.misc.softcam_streamrelay_url.value
   port = config.misc.softcam_streamrelay_port.value
   return host, port
  except:
   return "", ""
 @staticmethod
 def VV6meg():
  lst = []
  for line in FF2iRW(VVSz7C):
   line = line.strip()
   if iMatch(r"^((?:[A-Fa-f0-9]+:){10})$", line):
    lst.append(line.rstrip(":").upper())
  return lst
 @staticmethod
 def VV5llI(r, unknown="?"):
  serv = eServiceReference(r)
  if serv:
   path = serv.getPath()
   if not path     : return FFkz1q(r, False)
   elif path.startswith("/") : return "Local"
   elif FFOr4F(r)  : return "Stream Relay"
   elif FFPrVr(r)    : return "IPTV"
  return unknown
 @staticmethod
 def VVLTHQ():
  try: InfoBar.instance.openServiceList()
  except: pass
 @staticmethod
 def VVRKt9():
  inst = InfoBar.instance
  csel = inst and inst.servicelist
  if csel : return csel.lastroot.getValue(), csel.lastservice.getValue()
  else : return "", ""
 @staticmethod
 def VVZ1of():
  try: return [serv[-1] for serv in InfoBar.instance.servicelist.history]
  except: return []
 @staticmethod
 def VV59Kt(session, skipServ=None, mode=0):
  skipServ = skipServ or eServiceReference("")
  hLst = list(reversed(CCAnLc.VVZ1of()))
  if mode in (0, 1):
   for srv in hLst:
    if not srv.getPath().startswith(("/", "http")) and srv != skipServ:
     FFi8da(session, srv)
     return srv
  if mode in (0, 2):
   for srv in hLst:
    if not srv.getPath().startswith("/") and srv != skipServ:
     FFi8da(session, srv)
     return srv
  return None
class CC8eoU():
 def __init__(self, gapX=0, gapY=0):
  self.VVkI5D  = []
  self["myPicF"]   = Label()
  self["myPicB"]   = Label()
  self["myPic"]   = Pixmap()
  self.VVykua()
  x, y, w, h = self.VVuaAL["retPar"]
  x -= gapX
  y += gapY
  self.VVkI5D = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
 def VVQdSA(self, gapX, gapY):
  x, y, w, h = self.VVkI5D[2]
  x -= gapX
  y += gapY
  self.VVkI5D = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
 def VVpLGs(self, path):
  self.VVykua()
  if not (os.path.isfile(path) and CCf9Gq.VVl2HO(path) == "pic"):
   return False
  sz = FFX42v(path)
  if sz == 0:
   self.VVtwAl()
   return  False
  x, y, w, h = self.VVkI5D[2]
  right = x + w
  newW, newH, err = CCHa3c.VVDhWu(path)
  if not err:
   x1, y1, w, h = CCofSh.VVKT8T(newW, newH, w, h)
   if newH > newW:
    w, h = int(w * 1.6), int(h * 1.6)
   x = right - w
  self.VVY7nx(x, y, w, h)
  if FFlfvg(self["myPic"], path, fncCb_fail=self.VVtwAl):
   self.VVGezL()
   return True
  else:
   self.VVtwAl()
   return False
 def VVtwAl(self):
  self.VVykua()
  if FFgfSp(self["myPic"], "noPic"):
   x, y, w, h = self.VVkI5D[2]
   right = x + w
   w = h
   x = right - w
   self.VVY7nx(x, y, w, h)
   self.VVGezL()
 def VVY7nx(self, x, y, w, h):
  for i, obj in enumerate(self.VVuKSE()):
   if i == 0: x1, y1, w1, h1 = x-1, y-1, w+2, h+2
   else  : x1, y1, w1, h1 = x, y, w, h
   if all((x, y, w, h)):
    obj.instance.move(ePoint(int(x1), int(y1)))
    obj.instance.resize(eSize(*(int(w1), int(h1))))
 def VVuKSE(self):
  return [self[x] for x in ("myPicF", "myPicB", "myPic")]
 def VVGezL(self):
  try:
   for w in self.VVuKSE(): w.show()
  except:
   pass
 def VVykua(self):
  for w in self.VVuKSE(): w.hide()
 def VVipBn(self):
  return self["myPicF"].getVisible()
 def VV8KT2(self):
  return self["myPicF"].instance.size().height() if self.VVipBn() else 0
class CCISy5(Screen, CC8eoU):
 VVn7qY  = 0
 VVzSKQ    = 1
 VVyuhj    = 2
 VVgoj6   = 3
 VVxMle   = 4
 VVeEZ1   = 5
 VV5I8H    = 6
 VVLJNL    = 7
 VVez6E   = 8
 VVf7U2   = 9
 VVLF91   = 10
 VVnRAJ   = 11
 VVoTT4   = 12
 VVQZSA   = 13
 def __init__(self, session, VVjex7, title="", params=None, VVthiO=""):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1400, 1000, 50, 30, 10, "#05001921", "#05001921", 30, VVFHRx=(0, 0))
  self.session  = session
  self.VVjex7  = VVjex7
  self.Title   = title or "Service Info."
  self.params   = params
  self.VV3GYN  = None
  self.VVDhju  = ""
  self.VV5zMI  = ""
  self.VVu69c  = ""
  self.VVLZ0Z  = ""
  self.VVeZBd   = ""
  self.VVpSJG = ""
  self.VVKCwZ   = ""
  self.VVthiO  = VVthiO
  self.VVkthy  = ""
  self.chUrl   = ""
  self.VV3wvd = ""
  self.VVBMKy  = False
  self.VVhwjM  = ""
  self.VVdgGP  = ""
  self.VV0ZeP  = ""
  self.VViWtB  = ""
  self.VVyk4Y  = False
  self.VVitRU = False
  self.Sep   = FFITtK("%s\n", VVgzFX) % SEP
  self.VV4qKH = eTimer()
  FFfmZP(self, title=self.Title + FFITtK("    Processing ...", VVgzFX), addScrollLabel=True)
  CC8eoU.__init__(self)
  FFyNtd(self,
  {
   "info" : self.VVhuem ,
   "ok" : self.cancel   ,
   "cancel": self.cancel
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VVUrKi="chann_info")
  if   self.VVjex7 == self.VVn7qY : fnc = self.VVkzfs
  elif self.VVjex7 == self.VVzSKQ  : fnc = self.VVlkKU
  elif self.VVjex7 == self.VVyuhj  : fnc = self.VVTeSO
  elif self.VVjex7 == self.VVgoj6  : fnc = self.VVnGJA
  elif self.VVjex7 == self.VVxMle : fnc = self.VV8Zf1
  elif self.VVjex7 == self.VVeEZ1  : fnc = self.VVYEeh
  elif self.VVjex7 == self.VV5I8H  : fnc = self.VVOCr2
  elif self.VVjex7 == self.VVLJNL  : fnc = self.VVGieW
  elif self.VVjex7 == self.VVez6E  : fnc = self.VV5Poc
  elif self.VVjex7 == self.VVf7U2 : fnc = self.VVmKRJ
  elif self.VVjex7 == self.VVLF91  : fnc = self.VVb2wK
  elif self.VVjex7 == self.VVnRAJ : fnc = self.VV4F6V
  elif self.VVjex7 == self.VVoTT4 : fnc = self.VV9n5G
  elif self.VVjex7 == self.VVQZSA  : fnc = self.VVpFp5
  try: self.VV4qKH_conn = self.VV4qKH.timeout.connect(self.VVWsdQ)
  except: self.VV4qKH.callback.append(self.VVWsdQ)
  self.VV4qKH.start(50, False)
  self["myLabel"].setText("\n   Reading Info ...")
  self["myLabel"].VVNtRi()
  FFDiNL(fnc)
 def onExit(self):
  self.VV4qKH.stop()
 def cancel(self):
  if self.VVitRU:
   self.close()
 def VVkzfs(self):
  try: dum = self.session
  except: return
  s = CCaZ62(self.session)
  if not s.info:
   self.VVXm51()
   self.VVyk4Y = self.VVitRU = True
   return
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  self.VVpSJG = fPath
  self.VV3GYN  = s.info
  self.VVDhju  = s.VVDhju
  self.VV5zMI  = s.VV5zMI
  self.VVLZ0Z  = s.VVLZ0Z
  self.VVeZBd   = s.VVeZBd
  self.VVhwjM  = self.VVHjcO(s)
  self.VV0Azj(s.VVu69c)
 def VVlkKU(self):
  self.VVDhju, self.VVeZBd, rowNum, VVkthy = self.params
  self.Title += " " * 20 + rowNum
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  if VVDhju == self.VVDhju:
   self.VVkzfs()
  else:
   self.VVkthy = VVkthy
   self.VV0Azj(self.VVDhju)
 def VVTeSO(self):
  self.VVDhju, self.VVeZBd, self.VVkthy = self.params
  self.VV0Azj(self.VVDhju)
 def VVnGJA(self):
  self.VVDhju, self.VVeZBd, self.VVkthy = self.params
  self.VV0Azj(self.VVDhju)
 def VV8Zf1(self):
  self.VVDhju, self.VVeZBd, self.VVkthy = self.params
  self.VV0Azj()
 def VVYEeh(self):
  self.VVDhju, self.VVeZBd, self.VVkthy, self.VVthiO = self.params
  self.VV0Azj()
 def VVOCr2(self):
  self.VVDhju, self.VVeZBd, self.VVkthy, self.VVu69c, self.VVLZ0Z = self.params
  self.VV0Azj(self.VVLZ0Z)
 def VVGieW(self):
  self.VVu69c, self.VVeZBd, self.VVkthy, self.VVKCwZ = self.params
  self.VV0Azj()
 def VV5Poc(self):
  self.VVDhju, self.VVeZBd, self.VVkthy, self.chUrl, self.VVKCwZ = self.params
  self.VV0Azj(self.chUrl)
 def VVmKRJ(self):
  self.VVeZBd, self.VVkthy, self.VVKCwZ = self.params
  self.VV0Azj()
 def VVb2wK(self):
  self.VVDhju, self.chUrl, self.VVeZBd, self.VVkthy, self.VVKCwZ = self.params
  self.VV0Azj(self.chUrl)
 def VV4F6V(self):
  self.VVeZBd, self.VVkthy, self.VVKCwZ = self.params
  self.VV0Azj()
 def VV9n5G(self):
  self.VVkthy, self.VVthiO = self.params
  self.VV0Azj()
 def VVpFp5(self):
  self.VVkthy, self.VVKCwZ = self.params
  self.VVKCwZ = FF0rS9(self.VVKCwZ)
  self.VV0Azj()
 def VVWsdQ(self):
  if self.VVyk4Y:
   self["myTitle"].setText("  %s" % self.Title)
   self.VV4qKH.stop()
  if self.VVdgGP:
   txt, self.VVdgGP = self.VVdgGP, ""
   txt = self["myLabel"].getText().strip() + "\n\n" + txt.strip()
   self["myLabel"].setText("\n" + txt, VVPsQd=VV73ng)
   self.VVRy3V()
  if self.VV0ZeP:
   evLst, self.VV0ZeP = self.VV0ZeP, ""
   self.VVyO07(evLst)
  if self.VViWtB:
   path, self.VViWtB = self.VViWtB, ""
   self.VVBMKy = self.VVpvHT(path)
   self.VVwJQk(path)
 def VVXm51(self):
  txt = self.VVkthy.strip()
  cTxt = self.VVhwjM.strip()
  if txt and cTxt : txt += "\n\n%s\n%s" % (self.Sep, cTxt)
  else   : txt += cTxt
  self["myLabel"].setText(txt or "No active service", VVPsQd=VV73ng)
  self.VVRy3V()
 def VVRy3V(self):
  self["myLabel"].VVNtRi(minHeight=self.VV8KT2())
 def VVpvHT(self, path):
  isOk = self.VVpLGs(path)
  if isOk:
   self.VVRy3V()
  return isOk
 def VV0Azj(self, ref=""):
  if ref:
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})*(.+\/\/.+)", ref)
   if span:
    self.VV3wvd = FF0rS9(span.group(1))
    self.VVu69c = FF0rS9(span.group(2))
  if not self.VV3wvd:
   self.VV3wvd = CCISy5.VVqZxY(self.VVDhju) or CCISy5.VVqZxY(self.VVLZ0Z)
  if self.VVu69c and not "URL:" in self.VVhwjM and not "URL:" in self.VVkthy:
   self.VVkthy = self.VVkthy.rstrip() + "\n\nURL:\n%s\n" % FFITtK(CCISy5.VVPWbb(self.VVu69c), VVVAvR)
  self.VVXm51()
  FFDiNL(self.VVVITw)
 def VVVITw(self):
  if not self.VVBMKy and self.VVthiO:
   self.VVBMKy = self.VVpvHT(self.VVthiO)
  if not self.VVBMKy and self.VVDhju:
   png, path = CCUNc6.VVJkx7(self.VVDhju, self.VVeZBd)
   if png: self.VVBMKy = self.VVpvHT(path)
  if not self.VVBMKy and self.VV5zMI:
   png, path = CCUNc6.VVJkx7(self.VV5zMI, self.VVeZBd)
   if png: self.VVBMKy = self.VVpvHT(path)
  FFDiNL(self.VV3aEM)
 def VV3aEM(self):
  VVqL9w = CCfClD.VVu9S1(self.VVDhju)
  if VVqL9w: VVEgnI = []
  else  : VVEgnI = CCfClD.VVpLAz(self.VV3GYN, self.VVDhju)
  iThread(name="ajp_info_pic", target=BF(self.VVQmS8, VVqL9w, VVEgnI)).start()
  self.VVitRU = True
 def VVQmS8(self, VVqL9w, VVEgnI):
  try:
   title = FFiN5A("EPG:", VV6UAe)
   epg = ""
   evLst = []
   netOk = CChg05.VVIg8w
   if netOk:
    self.VVOT8C(self.VVKCwZ)
    if self.VVu69c:
     epg, evLst, VVKCwZ, err = CCISy5.VV5pXU(self.VVu69c)
     self.VVOT8C(VVKCwZ)
    if not epg and self.VVu69c:
     epg, evLst, err = CCSB3R.VVgEQj(self.VVu69c)
    if epg : self.VVdgGP = title + epg
    if evLst: self.VV0ZeP = evLst
   if not epg and (VVqL9w or VVEgnI):
    if   not netOk  : totTr = 0
    elif VVqL9w  : totTr = 2
    elif VVEgnI : totTr = 2
    self.VVdgGP = title + CCfClD.VVTHDW(VVqL9w or VVEgnI, totTr)
   self.VVzb3f()
  except:
   pass
  self.VVyk4Y = True
 def VVzb3f(self):
  txt = ""
  if self.VVpSJG:
   txt = CCHa3c.VVbBnJ(self.VVpSJG)
  elif self.VVu69c and self.VVeZBd:
   path, headers = CCHa3c.VVp5GZ(self.VVu69c, self.VVeZBd)
   if path:
    txt = CCHa3c.VVbBnJ(path, headers)
  if txt:
   self.VVdgGP = txt
 @staticmethod
 def VV5pXU(VVu69c):
  if "chCode" in VVu69c:
   p = CCNREC()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
   uHost = uUser = uPass = uId = ""
   p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCNREC.VVMjLY(host=host, mac=mac, ph1=ph1)
   if all((pHost, pUser, pPass, stID)) : uType, uHost, uUser, uPass, uId = mode, pHost, pUser, pPass, stID
   else        : return "", "", "", "No EPG (invalid URL) !"
  else:
   uType, uHost, uUser, uPass, uId, uChName = CCSB3R.VVsV5B(VVu69c)
   if not all([uHost, uUser, uPass, uId]):
    return "", "", "", "No EPG (invalid URL) !"
   span = iSearch(r"S\d{2,3}E\d{2,3} \((.+)\)", uChName)
   catID = span.group(1) if span else ""
  qUrl = "%s/player_api.php?username=%s&password=%s&action=" % (uHost, uUser, uPass)
  if   uType in ("live", "itv") : qUrl += "get_simple_data_table&stream_id=%s" % (uId)
  elif uType in ("movie", "vod") : qUrl += "get_vod_info&vod_id=%s" % (uId)
  elif uType == "series" and catID: qUrl += "get_series_info&series_id=%s" % (catID)
  else       : return "", "", "", "Cannot process this channels"
  txt, err = CCSB3R.VVEL0f(qUrl, timeout=3)
  if err: return "", "", "", "No EPG from server (%s)" % err
  epg = VVKCwZ = ""
  evLst = []
  if   uType in ("live", "itv") : epg, evLst, err = CCSB3R.VVCHJ7(txt, mode=3)
  elif uType in ("movie", "vod") : epg, VVKCwZ, err = CCSB3R.VVBQm9(txt)
  elif uType == "series"   : epg, VVKCwZ, err = CCSB3R.VVwOIV(txt, VVu69c)
  err = "" if epg else "No EPG from server !"
  return epg, evLst, VVKCwZ, err
 def VVOT8C(self, url):
  if url and not self.VVBMKy:
   path, err = FFEyUQ(url, "ajp_tmp.png", timeout=2, VVtOxO=True)
   if path:
    self.VViWtB = path
 def VVyO07(self, evLst):
  if self.VV3wvd and evLst:
   totEv, totOK = CCfClD.VVDV4n(self.VV3wvd, evLst, longDescDays=7)
   if totOK > 0:
    CCfClD.VVLWv9()
 def VVwJQk(self, path):
  if self.VVBMKy and self.VV3wvd and FFf0vs(path) and FFsGnd("ffmpeg"):
   pPath = CCUNc6.VVQ490()
   if VVrRHR(pPath):
    picon = self.VV3wvd.replace(":", "_") + ".png"
    cmd = CCISy5.VVomfz(path)
    cmd += FFDTPf("mv -f '%s' '%s%s'" % (path, pPath, picon))
    FF6usE(cmd)
 def VVHjcO(self, s):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Service Name", FFITtK(s.VVeZBd, VV6UAe))
  txt += tab("Channel Num", s.chNum) if s.chNum > 0 else ""
  txt += tab("Provider" , s.prov) if s.prov else ""
  if s.state: txt += tab("State", (FFITtK(s.state.replace("*", ""), VVcahY) if s.state.startswith("*") else s.state))
  vRes = CCISy5.VVIQXr(s.info)
  if vRes: txt += tab("Dimensions", vRes)
  aspect = self.VVT43R(s.info)
  if aspect: txt += tab("Video Format", aspect)
  txt += self.VVEQGt(s.info, "Video Type", iServiceInformation.sVideoType, 4)
  rate = FF7SHi(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   txt += "Frame Rate\t: %s\n" % rate
  if FFSeHR(s.info, iServiceInformation.sIsCrypted) == "1":
   txt += "Crypted\t: Yes\n"
  tot = CCISy5.VVGOEp(self.session)
  if tot > -1: txt += tab("Audio Tracks", tot)
  tot = CCISy5.VVF21Q()
  if tot > -1: txt += tab("Subtitles", tot)
  fPath, fDir, fName, picFile = CCISy5.VV9Ly5(self)
  isLocal = False
  isIptv  = len(s.VVLZ0Z) > 0
  if isIptv:
   txt += tab("Service Type", FFITtK("Stream-Relay" if FFOr4F(s.VVu69c) else "IPTV", VVi4ay))
   if s.VVDhju and s.VV5zMI and s.VVDhju != s.VV5zMI:
    txt += tab("S. Relay Ref.", s.VV5zMI)
   txt += CCISy5.VVZUMN(s.VVLZ0Z)
  elif fPath:
   isLocal = True
   txt += tab("Reference", s.VV6phL)
   txt += tab("Service Type", "Local Recording")
   txt += tab("File", fName)
   txt += tab("Directory", fDir)
   if FFf0vs(picFile):
    self.VVthiO = picFile
  elif s.VVDhju:
   txt += tab("Reference", s.VVDhju)
  if s.VVDhju.startswith("1:64:"):
   return txt
  if not isLocal or s.VVDhju.endswith(":" + s.VVeZBd):
   bouq = self.VVHGQa(s.VVDhju, s.VV5zMI, s.VVLZ0Z, s.VVeZBd)
   if bouq:
    txt += "\n" + bouq
  if not isLocal and not isIptv or s.VV5zMI:
   txt += "\n"
   txt += self.Sep
   namespace = None
   if s.VVDhju:
    tp = CCAAmm()
    tpTxt, namespace = tp.VVPHbt([s.VVDhju, s.VV5zMI])
    if tpTxt:
     txt += FFITtK("Tuner:\n", VV6UAe)
     txt += tpTxt
     txt += "\n"
     txt += self.Sep
   txt += FFITtK("Codes:\n", VV6UAe)
   if namespace: txt += "Namespace\t: %s\n" % namespace
   else  : txt += self.VVEQGt(s.info, "Namespace", iServiceInformation.sNamespace, 1, 8)
   txt += self.VVEQGt(s.info, "Video PID" , iServiceInformation.sVideoPID , 2, 4)
   txt += self.VVEQGt(s.info, "Audio PID" , iServiceInformation.sAudioPID , 2, 4)
   txt += self.VVEQGt(s.info, "PCR PID" , iServiceInformation.sPCRPID , 2, 4)
   txt += self.VVEQGt(s.info, "PMT PID" , iServiceInformation.sPMTPID , 2, 4)
   txt += self.VVEQGt(s.info, "TXT PID" , iServiceInformation.sTXTPID , 2, 4)
   txt += self.VVEQGt(s.info, "SID"  , iServiceInformation.sSID  , 2, 4)
   txt += self.VVEQGt(s.info, "ONID"  , iServiceInformation.sONID  , 2, 4)
   txt += self.VVEQGt(s.info, "TSID"  , iServiceInformation.sTSID  , 2, 4)
  return txt
 def VVEQGt(self, info, name, what, mode=0, digits=0):
  tab = "\t"
  txt = str(FF7SHi(info, what))
  if len(txt) > 0:
   try  : hexVal = hex(int(txt))[2:].upper()
   except : hexVal = ""
   if digits > 0:
    hexVal = hexVal.zfill(digits)
   if   mode == 1     : txt = hexVal
   elif mode == 2     : txt = "%s\tdec: %s" % (hexVal, txt)
   elif mode == 3     : txt = "Yes" if txt=="1" else "No"
   elif mode == 4     : txt = self.VV1UCT(txt)
   if txt : return "%s%s: %s\n" % (name, tab, txt)
   else : return ""
  else:
   return ""
 def VV1UCT(self, sVideoType):
  codec_data = { -1: "", 0: "MPEG-2", 1: "H.264 (MPEG-4 AVC)", 2: "H.263", 3: "VC1", 4: "MPEG-4 (VC)", 5: "VC1-SM", 6: "MPEG-1", 7: "H.265 (HEVC)", 8: "VP8", 9: "VP9", 10: "XVID", 11: "11", 12: "12", 13: "DIVX 3.11", 14: "DIVX 4", 15: "DIVX 5", 16: "AVS", 17: "17", 18: "VP6", 19: "19", 20: "20", 21: "SPARK" }
  return codec_data.get(int(sVideoType), "")
 def VVHGQa(self, VVDhju, sRelRef, VVLZ0Z, VVeZBd):
  VVDhju = FFKQxn(VVDhju, VVLZ0Z, VVeZBd)
  if not VVDhju:
   return ""
  fList = []
  txt = FF05rJ(VVHX6T + "bouquets.tv")
  list =  iFindall(r"(userbouquet[.].*[.]tv)", txt, IGNORECASE)
  if list: fList += list
  txt = FF05rJ(VVHX6T + "bouquets.radio")
  list =  iFindall(r"(userbouquet[.].*[.]radio)", txt, IGNORECASE)
  if list: fList.extend(list)
  VV5dDF = []
  ref1 = FF0rS9(VVDhju)
  for item in fList:
   path = VVHX6T + item
   if FFf0vs(path):
    txt = FF0rS9(FF05rJ(path))
    if ref1 in txt or sRelRef and sRelRef in txt:
     span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
     if span : bName = span.group(1)
     else : bName = "[ No Name ]"
     VV5dDF.append((bName, os.path.basename(path)))
  if not VV5dDF:
   return ""
  txt = self.Sep
  if len(VV5dDF) == 1:
   txt += "%s\t: %s%s\n" % (FFITtK("Bouquet", VV6UAe), VV5dDF[0][0], " (%s)" % VV5dDF[0][1] if VVd25Y else "")
  else:
   txt += FFITtK("Bouquets:\n", VV6UAe)
   for ndx, item in enumerate(VV5dDF):
    txt += "%d- %s%s\n" % (ndx + 1, item[0].strip(), " (%s)" % item[1] if VVd25Y else "")
  return txt
 def VVhuem(self):
  if not VVpSLv:
   return
  def VVEQGt(key, val):
   return "%s= %s\n" % (key.ljust(12), val)
  txt = ""
  s = CCaZ62(self.session)
  n = ("VVDhju", "VVu69c", "VVQwVu", "VVLZ0Z", "VVeZBd", "prov", "state")
  v = (s.VVDhju, s.VVu69c, s.VVQwVu, s.VVLZ0Z, s.VVeZBd, s.prov, s.state)
  for i in range(len(n)):
   txt += VVEQGt(n[i], v[i])
  if "chCode" in s.VVLZ0Z:
   p = CCNREC()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(s.VVu69c)
   n = ("valid", "ph1", "playHost", "mode", "host", "mac", "epNum", "epId", "chCm", "query")
   v = (valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, query)
   for i in range(len(n)):
    txt += VVEQGt(n[i], v[i])
  path = "/tmp/ajp_channel_details"
  with open(path, "a") as f:
   f.write("%s\n%s\n" % (SEP, txt))
  FF8PJn(self, "Saved to : %s" % path, 1000)
 @staticmethod
 @FFHF2S("Checking Server")
 def VVrTOV(SELF):
  if not CC5ENZ.VVPib3(SELF):
   return
  title = "File Size"
  fSize = "Not received from server"
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(SELF)
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(SELF)
  err = url =  fSize = resumable = ""
  if VVu69c and seekable == 3 and durVal > 0:
   url = iSub(r"[&?]mode=.+end=", r"", VVu69c, flags=IGNORECASE)
   url = iSub(r"[?]play_token.+", r"", url, flags=IGNORECASE)
   if url.endswith(":" + VVeZBd):
    url = url[:-(len(VVeZBd) + 1)]
   if "chCode" in VVu69c:
    url = CCNREC.VVYuvG(VVu69c)
   try:
    import requests
    resp = requests.get(url, headers=CCSB3R.VVY3r9(), timeout=4, stream=True, verify=False)
    if not resp.ok:
     FFU9uk(SELF, "Err-%d : %s" % (resp.status_code, resp.reason), title=title)
     return
    hSize = resp.headers.get("Content-Length", "")
    if hSize and hSize.isdigit():
     size = int(hSize)
     fSize = CCQdsv.VVAcha(size)
     if "vnd.apple" in resp.headers.get("content-type", ""):
      fSize += FFITtK(" (M3U/M3U8 File)", VVVAvR)
    else:
     fSize = "No info. from server. Try again later."
    resumable = "Yes" if CChTrx.VVAvee(resp) else "No"
   except requests.Timeout as e: err = "Connection Timeout"
   except      : err = "Connection Error"
  else:
   err = "Not a Movie/Series !"
  def VV2MoW(subj, val):
   return "%s\n%s\n\n" % (FFITtK("%s:" % subj, VV6UAe), val)
  title = "File Size"
  txt  = VV2MoW(title , fSize or "?")
  txt += VV2MoW("Name" , VVeZBd)
  txt += VV2MoW("URL" , url)
  if resumable: txt += VV2MoW("Supports Download-Resume", resumable)
  if err  : txt += FFITtK("Error:\n", VVcahY) + err
  FFyijw(SELF, txt, title=title)
 @staticmethod
 def VV9Ly5(SELF):
  fPath, fDir, fName = CCQdsv.VVZTzJ(SELF)
  if fPath:
   fPic = CCISy5.VVj2eY(fPath)
   return fPath, fDir, fName, fPic
  else:
   return "", "", "", ""
 @staticmethod
 def VVj2eY(path):
  p = os.path.splitext(path)[0]
  for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
   pic = "%s.%s" % (p, ext)
   if FFf0vs(pic):
    return pic
  return ""
 @staticmethod
 def VVomfz(path, maxW=132):
  return FFDTPf("ffmpeg -y -i '%s' -vf scale=-1:%d '%s'" % (path, maxW, path))
 @staticmethod
 def VVD1E7(VVDhju):
  VVDhju = CCISy5.VVqZxY(VVDhju)
  if VVDhju : return CCUNc6.VVQ490() + VVDhju.replace(":", "_").upper() + ".png"
  else  : return ""
 @staticmethod
 def VVqZxY(VVDhju):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVDhju, IGNORECASE)
  return span.group(1).upper() if span else ""
 @staticmethod
 def VVPWbb(url):
  if not FFOr4F(url):
   span = iSearch(r"(?:[A-Fa-f0-9]+[:]){10}(.+)", url, IGNORECASE)
   if span:
    url = span.group(1)
   if not VVpSLv:
    url = iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
  return FF0rS9(url)
 @staticmethod
 def VVZUMN(VVDhju, showUrl=True):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z = CCaZ62.VVXPhc(VVDhju)
  if VVu69c:
   txt = "Reference\t: %s\n" % VVDhju
   p = CCNREC()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
   if valid:
    txt += "Portal Host\t: %s\n" % host
    txt += "Portal MAC\t: %s\n"  % mac
    txt += "Portal Mode\t: %s\n" % {"itv":"Live", "vod":"VOD", "series":"Series"}.get(mode, "?")
   if showUrl:
    txt += "\n"
    txt += FFITtK("URL:", VVi4ay) + "\n%s\n" % CCISy5.VVPWbb(VVu69c)
  else:
   txt = "\n"
   txt += FFITtK("Reference:", VVi4ay) + "\n%s\n" % VVDhju
  return txt
 @staticmethod
 def VVIXmT(SELF, **kwargs):
  cbFnc = kwargs.pop("cbFnc", None)
  SELF.session.openWithCallback(cbFnc, CCISy5, **kwargs)
 @staticmethod
 def VViCdN(session):
  session.open(CCISy5, VVjex7=CCISy5.VVn7qY)
 @staticmethod
 def VVF21Q():
  try: return len(InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList())
  except: return -1
 @staticmethod
 def VVaEpg():
  try: lst = InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList() or []
  except: lst = []
  tEmb = tFil = 0
  for item in lst:
   if len(item) >= 5:
    typ, src = item[0], item[2]
    if  typ == 0: tEmb += 1
    elif typ == 1: tEmb += 1
    elif typ == 2:
     if  src == 1  : tEmb += 1
     elif 2 <= src <= 6 : tFil += 1
  if   tEmb and not tFil : return 1
  if   tFil and not tEmb : return 2
  elif tFil and tEmb  : return 3
  else     : return 0
 @staticmethod
 def VVGOEp(session):
  try: return session.nav.getCurrentService().audioTracks().getNumberOfTracks() or 0
  except: return -1
 @staticmethod
 def VVT43R(info):
  if info:
   aspect = FF7SHi(info, iServiceInformation.sAspect)
   if aspect.isdigit():
    aspect = int(aspect)
    if aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ) : return "4:3"
    else           : return "16:9"
  return ""
 @staticmethod
 def VVIQXr(info):
  w = FF7SHi(info, iServiceInformation.sVideoWidth)
  h = FF7SHi(info, iServiceInformation.sVideoHeight)
  if w and h and (w, h) != ("0", "0") : return "%s x %s" % (w, h)
  else        : return ""
class CCNREC():
 def __init__(self):
  self.VVkCVC()
  self.VVKj1k    = ""
  self.VVG1Kv   = "#f#11ffffaa#User"
  self.VVt74K   = "#f#11aaffff#Server"
  self.portal_firstResponse = {}
  self.portal_latestResponse = {}
 def VVkCVC(self):
  self.VVD5zt   = ""
  self.VV0Iab    = ""
  self.VVpc8v   = ""
  self.VVvlA2 = ""
  self.VVU503  = ""
  self.VV8kNO = 0
 def VVDhq2(self, url, mac, ph1="", VVqUOx=True):
  self.VVkCVC()
  self.VVKj1k = {"s": "/server/load.php", "p": "/portal.php", "q": "/portal1.php"}.get(ph1, "")
  host = self.VV4XkC(url)
  if not host:
   if VVqUOx:
    self.VVqIBc("Incorrect URL Format !\n\n%s" % url)
   return False
  mac = self.VVGKVN(mac)
  if not host:
   if VVqUOx:
    self.VVqIBc("Incorrect MAC Format !\n\n%s" % mac)
   return False
  self.VVD5zt = host
  self.VV0Iab  = mac
  return True
 def VVljKL(self):
  return {"/server/load.php":"s", "/portal.php":"p", "/portal1.php":"q"}.get(self.VVKj1k, "")
 def VV4XkC(self, url):
  if url.endswith("mac=") : url = url[:-4]
  if url.endswith("mac") : url = url[:-3]
  url = url.rstrip("/?")
  if url.endswith("/c") : url = url[:-2]
  url = url.rstrip("/ :")
  span = iSearch(r"(.+)(\/playlist.+mac)", url, IGNORECASE)
  if span:
   url = span.group(1)
  return url
 def VVGKVN(self, mac):
  span = iSearch(r"((?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2})", mac, IGNORECASE)
  if span : return span.group(1).upper()
  else : return ""
 def VVlJlD(self):
  h = self.portal_firstResponse.get("resHeaders", "")
  if h: return h.get("Server", "")
  else: return ""
 def VVU4Tj(self):
  res, err = self.VVdce0(self.VVqN0q())
  self.portal_firstResponse = self.portal_latestResponse
  if "403" in err or "404" in err or res and res.status_code == 200 and not res.text.strip():
   if self.VVD5zt.endswith("/c"):
    self.VVD5zt = self.VVD5zt[:-2]
    res, err = self.VVdce0(self.VVqN0q())
   elif self.VVD5zt.endswith("/stalker_portal"):
    self.VVD5zt = self.VVD5zt[:-15]
    res, err = self.VVdce0(self.VVqN0q())
   else:
    self.VVD5zt += "/c"
    res, err = self.VVdce0(self.VVqN0q())
  token = rand = ""
  if not err:
   try:
    tDict = jLoads(res.text)
    token = FFX7JA(tDict["js"], "token")
    rand  = FFX7JA(tDict["js"], "random")
   except:
    pass
  return token.strip(), rand.strip(), err
 def VV4B2b(self, VVqUOx=True):
  if not self.VVKj1k:
   self.VVPjVz()
  err = blkMsg = FFSQn9Txt = ""
  try:
   token, rand, err = self.VVU4Tj()
   if token:
    self.VVpc8v = token
    self.VVvlA2 = rand
    if rand:
     self.VV8kNO = 2
    prof, retTxt = self.VVzf0Q(True)
    if prof:
     self.VVU503 = retTxt
     if any(x in retTxt for x in ("device_id mismatch", "old firmware")):
      self.VV8kNO = 3
      prof, retTxt = self.VVzf0Q(False)
      if retTxt:
       self.VVU503 = retTxt
    return token, prof, ""
  except:
   pass
  tErr = err or "Could not get Token from server !"
  if blkMsg or FFSQn9Txt:
   tErr += "\n"
   if blkMsg: tErr += "\n%s" % blkMsg
   if FFSQn9Txt: tErr += "\n%s" % FFSQn9Txt
  if VVqUOx:
   self.VVqIBc(tErr)
  return "", "", tErr
 def VVPjVz(self):
  try:
   import requests
   url = self.VV9Q1g()
   jsFile = "xpcom.common.js"
   res = requests.get("%s/stalker_portal/c/%s" % (url, jsFile), headers=CCSB3R.VVY3r9(), stream=True, timeout=2)
   if not res.ok or not "javascript" in res.headers.get("content-type"):
    res = requests.get("%s/c/%s" % (url, jsFile), headers=CCSB3R.VVY3r9(), stream=True, timeout=2)
   if res.ok and "javascript" in res.headers.get("content-type"):
    patt = ""
    for line in res.iter_lines():
     if len(line) > 500:
      continue
     elif line:
      line = str(line.decode('utf-8'))
      span = iSearch(r"\s*var\s+pattern\s*=\s*\/(.+)\/\s*;", line, IGNORECASE)
      if span:
       patt = span.group(1)
      span = iSearch(r".+ajax_loader.+'(\/.+\.php)'", line, IGNORECASE)
      if span:
       if "portal_path" in line:
        if patt.endswith(r"*\/(.)*"): url += "/c"
        else      : url += "/stalker_portal"
       self.VVD5zt = url
       self.VVKj1k = span.group(1)
       return
  except:
   pass
  self.VVKj1k = "/server/load.php"
 def VV9Q1g(self):
  url = self.VVD5zt.rstrip("/")
  if url.endswith("/c")    : url = url[:-2]
  if url.endswith("/stalker_portal") : url = url[:-15]
  if url.endswith("/c")    : url = url[:-2]
  return url
 def VVGMO8(self, url, isJsFile=False):
  import requests
  jsFile = "xpcom.common.js" if isJsFile else "version.js"
  res, err = self.VVdce0("%s/stalker_portal/c/%s" % (url, jsFile))
  if not res or not "javascript" in res.headers.get("content-type"):
   res, err = self.VVdce0("%s/c/%s" % (url, jsFile))
  if res and "javascript" in res.headers.get("content-type"):
   if isJsFile:
    return str(res.content), ""
   else:
    span = iSearch(r"var\s+ver\s*=\s*'(.+)'", res.text, IGNORECASE)
    if span:
     return span.group(1), ""
  return "", err
 def VVzf0Q(self, capMac):
  res, err = self.VVdce0(self.VVxNTz(capMac))
  if not err:
   try:
    tDict = jLoads(res.text)
    word = "m" + "sg"
    blkMsg = FFX7JA(tDict["js"], "block_%s" % word)
    FFSQn9Txt = FFX7JA(tDict["js"], word)
    return tDict, FFSQn9Txt.strip() or blkMsg.strip()
   except:
    pass
  return "", ""
 def VVxNTz(self, capMac):
  param = ""
  if self.VVU503 or self.VVvlA2:
   param = self.getMoreAuth_params(self.getMoreAuth_IDs(self.VV0Iab.upper() if capMac else self.VV0Iab.lower(), self.VVvlA2))
  elif FFG0BS("bW9sLTI=") in self.VVD5zt:
   param = self.getMoreAuth_basic(self.VV0Iab.upper())
  return self.VVkuvB() + "type=stb&JsHttpRequest=1-xml&action=get_profile" + param
 exec(FFG0BS("ZGVmIGdldE1vcmVBdXRoX3BhcmFtcyhzZWxmLCBJZCk6DQogcGFyYW0gPSAiJmF1dGhfc2Vjb25kX3N0ZXA9MSZod192ZXJzaW9uPTIuMTctSUItMDAmaHdfdmVyc2lvbl8yPTYyJnNuPSVzJmRldmljZV9pZD0lcyZkZXZpY2VfaWQyPSVzJnNpZ25hdHVyZT0lcyIgJSAoSWRbMF0sIElkWzFdLCBJZFsxXSwgSWRbMl0pDQogcmV0dXJuIHBhcmFtICsgJyZ2ZXI9UGxheWVyIEVuZ2luZSB2ZXJzaW9uOiAweDU4YyZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwidHlwZSI6IlNUQiIsIm1vZGVsIjoiTUFHMjUwIiwicmFuZG9tIjoiJXMifScgJSAoSWRbM10sIElkWzBdLCBJZFs0XSkNCmRlZiBnZXRNb3JlQXV0aF9JRHMoc2VsZiwgbSwgcik6DQogaW1wb3J0IGhhc2hsaWINCiBtYWNVdGY4ID0gbS5lbmNvZGUoJ3V0Zi04JykNCiBzID0gaGFzaGxpYi5tZDUobWFjVXRmOCkuaGV4ZGlnZXN0KCkudXBwZXIoKVs6MTNdDQogcmV0dXJuIHMsIGhhc2hsaWIuc2hhMjU2KG1hY1V0ZjgpLmhleGRpZ2VzdCgpLnVwcGVyKCksIGhhc2hsaWIuc2hhMjU2KChzICsgbSkuZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpLCBtLCBy"))
 exec(FFG0BS("ZGVmIGdldE1vcmVBdXRoX2Jhc2ljKHNlbGYsIG0pOiByZXR1cm4gJyZod192ZXJzaW9uPTEuNy1CRC0wMCZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwibW9kZWwiOiJNQUcyNTAiLCJ0eXBlIjoiU1RCIn0nICUgKG0sIGhhc2hsaWIubWQ1KG0uZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpWzoxM10p"))
 def VV40vj(self, forceMoreInfo=False):
  rows = []
  if not forceMoreInfo:
   rows = self.VVNUtT()
  if len(rows) < 10:
   rows = self.VVcMHH()
  if not rows or len(rows[0]) == 2:
   rows.append(("Host"    , self.VVD5zt ))
   rows.append(("MAC (from URL)" , self.VV0Iab ))
   rows.append(("Token"   , self.VVpc8v ))
   rows.sort(key=lambda x: x[0].lower())
   return rows, 2
  else:
   rows.append(("1", self.VVG1Kv  , "MAC" , self.VV0Iab ))
   rows.append(("2", self.VVt74K, "Host" , self.VVD5zt ))
   rows.append(("2", self.VVt74K, "Token" , self.VVpc8v ))
   rows.sort(key=lambda x: (x[0], x[2]))
   return rows, 4
 def VVNUtT(self):
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCNREC.VVMjLY(host=self.VVD5zt, mac=self.VV0Iab)
  rows = []
  if pUrlAcc:
   res, err = self.VVdce0(pUrlAcc)
   if not err:
    try:
     tDict = jLoads(res.text)
     for key, val in tDict["user_info"].items() :
      if any(x in key for x in ("exp_date", "created_at")): val = FFMYsv(int(val))
      if isinstance(val, list): val = str(" , ".join(val))
      else     : val = str(val)
      rows.append(("1", self.VVG1Kv, str(key).replace("_", " ").title(), val))
     for key, val in tDict["server_info"].items():
      if "timestamp_now"  in key : val = FFMYsv(int(val))
      else      : val = str(val)
      rows.append(("2", self.VVt74K, str(key).replace("_", " ").title(), val))
    except:
     pass
  return rows
 def VVcMHH(self):
  token, profile, tErr = self.VV4B2b()
  try:
   item = profile["js"]
  except:
   return []
  if not isinstance(item, dict):
   return []
  rows = []
  c  = "#f#11ffff55#"
  rows = []
  for key, val in item.items():
   if not val:
    continue
   try:
    if key == "mac":
     if val and FFyVyt(val): val = FFG0BS(val.decode("UTF-8"))
     else     : val = self.VV0Iab
    elif key == "play_token":
     parts = val.split(":")
     if len(parts) == 3:
      pToken = parts[0]
      started = FFMYsv(int(parts[1]))
      if parts[2] : ends = FFMYsv(int(parts[1]) + int(parts[2]))
      else  : ends = ""
      val = "%s (%s ... %s)" % (pToken, started, ends)
    elif key == "aspect":
     val = " , ".join(["%s=%s" % (k, v) for k, v in jLoads(val)["js"].items()])
    elif key in ("created", "last_watchdog"):
     val = FFMYsv(int(val))
    elif isinstance(val, list):
     val = str(" , ".join(val))
    elif isinstance(val, dict):
     val = str(val).replace("u'", "").replace("'", "").strip("{} ")
    else:
     val = str(val).strip()
   except:
    val = str(val)
   rows.append(((str(key).replace("_", " ").title(), str(val))))
  return rows
 def VVUX4Y(self, mode, chCm, epNum, epId):
  token, profile, tErr = self.VV4B2b(VVqUOx=False)
  if not token:
   return ""
  crLinkUrl = self.VVTGd3(mode, chCm, epNum, epId)
  res, err = self.VVdce0(crLinkUrl)
  chUrl = ""
  if not err:
   try: chUrl = FFX7JA(jLoads(res.text)['js'], "cmd")
   except: pass
  chUrl = chUrl.replace("\t", "")
  if " " in chUrl:
   chUrl = chUrl.split(" ")[1].strip(" _")
  chUrl = chUrl.replace(":", "%3a")
  return chUrl
 def VVkuvB(self):
  return self.VVD5zt + self.VVKj1k + "?"
 def VVqN0q(self):
  return self.VVkuvB() + "type=stb&action=handshake&JsHttpRequest=1-xml&token="
 def VV3IoI(self, mode):
  url = self.VVkuvB() + "type=%s&JsHttpRequest=1-xml&action=" % mode
  if   mode == "itv"  : url += "get_genres"
  elif mode == "vod"  : url += "get_categories&force_ch_link_check="
  elif mode == "series": url += "get_categories"
  return url
 def VVSzoc(self, catID):
  return self.VVkuvB() + "type=series&action=get_ordered_list&sortby=added&movie_id=%s&p=1" % catID
 def VVLUAy(self, mode, catID, page):
  url = self.VVkuvB() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&sortby=number&p=%d&" % (mode, page)
  if mode == "itv": url += "genre=%s" % catID
  else   : url += "category=%s&force_ch_link_check=" % catID
  return url
 def VVi4cA(self, mode, searVVeZBd, catId, page):
  catId = ("&category=%s" % catId) if catId else ""
  return self.VVkuvB() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&search=%s&%s&p=%d" % (mode, searVVeZBd, catId, page)
 def VVZXpW(self, stID):
  return self.VVkuvB() + "type=itv&JsHttpRequest=1-xml&action=get_short_epg&ch_id=%s" % stID
 def VVTGd3(self, mode, chCm, serCode, serId):
  url = self.VVkuvB() + "action=create_link&"
  if mode == "series" : url += "type=vod&series=%s&JsHttpRequest=1-xml&cmd=/media/%s.mpg" % (serCode, serId)
  else    : url += "type=%s&cmd=%s&JsHttpRequest=1-xml&forced_storage=0&disable_ad=0&download=0" % (mode, chCm)
  return url
 def VVYao2(self):
  return self.VVkuvB() + "type=itv&JsHttpRequest=1-xml&action=create_link"
 def VVfwKQ(self, host, mac, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId):
  VVDhju = self.VV7RE0(catID, stID, chNum)
  query = self.VVTO4u(mode, self.VVljKL(), FF5VBY(host), FF5VBY(mac), serCode, serId, chCm, catID, stID)
  if   chCm.endswith(".m3u8") : chUrl = "%s?%s" % (chCm, query)
  elif "deviceMac=" in chCm : chUrl = "%s?%s" % (chCm, query)
  else      : chUrl = "%s/j.php?%s" % (host, query)
  chUrl = VVDhju + chUrl.replace(":", "%3a") + ":" + VVeZBd
  return VVDhju, chUrl
 def VVTO4u(self, mode, ph1, host, mac, serCode, serId, chCm, catID, stID):
  query = "mode=%s&ph1=%s&hst=%s&chCode=%s&epNum=%s&epId=%s&cId=%s&sId=%s&chCm=%s&end=" % (mode, ph1, host, mac, serCode, serId, catID, stID, chCm)
  return query.replace("ffmpeg ", "").replace(":", "%3a")
 def VVmjzD(self, url):
  if   "mode=itv"  in url: mode = "itv"
  elif "mode=vod"  in url: mode = "vod"
  elif "mode=series" in url: mode = "series"
  else       : return False, "", "", "", "", "", "", "", "", "", "", ""
  res  = iUrlparse(url)
  scheme = res.scheme
  netloc = res.netloc
  tDict = iUrlparse_qs(res.query)
  ph1  = tDict.get("ph1" , [""])[0].strip()
  host = tDict.get("hst" , [""])[0].strip()
  mac  = tDict.get("chCode", [""])[0].strip()
  epNum = tDict.get("epNum" , [""])[0].strip().replace(":" , "%3a")
  epId = tDict.get("epId" , [""])[0].strip().replace(":" , "%3a")
  chCm = tDict.get("chCm" , [""])[0].strip().replace("ffmpeg ", "").replace(":" , "%3a")
  catID = tDict.get("cId" , [""])[0].strip()
  stID = tDict.get("sId" , [""])[0].strip()
  span = iSearch(r"chCm=(.+)&end=", url, IGNORECASE)
  if span: chCm = span.group(1)
  query = self.VVTO4u(mode, ph1, host, mac, epNum, epId, FFma3M(chCm), catID, stID)
  if scheme: scheme += "://"
  playHost = scheme + netloc
  host  = FFG0BS(host)
  mac   = FFG0BS(mac)
  valid = False
  if self.VV4XkC(playHost) and self.VV4XkC(host) and self.VV4XkC(mac):
   if (mode in ("itv", "vod") and chCm) or (mode == "series" and epNum and epId):
    valid = True
  return valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query
 def VVQS8c(self, url):
  return iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
 def VVdce0(self, url, useCookies=True):
  self.portal_latestResponse = {"url": url, "resErr": ""}
  try: import requests
  except: return "", 'The "Requests" library is not installed'
  err = ""
  crErr = False
  try:
   headers = CCSB3R.VVY3r9()
   if self.VVpc8v:
    headers["Authorization"] = "Bearer %s" % self.VVpc8v
   self.portal_latestResponse["headers"] = headers
   if useCookies : cookies = {"mac": self.VV0Iab, "stb_lang": "en"}
   else   : cookies = None
   self.portal_latestResponse["cookies"] = cookies
   res = requests.get(url, headers=headers, allow_redirects=True, timeout=CFG.portalConnTimeout.getValue(), cookies=cookies)
   self.portal_latestResponse["resHeaders"] = res.headers
   self.portal_latestResponse["resErrCode"] = res.status_code
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except requests.Timeout as e  : crErr, err = True, "Connection Timeout"
  except requests.ConnectionError as e: crErr, err = True, "Connection Error"
  except Exception as e    : crErr, err = True, "Error\n" + str(e)[:120]
  self.portal_latestResponse["resErr"] = err
  self.portal_latestResponse["resCritical"] = crErr
  return "", err
 @staticmethod
 def VVJPQJ(url, extraHeaders=None, cookies=None, timeout=3, verify=False):
  resp, txt, err = None, "", ""
  try:
   import requests
   headers = CCSB3R.VVY3r9()
   if extraHeaders: headers.update(extraHeaders)
   resp = requests.get(url, headers=headers, allow_redirects=True, timeout=timeout, cookies=cookies, verify=verify)
   if resp.ok : txt = str(resp.text)
   else  : err = "Error %d\n\n%s" % (resp.status_code, resp.reason)
  except:
   err = "Error while contacting server !"
  return resp, txt, err
 def VVqIBc(self, err, title="Portal Browser"):
  FFU9uk(self, str(err), title=title)
 def VVvzqt(self, mode):
  if   mode in ("itv"  , CCSB3R.VVJlIE , CCSB3R.VVIqPb)  : return "Live"
  elif mode in ("vod"  , CCSB3R.VV58i3 , CCSB3R.VVhFEC)  : return "VOD"
  elif mode in ("series" , CCSB3R.VVkiMU , CCSB3R.VVY3Xw) : return "Series"
  else                          : return "IPTV"
 def VVRTLv(self, mode, searVVeZBd):
  return 'Find in %s : %s' % (self.VVvzqt(mode), FFITtK(searVVeZBd, VVVAvR))
 def VVU2k3(self, catchup=False):
  VVXXzc = []
  VVXXzc.append(("Live"    , "live"  ))
  VVXXzc.append(("VOD"    , "vod"   ))
  VVXXzc.append(("Series"   , "series"  ))
  if catchup:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Catch-up TV" , "catchup"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Account Info." , "accountInfo" ))
  return VVXXzc
 @staticmethod
 def VVi0iw(VVu69c):
  p = CCNREC()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
  if valid and chCm:
   if   mode == "itv"  : patt = r'.+ch\/(\d+)_'
   elif mode == "vod"  : patt = r'stream_id":"*(\d+)'
   elif mode == "series": patt = r'series_id":"*(\d+)'
   span = iSearch(patt, FFG0BS(chCm), IGNORECASE)
   if span:
    return span.group(1)
  return ""
 @staticmethod
 def VVYuvG(VVu69c):
  p = CCNREC()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
  if valid:
   if CCNREC.VVEPdA(chCm):
    return FF0rS9(chCm)
   else:
    ok = p.VVDhq2(host, mac, ph1, VVqUOx=False)
    if ok:
     try:
      chUrl = p.VVUX4Y(mode, chCm, epNum, epId)
      return FF0rS9(chUrl)
     except:
      pass
  return ""
 @staticmethod
 def VVEPdA(chCm):
  return chCm.startswith("http") and not "//localhost/" in chCm
 @staticmethod
 def VVJX6y(VVu69c):
  if not "chCode" in VVu69c: return None, "Not Portal"
  p = CCNREC()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
  if not valid: return None, "Invalid URL"
  return CCNREC.VV5rZm(host, mac, ph1)
 @staticmethod
 def VV5rZm(host, mac, ph1=""):
  p = CCNREC()
  if not p.VVDhq2(host, mac, ph1=ph1, VVqUOx=False): return None, "Invalid Host/MAC"
  token, profile, tErr = p.VV4B2b(VVqUOx=False)
  if not token: return None, tErr
  return p, ""
 @staticmethod
 def VVMjLY(VVu69c="", host="", mac="", ph1=""):
  pUrl = pUrlAcc = pUrlDnld = pHost = pUser = pPass = err = ""
  if   VVu69c  : p, err = CCNREC.VVJX6y(VVu69c)
  elif host and mac : p, err = CCNREC.VV5rZm(host, mac, ph1=ph1)
  else    : p, err = None, "Incorrect fnc params"
  if err:
   return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  url = p.VVYao2()
  res, err = p.VVdce0(url)
  try: cmd = FFX7JA(jLoads(res.text)["js"], "cmd")
  except: return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  cmd = cmd.replace("\t", "")
  span = iSearch(r"(http.+)\/(.+)\/(.+)(\/\?.+)", cmd)
  if span:
   pHost = span.group(1)
   pUser = FFma3M(span.group(2))
   pPass = FFma3M(span.group(3))
   pUrl = "%s/%s/%s/" % (pHost, pUser, pPass)
   pUrlAcc = "%s/player_api.php?username=%s&password=%s" % (pHost, pUser, pPass)
   pUrlDnld= "%s/get.php?username=%s&password=%s&type=m3u" % (pHost, pUser, pPass)
  else:
   err = "Not found"
  return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
class CCxZ66(CCNREC):
 def __init__(self):
  CCNREC.__init__(self)
  self.mode   = ""
  self.VVDhju  = ""
  self.VVeZBd   = ""
  self.VVLZ0Z  = ""
  self.chCm   = ""
  self.epNum   = ""
  self.epId   = ""
  self.query   = ""
 def VVWSsA(self, VVDhju, VVeZBd, VVu69c, VVLZ0Z):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVmjzD(VVu69c)
  if valid:
   if self.VVDhq2(host, mac, ph1, VVqUOx=False):
    self.mode  = mode
    self.VVDhju = VVDhju
    self.VVeZBd  = VVeZBd
    self.VVLZ0Z = VVLZ0Z
    self.chCm  = chCm
    self.epNum  = epNum
    self.epId  = epId
    self.query  = query
    return True
  return False
 def VVvzzW(self, session):
  chUrl = ""
  try:
   if self.chCm.startswith("Zz1"):
    self.chCm = FFG0BS(self.chCm[3:])
   else:
    chUrl = self.VVUX4Y(self.mode, self.chCm, self.epNum, self.epId)
  except:
   return False
  if CCNREC.VVEPdA(self.chCm) and ("get_download_link" in chUrl or not chUrl):
   chUrl = FF0rS9(self.chCm)
   chUrl = FFma3M(self.chCm)
   chUrl = chUrl.replace("%253a", "%3a")
   if not "?" in chUrl:
    chUrl += "?"
  elif " " in self.chCm or " " in chUrl:
   if " " in chUrl:
    chUrl = chUrl.split(" ")[1]
   if not "?" in chUrl:
    chUrl += "?"
  if not chUrl.startswith("http"):
   return False
  if not self.VVDhju.endswith(":"):
   self.VVDhju += ":"
  chUrl = chUrl.strip()
  chUrl = self.VVDhju + chUrl + ":" + self.VVeZBd
  newIptvRef = self.VVnGqX(chUrl, self.VVeZBd)
  bPath = CC41Tt.VVUMaM()
  if newIptvRef:
   newIptvRef1 = newIptvRef
   if CFG.simplePortal.getValue():
    newIptvRef1 = self.VVQS8c(newIptvRef)
   FF5deK(session, newIptvRef1)
   if self.VVLZ0Z and newIptvRef and bPath:
    serv = eServiceReference(newIptvRef)
    newCode = serv and serv.toString()
    if newCode:
     self.VV7htL(self.VVLZ0Z, newCode, bPath)
   return True
  else:
   return False
 def VVnGqX(self, chUrl, VVeZBd):
  newIptvRef = ""
  playMarks = ("play_token=", "/play/", "lid=")
  for toFind in playMarks:
   if toFind in chUrl:
    ndx = chUrl.find(toFind)
    if ndx > -1:
     ndx = chUrl.find(":", ndx)
     if ndx > -1:
      left  = chUrl[:ndx]
      right  = chUrl[ndx:]
      newIptvRef = left + "&" + self.query + right
    break
  if not newIptvRef:
   x1 = chUrl.find("?")
   if x1 > -1:
    x2 = chUrl[x1:].find(":")
    if x2 > -1:
     newIptvRef = chUrl[:x1+x2] + "&" + self.query + chUrl[x1+x2:]
  if not newIptvRef and VVeZBd:
   VVeZBd = ":" + VVeZBd
   if chUrl.endswith(VVeZBd):
    newIptvRef = chUrl[:-len(VVeZBd)].rstrip("?&") + "&" + self.query + VVeZBd
  return newIptvRef
 def VV7htL(self, oldCode, newCode, bPath):
  patt = r"((?:[A-Fa-f0-9]+[:]){10}).+(mode=.+)chCm="
  span = iSearch(patt, newCode, IGNORECASE)
  if span:
   newRef, newPar = span.group(1).upper(), span.group(2)
   params = ("ph1", "cId", "sId")
   for par in params:
    newPar = iSub(r"&%s=.*?&" % par, "&", newPar)
   span = iSearch(r"(sId=.+?)&", oldCode)
   sidTxt = span.group(1) if span else ""
   lines = FF2iRW(bPath)
   for ndx, line in enumerate(lines):
    span = iSearch(patt, line, IGNORECASE)
    if span and sidTxt in line:
     fileRef, filePar = span.group(1).upper(), span.group(2)
     if newRef == fileRef:
      for par in params:
       filePar = iSub(r"&%s=.*?&" % par, "&", filePar)
      if newPar == filePar:
       lines[ndx] = "#SERVICE %s" % newCode
       with open(bPath, "w") as f: f.write("\n".join(lines) + "\n")
       FFfve1()
class CCBoou(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVJlYA=False)
  self.session  = session
  self.Title   = "Movies Resume History"
  self.tbl   = None
  self.VVrpy9 = 0
  FFfmZP(self)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VV7ySG()
 @FFHF2S()
 def VV7ySG(self):
  path, lst, err = CCBoou.VVAjdC()
  if not lst:
   FFU9uk(self, "No resume points.", title=self.Title)
   self.cancel()
   return
  fName, fTxt, VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.session)
  self.VVrpy9 = grnB = 0
  rows = []
  for fName1 in lst:
   d = CCzCR1.VVxvlA(path + fName1)
   if d:
    if fName == fName1 : c, grnB = "#f#0022ff22#", 1
    else    : c = ""
    prog = str(int(round(100.0 * d["pos"] / d["dur"])))
    rows.append((c + d["nm"], c + FF79L2(d["dur"] / 90000.0), c + FF79L2(d["pos"] / 90000.0), "", prog, c + FFMYsv(d["w"]), fName1, d["u"], d["r"]))
   else:
    self.VVrpy9 += 1
  if self.tbl:
   self.tbl.VVxhz9(rows)
  elif rows:
   settTxt = FFITtK("Settings : ", VVVAvR) + (FFITtK(CFG.resumeMovies.getText(), VVsm0W if CFG.resumeMovies.getValue() == "off" else VVnQYw))
   rows.sort(key=lambda x: x[0][12:].lower() if iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", x[0]) else x[0].lower())
   bg = "#1a111020"
   VVNCwd = (3, 4, 80, 20)
   VVLj1d = self.cancel
   VVsB8G = (""  , BF(self.VVLxjS, False), [])
   VVI3Oq  = ("Play" , self.VV2SsO     , [])
   VV4dTm = (""  , self.VV6tbl    , [])
   VV5CrJ = ("Current", BF(self.VVLxjS, True) , [])
   VVbQ6N = ("Options", self.VVWWU0    , [])
   header  = ("Name" , "Duration", "Resume" , "Pos %" , "Pos %" , "Watched" , "File", "Source" , "ref" )
   widths  = (46  , 12  , 12  , 7   , 0.03  , 23  , 0.01 , 0.01  , 0  )
   VVgKQc = (LEFT  , CENTER , CENTER , CENTER , CENTER , CENTER , LEFT , LEFT  , LEFT )
   self.tbl = FFdCaM(self, None, title=self.Title, VVrX9P=settTxt, header=header, VV5dDF=rows, VVgKQc=VVgKQc, width=1600, height=900, VV1PTZ=widths, VV1Wwb=27, VVNCwd=VVNCwd, VVsB8G=VVsB8G, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N
        , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#06004455", VVcv6F="#00333333", VVsOjr="#0a332244")
  else:
   FFU9uk(self, err, title=self.Title)
   self.cancel()
  if self.tbl:
   if grnB : self.tbl.VVW6Cx()
   else : self.tbl.VVcilR()
 def cancel(self, VV5ybN=None):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VV2SsO(self, VV5ybN, title, txt, colList):
  CC2lVw.VVbVSZ(self.session, VVQpKh=False, VVr3eH=False, VV7GTU=colList[8], cbFnc=self.VV7ySG)
 def VV6tbl(self, VV5ybN, title, txt, colList):
  txt = "%s\n\n%s" % (title, txt)
  VVeZBd, VVDhju = colList[0], colList[8]
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVDhju.strip(), IGNORECASE)
  if span:
   VVDhju = span.group(1)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVxMle, params=(VVDhju, VVeZBd, txt))
 def VVLxjS(self, VVqUOx, VV5ybN, title, txt, colList):
  fName, fTxt, VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.session)
  if fName:
   VV5ybN.VVp9iQ(6, fName, VVqUOx=VVqUOx)
 def VVWWU0(self, VV5ybN, title, txt, colList):
  isMulti = VV5ybN.VVbbT0
  rows = VV5ybN.VVwKf5()
  ok = not isMulti or isMulti and rows
  VVXXzc = []
  VVXXzc.append(FFwjWO("Delete All"         , "all", not isMulti, VVcahY))
  VVXXzc.append(FFwjWO("Delete Selected Row%s" % FFEnJs(len(rows)) , "sel", ok))
  if self.VVrpy9:
   VVXXzc.append(VVzg1X)
   VVXXzc.append((VVnQYw + "Clear Unreadable Files"  , "bad"))
  params = [VV5ybN, isMulti, rows]
  cbFncDict = { "all": BF(self.VVmrjc, params + ["all"])
     , "sel": BF(self.VVmrjc, params + ["sel"])
     , "bad": BF(self.VVmrjc, params + ["bad"])
     }
  CCZALl(self, VV5ybN, setsOk=True).VVejOk(VVXXzc, cbFncDict, width=500)
 def VVmrjc(self, params):
  VV5ybN, isMulti, rows, item = params
  if item:
   if item == "sel":
    tot = len(rows)
    if isMulti : ques = "Delete %d Resume Point%s ?" % (tot, FFEnJs(tot))
    else  : ques = "Delete Selected Point ?"
   elif item == "all" : ques = "Delete all Resume Points ?"
   elif item == "bad" : ques = "Found %d unusable file%s that could not be added to table.\n\nDelete unusable files ?" % (self.VVrpy9, FFEnJs(self.VVrpy9))
   FFHsPu(self, BF(self.VV1KmQ, params), ques, title=self.Title)
 def VV1KmQ(self, params):
  VV5ybN, isMulti, rows, item = params
  path = CCzCR1.VVlenf("")
  if item == "sel":
   if isMulti:
    for fName in self.tbl.VVaOdg(6):
     FFqlCI(CCzCR1.VVlenf(fName))
   else:
    FFqlCI(CCzCR1.VVlenf(self.tbl.VVVWWJ(6)))
   self.VV7ySG()
  elif item == "all":
   for row in self.tbl.VVTq0J():
    FFqlCI(path + row[6])
   FFxLiP(self.session, "Done")
   self.cancel()
  elif item == "bad":
   path, lst, err = CCBoou.VVAjdC()
   tot = 0
   for fName in lst:
    d = CCzCR1.VVxvlA(path + fName)
    if not d:
     FFqlCI(path + fName)
     tot += 1
   self.VVrpy9 = 0
   FFSQn9(self, "Deleted %d unreadable file%s." % (tot, FFEnJs(tot)) if tot else "All files are OK.", title=self.Title)
 @staticmethod
 def VVAjdC():
  path = CCzCR1.VVlenf("")
  try:
   return path, os.listdir(path), ""
  except Exception as e:
   return path, [], str(e)
class CCzCR1():
 def __init__(self, VVC9WI):
  self.VVmcfy = None
  self.VVwOu0 = False
  self.VV53hm = 0
  self.VV4mrT = 0
  self.VVQjts = eTimer()
  try: self.VVQjts_conn = self.VVQjts.timeout.connect(self.VVabqD)
  except: self.VVQjts.callback.append(self.VVabqD)
  self.VVQjts.start(500, False)
  self.VVk98B()
 def VVk98B(self):
  path = self.VVlenf("")
  if VVrRHR(path):
   return os.path.isdir(path)
  else:
   try:
    os.makedirs(path)
    return True
   except:
    return False
 def VVabqD(self):
  self.VV53hm, self.VV4mrT = CCzCR1.VVCHUc(self.VVC9WI)
  if self.VVwOu0 and self.VV53hm:
   self.VVwOu0 = False
   self.VVcNLh()
 def VVGUXR(self):
  self.VVwOu0 = True
 def VVcNLh(self):
  fName, fTxt, VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.VVC9WI)
  if not fName or self.VVmcfy == fName:
   return
  tDict = CCzCR1.VVxvlA(self.VVlenf(fName))
  if tDict and "pos" in tDict and "dur" in tDict:
   newPos, newDur = tDict["pos"], tDict["dur"]
   if abs(self.VV53hm - newPos) // 90000.0 and newPos > 900000 and newPos < self.VV53hm - 900000:
    InfoBar.instance.doSeek(int(newPos))
    InfoBar.instance.hide()
    self.VVmcfy = fName
 def VVU2Ya(self):
  self.VVmcfy = None
  fName, fTxt, VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.VVC9WI)
  if not fName or self.VV53hm == 0:
   return
  if abs(self.VV53hm - self.VV4mrT) < 90000 * 2:
   FFqlCI(self.VVlenf(fName))
   return
  if self.VV4mrT > 90000 * 60 and self.VV4mrT < self.VV53hm - 900000 and self.VV53hm > 90000 * 60:
   self.VVk98B()
   tDict = {"v":1, "nm": str(VVeZBd), "u": str(fTxt), "r": str(VVkcp9), "pos": self.VV4mrT, "dur": self.VV53hm, "w": int(iTime())}
   try:
    import pickle
    with open(self.VVlenf(fName), 'wb') as f:
     pickle.dump(tDict, f, 2)
   except:
    pass
 @staticmethod
 def VVTurn(session):
  s = CCaZ62(session)
  fName = fTxt = ""
  conf = CFG.resumeMovies.getValue()
  if   conf in ("a", "i") and FFzNJJ(s.VVu69c): pass
  elif conf in ("a", "l") and s.Path.startswith("/")   : pass
  else              : return fName, fTxt, s.VVeZBd, s.VVkcp9
  fName = FFEkBW(s.uniqueId)
  fTxt = s.userTxt
  return fName, fTxt, s.VVeZBd, s.VVkcp9
 @staticmethod
 def VVxvlA(fPath):
  try:
   import pickle
   with open(fPath, 'rb') as f:
    d = pickle.load(f)
    if all(k in d for k in ("v", "nm", "u", "r", "pos", "dur", "w")):
     d["nm"], d["u"], d["r"] = str(d["nm"]), str(d["u"]), str(d["r"])
     return d
  except:
   pass
  return None
 @staticmethod
 def VVlenf(fName):
  return "%sajpanel_resume/%s" % (FFmAG5(), fName)
 @staticmethod
 def VVCHUc(session):
  serv = session.nav.getCurrentService()
  pSeek = serv and serv.seek()
  if not pSeek is None:
   durLst = pSeek.getLength()
   posLst = pSeek.getPlayPosition()
   if durLst[0] == 0 and posLst[0] == 0:
    return durLst[1], posLst[1]
  return 0, 0
class CCOwzx(CCzCR1):
 VV7BM7 = "START"
 VVVy3B = "INFO"
 VVYL6l = "EOF"
 VVOHqo = "End"
 def __init__(self, VVC9WI):
  CCzCR1.__init__(self, VVC9WI)
  self.VVC9WI   = VVC9WI
  self.VV68fy    = eTimer()
  self.VVIkn2    = None
  self.VVy4YG  = 0
  self.VV4GlO   = ""
  self.VVFVWR   = ""
  self.lastSimulatedEOF  = ""
  self.VVxJeQ   = ""
  try:
   from Components.ServiceEventTracker import ServiceEventTracker
   from enigma import iPlayableService
   evTrk = ServiceEventTracker(screen=self.VVC9WI.screen, eventmap={iPlayableService.evStart: self.VVABB9, iPlayableService.evEOF: self.VVf3X9, iPlayableService.evEnd: self.VV1VK9, iPlayableService.evUpdatedInfo: self.VVDYjK})
  except:
   pass
  try: self.VV68fy_conn = self.VV68fy.timeout.connect(self.VVtXQU)
  except: self.VV68fy.callback.append(self.VVtXQU)
  self.VV68fy.start(3000, False)
  self.VVtXQU()
 def VVtXQU(self):
  if not CFG.downloadMonitor.getValue():
   self.VVbrrm()
   return
  lst = CChTrx.VVREwG()
  avPerc = []
  txt = ""
  if lst:
   for path, totSz, logF in lst:
    if totSz:
     totSz = int(totSz) if totSz.isdigit() else 0
     curSz = 0
     sz = FFX42v(path)
     if sz > -1:
      curSz = sz
     if totSz:
      perc = (float(curSz) / float(totSz) * 100.0)
      avPerc.append(perc)
    elif logF:
     perc = CChTrx.VVxxiF(logF)
     if perc > -1:
      avPerc.append(perc)
   if lst:
    txt = "Files=%d" % len(lst)
    if avPerc:
     perc = sum(avPerc) / len(avPerc)
     if perc: txt += "   %.2f %%" % perc
  if txt:
   if not self.VVIkn2 : self.VVIkn2 = CCAt9K.VVuHy6(self.VVC9WI, txt, 30)
   else    : CCAt9K.VVEskH(self.VVIkn2, txt)
  elif self.VVIkn2:
   self.VVbrrm()
 def VVbrrm(self):
  if self.VVIkn2:
   self.VVC9WI.deleteDialog(self.VVIkn2)
   self.VVIkn2 = None
 def VVABB9(self):
  self.VVdVUr(CCOwzx.VV7BM7)
 def VVDYjK(self):
  self.VVdVUr(CCOwzx.VVVy3B)
  VVDhju, VVu69c, VVLZ0Z, VVmcCE = self.VVLKIP()
  self.VVxJeQ = VVmcCE
  self.VVGUXR()
 def VV1VK9(self):
  self.VVdVUr(CCOwzx.VVOHqo)
  self.VVxJeQ = ""
  FFUttZ(self, 1000, self.VVe8IC)
  self.VVU2Ya()
 def VVf3X9(self):
  self.VVdVUr(CCOwzx.VVYL6l)
  if CFG.autoResetFrozenIptvChan.getValue() == "off":
   return
  VVDhju, VVu69c, VVLZ0Z, VVmcCE = self.VVLKIP()
  if not VVLZ0Z or "file?file" in VVLZ0Z or ":ftp%3a//" in VVLZ0Z:
   return
  if iMatch(r"http.+(?:[A-Za-f0-9]+(%3a|:)){10}", VVu69c):
   return
  if self.VVFVWR == VVmcCE and self.VVy4YG > 0 and (iTime()- self.VVy4YG) < 10:
   return
  if self.VVxJeQ == VVmcCE:
   if CFG.autoResetFrozenIptvChan.getValue() == "on+":
    CCAt9K(self.VVC9WI, "Refreshing")
   CCAnLc.VVzv7h(self.VVC9WI)
  elif "&end=:" in VVLZ0Z:
   VVeZBd = VVLZ0Z[VVLZ0Z.index("&end=:") + 6:]
   pr = CCxZ66()
   if pr.VVWSsA(VVDhju, VVeZBd, VVu69c, VVLZ0Z):
    shown = InfoBar.instance.shown
    pr.VVvzzW(self.VVC9WI)
    if not shown: InfoBar.instance.hide()
  self.VVFVWR = VVmcCE
  self.VVy4YG = iTime()
 def VVe8IC(self):
  VVDhju, VVu69c, VVLZ0Z, VVmcCE = self.VVLKIP()
  if VVDhju.startswith("4097:") and self.lastSimulatedEOF != VVmcCE:
   FFUttZ(self, 1000, BF(self.VVrYKt, VVmcCE))
 def VVrYKt(self, ref):
  VVDhju, VVu69c, VVLZ0Z, VVmcCE = self.VVLKIP()
  if ref == VVmcCE and self.VV4GlO in (CCOwzx.VV7BM7, CCOwzx.VVOHqo):
   self.lastSimulatedEOF = VVmcCE
   self.VVf3X9()
 def VVLKIP(self):
  s = CCaZ62(self.VVC9WI)
  return s.VVDhju, s.VVu69c, s.VVLZ0Z, s.myPhp or s.VVu69c
 def VVdVUr(self, state):
  self.VV4GlO = state
  global VVHOJs_VAL
  VVHOJs_VAL = state
class CCRnM6():
 def __init__(self, SELF):
  self.SELF  = SELF
  self.Title  = "Update Current Bouquet EPG/PIcons"
  self.pPath  = CCUNc6.VVQ490()
  self.updErr  = ""
  self.isFfmpeg = FFsGnd("ffmpeg")
  self.totCh  = 0
  self.totIptv = 0
  self.totNotIptv = 0
  self.totEpgDnl = 0
  self.totPic  = 0
  self.totPicOK = 0
  self.epgLst  = []
  self.bName  = ""
  CCXRxc.VVJ9VK(SELF
      , VVCJhW  = self.VVxnki
      , VVuQkS = self.VVnymn)
 def VVxnki(self, VVM2wn):
  VVM2wn.VVkdWG("Reading Services ...")
  self.bName = CC41Tt.VVkU5R()
  services = CC41Tt.VVSaEJ()
  if not services:
   self.updErr = 'Cannot read service from: \n\n"%s"' % self.bName
   return
  elif len(services) == 0:
   self.updErr = 'No services in: \n\n"%s"' % self.bName
   return
  else:
   self.totCh = len(services)
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVqMKy(self.totCh)
  VVM2wn.VVkdWG("Downloading ...")
  for ndx, (VVkcp9, VVeZBd) in enumerate(services):
   if not VVM2wn or VVM2wn.isCancelled: return
   if FFPrVr(VVkcp9):
    self.totIptv += 1
    VVDhju, VVu69c, VVQwVu, VVLZ0Z = CCaZ62.VVXPhc(VVkcp9)
    if not VVM2wn or VVM2wn.isCancelled: return
    evLst = []
    epg = VVKCwZ = ""
    if VVu69c:
     epg, evLst, VVKCwZ, err = CCISy5.VV5pXU(VVu69c)
     if VVKCwZ: self.totPic += 1
    else:
     continue
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVAwgW(self.totEpgDnl, self.totPic)
    if not epg:
     epg, evLst, err = CCSB3R.VVgEQj(VVu69c)
    if evLst:
     self.epgLst.append((VVDhju, evLst))
     self.totEpgDnl += len(evLst)
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVAwgW(self.totEpgDnl, self.totPic)
    self.totPicOK += self.VVrcF1(VVkcp9, VVKCwZ)
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVAwgW(self.totEpgDnl, self.totPic)
   else:
    self.totNotIptv += 1
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
 def VVnymn(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if self.updErr:
   FFU9uk(self.SELF, self.updErr, title=self.Title)
   return
  totEpgOK = 0
  for VVDhju, evLst in self.epgLst:
   if evLst:
    totEv, totOK = CCfClD.VVDV4n(VVDhju, evLst)
    totEpgOK += totOK
  if totEpgOK > 0:
   CCfClD.VVLWv9()
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Bouquet"  , self.bName)
  txt += "\n"
  txt += tab("Services"  , self.totCh)
  txt += tab("Processed"  , self.totIptv)
  txt += tab("Non-IPTV"  , self.totNotIptv)
  txt += "\n"
  txt += tab("Events Found" , self.totEpgDnl)
  txt += tab("Events Added" , totEpgOK)
  txt += "\n"
  txt += tab("PIcons Found" , self.totPic)
  txt += tab("PIcons Added" , self.totPicOK)
  if not VV9zbx:
   self.Title += "  (stopped)"
  FFyijw(self.SELF, txt, title=self.Title)
 def VVrcF1(self, VVkcp9, url):
  if not all((url, self.isFfmpeg, VVrRHR(self.pPath))):
   return 0
  path, err = FFEyUQ(url, "ajp_tmp.png", timeout=2, VVtOxO=True)
  if not FFf0vs(path) or not VVrRHR(self.pPath):
   return 0
  VVDhju = CCISy5.VVqZxY(VVkcp9)
  picon = VVDhju.replace(":", "_") + ".png"
  cmd = CCISy5.VVomfz(path)
  cmd += FFDTPf("mv -f '%s' '%s%s'" % (path, self.pPath, picon))
  ok = FF6usE(cmd)
  return 1 if ok else 0
class CClqOe():
 def __init__(self, VV3zFO=False):
  self.VV6H5H  = CFG.hideIptvServerChannPrefix.getValue()
  self.VV61mo  = VV3zFO or CFG.hideIptvServerAdultWords.getValue()
  self.VVYRZC = r"(b[-]*e[-]*I[-]*N)"
  self.VVSdBe  = r"beIN"
  self.VVHam8 = iCompile( r"\s*^[A-Za-z]{2,4}\d*\s*(?:[|:-]|[^\x00-\x7F])+\s*(.+)"
          r"|^\[.{2}\]\s*(.+\[.{2}\]\s*\[.{2,}\])"
          r"|^(?!\[)*\s*[\[(|:][ A-Za-z0-9\/\-._:|\]\[]+[\])|:](.+)"
          r"|^[A-Za-z]{,3}[^\x21-\x7E]\s(.+)")
  self.VVlq6E = self.VVgsfT(self.VV6H5H, "ajpanel_iptv_prefix", False, ())
  self.VVdxuz = self.VVgsfT(self.VV61mo, "ajpanel_iptv_blacklist", True, ("+18","18 rated","18+","aduld","adult","adulte","adulto","aikuinen","blue film","blue movie","dirty film","dirty movie","dorosly","erotic","erwachsene","porn","r-17 film","r-17 movie","r-18 film","r-18 movie","r18 film","r18 movie","sex","skin flick","voksen","volwassen","vuxen","x-rated","xrated","xxi","xx","xvideo","xyz"))
 def VVgsfT(self, cond, fName, isLower, tSet):
  tSet = set(tSet)
  if cond:
   for path in (VV30Jg, FFmAG5()):
    path += fName
    if FFf0vs(path):
     for line in FF2iRW(path):
      line = line.strip()
      if len(line) >= 3:
       tSet.add(line.lower() if isLower else line)
  return tuple(sorted(tSet, key=lambda x: x.lower()))
 def VVYPwG(self, name,  censored=""):
  if self.VV61mo and (censored == "1" or any(x in name.lower() for x in self.VVdxuz)):
   return ""
  name = iSub(self.VVYRZC, self.VVSdBe, name, flags=IGNORECASE).strip()
  if CCSB3R.VV0Jba(name):
   return CCSB3R.VVFSjX(name)
  return self.VVCR5C(name)
 def VVCR5C(self, name):
  newName = ""
  if self.VV6H5H:
   span = iSearch(self.VVHam8, name)
   if span:
    tName = span.group(1) or span.group(2) or span.group(3) or span.group(4)
    if not tName.startswith(("HD", "[HD]", "SD", "[SD]")):
     newName = tName
   for t in self.VVlq6E:
    if name.startswith(t):
     newName = name[len(t):]
     break
  return newName.strip() or name
 def VV0ApM(self, name):
  name = iSub(self.VVYRZC, self.VVSdBe, name, flags=IGNORECASE).strip()
  name = self.VVCR5C(name)
  return name.lower().replace(" hd", "").replace(" fm", "").replace(" 4k", "").replace(" tv", "").replace(" sd", "").strip()
 def VVeM8A(self, name):
  if self.VV61mo and any(x in name.lower() for x in self.VVdxuz):
   return ""
  return name.strip()
 def VVyqRl(self, wordsList):
  lst = list(map(str.lower, wordsList))
  return any(x in self.VVdxuz for x in lst)
 def VVbLG6(self):
  return 'Cannot continue with adults words !\n\n"Skip Adults Channels" is activated in settings.'
 @staticmethod
 def VVW0yF():
  badW1 = CCCHs8.VVe9Ck()
  badW2 = CCCHs8.VVfTvc()
  nameCl = CClqOe()
  def VVjJzY(txt):
   txt = nameCl.VVCR5C(txt)
   txt = txt.replace("24/7", "")
   for ch in ":|_-+.[](){}#!@$%^*": txt = txt.replace(ch, " ")
   if len(txt) > 4: txt = iSub(r"\d{4,}", "", txt, flags=IGNORECASE)
   while "  " in txt: txt = txt.replace("  ", " ")
   words = []
   for word in txt.split():
    if not word.lower() in badW1 and not badW2.match(word):
     words.append(word)
   txt = " ".join(words)
   return txt.strip()
  return VVjJzY
class CC5tyY(CClqOe):
 def __init__(self, SELF, VVePgW, VVu9JD="", VVHMrJ="", cbFnc=None, chkExt=False):
  self.SELF  = SELF
  self.VVePgW = VVePgW
  self.VVu9JD  = VVu9JD
  self.outD  = "%s%s/" % (CCxgvM.VVtMU7(), VVHMrJ or os.path.basename(VVePgW)[:-4])
  self.cbFnc  = cbFnc
  self.chkExt  = chkExt
  self.Title  = "Create Local Server"
  self.err  = ""
  self.totGrp  = 0
  self.totCh  = 0
  self.totL  = self.totLh = 0
  self.totV  = self.totVh = 0
  self.totS  = self.totSh = 0
  self.totK  = self.totKh = 0
  self.totM  = self.totMh = 0
  self.totR  = self.totRh = 0
  self.totD  = self.totDh = 0
  self.totF  = self.totFh = 0
  self.totAll  = 0
  self.lineNum = 0
  CClqOe.__init__(self, VV3zFO=True)
  CCXRxc.VVJ9VK(self.SELF, VVmj1O="Checking File ...", titleBg="#22220022", bodyBg="#22220022"
      , VVCJhW  = self.VVzMTJ
      , VVuQkS = self.VVgVEd)
 def VVzMTJ(self, VVM2wn):
  if VVrRHR(self.outD):
   for f in iGlob(FFA4GT(self.outD) + "*"):
    FFqlCI(f)
  elif not FF6usE("mkdir -p '%s'" % self.outD):
   self.err = "Cannot make directory."
   return
  par = grp = url = marker = ""
  bDict = {}
  enc, totLines = CC2Ldo.VVCfu0(self.VVePgW)
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVqMKy(totLines)
  with ioOpen(self.VVePgW, "r", encoding=enc) as f:
   for line in f:
    self.lineNum += 1
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVwOHf(1)
    line = str(line.strip())
    if line.startswith("#EXTINF:"):
     par = line
     continue
    elif line.startswith("#EXTGRP:"):
     grp = line.partition("#EXTGRP:")[2].strip()
     continue
    elif not line.startswith("#"):
     url = line
    elif line.startswith("#EXTM3U"):
     continue
    if not (par and url):
     continue
    par = par.replace('""', '" "')
    span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
    VVeZBd = (((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else "") or "No-name"
    chBlk = 0 if self.VVYPwG(VVeZBd) else 1
    span = iSearch(r'tvg-logo="(.+?)"', par, IGNORECASE)
    icn = ((span.group(1)).replace("\t", "").strip() if span else "") or "-"
    span = iSearch(r'group-title="(.+?)"', par, IGNORECASE)
    cat = (grp or (span.group(1) if span else "")).replace("\t", "").strip()
    catBlk = 1 if cat and not self.VVeM8A(cat) else 0
    val1 = catBlk or chBlk
    typ = CCxgvM.VV1lfy(url, self.chkExt)
    if   typ == "Live"  : self.totL, self.totLh = self.totL + 1, self.totLh + 1 * val1
    elif typ == "VOD"  : self.totV, self.totVh = self.totV + 1, self.totVh + 1 * val1
    elif typ == "Series" : self.totS, self.totSh = self.totS + 1, self.totSh + 1 * val1
    elif typ == "Marker" : self.totK, self.totKh = self.totK + 1, self.totKh + 1 * val1
    elif typ == "Movie"  : self.totM, self.totMh = self.totM + 1, self.totMh + 1 * val1
    elif typ == "S.Relay" : self.totR, self.totRh = self.totR + 1, self.totRh + 1 * val1
    elif typ == "DVB"  : self.totD, self.totDh = self.totD + 1, self.totDh + 1 * val1
    elif typ == "FTP"  : self.totF, self.totFh = self.totF + 1, self.totFh + 1 * val1
    cat = cat or "* Uncategorized %s Channels *" % typ
    VVM2wn.VVkdWG("Ch=%s  ( L=%s  V=%s  S=%s )" % (self.totCh, self.totL, self.totV, self.totS))
    if typ == "Marker":
     marker = "%s\t%s\t%s\n" % (url, VVeZBd, "-")
     continue
    fileId = typ + cat
    fName = FFEkBW(fileId)
    totCh = (bDict[fileId][3] + 1) if fileId in bDict else 1
    bDict[fileId] = (typ, catBlk, fName, totCh, cat)
    with open(self.outD + fName, "a") as f:
     if marker:
      f.write(marker)
      marker = ""
      self.totAll += 1
     f.write("%s\t%s\t%s\t%s\n" % (chBlk or catBlk, url, VVeZBd, icn))
     self.totCh += 1
     self.totAll += 1
    par = grp = url = ""
  self.totGrp = len(bDict)
  if bDict:
   bLst = ["\t".join((typ, str(catBlk), fName, str(totCh), cat)) for ttl, (typ, catBlk, fName, totCh, cat) in bDict.items()]
   if bLst:
    try: fmTime = int(os.path.getmtime(self.VVePgW))
    except: fmTime = ""
    tab = lambda x, y: "#" + " %s: %s\n" % (x, y)
    with open(os.path.join(self.outD, "_main"), "w") as f:
     f.write(tab("File"  , self.VVePgW))
     f.write(tab("Modified" , fmTime))
     f.write(tab("URL"  , self.VVu9JD.partition("&type")[0]))
     f.write(tab("Saved"  , FFpe77()))
     f.write(tab("Entries" , self.totAll))
     f.write(tab("Services" , self.totCh))
     f.write(tab("Live"  , self.totL))
     f.write(tab("VOD"  , self.totV))
     f.write(tab("Series" , self.totS))
     if self.totK: f.write(tab("Marker" , self.totK))
     if self.totM: f.write(tab("Movie" , self.totM))
     if self.totR: f.write(tab("S.Relay" , self.totR))
     if self.totD: f.write(tab("DVB"  , self.totD))
     if self.totF: f.write(tab("FTP"  , self.totF))
     if self.totLh: f.write(tab("Blk_Live" , self.totLh))
     if self.totVh: f.write(tab("Blk_VOD" , self.totVh))
     if self.totSh: f.write(tab("Blk_Series" , self.totSh))
     if self.totKh: f.write(tab("Blk_Marker" , self.totKh))
     if self.totMh: f.write(tab("Blk_Movie" , self.totMh))
     if self.totRh: f.write(tab("Blk_S.Relay", self.totRh))
     if self.totDh: f.write(tab("Blk_DVB" , self.totDh))
     if self.totFh: f.write(tab("Blk_FTP" , self.totFh))
     f.write("\n".join(bLst))
 def VVgVEd(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  mainOk = FFf0vs(os.path.join(self.outD, "_main"))
  if not VV9zbx or not mainOk:
   FFelXn(self.outD)
  ln = "\n\nLine Number : %s" % self.lineNum
  if   not VV9zbx     : pass
  elif self.err      : FFU9uk(self.SELF, self.err, self.Title)
  elif threadCounter != threadTotal : FFU9uk(self.SELF, "Error in conversion process %s" % ln, self.Title)
  elif not mainOk      : FFU9uk(self.SELF, "Cannot extract channels", self.Title)
  elif self.cbFnc      : self.cbFnc(self.VVePgW, self.outD)
  else:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = tab("Groups", self.totGrp)
   txt += tab("Services", self.totCh)
   txt += tab("\nEntries" , self.totAll)
   txt += tab("  Live"  , self.totL)
   txt += tab("  VOD"  , self.totV)
   txt += tab("  Series" , self.totS)
   txt += tab("  Movie" , self.totM)
   txt += tab("  DVB"  , self.totD)
   txt += tab("  S.Relay" , self.totR)
   txt += tab("  FTP"  , self.totF)
   txt += tab("  Marker" , self.totK)
   txt += "\n%s\n%s" % (FFITtK("Output File:", VVnQYw), self.outD)
   FFyijw(self.SELF, txt, self.Title)
class CCxgvM(CClqOe):
 VVSQ7Z   = 0
 VVCcP4  = 1
 VVDym4 = 2
 VVgFlK = 3
 VVzxBl  = 4
 VVJiKT   = 5
 def __init__(self, SELF, mode, url="", m3uF="", VVs4iu=None):
  self.SELF   = SELF
  self.mode   = mode
  self.VVs4iu= VVs4iu
  self.Title   = "Local Servers & M3U Cache"
  self.VVAEMV  = ""
  self.url   = ""
  self.hst   = ""
  self.usr   = ""
  self.pas   = ""
  self.VVbVVr  = ""
  self.VVUXnR   = ""
  CClqOe.__init__(self)
  if not iZip:
   SELF.VVqIBc('"zipfile" Module not found !')
   return
  if   mode == CCxgvM.VVSQ7Z   : self.VVMLVD()
  elif mode == CCxgvM.VVCcP4  : self.VVQ6HZ(self.SELF, m3uF)
  elif mode == CCxgvM.VVDym4 : self.VVOFgm(m3uF)
  elif mode == CCxgvM.VVgFlK: self.VVsMV4(url)
  elif mode == CCxgvM.VVzxBl : self.VVsMV4(url)
  elif mode == CCxgvM.VVJiKT   : self.VVQ6HZ(self.SELF, m3uF)
 def VVsMV4(self, url):
  self.url = url
  self.hst, self.usr, self.pas, self.VVbVVr = CCxgvM.VVvtLs(self.url)
  if not all((self.hst, self.usr, self.pas, self.VVbVVr)):
   self.VVqIBc("Cannot process URL")
   return
  c1, c2, c3 = VVnQYw, VV6UAe, VVkLs0
  VVXXzc = []
  zipFile = "%s%s.zip" % (CCxgvM.VVtMU7(), self.VVbVVr)
  if FFf0vs(zipFile):
   VVXXzc.append((c1 + "Browse Local Server", "brwLS"))
   VVXXzc.append((c1 + "Update Local Server", "updLS"))
  else:
   VVXXzc.append((c1 + "Download Resources and Browse Locally", "newLS"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Save to M3U (Live/VOD)"   , "toM3U1"))
  VVXXzc.append((c2 + "Save to M3U (Live/VOD/Series)" , "toM3U2"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Download M3U  (Live=ts)"     , "ful" ))
  VVXXzc.append((c3 + "Download M3U  (Live=m3u8)"    , "ful8"))
  VVXXzc.append((c3 + "Download M3U  (Uncategorized Channels)" , "low" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Download EPG (XML-TV File)", "epg"))
  FFw2XU(self.SELF, BF(self.VVrv1g, zipFile), title="Server Resources", VVXXzc=VVXXzc, width=1000, VVfP2Q=True, VVVzvS="#22002233", VVhHWW="#22001122")
 def VVrv1g(self, zipFile, item=""):
  if item:
   title, ref, ndx = item
   if   ref == "brwLS" : self.VVBYbi(zipFile)
   elif ref == "updLS" : FFHsPu(self.SELF, BF(self.VVeK08, title, "newLS"), 'Update Local Cache ?\n\n"%s"' % self.VVbVVr, title=self.Title)
   elif ref == "toM3U1": self.SELF.VVftto(0, self.hst, self.usr, self.pas, title)
   elif ref == "toM3U2": self.SELF.VVftto(1, self.hst, self.usr, self.pas, title)
   else    : self.VVeK08(title, ref)
 def VVeK08(self, title, ref):
  if ref == "epg" : ext, php, fNm, typ = "xml", "xmltv", "epg"  , ""
  else   : ext, php, fNm, typ = "m3u", "get"  , "channels_" , "&type=m3u"
  if ref in ("newLS", "ful", "ful8"): typ += "_plus"
  if ref == "ful8": typ += "&output=m3u8"
  url = "%s/%s.php?username=%s&password=%s%s" % (self.hst, php, self.usr, self.pas, typ)
  if   ref == "epg": pass
  elif ref == "low": fNm += "uncat"
  else    : fNm += "grouped_" + ("m3u8" if ref == "ful8" else "ts")
  fName = "%s_%s_%s.%s" % (iUrlparse(self.hst).hostname, fNm, FF6eWd(), ext)
  cbFnc = self.VVYGUk if ref == "newLS" else None
  timeout = 90
  CCNCMt(self.SELF, url, os.path.join(FFmAG5(), fName), title=self.Title, pbTxt="Preparing file in server ...", cbFnc=cbFnc, timeout=timeout)
 def VVYGUk(self, ok, url, webFile, path):
  if ok:
   VVhMyz = iUrlparse(url).hostname
   cbFnc = BF(self.VVAfEb, True)
   CC5tyY(self.SELF, VVePgW=path, VVu9JD=url, VVHMrJ=VVhMyz, cbFnc=cbFnc)
  else:
   FFqlCI(path)
 def VVOFgm(self, path):
  m3File, m3Dir, VVEyvc, zPath, zFound = CCxgvM.VVeemh(path)
  cbFnc = BF(self.VVAfEb, False)
  CC5tyY(self.SELF, VVePgW=path, VVHMrJ=VVEyvc, cbFnc=cbFnc)
 def VVAfEb(self, delSrc, path, outD):
  if VVrRHR(outD):
   if delSrc : FFqlCI(path)
   VVQNy8 = outD.rstrip("/") + ".zip"
   CCxgvM.VVOC37(self.SELF, outD, VVQNy8, cbFnc=BF(self.VVBoo1, outD))
 def VVBoo1(self, outD, VVQNy8, tot, err):
  FFelXn(outD)
  if   tot: self.VVBYbi(VVQNy8)
  elif err: self.VVqIBc(err)
  else : self.VVqIBc("No files to compress !")
 @FFHF2S("Checking File Encoding ...", par=1)
 def VVQ6HZ(self, SELF, path):
  if not self.VVCI3i(path):
   m3File, m3Dir, VVEyvc, zPath, zFound = CCxgvM.VVeemh(path)
   if zFound: self.VVBYbi(zPath)
   else  : self.VVOFgm(path)
 def VVCI3i(self, path):
  if FFX42v(path) > pow(10, 4):
   return False
  m3u8 = False
  lst = []
  par = url = ""
  try:
   enc = CC2Ldo.VVM9Xv(path)
   with ioOpen(path, "r", encoding=enc) as f:
    c = 0
    for line in f:
     c += 1
     line = str(line).strip()
     if   c > 30          : break
     elif line.startswith("#EXTM3U")     : continue
     elif line.startswith("#EXTINF:")    : par = line
     elif line.startswith("#EXT-X-MEDIA-SEQUENCE:") : m3u8 = True
     elif par and not line.startswith("#")   : url = line
     if par and url:
      lst.append((par, url))
  except:
   self.VVqIBc("Cannot read file.\n\n%s" % path)
   return True
  if m3u8:
   VVeZBd = os.path.splitext(os.path.basename(path))[0]
   VVDhju, chUrl, VVu69c = CCxgvM.VVI4UZ(1, path, VVeZBd)
   CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=chUrl)
   return True
  if len(lst) == 1: par, url = lst[0]
  else   : return False
  if iMatch(r"^(?:[A-Za-z0-9]+:){10}$", url):
   CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=url)
   return True
  span = iSearch(r"^http.+((?:[A-Za-z0-9]+:){10})$", url)
  if span:
   CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=span.group(1))
   return True
  span = iSearch(r"^http.+\/((?:[A-Za-z0-9]+:){10}\/.+)", url)
  if span:
   CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=span.group(1))
   return True
  span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
  VVeZBd = ((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else ""
  VVeZBd = VVeZBd or os.path.splitext(os.path.basename(path))[0]
  span = iSearch(r"^((?:[A-Za-z0-9]+:){10})(http.+(?:[A-Za-z0-9]+:){10})$", url)
  if span:
   chUrl = "%s%s:%s" % (span.group(1), FFma3M(span.group(2)), VVeZBd)
   CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=chUrl)
   return True
  return False
 def VVMLVD(self):
  lst = [(os.path.splitext(os.path.basename(f))[0], f) for f in iGlob("%s/*.zip" % CCxgvM.VVtMU7()) if os.path.isfile(f)]
  if lst:
   lst.sort(key=lambda x: x[0].lower())
   VV5LxL  = self.VVNaah
   VVpuzu  = self.VVq9pE
   VVSuW0  = ("Home Menu" , FF9hlZ)
   VViDZz  = ("Rename" , self.VVgP5E)
   FFw2XU(self.SELF, None, title=self.Title, VVXXzc=lst, width=1200, VVnojT=3, VVhuPZ="", VV5LxL=VV5LxL, VVpuzu=VVpuzu, VVSuW0=VVSuW0, VViDZz=VViDZz
     , VVVzvS="#08000011", VVhHWW="#08111122", VVlIBH="#08333344")
  else:
   self.VVqIBc('No Local Servers.\n\nYou can add local server form %s.' % FFITtK("Server Resources", VV6UAe))
 def VVNaah(self, item):
  self.VVBYbi(item[2])
 def VVq9pE(self, VVZzW8, txt, ref, ndx):
  self.VVIYqS(ref)
 def VVgP5E(self, VVZzW8, path):
  oName = os.path.basename(path)[:-4]
  FFttdT(self.SELF, BF(self.VVL6Hw, VVZzW8, path, oName), defaultText=oName, title="Rename", message="New name")
 def VVL6Hw(self, VVZzW8, path, oName, nName):
  if not nName or not nName.strip(): return
  title = "Rename : %s" % oName
  nName = nName.strip()
  nPath = os.path.join(os.path.dirname(path), "%s.zip" % nName)
  if   path == nPath  : FF8PJn(VVZzW8, "No change", 800)
  elif FFf0vs(nPath) : FFU9uk(self.SELF, "Name already exists:\n\n%s" % nName, title=title)
  else     : FFHsPu(self.SELF, BF(self.VVdBdy, VVZzW8, title, path, nPath, nName), "Rename to:\n\n%s" % nName, title=title)
 def VVdBdy(self, VVZzW8, title, path, nPath, nName):
  try:
   os.rename(path, nPath)
   VVZzW8.VVPSDX((nName, nPath))
   FFar20(VVZzW8, "Renamed", 800)
  except Exception as e:
   FFU9uk(self.SELF, str(e), title=title)
 def VVBYbi(self, path):
  if path:
   self.VVUXnR = path
   title = os.path.splitext(FFVUvT(path))[0]
   if len(title) > 40: title = "%s .." % title[:40]
   cl = CCxgvM.VVwWU3(path)
   if cl.err or not cl.valid or not cl.totAll:
    self.VVqIBc("Invalid file:\n\n%s" % os.path.basename(path))
    return
   lst = []
   lst.append(("Live" , cl.totL, cl.totChL))
   lst.append(("VOD" , cl.totV, cl.totChV))
   lst.append(("Series", cl.totS, cl.totChS))
   if cl.totM or cl.totChM: lst.append(("Movie" , cl.totM, cl.totChM))
   if cl.totD or cl.totChD: lst.append(("DVB"  , cl.totD, cl.totChD))
   if cl.totR or cl.totChR: lst.append(("S.Relay" , cl.totR, cl.totChR))
   if cl.totF or cl.totChF: lst.append(("FTP"  , cl.totF, cl.totChF))
   lst = [(s, str(g), str(ch))for s, g, ch in lst]
   yelBtn = self.mode != CCxgvM.VVSQ7Z
   VVI3Oq  = (""    , BF(self.VVFXcW, path)   , [])
   VV4dTm = (""    , BF(self.VVAOc9, path) , [])
   VVEyDE = ("Home Menu"  , FF9hlZ             , [])
   VVbQ6N = ("Delete Cache" , BF(self.VVyTet, path) , []) if yelBtn else None
   header  = ("Type" , "Groups" , "Channels")
   widths  = (50  , 25  , 25  )
   VVgKQc = (LEFT  , CENTER , CENTER )
   FFdCaM(self.SELF, self.VVs4iu, title=title, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths
     , VVNYa4=30, VV0Jzc=20, width=1000, VV1Wwb=28, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N, VV4HrS=2
     , VVVzvS="#08222233", VVhHWW="#08222233", VVpaQ6="#08222233", VVI4UA="#083a4a4a", VVcv6F="#08222233", VVsOjr="#08333355")
 def VVAOc9(self, path, VV5ybN, txt, ref, ndx):
  self.VVIYqS(path)
 def VVyTet(self, path, VV5ybN, txt, ref, ndx):
  FFHsPu(self.SELF, BF(self.VVviLn, VV5ybN, path), "Delete ?\n\n%s" % path, title="Delete Local Cache")
 def VVviLn(self, VV5ybN, path):
  FFqlCI(path)
  if FFf0vs(path) : FF8PJn(VV5ybN, "No deleted", 1000)
  else    : VV5ybN.close()
 @FFHF2S(par=2)
 def VVFXcW(self, path, VV5ybN, title, txt, colList):
  self.VVAEMV = colList[0]
  lines, err = CCxgvM.VVmGOl(path, "_main", mode=1)
  if err:
   self.VVqIBc(err)
   return
  lst = []
  srcFil = VVu9JD = srcTm = ""
  for line in lines:
   if line.startswith("#"):
    subj, _, val = line.partition(":")
    subj, val = subj[1:].strip().lower(), val.strip()
    if   subj == "file"  : srcFil = val
    elif subj == "url"   : VVu9JD = val
    elif subj == "created" : srcTm  = val
   else:
    parts = line.split("\t")
    if len(parts) == 5:
     typ, catBlk, fName, totCh, cat = parts
     cat = self.VVeM8A(cat)
     if cat and typ == self.VVAEMV:
      lst.append((cat, totCh, fName))
  if len(lst) == 1 and iMatch(r"\* Uncategorized.+Channels \*", lst[0][0]):
   self.VVZmFU(VV5ybN, path, lst[0][0], lst[0][2])
  elif lst:
   mode = {"l": CCSB3R.VVJlIE, "v": CCSB3R.VV58i3, "s": CCSB3R.VVkiMU}.get(self.VVAEMV[:1].lower())
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = CCSB3R.VVB7ZP(mode)
   lst.sort(key=lambda x: x[0].lower())
   VVI3Oq  = ("Channels" , BF(self.VVDsux, path), [])
   VVEyDE = ("Home Menu" , FF9hlZ         , [])
   VVbQ6N = ("Find in %s" % self.VVAEMV, BF(self.VVkIKt, path) , [])
   header  = ("Category" , "Channels", "fName")
   widths  = (84   , 16  , 0   )
   VVgKQc = (LEFT   , CENTER , CENTER )
   FFdCaM(self.SELF, None, title=self.VVAEMV, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, width=1200, height=960, VV1Wwb=30, VVI3Oq=VVI3Oq, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA)
  else:
   FFk1YE(VV5ybN, "No Groups/Channels", 1000)
 def VVkIKt(self, path, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("Keyboard"  , "manualEntry"))
  VVXXzc.append(("From Filter" , "fromFilter"))
  FFw2XU(self.SELF, BF(self.VV4jzF, VV5ybN, path), title="Input Type", VVXXzc=VVXXzc, width=400)
 def VV4jzF(self, VV5ybN, path, item=None):
  if item == "manualEntry":
   FFttdT(self.SELF, BF(self.VVBhU0, VV5ybN, path), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCrT1G(self.SELF)
   filterObj.VVMhxB(BF(self.VVBhU0, VV5ybN, path))
 def VVBhU0(self, VV5ybN, path, item):
  if not item is None:
   title = "Find in %s" % self.VVAEMV
   words = None
   toFind = item.strip()
   FFDDwF(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCrT1G.VVYDJw(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      self.VVqIBc("Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        self.VVqIBc("All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVyqRl(words):
      self.VVqIBc(self.VVbLG6(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCXRxc.VVJ9VK(self.SELF, VVmj1O="Searching for:%s" % toFind[:15], totBars=2
          , VVCJhW  = BF(self.VVbPGT, VV5ybN, path, title, words, toFind, asPrefix)
          , VVuQkS = BF(self.VVWtKh, VV5ybN, title))
   if not words:
    FF8PJn(VV5ybN, "Nothing to find !", 1500)
 def VVbPGT(self, VV5ybN, path, title, words, toFind, asPrefix, VVM2wn):
  VVM2wn.VViN1g = []
  VVM2wn.VVqMKy(VV5ybN.VVJPu5())
  c = 0
  for ndx, (cat, totCh, fName) in enumerate(VV5ybN.VVTq0J()):
   lines, err = CCxgvM.VVmGOl(path, fName, mode=1)
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   VVM2wn.VVFO1V(len(lines))
   VVM2wn.VV75eC(0)
   VVM2wn.VVoScM(cat)
   for line in lines:
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVoreX(1)
    parts = line.split("\t")
    if len(parts) == 4:
     chBlk, url, name, icn = parts
     name = self.VVYPwG(name)
     if name:
      nm = name.lower()
      if asPrefix and not nm.startswith(words): continue
      elif any(x in nm for x in words)  : pass
      else         : continue
      if CCSB3R.VV0Jba(name):
       name = CCSB3R.VVFSjX(name)
      if icn == "-": icn =""
      c += 1
      if not VVM2wn or VVM2wn.isCancelled: return
      VVM2wn.VViN1g.append((str(c), name, "Yes" if icn else "", url, icn))
 def VVWtKh(self, winObj, cat, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g : self.VVNuhz(cat, VViN1g)
  elif VV9zbx : FFk1YE(winObj, "Not found", 1500)
 def VVDsux(self, path, VV5ybN, title, txt, colList):
  cat, totCh, fName = colList
  self.VVZmFU(VV5ybN, path, cat, fName)
 def VVZmFU(self, winObj, path, cat, fName):
  CCXRxc.VVJ9VK(self.SELF, VVmj1O="Reading Channels ...", VV9L2m=CCXRxc.VVE4fR
      , VVCJhW  = BF(self.VVaYBj, path, fName)
      , VVuQkS = BF(self.VVW904, winObj, cat))
 def VVaYBj(self, path, fName, VVM2wn):
  VVM2wn.VViN1g = []
  lines, err = CCxgvM.VVmGOl(path, fName, mode=1)
  if err:
   self.VVqIBc(err)
   return
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVqMKy(len(lines))
  c = 0
  for line in lines:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   parts = line.split("\t")
   if len(parts) == 4:
    chBlk, url, name, icn = parts
    name = self.VVYPwG(name)
    if name:
     if CCSB3R.VV0Jba(name):
      name = CCSB3R.VVFSjX(name)
     if icn == "-": icn =""
     c += 1
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VViN1g.append((str(c), name, "Yes" if icn else "", url, icn))
 def VVW904(self, winObj, cat, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g : self.VVNuhz(cat, VViN1g)
  else   : FFk1YE(winObj, "No channels", 1000)
 def VVNuhz(self, cat, lst):
  showGrn = self.VVkZb3() != "m3u"
  VVVzvS, VVhHWW, VVpaQ6, VVI4UA = CCSB3R.VVB7ZP(CCSB3R.VVIqPb)
  VVI3Oq  = ("Play"   , self.VVSAKA   , [])
  VV4dTm = (""    , self.VVHaWo, [])
  VVEyDE = ("Home Menu"  , FF9hlZ      , [])
  VV5CrJ = ("Download Options", self.VVWqo1,[]) if showGrn else None
  VVbQ6N = ("Options"  , BF(self.VVU7MK, cat), [])
  VVvrJb = ("Posters Mode" , self.VVEMft , [])
  header  = ("Num" , "Name", "Logo", "url" , "icn" )
  widths  = (8  , 84 , 8  , 0  , 0  )
  VVgKQc = (CENTER , LEFT , CENTER, CENTER, CENTER)
  FFdCaM(self.SELF, None, title=cat, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VVrpeX=True, VVylFd=1)
 def VVU7MK(self, VVCx62, VV5ybN, title, txt, colList):
  isMulti = VV5ybN.VVbbT0
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VV5ybN.VVQrKf()
   totTxt = "%d Service%s" % (tot, FFEnJs(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFITtK(totTxt, VV6UAe)
  cl = CCxgvM.VVwWU3(self.VVUXnR)
  hst, usr, pas, VVbVVr = CCxgvM.VVvtLs(cl.VVu9JD)
  if not VVbVVr:
   num, name, logo, url, VVKCwZ = colList
   hst, usr, pas, VVbVVr = CCxgvM.VVvtLs(url)
  VVCx622 = ("%s (%s)" % (VVCx62, VVbVVr)) if VVbVVr else ""
  mSel = CCZALl(self.SELF, VV5ybN, addSep=False, setsOk=True, setsBlue=True)
  VVXXzc, cbFncDict = [], None
  VVXXzc.append(VVzg1X)
  if itemsOK:
   VVXXzc.append(("Add %s to New Bouquet : %s"    % (totTxt, FFITtK(VVCx62 , VV8QGw)), "addToCur1"))
   if VVCx622: VVXXzc.append(("Add %s to New Bouquet : %s" % (totTxt, FFITtK(VVCx622, VVi4ay)) , "addToCur2"))
   VVXXzc.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   title = "Add to Bouquet"
   cbFncDict = { "addToCur1": BF(self.VVWnzj , VVCx62 , VV5ybN, title)
      , "addToCur2": BF(self.VVWnzj , VVCx622, VV5ybN, title)
      , "addToNew" : BF(self.VVUBXa, VVCx62, VV5ybN, title)
      }
  else:
   VVXXzc.append(("Add to Bouquet (nothing selected)", ))
  mSel.VVejOk(VVXXzc, cbFncDict, width=1400)
 @FFHF2S("Adding Services ...", par=2)
 def VVWnzj(self, VVCx62, VV5ybN, Title):
  chUrlLst = self.VVPCv7(VV5ybN)
  CC41Tt.VVsLIN(self.SELF, Title, VVCx62, "", chUrlLst)
 def VVUBXa(self, VVCx62, VV5ybN, Title):
  picker = CC41Tt(self.SELF, VV5ybN, Title, BF(self.VVPCv7, VV5ybN), VVJ2id=VVCx62)
 def VVPCv7(self, VV5ybN):
  isMulti = VV5ybN.VVbbT0
  chUrlLst = []
  rowNum = 0
  for ndx, (num, name, logo, url, VVKCwZ) in enumerate(VV5ybN.VVTq0J()):
   if not isMulti or VV5ybN.VVAkKb(ndx):
    chUrl = self.VVkGdi(rowNum, url, name)
    rowNum += 1
    if chUrl and name:
     chUrlLst.append(chUrl)
  return chUrlLst
 def VVWqo1(self, VV5ybN, title, txt, colList):
  isMulti = VV5ybN.VVbbT0
  tot  = VV5ybN.VVQrKf()
  if isMulti:
   if tot < 1:
    FF8PJn(VV5ybN, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFEnJs(tot)
  else:
   name = "ALL"
   plural = "s"
  VVXXzc = []
  VVXXzc.append(("Download %s %s%s" % (name, "PIcon" if self.VVAEMV == "Live" else "Poster", plural), "dnldPicons" ))
  if self.VVAEMV in ("VOD", "Series"):
   VVXXzc.append(VVzg1X)
   tName = "Movie" if self.VVAEMV == "VOD" else "Episode"
   VVXXzc.append(("Download Current %s" % tName    , "dnldSel"  ))
   VVXXzc.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if not CChTrx.VVnzW8():
    VVXXzc.append(VVzg1X)
    VVXXzc.append(("Download Manager"      , "dload_stat" ))
  FFw2XU(self.SELF, BF(self.VVXoyY, VV5ybN, colList), title="Download Options", VVXXzc=VVXXzc)
 def VVXoyY(self, VV5ybN, colList, item=None):
  if item:
   if   item == "dnldPicons" : CCSB3R.VVp6vy(self.SELF, VV5ybN, "m3u")
   elif item == "dnldSel"  : self.VVyRqB(VV5ybN, colList, True)
   elif item == "addSel"  : self.VVyRqB(VV5ybN, colList, False)
   elif item == "dload_stat" : CChTrx.VVWJLc(self.SELF, VV5ybN)
 def VVyRqB(self, VV5ybN, colList, startDnld):
  VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = self.VV35A0(colList)
  if startDnld:
   CChTrx.VVlexV(self.SELF, VVu69c)
  else:
   self.VVG0hg(VV5ybN, "Add to Download list", VVeZBd, [VVu69c], startDnld)
 def VVG0hg(self, VV5ybN, title, VVeZBd, VVSOaj, startDnld):
  FFHsPu(self.SELF, BF(self.VVH7vn, VV5ybN, VVSOaj, startDnld), VVeZBd, title=title)
 def VVH7vn(self, VV5ybN, VVSOaj, startDnld):
  added, skipped = CChTrx.VVogaa(VVSOaj)
  FF8PJn(VV5ybN, "Added", 1000)
 def VVSAKA(self, VV5ybN, title, txt, colList):
  VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = self.VV35A0(colList)
  if isMark:
   FF8PJn(VV5ybN, "Cannot play markers", 500)
  else:
   chUrl = CC5ENZ.VVHaiG(self.SELF, chUrl)
   VVthiO = self.VVzqmO(VVKCwZ)
   CC2lVw.VVbVSZ(self.SELF.session, VVVQym=(self, VV5ybN, "localServer"), VV7GTU=chUrl, VVthiO=VVthiO)
 def VV35A0(self, colList):
  return CCxgvM.VV6wA2(self.SELF, colList)
 def VVkxWd(self, VV5ybN, colList, isUp):
  VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = self.VV35A0(colList)
  if isMark:
   for i in range(VV5ybN.VVJPu5()):
    if isUp : VV5ybN.VVVMkx()
    else : VV5ybN.VVycmo()
    VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = self.VV35A0(VV5ybN.VVqY3Q())
    if not isMark:
     break
  VVthiO = self.VVzqmO(VVKCwZ)
  return VVeZBd, chUrl, VVthiO
 def VVHaWo(self, VV5ybN, title, txt, colList):
  VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = self.VV35A0(colList)
  CCISy5.VVIXmT(self.SELF, VVjex7=CCISy5.VVez6E, params=(VVDhju, VVeZBd, txt, chUrl, VVKCwZ))
 def VVEMft(self, VV5ybN, title, txt, colList):
  FFTSvN(VV5ybN, BF(self.SELF.session.open, CCw9hJ, VV5ybN, self.VVxreR(), 1, 4, 0, "Num"))
 def VVkZb3(self):
  return self.VVAEMV.lower() if self.VVAEMV in ("Live", "VOD", "Series") else "m3u"
 def VVxreR(self):
  return CCSB3R.VVoS8r(self.VVkZb3())
 def VVzqmO(self, VVKCwZ):
  return os.path.join(self.VVxreR(), os.path.basename(VVKCwZ)) if VVKCwZ else ""
 def VVIYqS(self, path):
  cl = CCxgvM.VVwWU3(path)
  srcFil = cl.srcFil or path
  if any((srcFil, cl.srv, cl.VVu9JD, cl.srcTm, cl.totAll)):
   c1 = VV6UAe
   tab = lambda x, y: ("   %s\t: %s\n" % (x, y))
   tab1 = lambda x, y: ("   %s\t: %s\n" % (x, y)) if y else ""
   ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, c1), str(y)) if y else ""
   txt  = ttl("Name"  , cl.srv)
   txt += ttl("Saved"  , cl.srcTm)
   if FFf0vs(srcFil):
    t = srcFil + FFITtK("\nNote : Original file was modified.", VVu50a) if cl.toUpd else ""
    txt += ttl("Source File", t)
   txt += ttl("Source URL"  , cl.VVu9JD)
   txt += FFITtK("Total:\n", c1)
   txt += tab("Groups"  , cl.totGrp)
   txt += tab("Services" , cl.totSrv)
   if cl.totEnt:
    txt += FFITtK("\nEntries (%s):\n" % cl.totEnt, c1)
    txt += tab1("  Live" , cl.totChL)
    txt += tab1("  VOD"  , cl.totChV)
    txt += tab1("  Series" , cl.totChS)
    txt += tab1("  Movie" , cl.totChM)
    txt += tab1("  DVB"  , cl.totChD)
    txt += tab1("  S.Relay" , cl.totChR)
    txt += tab1("  FTP"  , cl.totChF)
    txt += tab1("  Marker" , cl.totChK)
   FFyijw(self.SELF, txt, "Services")
  else:
   FF8PJn(VVZzW8, "No info", 500)
 @staticmethod
 def VVwWU3(path):
  class CClf7d():
   def __init__(self):
    self.srv = os.path.splitext(FFVUvT(path))[0]
    self.srcFil = self.srcMod = self.VVu9JD = self.srcTm = ""
    self.totL = self.totV = self.totS = self.totM = self.totD = self.totR = self.totF = 0
    self.totChL = self.totChV = self.totChS = self.totChM = self.totChD = self.totChR = self.totChF = self.totChK = 0
    self.totEnt = self.totSrv = self.totAll = 0
    self.valid = False
    self.toUpd = False
    self.err = ""
    lines, self.err = CCxgvM.VVmGOl(path, "_main", mode=1)
    if self.err:
     return
    skip = CFG.hideIptvServerAdultWords.getValue()
    tab1 = lambda s, v, t: int(v) if s == t and v.isdigit() else 0
    tab2 = lambda s, v, t: int(v) if s == "blk_" + t and v.isdigit() else 0
    tab3 = lambda x, catBlk: 1 if (line.startswith(x) and not (skip and catBlk)) else 0
    for line in lines:
     if line.startswith("#"):
      subj, _, val = line.partition(":")
      subj, val = subj[1:].strip().lower(), val.strip()
      if   subj == "file"  : self.srcFil = val
      elif subj == "modified" : self.srcMod = val
      elif subj == "url"  : self.VVu9JD = val
      elif subj == "saved" : self.srcTm  = val
      elif subj == "entries" : self.totEnt = val
      elif subj == "services" : self.totSrv = val
      self.totChL += tab1(subj, val, "live" )
      self.totChV += tab1(subj, val, "vod" )
      self.totChS += tab1(subj, val, "series" )
      self.totChM += tab1(subj, val, "movie" )
      self.totChD += tab1(subj, val, "dvb" )
      self.totChR += tab1(subj, val, "s.relay")
      self.totChF += tab1(subj, val, "ftp" )
      self.totChK += tab1(subj, val, "marker" )
      if skip:
       self.totChL -= tab2(subj, val, "live" )
       self.totChV -= tab2(subj, val, "vod" )
       self.totChS -= tab2(subj, val, "series" )
       self.totChM -= tab2(subj, val, "movie" )
       self.totChD -= tab2(subj, val, "dvb" )
       self.totChR -= tab2(subj, val, "s.relay")
       self.totChF -= tab2(subj, val, "ftp" )
       self.totChK -= tab2(subj, val, "marker" )
     else:
      parts = line.split("\t")
      if len(parts) == 5:
       typ, catBlk, fName, totCh, cat = line.split("\t")
       catBlk = catBlk == "1"
       self.totL += tab3("Live" , catBlk)
       self.totV += tab3("VOD"  , catBlk)
       self.totS += tab3("Series" , catBlk)
       self.totM += tab3("Movie" , catBlk)
       self.totD += tab3("DVB"  , catBlk)
       self.totR += tab3("S.Relay" , catBlk)
       self.totF += tab3("FTP"  , catBlk)
    self.totGrp = self.totL + self.totV + self.totS + self.totM + self.totD + self.totR + self.totF
    self.totCh = self.totChL + self.totChV + self.totChS + self.totChM + self.totChD + self.totChR + self.totChF
    self.totAll = self.totGrp + self.totCh
    self.valid = any((self.srv, self.srcFil, self.VVu9JD, self.srcTm, self.totAll))
    if self.srcMod and FFf0vs(self.srcFil):
     try:
      old = int(self.srcMod)
      cur = int(os.path.getmtime(self.srcFil))
      self.toUpd = old != cur
     except:
      pass
  return CClf7d()
 def VVqIBc(self, err, title=""):
  FFU9uk(self.SELF, err, title=title or self.Title)
 def VVkGdi(self, rowNum, url, VVeZBd):
  VVDhju = CCxgvM.VV2U8q(rowNum + 1, url)
  span1 = iSearch(r"((?:[a-z0-9]+:){10})(.+)(:.+)", url, IGNORECASE)
  span2 = iSearch(r"((?:[a-z0-9]+:){10})(.+)"  , url, IGNORECASE)
  span3 = iSearch(r"((?:[a-z0-9]+:){10})$"  , url, IGNORECASE)
  span4 = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", url, IGNORECASE)
  if   span1 : return "%s%s%s"  % (span1.group(1), FFma3M(span1.group(2)), span1.group(3))
  elif span2 : return "%s%s:%s" % (span2.group(1), FFma3M(span2.group(2)), VVeZBd)
  elif span3 : return span3.group(1)
  elif span4 : return "%s%s:%s" % (VVDhju, FFma3M(span4.group(1)) + span4.group(2) + FFma3M(span4.group(3)) + span4.group(4), VVeZBd)
  else  : return "%s%s:%s" % (VVDhju, FFma3M(url), VVeZBd)
 @staticmethod
 def VV2U8q(rowNum, url):
  span = iSearch(r".+\/(\d+)\.?", url)
  num = span.group(1) if span else "444"
  catID = "333"
  chNum = str(rowNum)
  stID = num if int(num) < 0xeeee0000 else "444"
  VVDhju = CCSB3R.VV7RE0(catID, stID, chNum)
  return VVDhju
 @staticmethod
 def VVeemh(path):
  m3Dir = FFA4GT(os.path.dirname(path))
  m3File = os.path.basename(path)
  VVEyvc = os.path.splitext(m3File)[0]
  zPath = "%s%s.zip" % (CCxgvM.VVtMU7(), VVEyvc)
  zFound = FFf0vs(zPath)
  return m3File, m3Dir, VVEyvc, zPath, zFound
 @staticmethod
 def VVtMU7():
  return FFmAG5() + "ajpanel_local_servers/"
 @staticmethod
 def VV6wA2(SELF, colList):
  num, name, logo, url, VVKCwZ = colList
  VVeZBd = FFes9J(name)
  isMark = FF2eiM(url)
  if iMatch(r"^([A-Fa-f0-9]+[:]){10}", url):
   VVDhju = chUrl = url
   VVu69c = ""
  else:
   VVDhju, chUrl, VVu69c = CCxgvM.VVI4UZ(int(num) + 1, url, VVeZBd)
  return VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark
 @staticmethod
 def VVI4UZ(num, url, VVeZBd):
  VVu69c = FF0rS9(url)
  VVDhju = CCxgvM.VV2U8q(num, VVu69c)
  span = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", VVu69c, IGNORECASE)
  if span : encUrl = FFma3M(span.group(1)) + span.group(2) + FFma3M(span.group(3)) + span.group(4)
  else : encUrl = FFma3M(VVu69c)
  chUrl = "%s%s:%s" % (VVDhju, encUrl, VVeZBd)
  VVu69c = "%s:%s" % (VVu69c, VVeZBd)
  return VVDhju, chUrl, VVu69c
 @staticmethod
 def VVOC37(SELF, Dir, VVQNy8, cbFnc=None):
  CCXRxc.VVJ9VK(SELF, VVmj1O="Counting Files ...", titleBg="#22220022", bodyBg="#22002211", barBg="#0a226622"
      , VVCJhW  = BF(CCxgvM.VVY4aP, Dir, VVQNy8)
      , VVuQkS = BF(CCxgvM.VVzyCs, SELF, VVQNy8, cbFnc))
 @staticmethod
 def VVY4aP(Dir, VVQNy8, VVM2wn):
  tot = 0
  for root, dirs, files in os.walk(Dir):
   tot += len(files)
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVqMKy(tot)
  VVM2wn.VViN1g = (0, "")
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VVQNy8, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
      if not VVM2wn or VVM2wn.isCancelled: return
      VVM2wn.VVwOHf(1)
      VVM2wn.VVkdWG("Archiving Files : %s" % tot)
      VVM2wn.VViN1g = (tot, "")
  except Exception as e:
   VVM2wn.VViN1g = (tot, str(e))
 @staticmethod
 def VVzyCs(SELF, VVQNy8, cbFnc, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  tot, err = VViN1g
  if err: FFqlCI(VVQNy8)
  if cbFnc: cbFnc(VVQNy8, tot, err)
 @staticmethod
 def VVWGlJ(Dir, VVQNy8):
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VVQNy8, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
  except Exception as e:
   err = str(e)
  return tot, err
 @staticmethod
 def VVmGOl(VVQNy8, fil, mode=0):
  try:
   with iZip.ZipFile(VVQNy8) as zipF:
    zInfLst = zipF.infolist()
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if fName == fil:
      with zipF.open(zipInfo.filename) as f:
       txt = f.read().decode()
       if mode == 0: return str(txt), ""
       else  : return [str(x.strip()) for x in txt.splitlines()], ""
  except Exception as e:
   return "", str(e)
  return "", "Missing file"
 @staticmethod
 def VVvtLs(url):
  try: res = iUrlparse(url)
  except: return [""] * 4
  scheme = res.scheme
  netloc = res.netloc
  query = res.query
  VVbVVr = res.hostname or ""
  hst  = "%s://%s" % ((scheme or "http"), netloc)
  d = iUrlparse_qs(query)
  usr = d.get("username")[0] if "username" in d else ""
  pas = d.get("password")[0] if "password" in d else ""
  return hst, usr, pas, VVbVVr
 @staticmethod
 def VV1lfy(url, chkExt=False):
  if any(x in url for x in ("/series/", "mode=series")):
   return "Series"
  if any(x in url for x in ("/movie/", "/movie.php", "/media/vod", "mode=vod", "/vod/", "/video/", "/timeshift/")):
   return "VOD"
  if any(x in url for x in ("/live/", "/live2/", "/live.php", "mode=itv", "?ext=.ts", "/index.m3u8")):
   return "Live"
  if url.startswith("1:64:")       : return "Marker"
  if url.startswith("/")        : return "Movie"
  if FFOr4F(url)        : return "S.Relay"
  if iMatch(r"^(?:[A-Fa-f0-9]+:){10}", url)   : return "DVB"
  if iMatch(r"^http.+(?:[A-Fa-f0-9]+:){10}", url)  : return "DVB"
  if any(x in url for x in ("file?file", ":ftp%3a//")): return "FTP"
  if chkExt and any(x in url for x in (".mp4", ".mkv", ".avi")):
   return "VOD"
  return "Live"
class CC5ENZ(CCNREC):
 def __init__(self):
  self.curPortalCatId = ""
  CCNREC.__init__(self)
 def VVqcpt(self):
  if CC5ENZ.VVPib3(self):
   self.VVIcSt(2)
 def VVVYLv(self, winSession, url, mac):
  self.VVmrz9 = url
  if CC5ENZ.VVPib3(self):
   if self.VVDhq2(url, mac):
    FFTSvN(winSession, self.VV64XY, title="Checking Server ...")
   else:
    FFU9uk(self, "Incorrect URL or MAC format !", title="Starting Portal Browser")
 def VVJVZw(self, item=None):
  if item:
   VVZzW8, txt, path, ndx = item
   enc = CC2Ldo.VVM9Xv(path, self)
   if enc == -1:
    return
   CCXRxc.VVJ9VK(self, VVmj1O="Processing file lines"
       , VVCJhW  = BF(self.VVgq8l, path, enc)
       , VVuQkS = BF(self.VV4se0, VVZzW8, path))
 def VVgq8l(self, path, enc, VVM2wn):
  urlMacPatt  = r"(.*)(https?:\/\/.+(?::[0-9]+)*)(?:.+)((?:[A-Fa-f0-9]{2}\s*:\s*){5}[A-Fa-f0-9]{2})(.*)"
  urlOnlyPatt = r"\s*(https?:\/\/.+(?::[0-9]+)*)"
  macOnlyPatt = r"((?:(?:.*mac\s*)[^A-Fa-f0-9]\s*)*)((?:(?:(?:[A-Fa-f0-9]{2})\s*:\s*){5})\s*(?:[A-Fa-f0-9]{2}))(.*)"
  tableRows, url = [], ""
  lineNum = 0
  totLines = 0
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    totLines += 1
  VVM2wn.VVqMKy(totLines)
  VVM2wn.VViN1g = []
  def VVjJzY(subj, host, mac, info):
   if host and mac and VVM2wn:
    if not [1 for _, _, _, host1, mac1, _ in VVM2wn.VViN1g if (host1, mac1) == (host, mac)]:
     VVM2wn.VViN1g.append((str(len(VVM2wn.VViN1g) + 1), str(lineNum), subj, host, mac, info))
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    lineNum += 1
    if not VVM2wn or VVM2wn.isCancelled:
     return
    VVM2wn.VVwOHf(1, True)
    line = str(line).strip()
    if not line or len(line) > 500 or "password" in line:
     continue
    span = iSearch(urlMacPatt, line, IGNORECASE)
    if span:
     subj = span.group(1).strip().strip(',"') or "-"
     url  = span.group(2).strip().split(" ")[0].split("\t")[0].strip()
     mac  = span.group(3).strip().replace(" ", "").upper()
     info = span.group(4).strip().strip(',;"\t') or "-"
     host = self.VV4XkC(url).replace('"mac', "").strip(',"')
     mac  = self.VVGKVN(mac)
     VVjJzY(subj, host, mac, info)
     url = ""
     continue
    if not url:
     span = iSearch(urlMacPatt, line, IGNORECASE)
     if not span:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
    else:
     span = iSearch(macOnlyPatt, line.replace("\t", " "), IGNORECASE)
     if span:
      subj = span.group(1).strip().strip(',"') or "-"
      mac  = span.group(2).strip().replace(" ", "").upper()
      info = span.group(3).strip().strip(',;"') or "-"
      host = self.VV4XkC(url).strip(',;"\t')
      mac  = self.VVGKVN(mac)
      VVjJzY("", host, mac, info)
     else:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
 def VV4se0(self, VVmKt7, path, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g:
   VVI3Oq  = ("Select"   , self.VVfzTQ , [])
   VV9mY2  = BF(self.VVsGWF, VVmKt7)
   VVEyDE  = ("Home Menu"  , FF9hlZ            , [])
   VV5CrJ = ("Browse as M3U" , self.VVNxZy        , [])
   VVbQ6N = ("Edit File"  , BF(self.VVKLTL, path)       , [])
   VVvrJb = ("Options"  , BF(self.VV8nzO, VVmKt7, path) , [])
   header   = ("Num" , "LineNum" , "Title" , "Host", "MAC-Address" , "Comments")
   widths   = (7  , 0   , 12  , 36 , 20   , 25  )
   VVgKQc  = (CENTER , CENTER , LEFT  , LEFT , CENTER  , LEFT  )
   VV5ybN = FFdCaM(self, None, title=os.path.basename(path), header=header, VV5dDF=VViN1g, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV9mY2=VV9mY2, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVVzvS="#0a001122", VVhHWW="#0a001122", VVpaQ6="#0a001122", VVI4UA="#00004455", VVcv6F="#0a333333", VVsOjr="#11331100", VVrpeX=True, VVylFd=3, VV7VIQ=CFG.lastFindServers)
   if not VV9zbx:
    FF8PJn(VV5ybN, "Stopped at line %s" % threadCounter, 1000)
  else:
   if VV9zbx:
    FFU9uk(self, "No valid portal data (or incorrect file format) in:\n\n%s" % path, title="Get Portal Data")
 @FFHF2S("Checking Access ...", par=1, clearMsg=False)
 def VVNxZy(self, VV5ybN, title, txt, colList):
  host, mac = colList[3], colList[4]
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCNREC.VVMjLY(host=host, mac=mac)
  VV5ybN.VV8SQf()
  if pUrlAcc and pUrlDnld : self.VVSgqw(VV5ybN, title, pUrlAcc)
  else     : FFU9uk(self, err or "No response from Server !", title="Playlist for : %s" % host)
 def VVfzTQ(self, VV5ybN, title, txt, colList):
  self.VVVYLv(VV5ybN, colList[3], colList[4])
 def VVKLTL(self, path, VV5ybN, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFf0vs(path) : CCAvJY(self, path, VVuQkS=BF(self.VVrnsp, VV5ybN), VVSkE3=rowNum)
  else    : FFbHk5(self, path)
 def VV8nzO(self, VVmKt7, path, VV5ybN, title, txt, colList):
  VVXXzc =[]
  VVXXzc.append(("Filter Responsive Servers"  , "tok"))
  VVXXzc.append(("Find Servers with Playlist Access", "plst"))
  FFw2XU(self, BF(self.VVs3QU, VVmKt7, VV5ybN, path), title="Portal Options", VVXXzc=VVXXzc, width=700)
 def VVs3QU(self, VVmKt7, VV5ybN, path, item):
  if not item: return
  isToken = item == "tok"
  nm, ext = os.path.splitext(os.path.basename(path))
  for s in ("TOKEN_", "PLAYLIST_", "OK_"): nm = nm.replace(s, "")
  nm = iSub(r"(_\d{8})", "", nm)
  nm = iSub(r"(_\d{6})", "", nm)
  nm, _ = os.path.splitext(nm)
  txt = "TOKEN" if item == "tok" else "PLAYLIST"
  nm = "%s_%s_%s.txt" % (nm, "TOKEN" if isToken else "PLAYLIST", FF6eWd())
  outF = os.path.join(os.path.dirname(path), nm)
  self.VVcYGa(VVmKt7, VV5ybN, outF, isToken, VV5ybN.VVTq0J(), VV5ybN.VVJPu5())
 def VVcYGa(self, VVmKt7, VV5ybN, outF, isToken, lst, tot):
  CCXRxc.VVJ9VK(self, VVmj1O="Checking Portals"
      , VVCJhW  = BF(self.VVEUCp, outF, isToken, lst, tot)
      , VVuQkS = BF(self.VVF4PO, VVmKt7, VV5ybN, outF, isToken))
 def VVEUCp(self, outF, isToken, lst, tot, VVM2wn):
  totOk = totNotOK = totHstErr = totSkip = 0
  VVM2wn.VViN1g = (totOk, totNotOK, totHstErr, totSkip, "")
  VVM2wn.VVqMKy(tot)
  skipHosts = set()
  for row in lst:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVLjbA(0, totOk)
   num, lNum, titl, host, mac, cmnt = row
   valid = False
   if host in skipHosts        : totSkip += 1
   elif self.VVDhq2(host, mac, VVqUOx=False) : valid = True
   else            : totHstErr += 1
   if valid:
    fLine = token = pUrlAcc = ""
    if isToken:
     t1 = iTime()
     token, profile, tErr = self.VV4B2b(VVqUOx=False)
     took = "%.3f" % (iTime() - t1)
     if token:
      fLine = "%s\t%s\t%s\t(Token: %s sec) %s" % (titl, host, mac, took, "" if cmnt == "-" else cmnt)
    else:
     p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCNREC.VVMjLY(host=host, mac=mac)
     if pUrlAcc:
      fLine = "%s\t%s\n%s\n" % (host, mac, pUrlAcc)
    if not VVM2wn or VVM2wn.isCancelled: return
    if isToken and token or not isToken and pUrlAcc:
     try:
      with open(outF, "a") as f:
       f.write("%s\n" % fLine)
      totOk += 1
      if not VVM2wn or VVM2wn.isCancelled: return
      VVM2wn.VViN1g = (totOk, totNotOK, totHstErr, totSkip, "")
     except Exception as e:
      if not VVM2wn or VVM2wn.isCancelled: return
      VVM2wn.VViN1g = (totOk, totNotOK, totHstErr, totSkip, str(e))
      return
    else:
     if self.portal_latestResponse.get("resCritical", ""):
      skipHosts.add(host)
      totSkip += 1
     else:
      totNotOK += 1
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VViN1g = (totOk, totNotOK, totHstErr, totSkip, "")
   VVM2wn.VVLjbA(1, totOk)
 def VVF4PO(self, VVmKt7, VV5ybN, outF, isToken, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  totOk, totNotOK, totHstErr, totSkip, err = VViN1g
  c1, c2 = VV8QGw, VVcahY
  tab = lambda a, b: "%s\t: %s\n" % (a, b)
  txt  = tab("Servers" ,  threadTotal)
  txt += tab("Checked" ,  threadCounter)
  txt += tab("Accessible" ,  FFITtK(totOk, c1 if totOk else c2))
  if totNotOK   : txt += tab("No Token" if isToken else "Not found", totNotOK)
  if totSkip   : txt += tab("Skipped"  , "%d (host access error)" % totSkip)
  if totHstErr  : txt += tab("Host Error" , totHstErr)
  if err    : txt += tab("\nError" , FFITtK(err, c2))
  if not VV9zbx : txt += tab("\nProcess", FFITtK("Stopped", c2))
  if totOk   : txt += "\n%s\n%s\n" % (FFITtK("Output File:", c1), outF)
  FFyijw(self, txt, title="Portal Servers Filtering")
  if totOk:
   if VVmKt7: VVmKt7.VVgjzO((outF, outF), isSort=True)
   if VV5ybN: VV5ybN.close()
 def VV64XY(self):
  token, profile, tErr = self.VV4B2b()
  if token:
   dots = "." * self.VV8kNO
   dots += {"s":"", "p":"+", "q":"++"}.get(self.VVljKL(), "")
   dots += "*" if not self.VVD5zt == self.VVmrz9 else ""
   if dots:
    dots = FFITtK(dots, VVgzFX)
   if CFG.simplePortal.getValue() : VVVzvS, VVhHWW = "#22553344", "#22552233"
   else       : VVVzvS, VVhHWW = "#22003344", "#22002233"
   VVXXzc  = self.VVU2k3()
   VV5LxL = self.VVi9Hg
   VVpuzu = BF(self.VV8q28, 1)
   VVSuW0 = ("Home Menu", FF9hlZ)
   VVI6TY= ("Add to Menu", BF(CCSB3R.VVFU3m, self, True, self.VVD5zt + "\t" + self.VV0Iab))
   VViDZz = ("Bookmark", BF(CCSB3R.VVTaN9, self, True, self.VVD5zt + "\t" + self.VV0Iab))
   VVZzW8 = FFw2XU(self, None, title="Portal Resources (MAC=%s) %s" % (self.VV0Iab, dots), VVXXzc=VVXXzc, VV5LxL=VV5LxL, VVpuzu=VVpuzu, VVSuW0=VVSuW0, VVI6TY=VVI6TY, VViDZz=VViDZz, VVVzvS=VVVzvS, VVhHWW=VVhHWW)
   self.VV63sN(VVZzW8)
 def VVi9Hg(self, item=None):
  if item:
   VVZzW8, title, ref, ndx = item
   if   ref == "live"   : mode = "itv"
   elif ref == "vod"   : mode = "vod"
   elif ref == "series"  : mode = "series"
   elif ref == "accountInfo" : mode = ""
   if mode : self.VVGeMb(VVZzW8, mode)
   else : self.VVHcV2(VVZzW8, title)
 @FFHF2S("Reading Account ...", par=1)
 def VVHcV2(self, VVZzW8, title, forceMoreInfo=False):
  rows, totCols = self.VV40vj(forceMoreInfo)
  title = "%s (MAC=%s)" % (title, self.VV0Iab)
  VVEyDE  = ("Home Menu" , FF9hlZ           , [])
  VV5CrJ  = None
  if VVpSLv:
   VV5CrJ = ("Get JS"  , BF(self.VV7m2U, self.VV9Q1g()) , [])
  if totCols == 2:
   VVvrJb = None
   header   = ("Subject" , "Value" )
   widths   = (43   , 57  )
   VVylFd  = 0
  else:
   VVvrJb = ("More Info.", BF(self.VVkMKO, VVZzW8)    , [])
   header   = ("Num", "User/Server" , "Subject" , "Value" )
   widths   = (0 , 15   , 35  , 50  )
   VVylFd  = 2
  FFdCaM(self, None, title=title, width=1200, header=header, VV5dDF=rows, VV1PTZ=widths, VV1Wwb=26, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVvrJb=VVvrJb, VVVzvS="#0a00292B", VVhHWW="#0a002126", VVpaQ6="#0a002126", VVI4UA="#00000000", VVylFd=VVylFd)
 @FFHF2S("Getting JS ...", par=2)
 def VV7m2U(self, url, VV5ybN, title, txt, colList):
  txt  = "// Host\t: %s\t%s\n" % (url, self.VV0Iab)
  ver, err = self.VVGMO8(url)
  txt += "// Version\t: %s\n\n" % (ver or err)
  js , err = self.VVGMO8(url, isJsFile=True)
  if err: txt += "Error : %s" % err
  else  : txt += js
  FFyijw(self, txt, title="JS Info", VVUrKi="Server_xpcom.common.js")
 def VVkMKO(self, VVZzW8, VV5ybN, title, txt, colList):
  VV5ybN.cancel()
  self.VVHcV2(VVZzW8, "Account Info.", forceMoreInfo=True)
 @FFHF2S("Reading Categories ...", par=1)
 def VVGeMb(self, VVZzW8, mode):
  token, profile, tErr = self.VV4B2b()
  if not token:
   return
  res, err = self.VVdce0(self.VV3IoI(mode))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]
     for item in chList:
      Id   = FFX7JA(item, "id"       )
      Title  = FFX7JA(item, "title"      )
      censored = FFX7JA(item, "censored"      )
      Title = self.VVeM8A(Title)
      if Title:
       isAll = Title.strip().lower() in ("all", "all channels")
       if not isAll or isAll and VVd25Y:
        list.append((Title.strip(), Id))
   except:
    pass
  title = self.VVvzqt(mode)
  if list:
   list.sort(key=lambda x: x[0].lower())
   self.VVHPL5 = dict([(x[1], x[0]) for x in list])
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP(mode)
   mName = self.VVvzqt(mode)
   VVsB8G  = (""     , BF(self.VVOCtr, mode), [])
   VVI3Oq   = ("Show List"   , BF(self.VVkwps, mode)   , [])
   VVEyDE  = ("Home Menu"   , FF9hlZ        , [])
   if mode in ("vod", "series"):
    VVbQ6N = ("Find in %s" % mName , BF(self.VVT0BP, mode, False), [])
    VVvrJb = ("Find in Selected" , BF(self.VVT0BP, mode, True) , [])
   else:
    VVbQ6N = None
    VVvrJb = None
   header   = None
   widths   = (100   , 0  )
   FFdCaM(self, None, title=title, width=1200, header=header, VV5dDF=list, VV1PTZ=widths, VV1Wwb=30, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVsB8G=VVsB8G, VVI3Oq=VVI3Oq, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VV7VIQ=CFG.lastFindIptv)
  else:
   s = "Authorization failed"
   if err:
    txt = err
   elif s in res.text:
    txt = s
    if self.VVU503:
     txt += "\n\n( %s )" % self.VVU503
   else:
    txt = "Could not get Categories from server!"
   FFU9uk(self, txt, title=title)
 @FFHF2S("Downloading ...", par=2)
 def VVyHPp(self, mode, VV5ybN, title, txt, colList):
  token, profile, tErr = self.VV4B2b()
  if not token:
   return
  VVonh7 = colList[1]
  catID  = colList[2]
  res, err = self.VVdce0(self.VVSzoc(catID))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]['data']
     for item in chList:
      Id    = FFX7JA(item, "id"    )
      actors   = FFX7JA(item, "actors"   )
      added   = FFX7JA(item, "added"   )
      age    = FFX7JA(item, "age"    )
      category_id  = FFX7JA(item, "category_id"  )
      description  = FFX7JA(item, "description"  )
      director  = FFX7JA(item, "director"   )
      genres_str  = FFX7JA(item, "genres_str"  )
      name   = FFX7JA(item, "name"    )
      path   = FFX7JA(item, "path"    )
      screenshot_uri = FFX7JA(item, "screenshot_uri" )
      series   = FFX7JA(item, "series"   )
      cmd    = FFX7JA(item, "cmd"    )
      cmd    = cmd.replace("ffmpeg ", "")
      for episode in eval(series):
       list.append((VVonh7, name, str(episode), category_id, Id, added, age, cmd, director, genres_str, actors, description, screenshot_uri, path))
   except:
    pass
  if list:
   list.sort(key=lambda x: (x[1], int(x[2])))
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = CCSB3R.VVB7ZP("")
   VVsB8G = (""     , BF(self.VV2ORY, mode, True)  , [])
   VVI3Oq  = ("Play"    , BF(self.VVMTI2, mode)       , [])
   VV4dTm = (""     , BF(self.VVDVf1, mode)     , [])
   VVEyDE = ("Home Menu"   , FF9hlZ            , [])
   VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, "sp", VVonh7) , [])
   VVbQ6N = ("Options"   , BF(self.VVU0BK, "pEp", mode, VVonh7) , [])
   VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, True)      , [])
   header   = ("Name" , "Season" , "Episode" , "catID" , "ID" , "Added" , "Age" , "cmd" , "Director", "Genre" , "Actors" , "Description" , "Screenshot" , "Path")
   widths   = (65  , 20  , 15  , 0   , 0   , 0.01 , 0.01 , 0  , 0.01  , 0.01  , 0   , 0    , 0    , 0  )
   VVgKQc  = (LEFT  , LEFT  , CENTER , LEFT  , LEFT  , LEFT , LEFT , LEFT , LEFT  , LEFT  , LEFT  , LEFT   , LEFT   , LEFT )
   FFdCaM(self, None, title=VVonh7, width=1200, header=header, VV5dDF=list, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVsB8G=VVsB8G, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindIptv, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA)
  else:
   FFU9uk(self, "Could not get Episodes from server!", title=VVonh7)
 def VVT0BP(self, mode, searchInCat, VV5ybN, title, txt, colList):
  searchCatId = colList[1].strip() if searchInCat else ""
  VVXXzc = []
  VVXXzc.append(("Keyboard"  , "manualEntry"))
  VVXXzc.append(("From Filter" , "fromFilter"))
  FFw2XU(self, BF(self.VVWzGz, VV5ybN, mode, searchCatId), title="Input Type", VVXXzc=VVXXzc, width=400)
 def VVWzGz(self, VV5ybN, mode, searchCatId, item=None):
  if item == "manualEntry":
   FFttdT(self, BF(self.VVqktN, VV5ybN, mode, searchCatId), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCrT1G(self)
   filterObj.VVMhxB(BF(self.VVqktN, VV5ybN, mode, searchCatId))
 def VVqktN(self, VV5ybN, mode, searchCatId, item):
  if not item is None:
   searVVeZBd = item.strip()
   FFDDwF(CFG.lastFindIptv, searVVeZBd)
   title = self.VVRTLv(mode, searVVeZBd)
   if "," in searVVeZBd : FFU9uk(self, "Use only one word to search in Portal Servers !\n\nRemove the comma.", title=title)
   elif len(searVVeZBd) < 3: FFU9uk(self, "Enter at least 3 characters.", title=title)
   else     :
    if CFG.hideIptvServerAdultWords.getValue() and self.VVyqRl([searVVeZBd]):
     FFU9uk(self, self.VVbLG6(), title=title)
    else:
     self.VVJ31y(mode, searVVeZBd, "", searVVeZBd, searchCatId)
 def VVkwps(self, mode, VV5ybN, title, txt, colList):
  bName = colList[0].strip()
  catID = colList[1].strip()
  self.curPortalCatId = catID
  self.VVJ31y(mode, bName, catID, "", "")
 def VVJ31y(self, mode, bName, catID, searVVeZBd, searchCatId):
  CCXRxc.VVJ9VK(self, VVmj1O="Reading from server"
      , VVCJhW  = BF(self.VVy7KC, mode, bName, catID, searVVeZBd, searchCatId)
      , VVuQkS = BF(self.VVfnRP, mode, bName, catID, searVVeZBd, searchCatId))
 def VVfnRP(self, mode, bName, catID, searVVeZBd, searchCatId, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if searVVeZBd : title = self.VVRTLv(mode, searVVeZBd)
  else   : title = "%s : %s" % (self.VVvzqt(mode), bName)
  if VViN1g:
   VV5CrJ = None
   VVbQ6N = None
   if mode == "series":
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP("series2")
    VVI3Oq  = ("Episodes"   , BF(self.VVyHPp, mode)           , [])
   else:
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP("")
    VVI3Oq  = ("Play"    , BF(self.VVMTI2, mode)           , [])
    VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, "vp" if mode == "vod" else "", "") , [])
    VVbQ6N = ("Options"   , BF(self.VVU0BK, "pCh", mode, bName)      , [])
   VVsB8G = (""      , BF(self.VV2ORY, mode, False)      , [])
   VV4dTm = (""      , BF(self.VVUFrt, mode)         , [])
   VVEyDE = ("Home Menu"    , FF9hlZ                , [])
   VVvrJb = ("Posters Mode"   , BF(self.VVmhAx, mode, False)         , [])
   header   = ("Num" , "Name", "catID", "genreID" , "Icon", "cmd" , "Cat./Genre" , "Logo", "play", "actors" , "descr" , "director", "Catch-up")
   widths   = (9  , 50  , 0   , 0     , 0  , 0  , 25   , 6  , 0  , 0   , 0   , 0   , 10  )
   VVgKQc  = (CENTER, LEFT  , CENTER , CENTER  , LEFT , LEFT , LEFT   , CENTER, LEFT , LEFT  , LEFT  , LEFT  , CENTER )
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VViN1g, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindIptv, VVI3Oq=VVI3Oq, VVsB8G=VVsB8G, VV4dTm=VV4dTm, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VVrpeX=True, VVylFd=1)
   if not VV9zbx:
    if not threadCounter == threadTotal:
     tot = " (Stopped at %d of %d) " % (threadCounter, threadTotal)
     VV5ybN.VVq4kA(VV5ybN.VVIdZ2() + tot)
    if threadErr: FF8PJn(VV5ybN, "Error while reading !", 2000)
    else  : FF8PJn(VV5ybN, "Stopped at channel %s" % threadCounter, 1000)
  else:
   if searVVeZBd : FFU9uk(self, "Could not find names with:\n\n%s" % searVVeZBd, title=title)
   else   : FFU9uk(self, "Could not get list from server !", title=title)
 def VVUFrt(self, mode, VV5ybN, title, txt, colList):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, VV6UAe), str(y)) if y.strip() and not "N/A" in y else ""
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y.strip() and not "N/A" in y else ""
  Num, Name, catID, genreID, Icon, cmd, Cat_Genre, Logo, play, actors, descr, director, arch = colList
  txt  = tab("Number"  , Num)
  txt += tab("Name"  , Name)
  txt += tab("Category" , self.VVHPL5.get(genreID, ""))
  txt += tab("Cat./Genre" , Cat_Genre)
  txt += tab("Director" , director)
  txt += "\n"
  txt += ttl("Actors"  , actors)
  txt += ttl("Description", descr)
  play = play.strip()
  if play and not play.startswith("[No "):
   txt += ttl("Cur. Playing", play)
  if mode == "series":
   VVeZBd = colList[1]
   VVKCwZ = colList[4]
   txt  = "%s\n\n%s" % (title, txt)
   CCISy5.VVIXmT(self, VVjex7=CCISy5.VVnRAJ, params=(VVeZBd, txt, VVKCwZ))
  else:
   self.VVobd3(mode, VV5ybN, title, txt, colList)
 def VVDVf1(self, mode, VV5ybN, title, txt, colList):
  txt += "\n"
  txt += "Actors:\n%s\n\n" % FFITtK(colList[10], VVVAvR)
  txt += "Description:\n%s" % FFITtK(colList[11], VVVAvR)
  self.VVobd3(mode, VV5ybN, title, txt, colList)
 def VVobd3(self, mode, VV5ybN, title, txt, colList):
  VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, colList)
  VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
  txt = "%s\n\n%s" % (title, txt)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVLF91, params=(VVDhju, chUrl, VVeZBd, txt, VVKCwZ))
 def VVy7KC(self, mode, bName, catID, searVVeZBd, searchCatId, VVM2wn):
  try:
   token, profile, tErr = self.VV4B2b()
   if not token:
    return
   if VVM2wn.isCancelled:
    return
   VVM2wn.VViN1g, total_items, max_page_items, err = self.VV8cJi(mode, catID, 1, 1, searVVeZBd, searchCatId)
   if VVM2wn.isCancelled:
    return
   if VVM2wn.VViN1g and total_items > -1 and max_page_items > -1:
    VVM2wn.VVqMKy(total_items)
    VVM2wn.VVwOHf(max_page_items, True)
    pages = int(iCeil(float(total_items) / float(max_page_items)))
    total_items = pages
    for i in range(pages - 1):
     if VVM2wn.isCancelled:
      return
     page = i + 2
     counter = (i + 1) * max_page_items + 1
     list, total_items, max_page_items, err = self.VV8cJi(mode, catID, page, counter, searVVeZBd, searchCatId)
     if err:
      VVM2wn.VVNQHr()
     if VVM2wn.isCancelled:
      return
     if list:
      VVM2wn.VViN1g += list
      VVM2wn.VVwOHf(len(list), True)
  except:
   pass
 def VV8cJi(self, mode, catID, page, counter, searVVeZBd, searchCatId):
  list = []
  total_items = max_page_items = -1
  if searVVeZBd : url = self.VVi4cA(mode, searVVeZBd, searchCatId, page)
  else   : url = self.VVLUAy(mode, catID, page)
  res, err = self.VVdce0(url)
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     item = tDict["js"]
     total_items  = self.VVxxuy(FFX7JA(item, "total_items"  ))
     max_page_items = self.VVxxuy(FFX7JA(item, "max_page_items" ))
     chList = tDict["js"]['data']
     cmdStr = "http://localhost/ch/"
     for item in chList:
      Id    = FFX7JA(item, "id"     )
      name   = FFX7JA(item, "name"     )
      o_name   = FFX7JA(item, "o_name"    )
      category_id  = FFX7JA(item, "category_id"   )
      tv_genre_id  = FFX7JA(item, "tv_genre_id"   )
      number   = FFX7JA(item, "number"    ) or str(counter)
      logo   = FFX7JA(item, "logo"     )
      screenshot_uri = FFX7JA(item, "screenshot_uri"  )
      pic    = FFX7JA(item, "pic"     )
      cmd    = FFX7JA(item, "cmd"     )
      censored  = FFX7JA(item, "censored"    )
      genres_str  = FFX7JA(item, "genres_str"   )
      curPlay   = FFX7JA(item, "cur_playing"   )
      actors   = FFX7JA(item, "actors"    )
      descr   = FFX7JA(item, "description"   )
      director  = FFX7JA(item, "director"    )
      archive   = FFX7JA(item, "archive"    )
      archDur   = FFX7JA(item, "tv_archive_duration" )
      catID   = category_id or tv_genre_id
      arch = "Yes" if archive == "1" else ""
      if archDur:
       if archDur.isdigit():
        tot = int(archDur)
        if tot > 0: arch = "%s hour%s" % (tot, FFEnJs(tot))
       else:
        arch = archDur
      name = o_name or name
      if " " in cmd :
       cmd = cmd.split(" ")[1].strip()
      if mode == "itv" and not cmdStr in cmd and not cmd.endswith(".m3u8") and not "ffrt" in cmd:
       if ("token=" in cmd and "d=Mag" in cmd) or "AuthToken=" in cmd or "play_token=" in cmd:
        cmd = "Zz1" + FF5VBY(cmd)
       else:
        span = iSearch(r"stream=(.+)&", cmd)
        if span:
         cmd = "%s%s_" % (cmdStr, span.group(1))
        else:
         span = iSearch(r".+\/.+\/.+\/(.+)", cmd)
         if span:
          cmd = "%s%s_" % (cmdStr, span.group(1))
      if   logo.startswith("http")   : picon = logo
      elif pic.startswith("http")    : picon = pic
      elif screenshot_uri.startswith("http") : picon = screenshot_uri
      else         : picon = logo or screenshot_uri or pic
      sp = "/stalker_portal"
      if picon.startswith(sp):
       picon = (self.VVD5zt + picon).replace(sp * 2, sp)
      isIcon = "Yes" if picon.startswith("http") else ""
      counter += 1
      name = self.VVYPwG(name, censored=censored)
      if name:
       list.append((number, name, Id, catID, picon, cmd, genres_str, isIcon, curPlay, actors, descr, director, arch))
   except:
    err = "Channel Parse Error !"
  return list, total_items, max_page_items, err
 def VVxxuy(self, valStr):
  try:
   return int(valStr)
  except:
   return -1
 def VVMTI2(self, mode, VV5ybN, title, txt, colList):
  VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, colList)
  VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
  if self.VV0Jba(VVeZBd):
   FF8PJn(VV5ybN, "This is a marker!", 300)
  else:
   chUrl = CC5ENZ.VVHaiG(self, chUrl)
   VVthiO = os.path.join(self.VVoS8r(mode), os.path.basename(VVKCwZ)) if VVKCwZ else ""
   CC2lVw.VVbVSZ(self.session, VVVQym=(self, VV5ybN, mode), VV7GTU=chUrl, VVthiO=VVthiO)
 def VVc8y9(self, mode, VV5ybN, colList):
  VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, colList)
  VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
  VVthiO = os.path.join(self.VVoS8r(mode), os.path.basename(VVKCwZ)) if VVKCwZ else ""
  return VVeZBd, chUrl, VVthiO
 def VVaK5d(self, mode, colList):
  if mode == "series":
   VVeZBd = colList[0]
   season = colList[1]
   serCode = colList[2]
   catID = colList[3]
   serId = colList[4]
   chCm = colList[7]
   VVKCwZ = colList[12]
   VVeZBd = "%s (%s - %s)" % (VVeZBd, season, serCode)
   chNum = serCode
   stID = serId.replace(":", "_")
  else:
   chNum = colList[0]
   VVeZBd = colList[1]
   stID = colList[2]
   catID = colList[3]
   VVKCwZ = colList[4]
   chCm = colList[5]
   serCode = ""
   serId = ""
  return VVeZBd.strip(), catID.strip(), stID.strip(), chNum.strip(), chCm.strip(), serCode.strip(), serId.strip(), VVKCwZ.strip()
 @staticmethod
 def VVPib3(SELF, install=True, cbFnc=None):
  try:
   import requests
   return True
  except:
   if install:
    title = 'Install "Requests"'
    VVXXzc = []
    VVXXzc.append((title        , "inst" ))
    VVXXzc.append(("Update Packages then %s" % title , "updInst" ))
    FFw2XU(SELF, BF(CC5ENZ.VVOdGT, SELF, cbFnc=cbFnc), title='This requires Python "Requests" library', VVXXzc=VVXXzc)
   return False
 @staticmethod
 def VVOdGT(SELF, item=None, cbFnc=None):
  if item:
   cmdUpd = FFKA8e(VVtAyn)
   if cmdUpd:
    cmdInst = FFiD2M(VVUWS4, "python-requests")
    if pyVersion[0] >= 3:
     cmdInst = cmdInst.replace("python-", "python3-")
    if   item == "inst"  : cmd = cmdInst
    elif item == "updInst" : cmd = cmdUpd + " && " + cmdInst
    FFNQkI(SELF, cmd, VVTHJE=True, title='Installing "Requests" Library', VVUYyP=cbFnc)
   else:
    FFD8hf(SELF)
 def VVY0A4(self):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVmjzD(CCaZ62(self.session).VVu69c)
  return mode, host, catID, stID, epNum.replace("%3a", ":"), epId.replace("%3a", ":")
 def VV63sN(self, VVZzW8):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVY0A4()
  if all((curMode, curHost, curCat)) and curHost == self.VVD5zt:
   VVZzW8.VVEaHH({"itv": 0, "vod": 1, "series": 2}.get(curMode, 0))
 def VVOCtr(self, mode, VV5ybN, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVY0A4()
  if all((curMode, curHost, curCat)) and curMode == mode and curHost == self.VVD5zt:
   VV5ybN.VVdP7o({1:curCat})
 def VV2ORY(self, mode, isEp, VV5ybN, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVY0A4()
  if all((curMode, curHost, curCat)) and curCat == self.curPortalCatId and curMode == mode and curHost == self.VVD5zt:
   if mode in ("itv", "vod"):
    VV5ybN.VVdP7o({2:curStID})
   else: #series
    if isEp:
     VV5ybN.VVdP7o({2:curEpNum, 4:curEpId})
    elif mode == "series":
     ser1 = curEpId.split(":")[0]
     ser2 = "%s:%s" % (ser1, ser1)
     ok = VV5ybN.VVdP7o({2:ser2})
     if not ok: VV5ybN.VVdP7o({2:ser1})
 @staticmethod
 def VVrdM9(VVu69c):
  span = iSearch(r"(mode=.+)&chCm=.+&end=:(.+)", VVu69c, IGNORECASE)
  if span : return span.group(1), span.group(2)
  else : return "", ""
 @staticmethod
 def VVHaiG(SELF, chUrl):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(SELF)
  phpPart1, VVeZBd1 = CC5ENZ.VVrdM9(VVu69c)
  phpPart2, VVeZBd2 = CC5ENZ.VVrdM9(FF0rS9(chUrl))
  return None if phpPart1 and (phpPart1, VVeZBd1) == (phpPart2, VVeZBd2) else chUrl
class CCSB3R(Screen, CC5ENZ, CClqOe, CCYl55):
 VVwMSf    = 0
 VVbSP8    = 1
 VVNrih    = 2
 VV1E3b    = 3
 VVTJuV     = 4
 VVpWPz     = 5
 VVIdtB     = 6
 VVAZTu     = 7
 VVhNmC     = 8
 VVWgRr     = 9
 VV6gKn      = 10
 VV4k5A     = 11
 VVY2qr     = 12
 VVR1A1     = 13
 VVNdKD     = 14
 VVN2YV      = 15
 VV1c79      = 16
 VVt5oO      = 17
 VVMbgK      = 18
 VVI0qc      = 19
 VVbJQL    = 0
 VVJlIE   = 1
 VV58i3   = 2
 VVkiMU   = 3
 VVC8z8  = 4
 VVnsRa  = 5
 VVIqPb   = 6
 VVhFEC   = 7
 VVY3Xw  = 8
 VVCHxt  = 9
 VVZImy  = 10
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 970, 1050, 50, 40, 30, "#0a0a0a2a", "#0a0a0a1a", 28, VV1fgG=1)
  self.session     = session
  self.VV5ybN    = None
  self.VVsSnk     = "Local IPTV Services"
  self.VVJBt9    = {}
  self.VVEQWS = False
  self.VVxfaK   = CCSB3R.VVt2XK(atLeastOne=True)
  self.VV1V0y    = True
  self.VVmrz9      = ""
  self.VVpeQQ    = None
  self.VVHPL5     = {}
  CC5ENZ.__init__(self)
  CClqOe.__init__(self)
  VVXXzc = self.VV4L9C()
  FFfmZP(self, title="IPTV", VVXXzc=VVXXzc)
  FFyNtd(self, {"menu" : self.VVungV})
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVsL4Q)
  global VVjKhK
  VVjKhK = True
 def VVvFMs(self):
  self["myMenu"].setList(self.VV4L9C())
  FFbm8U(self)
  FF1uow(self)
  if self.VV1V0y:
   self.VV1V0y = False
   FFTDN6(self["myMenu"])
   self.VVkW34()
   FFI5rG()
 def VVkW34(self):
  qUrl, VVu69c, VVLZ0Z = CCSB3R.VVxAMw(self)
  if qUrl or "chCode" in VVLZ0Z:
   for ndx, item in enumerate(self["myMenu"].list):
    if item[0] == "IPTV Server Browser (from Current Channel)" and len(item) > 1:
     self["myMenu"].moveToIndex(ndx)
     break
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  FFdsOh("VVjKhK")
 def VVsL4Q(self):
  if self["myMenu"].getCurrent()[1] in ("VV53z2", "VVnEetPortal") : self["keyMenu"].show()
  else                      : self["keyMenu"].hide()
 def VVungV(self):
  if self["myMenu"].getVisible():
   title, item = self["myMenu"].getCurrent()
   if   item == "VV53z2" : confItem = CFG.favServerPlaylist
   elif item == "VVnEetPortal" : confItem = CFG.favServerPortal
   else         : return
   url = confItem.getValue().strip().split()[0]
   title += (" : %s" % FFITtK(CCSB3R.VVBOAE(url)[1], VVu50a)) if url else ""
   FFHsPu(self, BF(self.VVFS66, confItem), "Remove from menu ?", title=title)
 def VVFS66(self, confItem):
  FFDDwF(confItem, "")
  self.VVvFMs()
 def VV4L9C(self):
  fav1, fav2 = CFG.favServerPlaylist.getValue(), CFG.favServerPortal.getValue()
  c1 = VVCBkQ
  VVXXzc = []
  if fav1: VVXXzc.append((c1 +  "Favourite Playlist Server"    , "VV53z2" ))
  if fav2: VVXXzc.append((c1 +  "Favourite Portal Server"    , "VVnEetPortal" ))
  VVXXzc.append(("IPTV Server Browser (from Playlists)"     , "VVkXvg_fromPlayList" ))
  VVXXzc.append(("IPTV Server Browser (from Portal List)"    , "VVkXvg_fromMac"  ))
  qUrl, VVu69c, VVLZ0Z = CCSB3R.VVxAMw(self)
  fromCurCond = qUrl or "chCode" in VVLZ0Z
  VVXXzc.append(FFwjWO("IPTV Server Browser (from Current Channel)", "VVkXvg_fromCurrChan", fromCurCond))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Local Servers & M3U Cache"       , "browser_localServ"  ))
  VVXXzc.append(("M3U/M3U8 File Browser"        , "VVZcAj"   ))
  if self.VVxfaK:
   VVXXzc.append(("IPTV Services (from Local Bouquets)"    , "iptvTable_all"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVeXRs", fromCurCond))
  if self.VVxfaK:
   VVXXzc.append(VVzg1X)
   c1, c2 = VVkLs0, VV6UAe
   t1 = FFITtK("auto-match names", VVCBkQ)
   t2 = FFITtK("from xml file"  , VVCBkQ)
   VVXXzc.append((c1 + "Count Available IPTV Channels"    , "VVDLMT"    ))
   VVXXzc.append((c1 + "Copy EPG/PIcons between Channels (%s)" % t2 , "copyEpgPicons"   ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c2 + "Share Reference with DVB Channels (%s)" % t2 , "renumIptvRef_fromFile" ))
   VVXXzc.append((c2 + "Share Reference with DVB Channels (%s)" % t1 , "VVTVFX" ))
   VVXXzc.append((VVu50a + "More Reference Tools ..."  , "VVXnOR"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Reload Channels and Bouquets"       , "VVZel2"   ))
  VVXXzc.append(VVzg1X)
  if not CChTrx.VVnzW8():
   VVXXzc.append(("Download Manager"         , "dload_stat"    ))
  else:
   VVXXzc.append(("Download Manager ... No downloads"    ,       ))
  return VVXXzc
 def VVFJs1(self, item):
  self.VVmrz9 = ""
  tTitle = "Share Reference with DVB Service"
  if item is not None:
   if   item == "VVtQ7z"   : self.VVtQ7z()
   elif item == "VV2UFc" : self.VV2UFc()
   elif item == "VVPATz" : FFHsPu(self, self.VVPATz, "Change Current List References to Unique Codes ?")
   elif item == "VViNGc_rows" : FFHsPu(self, BF(FFTSvN, self.VV5ybN, self.VViNGc), "Change Current List References to Identical Codes ?")
   elif item == "VV60jF"   : self.VV60jF(tTitle)
   elif item == "VVmxlO"   : self.VVmxlO(tTitle)
   elif item == "VV53z2" : self.VVnEet(False)
   elif item == "VVnEetPortal" : self.VVnEet(True)
   elif item == "VVkXvg_fromPlayList" : self.VVIcSt(1)
   elif item == "VVkXvg_fromMac"  : self.VVqcpt()
   elif item == "VVkXvg_fromCurrChan" : self.VV5pRm()
   elif item == "browser_localServ"  : CCxgvM(self, CCxgvM.VVSQ7Z)
   elif item == "VVZcAj"   : self.VVZcAj()
   elif item == "iptvTable_all"   : self.VVbsck(self.VVwMSf)
   elif item == "VVeXRs" : CCSB3R.VVeXRs(self)
   elif item == "VVDLMT"    : self.VVDLMT()
   elif item == "copyEpgPicons"   : self.VVgxjc(False)
   elif item == "renumIptvRef_fromFile" : self.VVgxjc(True)
   elif item == "VVTVFX" : FFHsPu(self, self.VVTVFX, VVYjCX="Continue ?")
   elif item == "VVXnOR"    : self.VVXnOR()
   elif item == "VVZel2"   : CCAnLc.VVZel2(self)
   elif item == "dload_stat"    : CChTrx.VVWJLc(self)
 def VVTOku(self):
  item = FFiaTH(self)
  self.VVFJs1(item)
 @FFHF2S("Loading Channels ...")
 def VVbsck(self, mode):
  VVJwgn = self.VV4GJt(mode)
  if VVJwgn:
   bg = "#1b001121"
   VV5CrJ = ("Current Service", self.VVOx6V , [])
   VVbQ6N = ("Options"  , self.VV4Urs   , [])
   VVvrJb = ("Filter"   , self.VVP3fc   , [])
   VVI3Oq  = ("Play"   , BF(self.VVLqox)  , [])
   VV4dTm = (""    , self.VV1AaZ    , [])
   VVsB8G = (""    , self.VVhUhF     , [])
   header   = ("Num" , "Name", "Bouquet" , "Type", "Ref.", "URL" )
   widths   = (8  , 30 , 30  , 6  , 26 , 0  )
   VVgKQc  = (CENTER , LEFT , LEFT  , CENTER, LEFT , LEFT )
   FFdCaM(self, None, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1750, height=1000, VV1Wwb=25
     , VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV4dTm=VV4dTm, VVsB8G=VVsB8G
     , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#11004a55", VVrpeX=True, VVylFd=1)
  else:
   if mode == self.VVWgRr: err = "No Live IPTV channels !"
   else       : err = "No IPTV channels !"
   FFU9uk(self, err)
 def VVhUhF(self, VV5ybN, title, txt, colList):
  self.VV5ybN = VV5ybN
 def VV4Urs(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("Add Current List to a New Bouquet"     , "VVtQ7z"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Delete Current List (from all Bouquets)" , "VV2UFc" , VV5ybN.VVIdZ2().startswith("Filter:"), VVcahY))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Change Current List References to Unique Codes" , "VVPATz"))
  VVXXzc.append(("Change Current List References to Identical Codes", "VViNGc_rows" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Share Reference with DVB Service (manual entry)" , "VV60jF"   ))
  VVXXzc.append(("Share Reference with DVB Service (auto-find)"  , "VVmxlO"   ))
  FFw2XU(self, self.VVFJs1, title="IPTV Tools", VVXXzc=VVXXzc)
 @FFHF2S(par=1)
 def VVP3fc(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  VVXXzc.append(("All"         , "all"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Prefix of Selected Channel"   , "sameName" ))
  VVXXzc.append(("Suggest Words from Selected Channel" , "partName" ))
  VVXXzc.append(("Names with Non-English Characters" , "nonEnglish" ))
  VVXXzc.append(("Duplicate References"     , "depRef"  ))
  VVXXzc.append(("Reference x:x:x:x:0:0:0:0:0:0:"  , "ref00"  ))
  VVXXzc.append(("Stream Relay"       , "SRelay"  ))
  VVXXzc.append(FFAiun("Category"))
  VVXXzc.append(("Live"         , "live"  ))
  VVXXzc.append(("VOD"         , "vod"   ))
  VVXXzc.append(("Series"        , "series"  ))
  VVXXzc.append(("Uncategorized"      , "uncat"  ))
  VVXXzc.append(FFAiun("Media"))
  VVXXzc.append(("Video"        , "video"  ))
  VVXXzc.append(("Audio"        , "audio"  ))
  VVXXzc.append(FFAiun("File Type"))
  VVXXzc.append(("MKV"         , "MKV"   ))
  VVXXzc.append(("MP4"         , "MP4"   ))
  VVXXzc.append(("MP3"         , "MP3"   ))
  VVXXzc.append(("AVI"         , "AVI"   ))
  VVXXzc.append(("FLV"         , "FLV"   ))
  VVXXzc.extend(CC41Tt.VV5FZT(prefix="__b__", onlyIptv=True))
  inFilterFnc = BF(self.VVsQOr, VV5ybN) if VV5ybN.VVIdZ2().startswith("Filter:") else None
  filterObj = CCrT1G(self)
  filterObj.VVoKta(VVXXzc, VVXXzc, BF(self.VV95Zf, VV5ybN, False), inFilterFnc=inFilterFnc)
 def VVsQOr(self, VV5ybN, VVZzW8, item):
  self.VV95Zf(VV5ybN, True, item)
 def VV95Zf(self, VV5ybN, inFilter, item=None):
  self.VVEQWS = inFilter
  prefix = VV5ybN.VVVWWJ(1).split(" ")[0]
  if item is not None:
   if   item == "all"    : mode, words, title = self.VVwMSf , ""  , self.VVsSnk
   elif item == "sameName"   : mode, words, title = self.VVbSP8 , prefix , prefix + " ..."
   elif item == "partName"   : mode, words, title = self.VVNrih , ""  , ""
   elif item == "nonEnglish"  : mode, words, title = self.VV1E3b , ""  , "Names with Non-English Characters"
   elif item == "depRef"   : mode, words, title = self.VVIdtB  , ""  , "Duplicate References"
   elif item == "ref00"   : mode, words, title = self.VVAZTu  , ""  , "Reference x:x:x:x:0:0:0:0:0:0:"
   elif item == "SRelay"   : mode, words, title = self.VVhNmC  , ""  , "Stream Relay"
   elif item == "live"    : mode, words, title = self.VVWgRr  , ""  , "Live"
   elif item == "vod"    : mode, words, title = self.VV6gKn   , ""  , "VOD"
   elif item == "series"   : mode, words, title = self.VV4k5A  , ""  , "Series"
   elif item == "uncat"   : mode, words, title = self.VVY2qr  , ""  , "Uncategorized"
   elif item == "video"   : mode, words, title = self.VVR1A1  , ""  , "Video"
   elif item == "audio"   : mode, words, title = self.VVNdKD  , ""  , "Audio"
   elif item == "MKV"    : mode, words, title = self.VVN2YV   , ""  , "MKV"
   elif item == "MP4"    : mode, words, title = self.VV1c79   , ""  , "MP4"
   elif item == "MP3"    : mode, words, title = self.VVt5oO   , ""  , "MP3"
   elif item == "AVI"    : mode, words, title = self.VVMbgK   , ""  , "AVI"
   elif item == "FLV"    : mode, words, title = self.VVI0qc   , ""  , "FLV"
   elif item.startswith("__b__") : mode, words, title = self.VVTJuV  , item[5:] , item[5:]
   elif item.startswith("__w__") : mode, words, title = self.VVpWPz  , item[5:] , item[5:]
   else       : return
  if mode != self.VVwMSf:
   tTitle = "Filter: "
   if mode == self.VVTJuV:
    tTitle += " Bouquet = "
   title = tTitle + FFITtK(title, VVnQYw)
  if len(title) > 85:
   title = title[:85] + ".."
  if mode == self.VVNrih:
   VVXXzc = []
   VVeZBd = VV5ybN.VVVWWJ(1)
   if VVeZBd:
    list = set()
    for match in iFinditer(r"((?:[^\x00-\x7F]+\s*)+)", VVeZBd, IGNORECASE):
     list.add(match.group(1).strip())
    if list:
     for match in iFinditer(r"(\w+)", VVeZBd, IGNORECASE):
      list.add(match.group(1).strip())
    words = VVeZBd.split(" ")
    tWord = ""
    for word in words:
     tWord += " " + word
     list.add(word.strip())
     list.add(tWord.strip())
    for item in sorted(list):
     if item:
      VVXXzc.append((item, item))
    if not VVXXzc and VVeZBd:
     VVXXzc.append((VVeZBd, VVeZBd))
    FFw2XU(self, self.VVs9l0, VVXXzc=VVXXzc)
   else:
    VV5ybN.VVjSys("Invalid Channel Name")
  else:
   words, asPrefix = CCrT1G.VVYDJw(words)
   if not words and mode in (self.VVTJuV, self.VVpWPz):
    FF8PJn(self.VV5ybN, "Incorrect filter", 2000)
   else:
    self.VVpeQQ = BF(FFTSvN, self.VV5ybN, BF(self.VVHqjb, mode, words, asPrefix, title), clearMsg=False, title="Filtering ...")
    self.VVpeQQ()
 def VVs9l0(self, word=None):
  if word:
   title = "Filter: %s" % FFITtK(word, VVnQYw)
   self.VVpeQQ = BF(FFTSvN, self.VV5ybN, BF(self.VVHqjb, self.VVNrih, [word.lower()], False, title), clearMsg=False, title="Filtering ...")
   self.VVpeQQ()
 @staticmethod
 def VVFSjX(txt):
  return "#f#11ffff00#" + txt
 def VVHqjb(self, mode, words, asPrefix, title):
  if self.VVEQWS : VVJwgn = self.VVCdH0(mode=mode, words=words, asPrefix=asPrefix)
  else       : VVJwgn = self.VV4GJt(mode=mode, words=words, asPrefix=asPrefix)
  if VVJwgn:
   self.VV5ybN.VVxhz9(VVJwgn, title)
   return True
  else:
   self.VV5ybN.VVjSys("Not found")
   return False
 def VVCdH0(self, mode=0, words=None, asPrefix=False):
  VVJwgn = []
  for row in self.VV5ybN.VVTq0J():
   row = list(map(str.strip, row))
   chNum, VVeZBd, VVzhkp, chType, VVDhju, url = row
   if self.VVbJEO(mode, VVDhju, FF0rS9(url).lower(), VVeZBd, words, VVzhkp.lower(), asPrefix):
    VVJwgn.append(row)
  VVJwgn = self.VV6tmx(mode, VVJwgn)
  return VVJwgn
 def VV4GJt(self, mode=0, words=None, asPrefix=False, isStripChan=False):
  patt = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+"
  if isStripChan: patt += r"[^\x00-\x7F]*(.+)[^\x00-\x7F]*"
  else    : patt += r"(.+)"
  VVJwgn = []
  files = CCSB3R.VVt2XK()
  if files:
   chNum = 1
   for path in files:
    if path.endswith("radio"): chType = "Radio"
    else      : chType = "TV"
    txt = FF05rJ(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVzhkp = span.group(1)
    else : VVzhkp = ""
    VVzhkp_lCase = VVzhkp.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVDhju = match.group(1).upper()
     url  = match.group(2).strip()
     VVeZBd = match.group(3).strip()
     if self.VV0Jba(VVeZBd): VVekaj = self.VVFSjX(VVeZBd)
     else        : VVekaj = VVeZBd
     row = (str(chNum), VVekaj, VVzhkp, chType + (" SRel" if FFOr4F(url) else ""), VVDhju, url)
     if self.VVbJEO(mode, VVDhju, FF0rS9(url).lower(), VVeZBd, words, VVzhkp_lCase, asPrefix):
      VVJwgn.append(row)
      chNum += 1
  VVJwgn = self.VV6tmx(mode, VVJwgn)
  return VVJwgn
 def VV6tmx(self, mode, VVJwgn):
  newRows = []
  if VVJwgn and mode == self.VVIdtB:
   counted  = iCounter(elem[4] for elem in VVJwgn)
   for item in VVJwgn:
    tot = counted.get(item[4], 0)
    if tot > 1:
     newRows.append(item)
   return newRows
  else:
   return VVJwgn
 def VVbJEO(self, mode, VVDhju, tUrl, VVeZBd, words, VVzhkp_lCase, asPrefix):
  if   mode == self.VVwMSf : return True
  elif mode == self.VVIdtB : return True
  elif mode == self.VVAZTu  : return ":0:0:0:0:0:0:" in VVDhju
  elif mode == self.VVhNmC : return FFOr4F(tUrl)
  elif mode == self.VVR1A1  : return CCSB3R.VVsV5B(tUrl, getAudVid=True) == "vid"
  elif mode == self.VVNdKD  : return CCSB3R.VVsV5B(tUrl, getAudVid=True) == "aud"
  elif mode == self.VVWgRr  : return CCSB3R.VVsV5B(tUrl, compareType="live")
  elif mode == self.VV6gKn  : return CCSB3R.VVsV5B(tUrl, compareType="vod")
  elif mode == self.VV4k5A : return CCSB3R.VVsV5B(tUrl, compareType="series")
  elif mode == self.VVY2qr  : return CCSB3R.VVsV5B(tUrl, compareType="")
  elif mode == self.VVN2YV  : return CCSB3R.VVsV5B(tUrl, compareExt="mkv")
  elif mode == self.VV1c79  : return CCSB3R.VVsV5B(tUrl, compareExt="mp4")
  elif mode == self.VVt5oO  : return CCSB3R.VVsV5B(tUrl, compareExt="mp3")
  elif mode == self.VVMbgK  : return CCSB3R.VVsV5B(tUrl, compareExt="avi")
  elif mode == self.VVI0qc  : return CCSB3R.VVsV5B(tUrl, compareExt="flv")
  elif mode == self.VVbSP8: return VVeZBd.lower().startswith(words[0])
  elif mode == self.VVNrih: return words[0] in VVeZBd.lower()
  elif mode == self.VV1E3b: return bool(iSearch(r"[^\x00-\x7F]", VVeZBd))
  elif mode == self.VVTJuV : return words[0] == VVzhkp_lCase
  elif mode == self.VVpWPz :
   name = VVeZBd.lower()
   for word in words:
    if asPrefix:
     if name.startswith(word) : return True
    elif word in name    : return True
  return False
 def VVtQ7z(self):
  picker = CC41Tt(self, self.VV5ybN, "Add to Bouquet", self.VVe8lL)
 def VVe8lL(self):
  chUrlLst = []
  for row in self.VV5ybN.VVTq0J():
   chUrlLst.append(row[4] + row[5])
  return chUrlLst
 def VV2UFc(self):
  tot = self.VV5ybN.VVJPu5()
  FFHsPu(self, self.VVyCnA, "Delete %s IPTV Channel%s ?" % (tot, FFEnJs(tot)))
 def VVyCnA(self):
  bFiles = CCSB3R.VVt2XK()
  if not bFiles:
   FF8PJn(self.VV5ybN, "No bouquets files !", 1500)
   return
  totRows = self.VV5ybN.VVJPu5()
  if not totRows:
   FF8PJn(self.VV5ybN, "Cannot read list", 1500)
   return
  CCXRxc.VVJ9VK(self, VVmj1O="Renumbering References", VV9L2m=CCXRxc.VVE4fR, totBars=2
      , VVCJhW  = BF(self.VV3Gvb, totRows, bFiles)
      , VVuQkS = self.VVYgpy )
 def VV3Gvb(self, totRows, bFiles, VVM2wn):
  totDel = totBouq = 0
  VVM2wn.VVqMKy(len(bFiles))
  VVM2wn.VVFO1V(totRows)
  VVM2wn.VViN1g = (totRows, totDel, totBouq)
  for path in bFiles:
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if FFf0vs(path):
    toSave = False
    txt  = FF05rJ(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span : bName = span.group(1)
    else : bName = os.path.splitext(os.path.basename(path))[0]
    VVM2wn.VVkdWG("%s   %s" % (totDel, bName))
    VVM2wn.VVwOHf(1)
    VVM2wn.VV75eC(0)
    for row in self.VV5ybN.VVTq0J():
     if not VVM2wn or VVM2wn.isCancelled:
      return
     VVM2wn.VVoreX(1)
     ref = row[4] + row[5]
     if ref in txt:
      txt, tot = iSubn(r"(#SERVICE\s+%s\n#DESCRIPTION.+\n?)" % iEscape(ref), "", txt)
      if tot > 0:
       totDel += tot
       VVM2wn.VViN1g = (totRows, totDel, totBouq)
       toSave = True
    if toSave:
     totBouq += 1
     VVM2wn.VViN1g = (totRows, totDel, totBouq)
     with open(path, "w") as f:
      f.write(txt)
 def VVYgpy(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  totRows, totDel, totBouq = VViN1g
  if totBouq:
   FFfve1()
   txt  = "Channels\t: %s\n" % totRows
   txt += "Deleted\t: %s   (from %s bouquet%s)" % (totDel, totBouq, FFEnJs(totBouq))
   FFyijw(self, txt, VVuQkS=BF(FFTSvN, self.VV5ybN or self, self.VVVhZj, clearMsg=False))
  else:
   FFSQn9(self, "No changes.")
 def VVVhZj(self):
  if self.VV5ybN:
   if not self.VVpeQQ():
    if not self.VVHqjb(self.VVwMSf, "", False, "Local IPTV Services"):
     self.VV5ybN.cancel()
 def VVXnOR(self):
  t1 = FFITtK("Bouquet" , VV6UAe)
  t2 = FFITtK("ALL"  , VVu50a)
  t3 = FFITtK("Unique"  , VVkLs0)
  t4 = FFITtK("Identical" , VVCBkQ)
  VVXXzc = []
  VVXXzc.append((VVnQYw + "Check System Acceptable Reference Types", "VVC65n"))
  VVXXzc.append(FFwjWO("Check Reference Codes Format", "VViFNk", self.VVxfaK, VVnQYw))
  VVXXzc.append(VVzg1X)
  txt = "Change %s Ref. Types to (1/4097/5001/5002/8192/8193/8793) .."
  VVXXzc.append((txt % t1, "VVIDg2" ))
  VVXXzc.append((txt % t2, "VVpLmx_all"  ))
  VVXXzc.append(VVzg1X)
  txt = "Change %s References to %s Codes .."
  VVXXzc.append((txt % (t1, t3), "VVrH3k" ))
  VVXXzc.append((txt % (t2, t3), "VVqr51"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Change %s References to %s Codes" % (t2, t4) , "VViNGc_all"))
  VV5LxL = self.VVJVNv
  FFw2XU(self, None, width=1220, title="IPTV Reference Tools", VVXXzc=VVXXzc, VV5LxL=VV5LxL, VVVzvS="#22002233", VVhHWW="#22001122")
 def VVJVNv(self, item=None):
  if item:
   ques = "Continue ?"
   VVZzW8, txt, item, ndx = item
   if   item == "VVC65n"    : FFTSvN(VVZzW8, self.VVC65n)
   elif item == "VViFNk"     : FFTSvN(VVZzW8, self.VViFNk)
   elif item == "VVIDg2" : self.VVW2Qr(VVZzW8, self.VVIstv)
   elif item == "VVpLmx_all"  : self.VVIstv(VVZzW8, None, None)
   elif item == "VVrH3k" : self.VVrH3k(VVZzW8, txt)
   elif item == "VVqr51"  : FFHsPu(self, BF(self.VVqr51 , VVZzW8, txt), title=txt, VVYjCX=ques)
   elif item == "VViNGc_all"  : FFHsPu(self, BF(FFTSvN, VVZzW8, self.VViNGc), title=txt, VVYjCX=ques)
 def VVIstv(self, VVZzW8, bName, bPath):
  VVXXzc = []
  for rt in CCSB3R.VV0JA5():
   VVXXzc.append(("%s\t ... %s" % (rt, CCSB3R.VVUGUR(rt)), rt))
  FFw2XU(self, BF(self.VVDk21, VVZzW8, bName, bPath), VVXXzc=VVXXzc, width=800, title="Change Reference Types to:")
 def VVDk21(self, VVZzW8, bName, bPath, rType=None):
  if rType:
   self.VVJ5qQ(VVZzW8, bName, bPath, rType)
 def VVW2Qr(self, VVZzW8, fnc):
  VVXXzc = CC41Tt.VV5FZT()
  if VVXXzc:
   FFw2XU(self, BF(self.VVmQtU, VVZzW8, fnc), VVXXzc=VVXXzc, title="IPTV Bouquets", VVfP2Q=True)
  else:
   FF8PJn(VVZzW8, "No bouquets Found !", 1500)
 def VVmQtU(self, VVZzW8, fnc, item=None):
  if item:
   bName, bRef, ndx = item
   span = iSearch(r'BOUQUET "(.+)" ORDER', bRef, IGNORECASE)
   if span:
    bPath = VVHX6T + span.group(1)
    if FFf0vs(bPath): fnc(VVZzW8, bName, bPath)
    else    : FF8PJn(VVZzW8, "Bouquet file not found!", 2000)
   else:
    FF8PJn(VVZzW8, "Cannot process bouquet !", 2000)
 def VVJ5qQ(self, VVZzW8, bName, bPath, rType):
  if bPath: title = "Change for Bouquet : %s" % FFITtK(bName, VVaR8d)
  else : title = "Change for %s" % FFITtK("All IPTV Services", VVaR8d)
  FFHsPu(self, BF(self.VVpkJ5, VVZzW8, bName, bPath, rType), "Change to : %s ?" % FFITtK(rType, VVaR8d), title=title)
 @FFHF2S("Changing Type ...", par=1)
 def VVpkJ5(self, VVZzW8, bName, bPath, rType):
  totChange = 0
  if bPath: files = [bPath]
  else : files = CCSB3R.VVt2XK()
  if files:
   newRType = rType + ":"
   piconPath = CCUNc6.VVQ490()
   for path in files:
    if   not FFf0vs(path)      : err = "Cannot read the file:\n\n%s" % path
    elif not CCQdsv.VVz66T(self, path) : err = "File is not in 'UTF-8' Encoding:\n\n%s" % path
    else           : err = ""
    if err:
     FFU9uk(self, err)
     return
    newpFile = path + ".tmp"
    totMod = 0
    with open(newpFile, "w") as tFile:
     with ioOpen(path, "r", encoding="utf-8") as f:
      for line in f:
       span = iSearch(r"#SERVICE\s+([A-Fa-f0-9]+[:]).+http.+", line)
       if span:
        oldRType = span.group(1)
        if not oldRType == newRType:
         totMod += 1
         totChange += 1
         span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
         if span : oldPicon = piconPath + span.group(1).strip(":").replace(":", "_") + ".png"
         else : oldPicon = ""
         line = iSub(r"(#SERVICE)\s+[A-Fa-f0-9]+[:](.+http.+)", r"\1 %s\2" % newRType, line)
         if FFf0vs(oldPicon):
          span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
          if span:
           FF6usE("mv -f '%s' '%s'" % (oldPicon, piconPath + span.group(1).strip(":").replace(":", "_") + ".png"))
       tFile.write(line)
    if totMod: cmd = "mv -f '%s' '%s'" % (newpFile, path)
    else  : cmd = "rm -f '%s'" % newpFile
    FF6usE(cmd)
  self.VV5uIE(totChange > 0, 'Change Ref. Codes to "%s"' % rType, "Changes = %d" % totChange)
 @FFHF2S()
 def VVDLMT(self):
  totFiles = 0
  files  = CCSB3R.VVt2XK()
  if files:
   totFiles = len(files)
  totChans = 0
  VVJwgn = self.VV4GJt()
  if VVJwgn:
   totChans = len(VVJwgn)
  FFyijw(self, "Total Files\t: %d\nTotal Channels\t: %d" % (totFiles, totChans))
 def VViFNk(self):
  files = CCSB3R.VVt2XK()
  if files:
   totInvalid = 0
   invTxt  = ""
   for path in files:
    txt = FF05rJ(path)
    for match in iFinditer(r"#SERVICE\s+(?!(?:(?:[A-Fa-f0-9]+[:]){10})).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE):
     totInvalid += 1
     invTxt += "%s\t: %s\n" % (os.path.basename(path), match.group(1))
   if totInvalid == 0 : color = VV8QGw
   else    : color = VVcahY
   totInvalid = FFITtK(totInvalid, color)
   txt  = "Processed Files\t\t: %d\n" % len(files)
   txt += "Invalid References\t: %s\n" % totInvalid
   if invTxt:
    txt += FFITtK("\nInvalid Refrences (File & Chan. Name):\n", color)
    txt += invTxt
  else:
   txt = "No IPTV Files processed."
  FFyijw(self, txt, title="Check IPTV References")
 def VVC65n(self):
  bName  = "%s_IPTV_TMP_BOUQUET_DEL" % VVryLp
  userBName = "userbouquet.%s.tv"  % bName
  chPrefix = "Testing RType "
  rTypeList = CCSB3R.VV0JA5()
  chUrlLst = []
  for rType in (rTypeList):
   ref = "%s:0:1:DDD:DDD:DDD:DDD:0:0:0:http%%3a//testUrl.com/aa/bb.m3u8:Testing RType %s" % (rType, rType)
   chUrlLst.append(ref)
  CC41Tt.VVsLIN(self, "", bName, "", chUrlLst, showRes=False)
  acceptedList = []
  VVEWiG = eServiceReference('1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % userBName)
  if VVEWiG:
   VVq3wX = FFaKV3(VVEWiG)
   if VVq3wX:
    for service in VVq3wX:
     VVeZBd = service[1]
     acceptedList.append(VVeZBd.replace(chPrefix, ""))
  path = VVHX6T + userBName
  bFile = VVHX6T + "bouquets.tv"
  tmpF = bFile + ".tmp"
  cmd = FFDTPf("grep -v '%s' '%s' > '%s'; mv '%s' '%s'" % (userBName, bFile, tmpF, tmpF, bFile))
  cmd += FFDTPf("rm -f '%s'" % path)
  FF6usE(cmd)
  FFfve1()
  title = "System Acceptable Reference Types"
  if acceptedList:
   txt = ""
   for item in rTypeList:
    if item in acceptedList : res, color = "Yes", VV8QGw
    else     : res, color = "No" , VVcahY
    pl = CCSB3R.VVUGUR(item)
    txt += "    %s\t: %s%s\n" % (item, FFITtK(res, color), FFITtK("\t... %s" % pl, VVVAvR) if pl else "")
   FFyijw(self, txt, title=title)
  else:
   txt = FFU9uk(self, "Could not complete the test on your system!", title=title)
 @FFHF2S()
 def VVTVFX(self):
  VVzpSM, err = CCAnLc.VV0Bni(self, CCAnLc.VVV48d)
  if VVzpSM:
   totChannels = 0
   totChange = 0
   for path in CCSB3R.VVt2XK():
    toSave = False
    txt = FF05rJ(path)
    for match in iFinditer(r"(#SERVICE\s+[A-Fa-f0-9]+:)0:(?:[A-Fa-f0-9]+[:]){8}(.+\n#DESCRIPTION\s+(?:.+[:()|\]\[])*(.+))", txt, IGNORECASE):
     totChannels += 1
     VVeZBd = match.group(3).strip(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")
     VVDhju = VVzpSM.get(VVeZBd, "")
     if VVDhju:
      VVDhju  = VVDhju[VVDhju.index(":") + 1:]
      toSave  = True
      totChange += 1
      txt = txt.replace(match.group(0), match.group(1) + VVDhju + ":" + match.group(2))
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
   txt  = "Channels\t: %d\n" % totChannels
   txt += "Changed\t: %d\n" % totChange
   self.VV5uIE(totChange > 0, "Copy Ref. from existing Channels", txt)
  else:
   FFU9uk(self, 'No channels in "lamedb" !')
 def VVqr51(self, VVZzW8, title):
  bFiles = CCSB3R.VVt2XK()
  if bFiles: self.VVFbVQ(bFiles, title)
  else  : FF8PJn(VVZzW8, "No bouquets files !", 1500)
 def VVrH3k(self, VVZzW8, title):
  self.VVW2Qr(VVZzW8, BF(self.VVcmJI, title))
 def VVcmJI(self, title, VVZzW8, bName, bPath):
  self.VVFbVQ([bPath], title)
 def VVFbVQ(self, bFiles, title):
  CCXRxc.VVJ9VK(self, VVmj1O="Renumbering References"
      , VVCJhW  = BF(self.VVhwje, bFiles)
      , VVuQkS = BF(self.VVYvpL, title))
 def VVhwje(self, bFiles, VVM2wn):
  VVM2wn.VViN1g = ""
  VVM2wn.VVkdWG("Calculating Reference ...")
  totLines = 0
  patt = r"#SERVICE\s+(?:[A-Fa-f0-9]+[:]){10}(.+\/\/.+)"
  for path in bFiles:
   if FFf0vs(path):
    lines = FF2iRW(path)
    for line in lines:
     span = iSearch(patt, line)
     if span:
      totLines += 1
  if not VVM2wn or VVM2wn.isCancelled:
   return
  elif not totLines:
   VVM2wn.VViN1g = "No IPTV Services !"
   return
  else:
   VVM2wn.VVqMKy(totLines)
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if FFf0vs(path):
    toSave = False
    bName  = os.path.basename(path)
    lines  = FF2iRW(path)
    for ndx, line in enumerate(lines):
     if not VVM2wn or VVM2wn.isCancelled:
      return
     if ndx == 0:
      span = iSearch(r"#NAME\s+(.+)", line, IGNORECASE)
      if span:
       bName = span.group(1)
      if VVM2wn:
       VVM2wn.VVkdWG("Processing : %s " % bName)
     span = iSearch(patt, line)
     if span:
      if VVM2wn:
       VVM2wn.VVwOHf(1)
      VVDhju, startId, startNS = CC41Tt.VV36AT(rType, CC41Tt.VVe1BZ, [], startId, startNS)
      if VVDhju:
       lines[ndx] = "#SERVICE %s" % (VVDhju + span.group(1))
       toSave = True
      else:
       if VVM2wn:
        VVM2wn.VViN1g = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
 def VVYvpL(self, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  txt  = "Found\t: %d\n"  % threadTotal
  txt += "Changed\t: %d\n" % threadCounter
  if VViN1g:
   txt += "\n\n%s\n%s" % (FFITtK("Ended with Error:", VVcahY), VViN1g)
  self.VV5uIE(True, title, txt)
 def VVPATz(self):
  bFiles = CCSB3R.VVt2XK()
  if not bFiles:
   FF8PJn(self.VV5ybN, "No bouquets files !", 1500)
   return
  tableRefList = []
  for row in self.VV5ybN.VVTq0J():
   tableRefList.append((row[4], row[5]))
  if not tableRefList:
   FF8PJn(self.VV5ybN, "Cannot read list", 1500)
   return
  CCXRxc.VVJ9VK(self, VVmj1O="Renumbering References"
      , VVCJhW  = BF(self.VVyiAG, bFiles, tableRefList)
      , VVuQkS = BF(self.VVYvpL, "Change Current List References to Unique Codes"))
 def VVyiAG(self, bFiles, tableRefList, VVM2wn):
  VVM2wn.VViN1g = ""
  VVM2wn.VVkdWG("Reading System References ...")
  refLst = CC41Tt.VVqvMw(CC41Tt.VVe1BZ, stripRType=True)
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VVqMKy(len(tableRefList))
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if FFf0vs(path):
    toSave = False
    bName = os.path.basename(path)
    txt  = FF05rJ(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span:
     bName = span.group(1)
    if not VVM2wn or VVM2wn.isCancelled:
     return
    VVM2wn.VVkdWG("Processing : %s " % bName)
    for ref, url in tableRefList:
     if not VVM2wn or VVM2wn.isCancelled:
      return
     VVkcp9 = ref + url
     if VVkcp9 in txt:
      VVM2wn.VVwOHf(1)
      VVDhju, startId, startNS = CC41Tt.VV36AT(rType, CC41Tt.VVe1BZ, refLst, startId, startNS)
      if VVDhju:
       tot = txt.count(VVkcp9)
       if tot > 0:
        txt = txt.replace(VVkcp9, VVDhju + url)
        toSave = True
      else:
       if VVM2wn:
        VVM2wn.VViN1g = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
 def VViNGc(self):
  list = None
  if self.VV5ybN:
   list = []
   for row in self.VV5ybN.VVTq0J():
    list.append(row[4] + row[5])
  files = CCSB3R.VVt2XK()
  totChange = 0
  if files:
   for path in files:
    lines = FF2iRW(path)
    toSave = False
    for ndx, line in enumerate(lines):
     span = iSearch(r"#SERVICE\s+(.+\/\/.+)", line, IGNORECASE)
     if span:
      if not list or span.group(1) in list:
       txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]){3})(?:[A-Fa-f0-9]+[:]){7}(.+\/\/.+)", r"\g<1>%s\2" % ("0:" * 7), line, IGNORECASE)
       if tot > 0:
        lines[ndx] = txt
        toSave  = True
        totChange += 1
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
  self.VV5uIE(totChange > 0, "Change to Identical Ref. Codes", "Changes = %d" % totChange)
 def VV5uIE(self, isChanged, title, txt, refreshTable=True):
  if isChanged:
   FFfve1()
   if refreshTable and self.VV5ybN:
    VVJwgn = self.VV4GJt()
    if VVJwgn and self.VV5ybN:
     self.VV5ybN.VVxhz9(VVJwgn, self.VVsSnk)
     self.VV5ybN.VVjSys(txt)
   FFyijw(self, txt, title=title)
  else:
   FFSQn9(self, "No changes.")
 @staticmethod
 def VVt2XK(atLeastOne=False, onlyFileName=False):
  types = ('*.tv', '*.radio')
  files = []
  for f in types:
   files.extend(iGlob(VVHX6T + f))
  if files:
   iptvFiles = []
   for path in files:
    if FFf0vs(path):
     txt = FF05rJ(path)
     span = iSearch(r"#SERVICE.+\/\/.+\n#DESCRIPTION.+", txt, IGNORECASE)
     if span:
      iptvFiles.append(os.path.basename(path) if onlyFileName else path)
      if atLeastOne:
       return iptvFiles
   return iptvFiles
  else:
   return None
 def VV1AaZ(self, VV5ybN, title, txt, colList):
  Num, Name, Bouquet, Type, Ref, URL = VV5ybN.VVqY3Q()
  VVu69c = FF0rS9(URL)
  VVLZ0Z = "%s:%s" % (Ref.rstrip(":"), URL.rstrip(":"))
  if not VVLZ0Z.endswith(":" + Name):
   VVLZ0Z += ":" + Name
  txt  = "%s\n\n" % title
  txt += "Name\t: %s\n" % FFITtK(Name, VV6UAe)
  txt += "Bouquet\t: %s\n" % Bouquet
  txt += CCISy5.VVZUMN(FF0rS9(VVLZ0Z), showUrl=False)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VV5I8H, params=(Ref, Name, txt, VVu69c, VVLZ0Z))
 def VVGhX7(self, VV5ybN, colList):
  VVeZBd = colList[1]
  VVDhju = colList[4]
  url  = colList[5]
  chUrl = VVDhju + url
  return VVeZBd, chUrl
 def VVLqox(self, VV5ybN, title, txt, colList):
  VVeZBd, chUrl = self.VVGhX7(VV5ybN, colList)
  self.VVFubH(VV5ybN, VVeZBd, chUrl, "localIptv")
 def VVk6GX(self, mode, VV5ybN, colList):
  VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, colList)
  VVthiO = os.path.join(self.VVoS8r(mode), os.path.basename(VVKCwZ)) if VVKCwZ else ""
  return VVeZBd, chUrl, VVthiO
 def VVj6Ao(self, mode, VV5ybN, title, txt, colList):
  VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, colList)
  VVthiO = os.path.join(self.VVoS8r(mode), os.path.basename(VVKCwZ)) if VVKCwZ else ""
  self.VVFubH(VV5ybN, VVeZBd, chUrl, mode, VVthiO)
 def VVFubH(self, VV5ybN, VVeZBd, chUrl, mode, VVthiO=""):
  VVeZBd = FFes9J(VVeZBd)
  if self.VV0Jba(VVeZBd):
   FF8PJn(VV5ybN, "This is a marker!", 300)
  else:
   CC2lVw.VVbVSZ(self.session, VVVQym=(self, VV5ybN, mode), VV7GTU=chUrl, VVthiO=VVthiO, VVKvO9=mode == self.VVCHxt)
 @staticmethod
 def VV0Jba(VVeZBd):
  mark = ("--", "__", "==", "##",  "**", "_*", "*_", str(u"\u2605" * 2))
  if VVeZBd.startswith(mark) and VVeZBd.endswith(mark):
   return True
  return False
 def VVOx6V(self, VV5ybN, title, txt, colList):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  if VVDhju:
   url1 = FF0rS9(VVQwVu.strip())
   for ndx, row in enumerate(VV5ybN.VVTq0J()):
    if VVDhju in row[4]:
     tableRow = FF0rS9(row[5].strip())
     if url1 in tableRow or tableRow in url1:
      VV5ybN.VV43d2(ndx)
      break
   else:
    FF8PJn(VV5ybN, "Not found", 1000)
 def VVZcAj(self):
  if CC5ENZ.VVPib3(self):
   self.VVLrmR()
 @FFHF2S("Searching ...")
 def VVLrmR(self):
  lines = self.VV7Vdf(3)
  if lines:
   lst = []
   for f in lines:
    if os.path.isfile(f):
     m3File, m3Dir, VVEyvc, zPath, zFound = CCxgvM.VVeemh(f)
     sz = FFX42v(f)
     (m3SzT, m3Sz) = (CCQdsv.VVAcha(sz, mode=4), str(sz)) if sz > -1 else ("", "")
     m3Tm = zSz = ""
     if zFound:
      sz = FFX42v(zPath)
      zSz = CCQdsv.VVAcha(sz, mode=4) if sz > -1 else ""
      if zSz: m3SzT = "#f#0066ff66#" + m3SzT
      m3Tm = CCxgvM.VVwWU3(zPath).srcMod
     lst.append((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
   title = "M3U/M3U8 File Browser"
   if lst:
    lst.sort(key=lambda x: x[0].lower())
    bTitle = "Playlist Options"
    bg = "#11221122"
    VVPWLU  = {3:2}
    VVI3Oq  = ("Select"    , self.VVBjDw       , [])
    VV5CrJ = ("Refresh File Cache" , self.VVejeq    , [])
    VVbQ6N = ("File Options"  , self.VVV30Y       , [])
    VVvrJb = (bTitle    , BF(self.VVhZYv, bTitle) , [])
    header   = ("File" , "Path", "Size","Size" , "zPath" , "Cached Size" , "m3Tm" )
    widths   = (50  , 38 , 0.02 , 12 , 0   , 0.01   , 0   )
    VVgKQc  = (LEFT  , LEFT , CENTER, CENTER, CENTER , CENTER  , CENTER )
    tbl = FFdCaM(self, None, title=title, header=header, VV5dDF=lst, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVPWLU=VVPWLU, VVI3Oq=VVI3Oq, VVvrJb=VVvrJb, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVVzvS="#11221122", VVhHWW=bg, VVpaQ6=bg, VVI4UA="#11004a55", VVcv6F="#0a333333", VVsOjr="#06333333")
    tbl.VVIl4g(BF(self.VVCcWi, tbl))
   else:
    FFU9uk(self,"No files found." , title=title)
 def VVBjDw(self, VV5ybN, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  CCxgvM(VV5ybN, CCxgvM.VVCcP4, m3uF=m3Dir+m3File, VVs4iu=BF(self.VVT9qg, VV5ybN))
 def VVejeq(self, VV5ybN, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  if VV5ybN["keyGreen"].getVisible():
   CCxgvM(self, CCxgvM.VVDym4, m3uF=m3Dir+m3File, VVs4iu=BF(self.VVT9qg, VV5ybN))
 def VVV30Y(self, VV5ybN, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VVXXzc = []
  VVXXzc.append(("Delete Selected File"   , "delm3u"))
  if zSz: VVXXzc.append(("Delete Local Cache" , "delZip"))
  FFw2XU(self, BF(self.VVLfEY, VV5ybN, colList), title="File Options", VVXXzc=VVXXzc, width=700, VVfP2Q=True)
 def VVLfEY(self, VV5ybN, colList, item):
  if item:
   title, ref, ndx = item
   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
   if  ref == "delm3u": path = m3Dir + m3File
   elif ref == "delZip": path = zPath
   FFHsPu(self, BF(self.VVTsuN, VV5ybN, path, ref), "Delete ?\n\n%s" % path, title=title)
 def VVTsuN(self, VV5ybN, path, ref):
  FFqlCI(path)
  if ref == "delm3u":
   if FFf0vs(path) : FF8PJn(VV5ybN, "No deleted", 1000)
   else    : VV5ybN.VVE3Oz()
  elif ref == "delZip":
   self.VVT9qg(VV5ybN)
 def VVhZYv(self, Title, VV5ybN, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VVXXzc = []
  VVXXzc.append(("Browse Selected Server Online"  , "br"))
  VVXXzc.append(("Filter Playlist URLs (from all Files)", "fl"))
  FFw2XU(self, BF(self.VV4ci7, VV5ybN, m3Dir+m3File), title=Title, VVXXzc=VVXXzc, width=700, VVfP2Q=True)
 def VV4ci7(self, VV5ybN, path, item):
  if item:
   title, ref, ndx = item
   if  ref == "br": self.VVMH1M(VV5ybN, title, path)
   elif ref == "fl": self.VVLPKB(VV5ybN)
 def VVT9qg(self, VV5ybN, *arg):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV5ybN.VVqY3Q()
  sz = FFX42v(zPath)
  zSz = CCQdsv.VVAcha(sz, mode=4) if sz > -1 else ""
  try: m3Tm = str(int(os.path.getmtime(m3Dir + m3File)))
  except: m3Tm = ""
  VV5ybN.VVULq3((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
  if zSz:
   fg = FFEIV2("#0066ff66")
   ndx = VV5ybN.VVfkJL()
   VV5ybN.VVgyd0(ndx, 3, 8, fg)
   VV5ybN.VVgyd0(ndx, 3, 9, fg)
  self.VVCcWi(VV5ybN)
 def VVCcWi(self, VV5ybN):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV5ybN.VVqY3Q()
  VV5ybN["keyGreen"].hide()
  if zSz and m3Tm:
   try: curTm = int(os.path.getmtime(m3Dir + m3File))
   except: curTm = ""
   if curTm and m3Tm != str(curTm):
    VV5ybN["keyGreen"].show()
 def VVLPKB(self, VV5ybN):
  CCXRxc.VVJ9VK(self, titleBg="#22003344", bodyBg="#22001122"
      , VVCJhW  = BF(self.VVV5R5, VV5ybN)
      , VVuQkS = self.VVODa7)
 def VVV5R5(self, VV5ybN, VVM2wn):
  lst = []
  dupl = 0
  totF = VV5ybN.VVJPu5()
  VVM2wn.VVqMKy(totF)
  VVM2wn.VViN1g = (totF, dupl, lst)
  for ndx, (m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm) in enumerate(VV5ybN.VVTq0J()):
   path = m3Dir + m3File
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVkdWG(os.path.basename(path))
   VVM2wn.VVwOHf(1)
   if FFf0vs(path):
    enc = CC2Ldo.VVM9Xv(path)
    if not enc == -1:
     with ioOpen(path, "r", encoding=enc) as f:
      for line in f:
       if not VVM2wn or VVM2wn.isCancelled: return
       line = str(line).strip()
       line, _, _ = line.partition("?")
       line, _, _ = line.partition("&")
       if len(line) < 500:
        url = CCSB3R.VV796l(line)
        if url:
         if not url in lst: lst.append(url)
         else    : dupl += 1
         VVM2wn.VViN1g = (totF, dupl, lst)
         break
 def VVODa7(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  title = "Create Playlist from m3u Files"
  totF, dupl, lst = VViN1g
  if not lst:
   FFU9uk(self, "Could not obtain URLs from this file list !", title=title)
   return
  lst.sort()
  pListF = "%sPlaylist_%s.txt" % (FFY5i9(), FF6eWd())
  with open(pListF, "w") as f:
   for url in lst:
    f.write(url + "\n")
  txt = ""
  txt += "Total Files\t: %d\n" % totF
  txt += "Prcessed Files\t: %d\n" % threadCounter
  if dupl > 0: txt += "Duplicates\t: %d  (removed)\n" % dupl
  txt += "Created Lines\t: %d\n" % len(lst)
  txt += "Playlist File\t: %s" % pListF
  FFyijw(self, txt, title=title)
 @FFHF2S("Searching ...")
 def VVIcSt(self, mode):
  if   mode == 1: title, okFnc = "Select Playlist File", self.VVvKLL
  elif mode == 2: title, okFnc = "Select Portal File"  , self.VVJVZw
  lines = self.VV7Vdf(mode)
  if lines:
   lines.sort()
   VVXXzc = []
   for line in lines:
    VVXXzc.append((FFITtK(line, VV6UAe) if "Bookmarks" in line else line, line))
   t = CCHa3c.VVCDdv(901 if mode==1 else 902) if mode in (1, 2) and VVpSLv else None
   VVpuzu = self.VVRju7
   VVBztL = (VV6UAe + t, BF(self.VV97vK, mode, t)) if t else None
   VViDZz = ("Merge All Files", BF(self.VVshS5, mode)) if len(VVXXzc) > 1 else None
   FFw2XU(self, None, title=title, VVXXzc=VVXXzc, width=1700, height=900, VV5LxL=okFnc, VVpuzu=VVpuzu, VVBztL=VVBztL, VViDZz=VViDZz, VVhuPZ="")
 def VV7Vdf(self, mode):
  err = excl = ""
  dirs = []
  path = "/"
  if CFG.iptvHostsMode.getValue() == VV1rMY:
   excl = FFoSAW(1)
  else:
   lst = list(set(list(map(str.strip, CFG.iptvHostsDirs.getValue().split(",")))))
   tList = []
   for Dir in lst:
    if VVrRHR(Dir):
     tList.append(Dir)
   lst = sorted(tList, key=len)
   for Dir in lst:
    for dir1 in dirs:
     if len(Dir) > len(dir1) and Dir.startswith(dir1):
      break
    else:
     dirs.append(Dir)
   if   len(dirs) == 1 : path = dirs[0]
   elif len(dirs) > 1 : path = "{%s}" % ",".join(dirs)
   if not dirs:
    FFU9uk(self, 'Directory not found !\n\nCheck your settings option:\n\n"IPTV Hosts Files Path (Playlist, Portal, M3U)"')
    return []
  if   mode == 1: par = r'\( -iname "*playlist*" -o -iname "*stalker*" -o -iname "*urlscan.io*" \) | grep -i "\.txt\|\.json"'
  elif mode == 2: par = r'\( -iname "*portal*" -o -iname "*stalker*" -o -iname "*urlscan.io*"  \) | grep -i "\.txt\|\.conf\|\.json"'
  elif mode == 3: par = r'-iname "*.m3u" -o -iname "*.m3u8" | grep -i "\.m3u\|\.m3u8"'
  files = FFunRV("find %s %s %s 2> /dev/null" % (path, excl, par))
  if files:
   err = CCQdsv.VVbsXD(files)
   if err : FFU9uk(self, err + FFITtK('\n\n( Change "IPTV Hosts Files Path" to "Custom" and try again )', VV6UAe))
   else : return files
  else:
   if   path == "/": txt = "!"
   elif dirs  : txt = "in directories listed in settings !"
   else   : txt = "in :\n%s" % path
   if   mode == 1: err = 'No Playlist files found %s\n\n Expecting ".txt" files\n(names must include the word "playlist")' % txt
   elif mode == 2: err = 'No portal files found %s\n\n Expecting ".txt" or ".conf" files\n(name must include the word "portal" or "stalker")' % txt
   elif mode == 3: err = 'No ".m3u" files found %s' % txt
   t = CCHa3c.VVCDdv(901 if mode==1 else 902) if mode in (1, 2) and VVpSLv else None
   if t: FFHsPu(self, BF(self.VV97vK, mode, t), "%s ?" % t)
   else: FFU9uk(self, err)
  return []
 def VVshS5(self, mode, VVZzW8, item):
  lst = VVZzW8.VVEyJ9()
  title = "Merge %s files" % len(lst)
  w1 = w2 = ""
  for nm in lst:
   nm = nm.lower()
   if "playlist" in nm: w1 = "Playlist_"
   if "portal" in nm or "stalker" in nm: w2 = "Portal_"
  path = "%sMerged_%s%s%s.txt" % (FFY5i9(), w1, w2, FF6eWd())
  err = ""
  with open(path, "w") as outF:
   sep = "=" * 100
   c = 0
   try:
    for fil in lst:
     c += 1
     outF.write("#%s\nFile-%s: %s\n#%s\n" % (sep, c, fil, sep))
     outF.write("%s\n\n" % FF05rJ(fil).strip())
   except Exception as e:
    err = str(e)
  if err:
   FFqlCI(path)
   FFU9uk(self, "Error in:\n%s\n\n%s" % (fil, err), title=title)
  else:
   FFSQn9(self, "Saved to:\n\n%s" % path, title=title)
   VVZzW8.VVgjzO((path, path), isSort=True)
 def VV97vK(self, mode, t, VVZzW8=None, item=None):
  if   mode == 1: fnc = self.VV9fNa(t, VVZzW8)
  elif mode == 2: fnc = self.VVR4HT(t, VVZzW8)
 @FFHF2S(par=2)
 def VV9fNa(self, title, VVZzW8):
  lst = []
  for i in range(100, 118): lst.append(CCHa3c.VVCDdv(i))
  try: l1, l2, l3, r, t, u, p, U, P, H, J, L, x1, x2, x3, x4, x5, x6 = lst
  except: return
  if not all(lst): return
  exp = iCompile(r".*(%s.+)\/.*%s=(.+)&%s=([^&]+)" % (H, U, P), IGNORECASE)
  lst, eLst, mT = set(), [], ""
  fTm = FF6eWd()
  dstPath = FFY5i9()
  for ndx, l in enumerate((l1, l2, l3), start=1):
   resp, txt, err = CCNREC.VVJPQJ(l, verify=True)
   if err:
    eLst.append(err)
   else:
    try: d = jLoads(txt)[r]
    except: d = {}
    for par in d:
     span = exp.search(str(par[t][u]))
     if span and all(span.groups()):
      lst.add(L % tuple([FF0rS9(x).strip() for x in span.groups()]))
   if VVpSLv > 1:
    mT += ("%s\n%s\n%s\n\n" % (l, resp.headers, "\n".join([("%s\t: %s" % (x.ljust(30), resp.headers.get(x, ""))) for x in (x1, x2, x3, x4, x5, x6)]))) if resp else ""
    with open("%s%s_%s_%s.%s" % (dstPath, p, fTm, ndx, J), "w") as f: f.write(txt)
  if VVpSLv > 1:
   with open("%s%s_%s_0" % (dstPath, p, fTm), "w") as f: f.write(mT)
  if lst  : self.VVhOYU(VVZzW8, None, "%s%s_%s.txt" % (dstPath, p, fTm), [(u, "") for u in lst], False)
  elif eLst: FFU9uk(self, "\n\n".join(eLst), title=title)
  else  : FFU9uk(self, "Not found", title=title)
 @FFHF2S(par=2)
 def VVR4HT(self, title, VVZzW8):
  u, p = CCHa3c.VVCDdv(200), CCHa3c.VVCDdv(201)
  if not all(u and p): return
  resp, txt, err = CCNREC.VVJPQJ(u, verify=True)
  U = iFindall(r'"@id": "(.+\.html)"', txt, IGNORECASE) if resp else None
  lst = set()
  for u in U:
   resp, txt, err = CCNREC.VVJPQJ(u, verify=True)
   if not txt: continue
   txt = txt.replace("http", "\nhttp")
   for line in txt.split("\n"):
    span = iSearch(r"(http[^< ]+).+(?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}", line)
    if span:
     u = span.group(1).partition("&")[0].partition("#")[0]
     for m in iFindall(r"((?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})", line):
      lst.add(("0", "0", "-", u, m.upper(), "-"))
  if lst:
   lst = sorted(lst)
   outF = "%s%s_%s.txt" % (FFY5i9(), p, FF6eWd())
   if VVpSLv > 1:
    self.VVcYGa(None, None, outF, True, lst, len(lst))
   else:
    with open(outF, "w") as f:
     for _, _, _, h, m, _ in lst: f.write("%s\t%s\n" % (h, m))
    VVZzW8.VVgjzO((outF, outF), isSort=True)
  else:
   FFU9uk(self, "Not found")
 def VVRju7(self, VVZzW8, txt, ref, ndx):
  txt = ref
  sz = FFX42v(ref)
  if sz > 0:
   txt += "\n\nSize: %s" % CCQdsv.VVAcha(sz)
  FFyijw(self, txt, title="File Path")
 def VVvKLL(self, item=None):
  if item:
   VVZzW8, txt, path, ndx = item
   self.VVEi0J(VVZzW8, path)
 @FFHF2S(par=1)
 def VVEi0J(self, VVZzW8, path):
  enc = CC2Ldo.VVM9Xv(path, self)
  if enc == -1:
   return
  num, lineNum, VVJwgn = 1, 0, []
  datePatt = iCompile(r"(?:(?:ends?|exp)(?:[\w]+))[: ]*(\d{4})[-_](\d{2})[-_](\d{2})(?:\s+(\d{2}):(\d{2}):(\d{2}))?", IGNORECASE)
  def VVaHPq(url, rem=""):
   if url:
    modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCSB3R.VVBOAE(url)
    uURL = uURL.rstrip("/")
    for item in VVJwgn:
     if item[2] == uURL and item[3] == uUser and item[4] == uPass:
      return 0
    span = datePatt.search(rem)
    c1 = ""
    if span:
     y, m, d, H, M, S = span.groups()
     H = int(H) if str(H).isdigit() else 0
     M = int(M) if str(M).isdigit() else 0
     S = int(S) if str(S).isdigit() else 0
     try:
      end = mktime(datetime(int(y), int(m), int(d), H, M, S).timetuple())
      c1 = "#f#00ff5555#" if iTime() > end else "#f#0055ff55#"
     except:
      c1 = "#f#00888888#"
    VVJwgn.append((str(len(VVJwgn)+1), str(lineNum), str(uURL), str(uUser), str(uPass), c1 + rem, url))
    return 1
   return 0
  title = "Get Playlist URLs"
  with ioOpen(path, "r", encoding=enc) as f:
   if path.endswith(".json"):
    fTxt = f.read()
    try:
     data = jLoads(fTxt)
     for d in data:
      uURL, uUser, uPass, end = d.get("host", ""), d.get("username", ""), d.get("password", ""), d.get("end_date", "")
      rem = ("Ends: %s" % FFMYsv(float(end))) if str(end).isdigit() else ""
      url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
      num += VVaHPq(url, rem)
    except:
     try:
      exp = iCompile(r".*(http.+)\/.*username=(.+)&password=([^&]+)", IGNORECASE)
      for d in jLoads(fTxt)["results"]:
       span = exp.search(str(d["task"]["url"]))
       if span and all(span.groups()):
        uURL, uUser, uPass = [FF0rS9(x.strip()) for x in span.groups()]
        url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
        num += VVaHPq(url)
     except Exception as e:
      FFU9uk(self, str(e), title=title)
      return
   else:
    l3 = []
    hstPatt = iCompile(r"(http?:\/\/[^\/]+)[^\s]+(?:\s+#(.+))?", IGNORECASE)
    usrPatt = iCompile(r"username\s*[=:]\s*(\S+)", IGNORECASE)
    pasPatt = iCompile(r"password\s*[=:]\s*(\S+)", IGNORECASE)
    for line in f:
     lineNum += 1
     line = str(line).strip()
     if not line or len(line) > 500:
      continue
     span = iSearch(r"(?:http.+)?(http.+php.+username=.+password=[^\s<]+)(?:\s+#(.+))?", line, IGNORECASE)
     url = rem = ""
     if span:
      url = span.group(1)
      rem = span.group(2).strip() if span.group(2) else ""
     else:
      span = iSearch(r"(http.+)\s+username(.+)\s+password\s+([^\s]+)(?:\s+#(.+))?", line, IGNORECASE)
      if span:
       host = FFA4GT(span.group(1).strip())
       user1 = span.group(2).strip()
       pass1 = span.group(3).strip()
       rem  = span.group(4).strip() if span.group(4) else ""
       url  = "%sget.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
     if url:
      l3 = []
     else:
      l3.append(line)
      if len(l3) > 3: l3.pop(0)
      if len(l3) == 3:
       spanH = hstPatt.search(l3[0])
       spanU = usrPatt.search(l3[1]) or usrPatt.search(l3[2])
       spanP = pasPatt.search(l3[2]) or pasPatt.search(l3[1])
       if spanH and spanU and spanP:
        host, user1, pass1 = spanH.group(1), spanU.group(1), spanP.group(1)
        rem = spanH.group(2).strip() if spanH.group(2) else ""
        if all((host, user1, pass1)): url = "%s/get.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
        l3 = []
     num += VVaHPq(url, rem)
  if VVJwgn:
   VVI3Oq  = ("Start"    , BF(self.VVg6zk, "Playlist File")      , [])
   VV9mY2  = BF(self.VVsGWF, VVZzW8)
   VVEyDE = ("Home Menu"   , FF9hlZ             , [])
   VV5CrJ = ("Server Resources" , self.VVfSu9     , [])
   VVbQ6N = ("Edit File"   , BF(self.VVNVak, path)        , [])
   VVvrJb = ("Check & Filter"  , BF(self.VV9eku, VVZzW8, path) , [])
   header   = ("Num" , "LineNum" , "Address" , "User" , "Password" , "Remarks" , "URL" )
   widths   = (7  , 0   , 33  , 17  , 17   , 26  , 0.03 )
   VVgKQc  = (CENTER , CENTER , LEFT  , LEFT   , LEFT   , LEFT  , LEFT  )
   FFdCaM(self, None, title=os.path.basename(path), header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1800, height=1000, VV1Wwb=26, VVI3Oq=VVI3Oq, VV9mY2=VV9mY2, VVEyDE=VVEyDE, VVvrJb=VVvrJb, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVVzvS="#11001116", VVhHWW="#11001116", VVpaQ6="#11001116", VVI4UA="#00003635", VVcv6F="#0a333333", VVsOjr="#11331100", VVrpeX=True, VVylFd=2, VV7VIQ=CFG.lastFindServers)
  else:
   FFU9uk(self, "No valid URLs line in this file:\n\n%s" % path, title=title)
 def VVsGWF(self, VVZzW8, VV5ybN, path):
  if VVZzW8 and path.endswith(".txt"):
   VVZzW8.VVgjzO((path, path), isSort=True)
 def VVfSu9(self, VV5ybN, title, txt, colList):
  CCxgvM(self, CCxgvM.VVzxBl, url=colList[6])
 def VVJO0w(self, VVZzW8, item):
  CCxgvM(self, CCxgvM.VVgFlK, url=self.VVJBt9["playListURL"])
 def VVg6zk(self, Title, VV5ybN, title, txt, colList):
  url = colList[6]
  self.VVSgqw(VV5ybN, Title, url)
 def VVNVak(self, path, VV5ybN, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFf0vs(path) : CCAvJY(self, path, VVuQkS=BF(self.VVrnsp, VV5ybN), VVSkE3=rowNum)
  else    : FFbHk5(self, path)
 def VVrnsp(self, VV5ybN, fileChanged):
  if fileChanged:
   VV5ybN.cancel()
 def VV60jF(self, title):
  curChName = self.VV5ybN.VVVWWJ(1)
  FFttdT(self, BF(self.VV2sx3, self.VV5ybN, title), defaultText=curChName, title=title, message="Enter Name:")
 @FFHF2S(par=1)
 def VV2sx3(self, VV5ybN, title, name):
  if name:
   VVzpSM, err = CCAnLc.VV0Bni(self, CCAnLc.VVSyjB, VVAomI=False, VVw9e0=False)
   list = []
   if VVzpSM:
    name = self.VV0ApM(name)
    ratio = "1"
    for item in VVzpSM:
     if name in item[0].lower():
      list.append((item[0], FFYWFN(item[2]), item[3], ratio))
   if list : self.VVdBX2(list, title)
   else : FFU9uk(self, "Not found:\n\n%s" % name, title=title)
 def VVmxlO(self, title):
  curChName = self.VV5ybN.VVVWWJ(1)
  CCXRxc.VVJ9VK(self, VVmj1O="Find similar names"
      , VVCJhW  = self.VVgFPS
      , VVuQkS = BF(self.VVCTBN, title, curChName))
 def VVgFPS(self, VVM2wn):
  curChName = self.VV5ybN.VVVWWJ(1)
  VVzpSM, err = CCAnLc.VV0Bni(self, CCAnLc.VVXIul, VVAomI=False, VVw9e0=False)
  if not VVzpSM or not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VViN1g = []
  VVM2wn.VVqMKy(len(VVzpSM))
  curCh = self.VV0ApM(curChName)
  for VVDhju in VVzpSM:
   VVeZBd, sat, inDB = VVzpSM.get(VVDhju, ("", "", 0))
   ratio = CCUNc6.VVZ29q(VVeZBd.lower(), curCh)
   if not VVM2wn or VVM2wn.isCancelled:
    return
   VVM2wn.VVwOHf(1, True)
   if VVM2wn and ratio > 50:
    VVM2wn.VViN1g.append((VVeZBd, FFYWFN(sat), VVDhju.replace("_", ":"), str(ratio)))
 def VVCTBN(self, title, curChName, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g: self.VVdBX2(VViN1g, title)
  elif VV9zbx: FFU9uk(self, "No similar names found for:\n\n%s" % curChName, title)
 def VVdBX2(self, VVJwgn, title):
  FFTSvN(self.VV5ybN, BF(self.VVjX0y, VVJwgn, title))
 def VVjX0y(self, VVJwgn, title):
  curChName = self.VV5ybN.VVVWWJ(1)
  VV9cB4 = self.VV5ybN.VVVWWJ(4)
  VVmrz9  = self.VV5ybN.VVVWWJ(5)
  VVJwgn.sort(key=lambda x: (100-int(x[3]), x[0].lower()))
  VVI3Oq  = ("Share Sat/C/T Ref.", BF(self.VVjDHB, title, curChName, VV9cB4, VVmrz9), [])
  header   = ("Name" , "Sat"  , "Reference" , "Ratio" )
  widths   = (34  , 33  , 33   , 0   )
  FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VVVzvS="#0a00112B", VVhHWW="#0a001126", VVpaQ6="#0a001126", VVI4UA="#00000000")
 def VVjDHB(self, newtitle, curChName, VV9cB4, VVmrz9, VV5ybN, title, txt, colList):
  newChName = colList[0]
  newRefCode = colList[2]
  data  = newtitle, curChName, VV9cB4, VVmrz9, newChName, newRefCode
  ques  = "IPTV Channel\t: %s\n\nSat/C/T Chan. \t: %s\n" % (curChName, newChName)
  FFHsPu(self.VV5ybN, BF(self.VVmTZf, VV5ybN, data), ques, title=newtitle, VVys8X=True)
 @FFHF2S(par=1)
 def VVmTZf(self, VV5ybN, data):
  VV5ybN.cancel()
  title, curChName, VV9cB4, VVmrz9, newChName, newRefCode = data
  VVmrz9  = VVmrz9.strip()
  VV9cB4 = VV9cB4.strip()
  newRefCode = newRefCode.strip()
  if not VV9cB4.endswith(":") : VV9cB4 += ":"
  if not newRefCode.endswith(":") : newRefCode += ":"
  curFullUrl = newFullUrl = ""
  span = iSearch(r"([A-Fa-f0-9]+:).+", VV9cB4, IGNORECASE)
  if span:
   curRType = span.group(1)
   span = iSearch(r"[A-Fa-f0-9]+:(.+)", newRefCode, IGNORECASE)
   if span:
    newRefCode = curRType + span.group(1)
    curFullUrl = VV9cB4 + VVmrz9
    newFullUrl = newRefCode + VVmrz9
  totChanges = 0
  resTxt = resErr = ""
  if curFullUrl and newFullUrl:
   for path in CCSB3R.VVt2XK():
    txt = FF05rJ(path)
    if curFullUrl in txt:
     totChanges += 1
     txt = txt.replace(curFullUrl, newFullUrl)
     with open(path, "w") as f:
      f.write(txt)
   if totChanges > 0:
    FFfve1()
    newRow = []
    for i in range(6):
     newRow.append(self.VV5ybN.VVVWWJ(i))
    newRow[4] = newRefCode
    done = self.VV5ybN.VVULq3(newRow)
    resTxt = "Done"
   else:
    resErr = "Not found in IPTV files"
  else:
   resErr = "Cannot read Chan. Info."
  if   resTxt: FFDiNL(BF(FFSQn9 , self, resTxt, title=title))
  elif resErr: FFDiNL(BF(FFU9uk, self, resErr, title=title))
 def VV9eku(self, VVmKt7, path, VV5ybN, title, txt, colList):
  outF = "%s_OK_%s.txt" % (path, FF6eWd())
  lst = [(url, remarks) for num, lineNum, hst, usr, pas, remarks, url in VV5ybN.VVTq0J()]
  self.VVhOYU(VVmKt7, VV5ybN, outF, lst, True)
 def VVhOYU(self, VVmKt7, VV5ybN, outF, lst, hasFile):
  CCXRxc.VVJ9VK(self, VVmj1O="Checking Authorized Servers"
      , VVCJhW  = BF(self.VVOSZh, VV5ybN, lst)
      , VVuQkS = BF(self.VVchFd, VVmKt7, VV5ybN, outF, len(lst), hasFile))
 def VVOSZh(self, VV5ybN, lst, VVM2wn):
  VVM2wn.VVqMKy(len(lst))
  VVM2wn.VViN1g = []
  datePatt = iCompile(r"(?:ends?|exp)[\w]+[: ]*\d{4}[-_]\d{2}[-_]\d{2}(?:\s+\d{2}:\d{2}:\d{2})?(.*)", IGNORECASE)
  for url, remarks in lst:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1, True)
   qUrl = self.VVahPD(self.VVbJQL, url)
   txt, err = self.VVEL0f(qUrl, timeout=1)
   if not err:
    try:
     tDict = jLoads(txt)
     if tDict and not err and "server_info" in tDict:
      item = tDict["user_info"]
      if not FFX7JA(item, "auth") == "0":
       end = item.get("exp_date", "")
       rem = ("Ends: %s" % FFMYsv(float(end))) if str(end).isdigit() else ""
       if remarks:
        span = datePatt.search(remarks)
        if span : rem += (" ... %s" % span.group(1)) if span.group(1) else ""
        else : rem += " ... %s" % remarks
       if not VVM2wn or VVM2wn.isCancelled: return
       VVM2wn.VViN1g.append("%s%s" % (qUrl, ("\t#" + " " + rem) if rem else ""))
    except:
     pass
 def VVchFd(self, VVmKt7, VV5ybN, outF, totChk, hasFile, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  title = "Authorized Servers"
  if VViN1g:
   totAuth = len(VViN1g)
   if hasFile and totAuth == totChk:
    FFSQn9(self, "All URLs are authorized.", title=title)
   else:
    with open(outF, "w") as f:
     for item in VViN1g:
      f.write("%s\n" % item)
    if VVmKt7 : VVmKt7.VVgjzO((outF, outF), isSort=True)
    else   : self.VVIcSt(1)
    txt = FFITtK("Process Stopped\n\n", VVsm0W) if not VV9zbx else ""
    txt += "Checked\t: %d/%d\n"  %  (threadCounter, totChk)
    txt += "Authorized\t: %s\n\n" %  FFITtK(totAuth, VV8QGw)
    txt += "%s\n%s"    %  (FFITtK("Result File:", VV6UAe), outF)
    FFyijw(self, txt, title=title)
    if VV5ybN: VV5ybN.close()
  else:
   FFU9uk(self, "No authorized URL found !", title=title)
 @staticmethod
 def VVEL0f(url, timeout=3, allowDocType=False):
  if not iRequest:
   return "" , "Cannot import URLLIB/URLLIB2 !"
  try:
   req = iRequest(url)
   req.add_header("User-Agent", CCSB3R.VVmGzj())
   res = iUrlopen(req, timeout=timeout)
   resCode = res.code
   if resCode == 200 :
    cont = res.headers.get("Content-Type")
    if cont:
     if not any(x in cont for x in ("/json", "/ld+json", "text/html", "text/plain")):
      return "", "Unexpected server data type ( %s )" % cont
     res = res.read().decode("UTF-8", "replace")
     if res:
      if not allowDocType and ("<!DOCTYPE html" in res or "<html" in res):
       sErr = "Username or password is invalid."
       if sErr in res : return "", sErr
       else   : return "", "Incorrect data format from server (html)."
      else:
       return res, ""
     else:
      return "", "No data from server."
    else:
     return "", "No data received from server"
   elif resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", err
  except Exception as e:
   return "", str(e)
 @staticmethod
 def VVBOAE(url):
  uURL = uProtoc = uHost = uPort = uQuery = uUser = uPass = ""
  modified = False
  uQueryParam = {}
  span  = iSearch(r"\s*(?:(.+):\/\/)*([^:^\/]*)(?::(\d*)\/)*\/*([^\?]*)\?*(.+)", url, IGNORECASE)
  if span:
   modified = True
   uProtoc = span.group(1) or ""
   uHost = span.group(2) or ""
   uPort = span.group(3) or ""
   uQuery = span.group(4) or ""
   param = span.group(5) or ""
   for part in param.split("&"):
    if "=" in part:
     if   part.lower().startswith("username"): uUser = part.split("=")[1]
     elif part.lower().startswith("password"): uPass = part.split("=")[1]
     parts = part.split("=")
     key = parts[0]
     val = parts[1]
     uQueryParam[key] = val
  if uProtoc : uProtoc += "://"
  if uPort : uPort = ":" + uPort
  uURL = "%s%s%s/" % (uProtoc, uHost, uPort)
  return modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam
 @staticmethod
 def VVsV5B(url, justValidate=False, getAudVid=False, compareType=None, compareExt=None, justRetDotExt=False):
  res = scheme = netloc = path = params = query = fragment = username = password = hostname = port = ""
  try:
   if not iUrlparse(url).scheme:
    url = url.lstrip("/")
    url = "http://" + url
   res   = iUrlparse(url)
   scheme  = res.scheme
   netloc  = res.netloc
   path  = res.path
   params  = res.params
   query  = res.query
   fragment = res.fragment
   username = res.username or ""
   password = res.password or ""
   hostname = res.hostname or ""
   port  = res.port  or ""
  except:
   pass
  if justValidate:
   return all([scheme, netloc, path])
  tmpPath = path.strip("/")
  if   path.startswith("/live/") : chType, tmpPath = "live" , path[6:]
  elif path.startswith("/movie/") : chType, tmpPath = "vod" , path[7:]
  elif path.startswith("/series/"): chType, tmpPath = "series", path[8:]
  elif any(x in url for x in ("mode=itv", "/stream.", "/live."))     : chType = "live"
  elif any(x in url for x in ("mode=vod", "/movie/", "/vod/", "/video/", ".m3u8")): chType = "vod"
  elif "mode=series" in url  : chType = "series"
  else       : chType = ""
  parts = tmpPath.split("/")
  if len(parts) >= 2:
   username = parts[0]
   password = parts[1]
   if len(parts) > 2:
    tmpPath  = "/".join(parts[2:])
  parts  = tmpPath.split(":")
  fileName = parts[0]
  if len(parts) > 1: VVeZBd = ":".join(parts[1:])
  elif ":" in query: VVeZBd = query.split(":")[1]
  else    : VVeZBd = ""
  streamId, dotExt = os.path.splitext(fileName)
  ext = dotExt[1:]
  if justRetDotExt:
   return dotExt
  if compareExt:
   if compareExt == ext: return True
   else    : return False
  if getAudVid:
   if ext:
    tDict = CCf9Gq.VVl1a5()
    if   ext in list(tDict["mov"]): return "vid"
    elif ext in list(tDict["mus"]): return "aud"
   return ""
  if streamId.isdigit():
   if not chType :
    if not ext              : chType = "live"
    elif iSearch(r"(s\d\d.*e\d\d|e\d\d.*s\d\d)", VVeZBd, IGNORECASE): chType = "series"
    else               : chType = "movie:"
  else:
   streamId = ""
  if compareType is not None:
   if compareType == chType: return True
   else     : return False
  else:
   if scheme:
    scheme += "://"
   host = scheme + netloc
   return chType, host, username, password, streamId, VVeZBd
 @staticmethod
 def VVHGMA(VVu69c):
  return CCSB3R.VVsV5B(VVu69c, justRetDotExt=True)
 def VVahPD(self, mode, url, Id="0"):
  Id = str(Id).strip()
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVBOAE(url)
  url = "%splayer_api.php?username=%s&password=%s" % (uURL, uUser, uPass)
  if   mode == self.VVbJQL   : return "%s"            % url
  elif mode == self.VVJlIE   : return "%s&action=get_live_categories"     % url
  elif mode == self.VV58i3   : return "%s&action=get_vod_categories"      % url
  elif mode == self.VVkiMU  : return "%s&action=get_series_categories"     % url
  elif mode == self.VVC8z8  : return "%s&action=get_live_categories"     % url
  elif mode == self.VVnsRa : return "%s&action=get_series_info&series_id=%s"   % (url, Id)
  elif mode == self.VVIqPb   : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
  elif mode == self.VVhFEC    : return "%s&action=get_vod_streams&category_id=%s"   % (url, Id)
  elif mode == self.VVY3Xw  : return "%s&action=get_series&category_id=%s"    % (url, Id)
  elif mode == self.VVZImy : return "%s&action=get_live_streams"      % url
  elif mode == self.VVCHxt  : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
 @FFHF2S(par=1, clearMsg=False)
 def VVMH1M(self, VV5ybN, title, path):
  if FFf0vs(path):
   enc = CC2Ldo.VVM9Xv(path, self)
   if enc == -1: return
   qUrl = ""
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     line = str(line).strip()
     if not line or len(line) > 500: continue
     qUrl = CCSB3R.VV796l(line)
     if qUrl:
      break
   VV5ybN.VV8SQf()
   if qUrl : self.VVSgqw(VV5ybN, title, qUrl)
   else : FFU9uk(self, "Invalid M3U line format in:\n\n%s" % path, title=title)
  else:
   FFU9uk(self, "Cannot open file :\n\n%s" % path, title=title)
 def VV5pRm(self):
  title = "Current Channel Server"
  qUrl, VVu69c, VVLZ0Z = CCSB3R.VVxAMw(self)
  if qUrl or "chCode" in VVLZ0Z:
   p = CCNREC()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
   if valid:
    self.VVVYLv(self, host, mac)
    return
   elif qUrl:
    self.VVSgqw(self, title, qUrl)
    return
  FFU9uk(self, "Error in current channel URL !", title=title)
 @staticmethod
 def VVxAMw(SELF):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(SELF)
  qUrl = CCSB3R.VV796l(VVu69c)
  return qUrl, VVu69c, VVLZ0Z
 @staticmethod
 def VV796l(url):
  if url.startswith("#"):
   return ""
  url = url.strip(" /")
  try: res = iUrlparse(url)
  except: return ""
  scheme = res.scheme
  netloc = res.netloc
  if not scheme or not netloc:
   return ""
  host = scheme + "://" +  netloc
  path = res.path.strip("/")
  if   path.startswith("live/") : path = path[5:]
  elif path.startswith("movie/") : path = path[6:]
  elif path.startswith("series/") : path = path[7:]
  parts = path.split("/")
  part = "%s/get.php?username=%s&password=%s&type=m3u"
  if len(parts) == 3 and len(parts[0]) > 1:
   return part % (host, parts[0], parts[1])
  else:
   data = CCSB3R.VV6RmU(url)
   if data : return part % (data[0], data[1], data[2])
   else : return ""
 @FFHF2S("Checking Server ...", par=1)
 def VVSgqw(self, SELF, title, url):
  self.VVmrz9 = url
  self.VVJBt9 = {}
  qUrl = self.VVahPD(self.VVbJQL, url)
  txt, err = self.VVEL0f(qUrl)
  if err:
   err = "Server Error:\n\n%s" % err
  tDict = {}
  if not err:
   try: tDict = jLoads(txt)
   except: pass
   if not tDict:
    err = "Could not parse server data !"
  if tDict and not err:
   self.VVJBt9 = {"playListURL": url}
   if "user_info" in tDict and "server_info" in tDict:
    item = tDict["user_info"]
    self.VVJBt9["username"    ] = FFX7JA(item, "username" )
    self.VVJBt9["password"    ] = FFX7JA(item, "password" )
    self.VVJBt9["message"    ] = FFX7JA(item, "message" )
    self.VVJBt9["auth"     ] = FFX7JA(item, "auth"  )
    self.VVJBt9["status"    ] = FFX7JA(item, "status"  )
    self.VVJBt9["exp_date"    ] = FFX7JA(item, "exp_date" , isDate=True)
    self.VVJBt9["is_trial"    ] = FFX7JA(item, "is_trial" )
    self.VVJBt9["active_cons"   ] = FFX7JA(item, "active_cons")
    self.VVJBt9["created_at"   ] = FFX7JA(item, "created_at" , isDate=True)
    self.VVJBt9["max_connections"  ] = FFX7JA(item, "max_connections")
    self.VVJBt9["allowed_output_formats"] = FFX7JA(item, "allowed_output_formats")
    key = "allowed_output_formats"
    val = item.get(key, None)
    if isinstance(val, list):
     self.VVJBt9[key] = " , ".join(val)
    item = tDict["server_info"]
    self.VVJBt9["url"    ] = FFX7JA(item, "url"   )
    self.VVJBt9["port"    ] = FFX7JA(item, "port"   )
    self.VVJBt9["https_port"  ] = FFX7JA(item, "https_port"  )
    self.VVJBt9["server_protocol" ] = FFX7JA(item, "server_protocol")
    self.VVJBt9["rtmp_port"   ] = FFX7JA(item, "rtmp_port"  )
    self.VVJBt9["timezone"   ] = FFX7JA(item, "timezone"  )
    self.VVJBt9["timestamp_now"  ] = FFX7JA(item, "timestamp_now" , isDate=True)
    self.VVJBt9["time_now"   ] = FFX7JA(item, "time_now"  )
    VVXXzc  = self.VVU2k3(True)
    VV5LxL = self.VVc0tL
    VVpuzu = BF(self.VV8q28, 0)
    VVSuW0 = ("Home Menu" , FF9hlZ)
    VVBztL = ("Resources" , self.VVJO0w)
    VVI6TY= ("Add to Menu", BF(CCSB3R.VVFU3m, self, False, self.VVJBt9["playListURL"]))
    VViDZz = ("Bookmark" , BF(CCSB3R.VVTaN9, self, False, self.VVJBt9["playListURL"]))
    VVZzW8 = FFw2XU(self, None, title="IPTV Server Resources", VVXXzc=VVXXzc, VV5LxL=VV5LxL, VVpuzu=VVpuzu, VVSuW0=VVSuW0, VVBztL=VVBztL, VVI6TY=VVI6TY, VViDZz=VViDZz)
    self.VVTZT5(VVZzW8)
   else:
    err = "Cannot get User-Data from server !"
  if err:
   FFU9uk(self, err, title=title)
  FF8PJn(self)
 def VVc0tL(self, item=None):
  if item:
   VVZzW8, title, ref, ndx = item
   if   ref == "live"   : self.VVMyAV(VVZzW8, self.VVJlIE , title=title)
   elif ref == "vod"   : self.VVMyAV(VVZzW8, self.VV58i3 , title=title)
   elif ref == "series"  : self.VVMyAV(VVZzW8, self.VVkiMU , title=title)
   elif ref == "catchup"  : self.VVMyAV(VVZzW8, self.VVC8z8, title=title)
   elif ref == "accountInfo" : FFTSvN(VVZzW8, BF(self.VVP8bM, title=title))
 def VVTZT5(self, VVZzW8):
  dUrl = CCaZ62(self.session).VVu69c
  if   FFJoTR(dUrl): VVZzW8.VVEaHH(2)
  elif FFBaXf(dUrl) : VVZzW8.VVEaHH(1)
 @FFHF2S(par=2)
 def VV8q28(self, isPortal, VVZzW8, txt, ref, ndx):
  txt  = "%s\n\n" % self.VVmrz9
  if isPortal:
   tab  = lambda x, y: "%s\t: %s\n" % (x, y)
   wServ = self.VVlJlD()
   if wServ:
    txt += tab("Web Server", wServ)
   if VVpSLv:
    ver, err = self.VVGMO8(self.VV9Q1g())
    txt += tab("Original", self.VVmrz9)
    txt += tab("Modified", self.VVD5zt)
    txt += tab("PHP"  , self.VVKj1k)
    txt += tab("Extra"  , {2:"Big", 3:"Sml"}.get(self.VV8kNO, "-"))
    txt += tab("Version" , (ver or err))
    txt += "\n%s\n..\tBig\n...\tSml\nBlank\t/s/l.p\n+\t/p.p\n++\t/p1.p\n*\tModed" % SEP
  FFyijw(self, txt, title="Current Server")
 def VVP8bM(self, title):
  rows = []
  for key, val in self.VVJBt9.items():
   if isinstance(val, list): val = str(" , ".join(val))
   else     : val = str(val)
   if any(x in key for x in ("url", "port", "https_port", "server_protocol", "rtmp_port", "timezone", "timestamp_now", "time_now")):
    num, part = "2", self.VVt74K
   else:
    num, part = "1", self.VVG1Kv
   rows.append((num, part, str(key).replace("_", " ").title(), str(val)))
  rows.sort(key=lambda x: (x[0], x[2]))
  VVEyDE  = ("Home Menu", FF9hlZ, [])
  VV5CrJ  = None
  if VVpSLv:
   VV5CrJ = ("Get JS" , BF(self.VV7m2U, "/".join(self.VVJBt9["playListURL"].split("/")[:-1])), [])
  header    = ("Num", "User/Server" , "Subject" , "Value" )
  widths    = (0 , 15   , 35  , 50  )
  FFdCaM(self, None, title=title, width=1200, header=header, VV5dDF=rows, VV1PTZ=widths, VV1Wwb=26, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVVzvS="#0a00292B", VVhHWW="#0a002126", VVpaQ6="#0a002126", VVI4UA="#00000000", VVylFd=2)
 def VVqDQU(self, mode, jData):
  list = []
  err  = ""
  try:
   tDict = jLoads(jData)
   if tDict:
    if mode in (self.VVIqPb, self.VVCHxt):
     for ndx, item in enumerate(tDict, start=1):
      num      = FFX7JA(item, "num"     )
      name     = FFX7JA(item, "name"     )
      stream_id    = FFX7JA(item, "stream_id"   )
      stream_icon    = FFX7JA(item, "stream_icon"   )
      epg_channel_id   = FFX7JA(item, "epg_channel_id"  )
      added     = FFX7JA(item, "added"    , isDate=True)
      is_adult    = FFX7JA(item, "is_adult"    )
      category_id    = FFX7JA(item, "category_id"   )
      tv_archive    = FFX7JA(item, "tv_archive"   )
      direct_source   = FFX7JA(item, "direct_source"  )
      archDur     = FFX7JA(item, "tv_archive_duration" )
      name = self.VVYPwG(name, censored=is_adult)
      if name:
       if mode == self.VVIqPb or mode == self.VVCHxt and tv_archive == "1":
        hasPicon = "Yes" if stream_icon else ""
        VV1CZl = "Yes" if tv_archive == "1" else ""
        if archDur:
         if archDur.isdigit():
          tot = int(archDur)
          if tot > 0: VV1CZl = "%s day%s" % (tot, FFEnJs(tot))
         else:
          VV1CZl = archDur
        list.append((num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VV1CZl, direct_source))
    elif mode == self.VVhFEC:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFX7JA(item, "num"     )
      name    = FFX7JA(item, "name"     )
      stream_id   = FFX7JA(item, "stream_id"   )
      stream_icon   = FFX7JA(item, "stream_icon"   )
      added    = FFX7JA(item, "added"    , isDate=True)
      is_adult   = FFX7JA(item, "is_adult"    )
      category_id   = FFX7JA(item, "category_id"   )
      container_extension = FFX7JA(item, "container_extension" ) or "mp4"
      name = self.VVYPwG(name, censored=is_adult)
      if name:
       isPicon = "Yes" if stream_icon else ""
       list.append((num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon))
    elif mode == self.VVY3Xw:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFX7JA(item, "num"     )
      name    = FFX7JA(item, "name"     )
      series_id   = FFX7JA(item, "series_id"   )
      cover    = FFX7JA(item, "cover"    )
      genre    = FFX7JA(item, "genre"    )
      episode_run_time = FFX7JA(item, "episode_run_time"  )
      category_id   = FFX7JA(item, "category_id"   )
      container_extension = FFX7JA(item, "container_extension" ) or "mp4"
      name = self.VVYPwG(name)
      if name:
       isPicon = "Yes" if cover else ""
       list.append((num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon))
  except:
   err = "Cannot parse received data !"
  return list, err
 @FFHF2S("Downloading ...", par=1)
 def VVMyAV(self, VVZzW8, mode, title):
  cList, err = self.VVwWLb(mode)
  if cList and mode == self.VVC8z8:
   cList = self.VVGEBc(cList)
  if err:
   FFU9uk(self, err, title=title)
  elif cList:
   cList.sort(key=lambda x: x[0].lower())
   self.VVHPL5 = dict([(x[1], x[0]) for x in cList])
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP(mode)
   mName = self.VVvzqt(mode)
   if   mode == self.VVJlIE  : fMode = self.VVIqPb
   elif mode == self.VV58i3  : fMode = self.VVhFEC
   elif mode == self.VVkiMU : fMode = self.VVY3Xw
   elif mode == self.VVC8z8 : fMode = self.VVCHxt
   if mode == self.VVC8z8:
    VVbQ6N = None
    VVvrJb = None
   else:
    VVbQ6N = ("Find in %s" % mName , BF(self.VVmqXm, fMode, True) , [])
    VVvrJb = ("Find in Selected" , BF(self.VVmqXm, fMode, False) , [])
   VVI3Oq   = ("Show List"   , BF(self.VVcYzT, mode)  , [])
   VVEyDE  = ("Home Menu"   , FF9hlZ         , [])
   header   = ("Category Name", "catID","Parent ID", "Server Default Sorting" )
   widths   = (100, 0, 0, 0.02)
   FFdCaM(self, None, title=title, width=1200, header=header, VV5dDF=cList, VV1PTZ=widths, VV1Wwb=30, VVVTz9=True, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVI3Oq=VVI3Oq, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VV7VIQ=CFG.lastFindIptv)
  else:
   FFU9uk(self, "No list from server !", title=title)
  FF8PJn(self)
 def VVwWLb(self, mode, url=None, chkAdult=True):
  qUrl  = self.VVahPD(mode, url or self.VVJBt9["playListURL"])
  timeout = 20 if mode in (self.VVJlIE, self.VVC8z8) else 3
  txt, err = self.VVEL0f(qUrl, timeout=timeout)
  if err:
   return [], "Server Error:\n\n" + err
  list = []
  try:
   tDict = jLoads(txt)
   if tDict:
    c = 0
    for item in tDict:
     category_id  = FFX7JA(item, "category_id" )
     category_name = FFX7JA(item, "category_name")
     parent_id  = FFX7JA(item, "parent_id" )
     if chkAdult: category_name = self.VVeM8A(category_name)
     if category_name:
      c += 1
      list.append((category_name, category_id, parent_id, str(c)))
  except:
   return "", "Cannot parse received data !"
  return list, ""
 def VVGEBc(self, catList):
  mode = self.VVCHxt
  qUrl = self.VVahPD(mode, self.VVJBt9["playListURL"])
  txt, err= self.VVEL0f(qUrl)
  chanList= []
  if err:
   return []
  chanList, err = self.VVqDQU(mode, txt)
  newCatList = []
  for cat in catList:
   for ch in chanList:
    if cat[1] == ch[2] and not cat in newCatList:
     newCatList.append(cat)
  return newCatList
 @FFHF2S("Downloading ...", par=2)
 def VVcYzT(self, mode, VV5ybN, title, txt, colList):
  bName  = colList[0]
  catID  = colList[1]
  parentID = colList[2]
  title = self.VVvzqt(mode) + " : "+ bName
  if   mode == self.VVJlIE  : mode = self.VVIqPb
  elif mode == self.VV58i3  : mode = self.VVhFEC
  elif mode == self.VVkiMU : mode = self.VVY3Xw
  elif mode == self.VVC8z8 : mode = self.VVCHxt
  qUrl  = self.VVahPD(mode, self.VVJBt9["playListURL"], catID)
  txt, err = self.VVEL0f(qUrl, timeout=20)
  list  = []
  if not err and mode in (self.VVIqPb, self.VVhFEC, self.VVY3Xw, self.VVCHxt):
   list, err = self.VVqDQU(mode, txt)
  if err:
   FFU9uk(self, err, title=title)
  elif list:
   VVEyDE  = ("Home Menu"   , FF9hlZ            , [])
   if mode in (self.VVIqPb, self.VVCHxt):
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP(mode)
    VV4dTm = (""     , BF(self.VVt1Qo, mode)      , [])
    VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, "", "")   , [])
    VVbQ6N = ("Options"   , BF(self.VVU0BK, "lv", mode, bName)   , [])
    VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, False)     , [])
    VVI3Oq  = ("Play"    , BF(self.VVj6Ao, mode)       , [])
   elif mode == self.VVhFEC:
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP(mode)
    VVI3Oq  = ("Play"    , BF(self.VVj6Ao, mode)       , [])
    VV4dTm = (""     , BF(self.VVt1Qo, mode)      , [])
    VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, "v", "")   , [])
    VVbQ6N = ("Options"   , BF(self.VVU0BK, "v", mode, bName)   , [])
    VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, False)     , [])
   elif mode == self.VVY3Xw:
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP("series2")
    VVI3Oq  = ("Show Seasons"  , BF(self.VVMfjq, mode)       , [])
    VV4dTm = (""     , BF(self.VV55PJ, mode)     , [])
    VV5CrJ = None
    VVbQ6N = None
    VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, True)      , [])
   header, widths, VVgKQc = self.VV5wBo(mode)
   FFdCaM(self, None, title=title, header=header, VV5dDF=list, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindIptv, VV4dTm=VV4dTm, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VVrpeX=True, VVylFd=1)
  else:
   FFU9uk(self, "No Channels found !", title=title)
  FF8PJn(self)
 def VV5wBo(self, mode):
  if mode in (self.VVIqPb, self.VVCHxt):
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "epgID" , "Is Adult", "Logo", "Catch-up", "Link")
   widths   = (8  , 55  , 0   , 0   , 0  , 22  , 0   , 0   , 6  , 9   , 0.03 )
   VVgKQc  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER , CENTER, CENTER , CENTER)
  elif mode == self.VVhFEC:
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "isAdult" , "Ext" , "Logo")
   widths   = (8  , 62  , 0   , 0   , 0  , 24  , 0   , 0  , 6  )
   VVgKQc  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER, CENTER)
  elif mode == self.VVY3Xw:
   header   = ("Num" , "Name", "catID", "ID"  , "Genre" , "Dur.", "Ext" , "Cover" , "Logo" )
   widths   = (8  , 56  , 0   , 0   , 30  , 0  , 0  , 0   , 6   )
   VVgKQc  = (CENTER, LEFT  , LEFT   , CENTER , LEFT , CENTER, CENTER, LEFT  , CENTER )
  return header, widths, VVgKQc
 @FFHF2S("Downloading ...", par=2)
 def VVMfjq(self, mode, VV5ybN, title, txt, colList):
  title = colList[1]
  list, err = self.VVDzuB(colList[3])
  if err:
   FFU9uk(self, err, title=title)
  elif list:
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = CCSB3R.VVB7ZP("")
   VVEyDE = ("Home Menu"   , FF9hlZ          , [])
   VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, "s", title), [])
   VVbQ6N = ("Options"   , BF(self.VVU0BK, "s", mode, title) , [])
   VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, False)   , [])
   VV4dTm = (""     , BF(self.VVt1Qo, mode)    , [])
   VVI3Oq  = ("Play"    , BF(self.VVj6Ao, mode)     , [])
   header   = ("Season" , "Episode" , "Title" , "catID" , "stID", "Icon", "Ext" )
   widths   = (10  , 10  , 80  , 0   , 0  , 0  , 0  )
   VVgKQc  = (CENTER , CENTER , LEFT  , CENTER , CENTER, LEFT , CENTER)
   FFdCaM(self, None, title=title, header=header, VV5dDF=list, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindIptv, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA)
  else:
   FFU9uk(self, "No Channels found !", title=title)
  FF8PJn(self)
 def VVDzuB(self, series_id, url=None):
  qUrl  = self.VVahPD(self.VVnsRa, url or self.VVJBt9["playListURL"], series_id)
  txt, err = self.VVEL0f(qUrl)
  list  = []
  if not err:
   list = []
   err  = ""
   try:
    tDict = jLoads(txt)
    if tDict:
     title  = "Seasons"
     category_id = "222"
     icon  = ""
     if "info" in tDict:
      sName  = FFX7JA(tDict["info"], "name"  )
      category_id = FFX7JA(tDict["info"], "category_id" )
      icon  = FFX7JA(tDict["info"], "cover"  )
     if "episodes" in tDict:
      seasons = tDict["episodes"]
      for season in seasons:
       item = seasons[season]
       for EP in item:
        stream_id   = FFX7JA(EP, "id"     )
        episode_num   = FFX7JA(EP, "episode_num"  )
        epTitle    = FFX7JA(EP, "title"    )
        container_extension = FFX7JA(EP, "container_extension")
        seasonNum   = FFX7JA(EP, "season"    )
        sName = self.VVYPwG(sName)
        epTitle = self.VVYPwG(epTitle)
        epTitle = self.VV6PEr(series_id, sName, epTitle, seasonNum, episode_num)
        list.append((seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension))
   except:
    err = "Cannot parse received data !"
  return list, err
 def VV6PEr(self, catID, sName, eName, sNum, eNum):
  SeEp = ( "S%.2dE%.2d (%s)" % (int(sNum), int(eNum), catID) ) if sNum.isdigit() and eNum.isdigit() else ""
  prefix = sName + " " + SeEp
  patt = r"(S\d{1,3}\W*E\d{1,3})|(E\d{1,3}\W*S\d{1,3})"
  if eName.lower().startswith(sName.lower()):
   eName = sName + eName[len(sName):]
  if iMatch(r"^%s" % patt, eName, IGNORECASE):
   return iSub(patt, prefix, eName, flags=IGNORECASE)
  elif not eName.startswith(sName):
   return prefix + " " + eName
  elif eName.startswith(sName):
   eName, tot = iSubn(patt, SeEp, eName, flags=IGNORECASE)
   if tot : return eName
   else : return prefix + " " + eName[len(sName):].strip()
  return eName
 def VVftto(self, ser, hst, usr, pas, title):
  typ = "LVS" if ser else "LV"
  outF = "%s%s_%s_%s.m3u" % (FFY5i9(), FF80BW(iUrlparse(hst).hostname), typ, FF6eWd())
  CCXRxc.VVJ9VK(self, VVmj1O="Reading Categories ...", totBars=2
      , VVCJhW  = BF(self.VVpydq, ser, hst, usr, pas, outF, title)
      , VVuQkS = BF(self.VVuvjM, ser, outF, title))
 def VVpydq(self, ser, hst, usr, pas, outF, title, VVM2wn):
  VVM2wn.VVqMKy(7)
  self._tDic = {"totL": 0, "totV": 0, "totS": 0, "addL": 0, "addV": 0, "addS": 0, "addEp": 0, "err": ""}
  lCat, vCat, sCat = {}, {}, {}
  srcs = ("Live", "VOD", "Series")
  catMode = [self.VVJlIE, self.VV58i3, self.VVkiMU]
  modes = [self.VVIqPb, self.VVhFEC, self.VVY3Xw]
  acts = ["get_live_streams", "get_vod_streams", "get_series"]
  if not ser: catMode, modes, acts = catMode[:2], modes[:2], acts[:2]
  url  = "%s/player_api.php?username=%s&password=%s" % (hst, usr, pas)
  catErr = ""
  for mode in catMode:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   lst, err = self.VVwWLb(mode, url=url, chkAdult=False)
   catErr = err or catErr
   if not lst: continue
   dic = {Id: nm for nm, Id, pId, num in lst}
   if dic:
    if  mode == self.VVJlIE  : lCat = dic
    elif mode == self.VV58i3  : vCat = dic
    elif mode == self.VVkiMU: sCat = dic
  cats = [lCat, vCat, sCat]
  if not ser: cats = cats[:2]
  if not any((lCat, vCat, sCat)):
   self._tDic["err"] = catErr or "Cannot read categories."
   return
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for mode, src, catLst, act in tuple(zip(modes, srcs, cats, acts)):
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVkdWG("Reading %s ..." % src)
    VVM2wn.VVwOHf(1)
    VVM2wn.VV75eC(0)
    txt, err = self.VVEL0f("%s&action=%s" % (url, act), timeout=20)
    if txt:
     lst, err = self.VVqDQU(mode, txt)
     if not lst: continue
    else:
     continue
    tot = len(lst)
    if  mode == self.VVIqPb : self._tDic["totL"] = tot
    elif mode == self.VVhFEC  : self._tDic["totV"] = tot
    elif mode == self.VVY3Xw : self._tDic["totS"] = tot
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVkdWG("Saving %s ..." % src)
    VVM2wn.VVFO1V(len(lst))
    VVM2wn.VV75eC(0)
    for row in lst:
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VVoreX(1)
     colList = list(map(str.strip, row))
     if mode in (self.VVIqPb, self.VVhFEC):
      if mode == self.VVIqPb:
       num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VV1CZl, direct_source = colList
       VVKCwZ, ext, uCat = stream_icon, "", ""
      elif mode == self.VVhFEC:
       num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
       VVKCwZ, ext, uCat = stream_icon, "." + container_extension, "movie/"
      catNm = catLst.get(category_id, "")
      catNm = (' group-title="%s"' % catLst[category_id]) if category_id in catLst else ""
      pUrl  = (' tvg-logo="%s"' % VVKCwZ) if VVKCwZ else ""
      chUrl = "%s/%s%s/%s/%s%s" % (hst, uCat, usr, pas, stream_id, ext)
      f.write('#EXTINF:-1%s%s,%s\n' % (catNm, pUrl, name))
      f.write("%s\n" % chUrl)
      if mode == self.VVIqPb : self._tDic["addL"] += 1
      elif mode == self.VVhFEC : self._tDic["addV"] += 1
     else:
      num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon = row
      seLst, err = self.VVDzuB(series_id, url=url)
      if not seLst: continue
      addSer = 0
      for ep in seLst:
       if not VVM2wn or VVM2wn.isCancelled: return
       seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = list(map(str.strip, ep))
       pUrl = (' tvg-logo="%s"' % cover) if cover else ""
       chUrl= "%s/series/%s/%s/%s.%s" % (hst, usr, pas, stream_id, container_extension)
       f.write('#EXTINF:-1 group-title="%s"%s,%s (SE%s:EP%s)\n' % (name, pUrl, name, seasonNum, episode_num))
       f.write("%s\n" % chUrl)
       if not VVM2wn or VVM2wn.isCancelled: return
       self._tDic["addEp"] += 1
       addSer = 1
      self._tDic["addS"] += addSer
 def VVuvjM(self, ser, outF, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  d = self._tDic
  totL, totV, totS, addL, addV, addS, addEp = d["totL"], d["totV"], d["totS"], d["addL"], d["addV"], d["addS"], d["addEp"]
  if VV9zbx: txt = ""
  else   : txt = "%s\n\n" % FFITtK("Process stopped.", VVCBkQ)
  if (addL + addV + addS + addEp) > 0:
   txt += "Added Live\t: %s%s\n" % (addL, (" of %s" % totL) if (addL != totL) else "")
   txt += "Added VOD\t: %s%s\n"  % (addV, (" of %s" % totV) if (addV != totV) else "")
   if ser: txt += "Added Series\t: %s%s  ( Episodes : %s )\n" % (addS, (" of %s" % totS) if (addS != totS) else "", addEp)
   if FFf0vs(outF): txt += "\n%s\n%s" % (FFITtK("Saved to:", VVnQYw), outF)
   FFyijw(self, txt, title)
  elif d["err"]:
   FFU9uk(self, d["err"], title)
   FFqlCI(outF)
  else:
   FFqlCI(outF)
 def VVmqXm(self, mode, isAll, VV5ybN, title, txt, colList):
  onlyCatID = None if isAll else colList[1]
  VVXXzc = []
  VVXXzc.append(("Keyboard"  , "manualEntry"))
  VVXXzc.append(("From Filter" , "fromFilter"))
  FFw2XU(self, BF(self.VVySgI, VV5ybN, mode, onlyCatID), title="Input Type", VVXXzc=VVXXzc, width=400)
 def VVySgI(self, VV5ybN, mode, onlyCatID, item=None):
  if item == "manualEntry":
   FFttdT(self, BF(self.VVP4wt, VV5ybN, mode, onlyCatID), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCrT1G(self)
   filterObj.VVMhxB(BF(self.VVP4wt, VV5ybN, mode, onlyCatID))
 def VVP4wt(self, VV5ybN, mode, onlyCatID, item):
  if not item is None:
   title = "Find in names"
   words = None
   toFind = item.strip()
   FFDDwF(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCrT1G.VVYDJw(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      FFU9uk(self, "Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        FFU9uk(self, "All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVyqRl(words):
      FFU9uk(self, self.VVbLG6(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCXRxc.VVJ9VK(self, VVmj1O="Searching for:%s" % toFind[:15], totBars=2
          , VVCJhW  = BF(self.VVDWJL, VV5ybN, mode, onlyCatID, title, words, toFind, asPrefix)
          , VVuQkS = BF(self.VVqvEi, mode, toFind, title))
   if not words:
    FF8PJn(VV5ybN, "Nothing to find !", 1500)
 def VVDWJL(self, VV5ybN, mode, onlyCatID, title, words, toFind, asPrefix, VVM2wn):
  VVM2wn.VVqMKy(VV5ybN.VVJPu5() if onlyCatID is None else 1)
  VVM2wn.VViN1g = []
  for row in VV5ybN.VVTq0J():
   catName = row[0]
   catID = row[1]
   if not onlyCatID is None and not catID == onlyCatID:
    continue
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   VVM2wn.VV75eC(0)
   VVM2wn.VVoScM(catName)
   qUrl = self.VVahPD(mode, self.VVJBt9["playListURL"], catID)
   txt, err= self.VVEL0f(qUrl, timeout=20)
   if not err:
    tList, err = self.VVqDQU(mode, txt)
    if tList:
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VVFO1V(len(tList))
     for item in tList:
      if not VVM2wn or VVM2wn.isCancelled: return
      VVM2wn.VVoreX(1)
      name = item[1].strip().lower()
      name = self.VVYPwG(name)
      if name:
       if asPrefix and not name.startswith(words) : continue
       elif any(x in name for x in words)   : pass
       else          : continue
       if not VVM2wn or VVM2wn.isCancelled:
        return
       VVM2wn.VViN1g.append(item)
       VVM2wn.VVoScM(catName)
 def VVqvEi(self, mode, toFind, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g:
   title = self.VVRTLv(mode, toFind)
   VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP(mode)
   if mode == self.VVIqPb or mode == self.VVhFEC:
    if mode == self.VVhFEC : typ = "v"
    else          : typ = ""
    bName   = CCSB3R.VVG2ts(toFind)
    VVI3Oq  = ("Play"     , BF(self.VVj6Ao, mode)     , [])
    VV5CrJ = ("Download Options" , BF(self.VV4mXe, mode, typ, "") , [])
    VVbQ6N = ("Options"   , BF(self.VVU0BK, "fnd", mode, bName), [])
    VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, False)   , [])
    VV4dTm = (""     , BF(self.VVt1Qo, mode)    , [])
   elif mode == self.VVY3Xw:
    VVVzvS, VVhHWW, VVpaQ6, VVI4UA = self.VVB7ZP("series2")
    VVI3Oq  = ("Show Seasons"  , BF(self.VVMfjq, mode)     , [])
    VVbQ6N = None
    VV5CrJ = None
    VVvrJb = ("Posters Mode"  , BF(self.VVmhAx, mode, True)    , [])
    VV4dTm = (""     , BF(self.VV55PJ, mode)   , [])
   VVEyDE  = ("Home Menu"   , FF9hlZ          , [])
   header, widths, VVgKQc = self.VV5wBo(mode)
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VViN1g, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV4dTm=VV4dTm, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA, VVrpeX=True, VVylFd=1)
   if not VV9zbx:
    FF8PJn(VV5ybN, "Stopped" , 1000)
  else:
   if VV9zbx:
    FFU9uk(self, "Not found in names !\n\n( %s )" % toFind, title=title)
 def VVxQwi(self, mode, colList):
  colList = list(map(str.strip, colList))
  if mode in (self.VVIqPb, self.VVCHxt):
   num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VV1CZl, direct_source = colList
   chNum, VVeZBd, catID, stID, VVKCwZ, ext, uCat = num, name, category_id, stream_id, stream_icon, "", ""
  elif mode == self.VVhFEC:
   num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
   chNum, VVeZBd, catID, stID, VVKCwZ, ext, uCat = num, name, category_id, stream_id, stream_icon, "." + container_extension, "movie/"
  else:
   seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = colList
   chNum, VVeZBd, catID, stID, VVKCwZ, ext, uCat = "222", epTitle, category_id, stream_id, icon, "." + container_extension, "series/"
  VVeZBd = FF2xYM(VVeZBd)
  url = self.VVJBt9["playListURL"]
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVBOAE(url)
  VVDhju = self.VV7RE0(catID, stID, chNum)
  chUrl = "%s%s%s/%s/%s%s"  % (uURL, uCat, uUser, uPass, stID, ext)
  chUrl = chUrl.replace(":", "%3a")
  chUrl = VVDhju + chUrl + ":" + VVeZBd
  return VVeZBd, chUrl, VVKCwZ, VVDhju
 def VVt1Qo(self, mode, VV5ybN, title, txt, colList):
  if mode in (self.VVIqPb, self.VVCHxt): catID = colList[2]
  elif mode == self.VVhFEC          : catID = colList[2]
  else                   : catID = colList[3]
  catName = self.VVHPL5.get(catID, "")
  if catName:
   txt = txt.strip() + "\nCategory\t: %s" % catName
  self.VVrTU7(mode, VV5ybN, title, txt, colList)
 @FFHF2S(par=2)
 def VVrTU7(self, mode, VV5ybN, title, txt, colList):
  VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, colList)
  txt = "%s\n\n%s" % (title, txt)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVez6E, params=(VVDhju, VVeZBd, txt, chUrl, VVKCwZ))
 @FFHF2S(par=2)
 def VV55PJ(self, mode, VV5ybN, title, txt, colList):
  name = colList[1]
  Dur  = colList[5]
  Cover = colList[7]
  txt  = "%s\n\n%s" % (title, txt)
  txt  += "Duration\t: %s" % Dur
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVf7U2, params=(name, txt, Cover))
 def VVmhAx(self, mode, isSerNames, VV5ybN, title, txt, colList):
  if mode == "m3u":
   nameCol, picCol, descCol, descTxt = 1, 4, 2, "Group"
  elif mode in ("itv", "vod", "series"):
   if isSerNames: nameCol, picCol, descCol, descTxt = 0, 12, 9, "Genre"
   else   : nameCol, picCol, descCol, descTxt = 1, 4 , 6, "Category/Genre"
  else:
   nameCol = 1
   if isSerNames         : picCol, descCol, descTxt = 7, 4, "Genre"
   elif mode == self.VVIqPb : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVCHxt : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVhFEC  : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVY3Xw : picCol, descCol, descTxt = 5, 0, "Season"
  FFTSvN(VV5ybN, BF(self.session.open, CCw9hJ, VV5ybN, self.VVoS8r(mode), nameCol, picCol, descCol, descTxt))
 @staticmethod
 def VVoS8r(mode):
  if   mode in ("itv", "live" , CCSB3R.VVIqPb, CCSB3R.VVCHxt): subD = "Live"
  elif mode in ("vod"   , CCSB3R.VVhFEC )          : subD = "VOD"
  elif mode in ("series"  , CCSB3R.VVY3Xw)          : subD = "Series"
  elif mode == "m3u"                       : subD = "M3U"
  else                          : subD = ""
  return FFA4GT(os.path.join(FFmAG5(), "Posters", subD))
 def VV4mXe(self, mode, typ, VVonh7, VV5ybN, title, txt, colList):
  VVXXzc = []
  isMulti = VV5ybN.VVbbT0
  tot  = VV5ybN.VVQrKf()
  if isMulti:
   if tot < 1:
    FF8PJn(VV5ybN, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFEnJs(tot)
  else:
   name = "ALL"
   plural = "s"
  txt = "PIcon" if mode in ("itv", CCSB3R.VVIqPb, CCSB3R.VVCHxt) else "Poster"
  VVXXzc.append(("Download %s %s%s" % (name, txt, plural)  , "dnldPicons" ))
  if typ:
   VVXXzc.append(VVzg1X)
   tName = "Movie" if typ.startswith("v") else "Episode"
   VVXXzc.append(("Download Current %s" % tName    , "dnldSel"  ))
   VVXXzc.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if typ.startswith("s"):
    VVXXzc.append(("Add All Episodes to Download List" , "addAllEp" ))
   if not CChTrx.VVnzW8():
    VVXXzc.append(VVzg1X)
    VVXXzc.append(("Download Manager"      , "dload_stat" ))
  FFw2XU(self, BF(self.VVEpzB, VV5ybN, mode, typ, VVonh7, colList), title="Download Options", VVXXzc=VVXXzc)
 def VVEpzB(self, VV5ybN, mode, typ, VVonh7, colList, item=None):
  if item:
   if   item == "dnldPicons" : self.VVp6vy(self, VV5ybN, mode)
   elif item == "dnldSel"  : self.VV54XL(VV5ybN, mode, typ, colList, True)
   elif item == "addSel"  : self.VV54XL(VV5ybN, mode, typ, colList, False)
   elif item == "addAllEp"  : self.VV2xf6(VV5ybN, mode, typ, VVonh7)
   elif item == "dload_stat" : CChTrx.VVWJLc(self, VV5ybN)
 @FFHF2S(par=1)
 def VV54XL(self, VV5ybN, mode, typ, colList, startDnld):
  VVeZBd, VVu69c = self.VVQTOV(mode, typ, colList)
  if startDnld:
   CChTrx.VVlexV(self, VVu69c)
  else:
   self.VV4glJ(VV5ybN, "Add to Download list", VVeZBd, [VVu69c], startDnld)
 def VV2xf6(self, VV5ybN, mode, typ, VVonh7):
  VVSOaj = []
  for row in VV5ybN.VVTq0J():
   VVeZBd, VVu69c = self.VVQTOV(mode, typ, row)
   VVSOaj.append(VVu69c)
  self.VV4glJ(VV5ybN, "Add to Download list", "%s\n\n( %d Episodes )" % (VVonh7, len(VVSOaj)), VVSOaj, False)
 def VV4glJ(self, VV5ybN, title, VVeZBd, VVSOaj, startDnld):
  FFHsPu(self, BF(self.VVQJJW, VV5ybN, VVSOaj, startDnld), VVeZBd, title=title)
 def VVQJJW(self, VV5ybN, VVSOaj, startDnld):
  added, skipped = CChTrx.VVogaa(VVSOaj)
  FF8PJn(VV5ybN, "Added", 1000)
 def VVQTOV(self, mode, typ, colList):
  if typ in ("v", "s"):
   VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, colList)
  elif typ in ("vp", "sp"):
   VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, colList)
   VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
  VVDhju, VVu69c, VVQwVu, VVLZ0Z = CCaZ62.VVXPhc(chUrl)
  return VVeZBd, VVu69c
 @staticmethod
 def VVp6vy(SELF, VV5ybN, mode):
  if FFsGnd("ffmpeg"):
   CCXRxc.VVJ9VK(SELF, VVmj1O="Downloading PIcons"
       , VVCJhW  = BF(CCSB3R.VVjPhs, SELF, VV5ybN, mode)
       , VVuQkS = BF(CCSB3R.VV7Ef9, SELF))
  else:
   FFHsPu(SELF, BF(CCSB3R.VVkD2h, SELF), '"FFmpeg" is required to resize the PIcons.\n\nInstall FFmpeg ?', title="Download all PIcons")
 @staticmethod
 def VVjPhs(SELF, VV5ybN, mode, VVM2wn):
  VVM2wn.VViN1g = {"total": 0, "threads": 0, "proces": 0, "badUrl": 0, "exist": 0, "attempt": 0, "ok": 0, "size0": 0, "fail": 0, "err": ""}
  VVUNvQ = set()
  pPath = CCUNc6.VVQ490()
  VVM2wn.VVkdWG("Collecting list ...")
  ndxLst = []
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   if not VV5ybN.VVbbT0 or VV5ybN.VVAkKb(ndx):
    ndxLst.append(ndx)
  if not VVM2wn or VVM2wn.isCancelled: return
  if ndxLst:
   VVM2wn.VViN1g["total"] = len(ndxLst)
   VVM2wn.VVqMKy(len(ndxLst))
   VVM2wn.VVSD3t(0)
  else:
   VVM2wn.VViN1g["err"] = "No valid URLs"
   return
  def VVeM58(VVKCwZ, picon):
   VVM2wn.VViN1g["threads"] += 1
   VVM2wn.VViN1g["attempt"] += 1
   path, err = FFEyUQ(VVKCwZ, picon, timeout=2, VVtOxO=True)
   if not VVM2wn or VVM2wn.isCancelled:
    FFqlCI(path)
   elif err:
    VVM2wn.VViN1g["fail"] += 1
    if any(x in err.lower() for x in ("time-out", "unauthorized")):
     VVM2wn.VViN1g["err"] = err.title()
   elif not path:
    pass
   elif FFX42v(path) == 0:
    VVM2wn.VViN1g["size0"] += 1
    FFqlCI(path)
   else:
    VVM2wn.VViN1g["ok"] += 1
    totOk = VVM2wn.VViN1g["ok"]
    VVM2wn.VVSD3t(totOk)
    cmd = CCISy5.VVomfz(path)
    cmd += FFDTPf("mv -f '%s' '%s'" % (path, pPath))
    FF6usE(cmd)
   if VVM2wn and not VVM2wn.isCancelled:
    VVM2wn.VViN1g["threads"] -= 1
  while ndxLst or VVM2wn.VViN1g["threads"] > 0:
   try:
    if not VVM2wn or VVM2wn.isCancelled : return
    elif VVM2wn.VViN1g["err"]   : return
    elif VVM2wn.VViN1g["threads"] >= 8: continue
    elif not ndxLst        : continue
   except:
    return
   row = VV5ybN.VVVB7s(ndxLst[0])
   ndxLst.pop(0)
   VVM2wn.VVwOHf(1)
   VVM2wn.VViN1g["proces"] += 1
   if mode in ("itv", "vod", "series"):
    VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = SELF.VVaK5d(mode, row)
    VVDhju = CCSB3R.VV7RE0(catID, stID, chNum)
   elif mode == "m3u":
    VVDhju, VVeZBd, chUrl, VVKCwZ, VVu69c, isMark = CCxgvM.VV6wA2(SELF, row)
   else:
    VVeZBd, chUrl, VVKCwZ, VVDhju = SELF.VVxQwi(mode, row)
   if not VVKCwZ:
    VVM2wn.VViN1g["badUrl"] += 1
    continue
   picon = VVDhju.replace(":", "_").rstrip("_") + ".png"
   if not VVM2wn or VVM2wn.isCancelled:
    return
   if FFf0vs(pPath + picon):
    VVM2wn.VViN1g["exist"] += 1
   elif not picon in VVUNvQ:
    VVUNvQ.add(picon)
    iThread(name="ajp_DnldPic", target=BF(VVeM58, VVKCwZ, picon)).start()
 @staticmethod
 def VV7Ef9(SELF, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  tDict = VViN1g
  txt  = ""
  txt += "Total Processed\t\t: %d of %d\n" % (tDict["proces"], tDict["total"])
  txt += "Download Success\t: %d of %s\n"  % (tDict["ok"], tDict["attempt"])
  txt += "Skipped (PIcon exist)\t: %d\n"  % tDict["exist"]
  txt += "Skipped (Size = 0)\t: %d\n"   % tDict["size0"]
  txt += "Incorrect PIcon URL\t: %d\n"  % tDict["badUrl"]
  txt += "Download Failure\t: %d\n"   % tDict["fail"]
  txt += "PIcons Path\t\t: %s\n"    % CCUNc6.VVQ490()
  if not VV9zbx: color = "#11402000"
  elif tDict["err"]: color = "#11201000"
  else    : color = "#22001122"
  if tDict["err"]:
   txt = "Critical Error\t\t: %s\n\n%s"  % (tDict["err"], txt)
  title = "PIcons Download Result"
  if not VV9zbx:
   title += "  (cancelled)"
  FFyijw(SELF, txt, title=title, VVpaQ6=color)
 @staticmethod
 def VVkD2h(SELF):
  cmd = FFiD2M(VVUWS4, "ffmpeg")
  if cmd : FFNQkI(SELF, cmd, title="Installing FFmpeg")
  else : FFD8hf(SELF)
 @staticmethod
 def VVeXRs(SELF):
  CCRnM6(SELF)
 @staticmethod
 def VVRTnq(chUrl, streamId, mode):
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCSB3R.VVBOAE(chUrl)
  qUrl = "%splayer_api.php?username=%s&password=%s&action=get_simple_data_table&stream_id=%s" % (uURL, uUser, uPass, streamId)
  txt, err = CCSB3R.VVEL0f(qUrl)
  if err : return "", err
  else : return CCSB3R.VVCHJ7(txt, mode=mode)
 @staticmethod
 def VVCHJ7(txt, mode):
  lst = []
  evLst = []
  try:
   tDict = jLoads(txt)
   for item in tDict["epg_listings"]:
    description = FFX7JA(item, "description"  , is_base64=True).replace("\n", " .. ")
    has_archive = FFX7JA(item, "has_archive"      )
    lang  = FFX7JA(item, "lang"        ).upper()
    now_playing = FFX7JA(item, "now_playing"      )
    tTitle  = FFX7JA(item, "title"   , is_base64=True)
    startServ = FFX7JA(item, "start"       )
    startT  = FFX7JA(item, "start_timestamp" , isDate=True )
    startTs  = FFX7JA(item, "start_timestamp"     )
    stopT  = FFX7JA(item, "stop_timestamp" , isDate=True )
    stopTs  = FFX7JA(item, "stop_timestamp"     )
    if mode == 0:
     if has_archive == "1":
      return True, ""
    elif mode == 1:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if has_archive == "1" or (startTs < iTime() and stopTs > iTime()):
       durMin = str((stopTs - startTs) // 60)
       durTm = FF79L2(stopTs - startTs)
       row = (startT[:-3], stopT[:-3], durTm, lang, tTitle, description, startServ, now_playing, durMin)
       if not row in lst:
        lst.append(row)
     except:
      pass
    elif mode == 2:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       shortDesc = ("Language : %s" % lang) if lang else ""
       lst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
    elif mode == 3:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       row = (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs)
       if not row in lst:
        lst.append(row)
        shortDesc = ("Language : %s" % lang) if lang else ""
        evLst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
  except:
   return "", "Cannot parse received data !"
  if   mode == 0: return False, ""
  elif mode == 1: return lst, ""
  elif mode == 2: return lst, ""
  elif mode == 3:
   sep = FFITtK("_" * 32 + "\n", VVgzFX)
   fg1, fg2, curTxt = VVHFlX, VVcahY, "    (CURRENT EVENT)"
   epg = ""
   for evNum, (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs) in enumerate(lst, start=1):
    if now_playing == "0": color, txt = fg1, ""
    else     : color, txt = fg2, curTxt
    epg += sep
    epg += FFITtK("Event\t: %d%s\n" % (evNum, txt), color)
    epg += "Title\t: %s\n"    % FFITtK(tTitle, VV6UAe)
    epg += "Start\t: %s\n"    % startT
    epg += "End\t: %s\n"    % stopT
    if lang   : epg += "Language\t: %s\n"  % lang
    if description : epg += "Description:\n%s\n" % FFITtK(description, VVVAvR)
   return epg, evLst, ""
  else:
   return lst, ""
 @staticmethod
 def VVgEQj(VVu69c):
  epg, evLst, err = "", [], ""
  if "mode=itv" in VVu69c:
   p, err = CCNREC.VVJX6y(VVu69c)
   if p:
    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
    if valid and stID:
     res, err = p.VVdce0(p.VVZXpW(stID))
     if res:
      epg, err = CCSB3R.VVPd4G(res.text, retLst=False)
      evLst, err = CCSB3R.VVPd4G(res.text, retLst=True)
      return epg, evLst, err
  else:
   data = CCSB3R.VV6RmU(VVu69c)
   if data:
    uHost, uUser, uPass, uId, VVeZBd = data
    if all((uHost, uUser, uPass, uId)):
     qUrl = "%s/player_api.php?username=%s&password=%s&action=get_short_epg&stream_id=%s" % (uHost, uUser, uPass, uId)
     txt, err = CCSB3R.VVEL0f(qUrl, timeout=3)
     if txt:
      epg, evLst, err = CCSB3R.VVCHJ7(txt, mode=3)
  return epg, evLst, err
 @staticmethod
 def VVPd4G(txt, retLst=False):
  epg = ""
  lst = []
  now = iTime()
  try:
   tDict = jLoads(txt)
   for item in tDict["js"]:
    actor = FFX7JA(item, "actor"       )
    cat  = FFX7JA(item, "category"       )
    descr = FFX7JA(item, "descr"   , is_base64=True).replace("\n", " .. ")
    director= FFX7JA(item, "director"       )
    name = FFX7JA(item, "name"    , is_base64=True)
    startT = FFX7JA(item, "start_timestamp" , isDate=True )
    startTs = FFX7JA(item, "start_timestamp"     )
    stopT = FFX7JA(item, "stop_timestamp" , isDate=True )
    stopTs = FFX7JA(item, "stop_timestamp"     )
    try:
     startTs, stopTs = int(startTs), int(stopTs)
     if stopTs > now:
      dur = stopTs - startTs
      row = (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur)
      if not row in lst:
       lst.append(row)
    except:
     pass
  except:
   return "", "Cannot parse received data !"
  if retLst:
   lst = [(startTs, dur, name, "", descr, 1) for (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur) in lst]
   return lst, ""
  else:
   sep  = FFITtK("_" * 32 + "\n", VVgzFX)
   curTxt = FFITtK("    (CURRENT EVENT)", VVnQYw)
   evNum = 1
   for actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur in lst:
    curEv = curTxt if (startTs < now and stopTs > now) else ""
    epg += sep
    epg += "Event\t: %d%s\n" % (evNum, curEv)
    epg += "Title\t: %s\n"  % FFITtK(name, VV6UAe)
    epg += "Start\t: %s\n"  % startT
    epg += "End\t: %s\n"  % stopT
    epg += "Description:\n%s\n" % FFITtK(descr , VVVAvR) if descr else "Description\t: - \n"
    epg += "Genre:\n%s\n"  % FFITtK(cat  , VVVAvR) if cat else ""
    epg += "Actors:\n%s\n"  % FFITtK(actor , VVVAvR) if actor else ""
    epg += "Director:\n%s\n" % FFITtK(director, VVVAvR) if director else ""
    evNum += 1
   return epg, ""
 @staticmethod
 def VVBQm9(txt):
  epg = movie_image = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   movie_image = FFX7JA(item, "movie_image" )
   genre  = FFX7JA(item, "genre"  )
   plot  = FFX7JA(item, "plot"   )
   country  = FFX7JA(item, "country"  )
   actors  = FFX7JA(item, "actors"  )
   cast  = FFX7JA(item, "cast"   )
   rating  = FFX7JA(item, "rating"  )
   director = FFX7JA(item, "director"  )
   releasedate = FFX7JA(item, "releasedate" )
   duration = FFX7JA(item, "duration"  )
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y and y != "-" else ""
   try:
    lang = FFX7JA(tDict["info"]["audio"]["tags"], "language")
    if lang:
     epg += tab("Language", lang.capitalize())
   except:
    pass
   epg += tab("Genre"  , genre)
   epg += tab("Released" , releasedate)
   epg += tab("Country" , country)
   epg += tab("Duration" , duration)
   epg += tab("Director" , director)
   epg += tab("Rating"  , rating)
   if cast or actors : epg += "Cast:\n%s\n\n" % FFITtK(cast or actors, VVVAvR)
   if plot    : epg += "Plot:\n%s"  % FFITtK(plot, VVVAvR)
  except Exception as e:
   err = str(e)
  return epg, movie_image, err
 @staticmethod
 def VVwOIV(txt, VVu69c):
  span = iSearch(r".+\/series\/.+\/.+\/(\d+)", VVu69c)
  epId = span.group(1) if span else ""
  epg = epSeason = epTitle = cover = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   cast  = FFX7JA(item, "cast"    )
   cover  = FFX7JA(item, "cover"   )
   director = FFX7JA(item, "director"   )
   genre  = FFX7JA(item, "genre"   )
   name  = FFX7JA(item, "name"    )
   plot  = FFX7JA(item, "plot"    )
   if epId:
    for sName, ep in tDict["episodes"].items():
     for item in ep:
      Id   = FFX7JA(item, "id"     )
      season  = FFX7JA(item, "season"    )
      Title  = FFX7JA(item, "title"    )
      if Id  == epId:
       epSeason, epTitle = season, Title
       break
     if epSeason or epTitle:
      break
   ttl = lambda x, y: "\n%s:\n%s\n\n" % (FFITtK(x, VV6UAe), str(y)) if y else ""
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y else ""
   epg =  tab("Season"  , epSeason)
   epg += tab("Title"  , epTitle)
   epg += tab("Name"  , name)
   epg += tab("Genre"  , genre)
   epg += tab("Director" , director)
   epg += ttl("Cast"  , cast)
   epg += ttl("Plot"  , plot)
  except Exception as e:
   err = str(e)
  return epg, cover, err
 @staticmethod
 def VV7RE0(catID, stID, chNum):
  MAX_4b = 65535
  MAX_8b = 4294967295
  SID  = CCSB3R.VV4HBS(catID, MAX_4b)
  TSID = CCSB3R.VV4HBS(chNum, MAX_4b)
  ONID = CCSB3R.VV4HBS(chNum, MAX_4b)
  NS  = CCSB3R.VV4HBS(stID, MAX_8b)
  if len(NS) == 4:
   NS = "1" + NS
  rType = CFG.iptvAddToBouquetRefType.getValue()
  return "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, TSID, ONID, NS)
 @staticmethod
 def VV4HBS(numStr, limit):
  if numStr.isdigit():
   i = int(numStr)
   if i > limit:
    i = limit
   return (hex(i))[2:].upper()
  else:
   return "222"
 @staticmethod
 def VVG2ts(txt):
  txt = iSub(iCompile(r'\W'), "_", txt)
  txt = FF7h5n(txt, "_")
  return "Bouquet" if txt == "_" else txt
 @staticmethod
 def VVB7ZP(mode):
  if   mode in ("itv"  , CCSB3R.VVJlIE)  : return "#0a21303C", "#0a21303C", "#0a21303C", "#00005566"
  elif mode in ("vod"  , CCSB3R.VV58i3)  : return "#1a260518", "#1a260518", "#1a260518", "#04224040"
  elif mode in ("series" , CCSB3R.VVkiMU) : return "#1a36013F", "#1a26012F", "#1a26012F", "#04224040"
  elif mode in ("catchup" , CCSB3R.VVC8z8) : return "#0a213044", "#0a213044", "#0a21303C", "#04224040"
  elif mode == CCSB3R.VVCHxt    : return "#0a202020", "#0a202020", "#0a202020", "#04663366"
  elif mode == "catchupEv"           : return "#0a00191B", "#0a001116", "#0a001116", "#00553344"
  elif mode == "series2"            : return "#0a462538", "#0a462538", "#0a462538", "#04224040"
  else                : return "#0a00292B", "#0a002126", "#0a002126", "#00005566"
 @staticmethod
 @FFHF2S("Reading ...")
 def VVdW5y(SELF, hostUrl, VVeZBd, streamId, ok_fnc, rst_fnc=None):
  pList, err = CCSB3R.VVRTnq(hostUrl, streamId, mode=1)
  title = "Catch-up TV Programs"
  if err:
   FFU9uk(SELF, "Server Error:\n\n%s" % err, title=title)
   return
  elif not pList:
   FFU9uk(SELF, "No Programs from server", title=title)
   return
  pList.sort(key=lambda x: x[0], reverse=True)
  grnSTime = ""
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(SELF)
  span = iSearch(r"(\d{4}-\d{2}-\d{2}):(\d{2})-(\d{2})", VVu69c)
  if span : sTime = span.group(1) + " " + span.group(2) + ":" + span.group(3)
  else : sTime = ""
  grn = False
  for ndx, row in enumerate(pList):
   if sTime in row[6] and row[4] in VVeZBd:
    pList[ndx] = tuple(["#f#0055ff55#" + x for x in row])
    grnSTime = row[6]
   elif row[7] == "1":
    pList[ndx] = tuple(["#f#00ffff00#" + x for x in row])
    grnSTime = row[6]
  span = iSearch(r"(.+)\/timeshift(\/.+\/.+)\/.+\/.+(\/.+)\.ts(.+)\s>>", VVDhju + ":" + VVQwVu, IGNORECASE)
  chUrl = "".join(span.groups()) if span else ""
  def VVbzuW(VV5ybN, title, txt, colList):
   FF5deK(SELF.session, chUrl)
   VV5ybN.cancel()
   if rst_fnc: rst_fnc()
  def VVQKRk(VV5ybN, title, txt, colList):
   VV5ybN.VVp9iQ(6, grnSTime, VVqUOx=True)
  title = "Programs for : " + FFITtK(VVeZBd, VVnQYw)
  VVVzvS, VVhHWW, VVpaQ6, VVI4UA = CCSB3R.VVB7ZP("catchupEv")
  VV5CrJ = ("Current Event" , VVQKRk , []) if grnSTime else None
  VVbQ6N = ("Play Latest" , VVbzuW , []) if chUrl else None
  VVI3Oq  = ("Play"  , ok_fnc  , [])
  header   = ("Start" , "End" , "Duration", "Lang", "Title" , "Description" , "sTime" , "Playing" , "DurMin" )
  widths   = (16  , 16 , 9   , 6  , 30  , 23   , 0   , 0   , 0   )
  VVgKQc  = (CENTER , CENTER, CENTER , CENTER, LEFT  , LEFT   , CENTER , CENTER , CENTER )
  FFdCaM(SELF, None, title=title, header=header, VV5dDF=pList, VVgKQc=VVgKQc, VV1PTZ=widths, width=1800, height=950, VV1Wwb=24, VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVI4UA=VVI4UA)
 @staticmethod
 def VV3BSK(rUrl, fPath):
  fPath = fPath.strip()
  if fPath.startswith("http://"):
   return fPath
  elif fPath.startswith("/"):
   try:
    res = iUrlparse(rUrl)
    scheme = res.scheme
    netloc = res.netloc
    if scheme and netloc:
     host = "%s://%s" % (scheme, netloc)
     return os.path.join(host, fPath.lstrip("/"))
   except:
    pass
   return ""
  else:
   baseUrl = os.path.dirname(rUrl).strip()
   fName = os.path.basename(rUrl).strip()
   return os.path.join(baseUrl, fPath)
 def VVFU3m(self, isPortal, line, selectionObj, item):
  title = "Add server to IPTV Menu (for easy access)"
  if isPortal : typ, confItem = "Portal" , CFG.favServerPortal
  else  : typ, confItem = "Playlist", CFG.favServerPlaylist
  rmTxt = "Removed from IPTV Menu."
  svTxt = 'Added to IPTV Menu.\n\nWill be shown as "%s"' % FFITtK("Favourite %s Server" % typ, VV8QGw)
  cur = confItem.getValue().strip().replace("\t", "\n")
  if cur == line.strip():
   FFHsPu(self, BF(self.VVrYzU, title, rmTxt, typ, confItem, ""), "Already in IPTV Menu !\n\nRemove ?", title=title)
  elif cur:
   FFHsPu(self, BF(self.VVrYzU, title, svTxt, typ, confItem, line), "Replace current favourite item ?\n\n%s" % ((cur[:60] + "..") if len(cur) > 60 else cur), title=title)
  else:
   self.VVrYzU(title, svTxt, typ, confItem, line)
 def VVrYzU(self, title, txt, typ, confItem, line):
  FFDDwF(confItem, line)
  FFSQn9(self, txt, title=title)
 def VVnEet(self, isPortal):
  if isPortal:
   span = iSearch(r"(.+)\s((?:[A-Fa-f0-9]+:){5}.+[A-Fa-f0-9]+)", CFG.favServerPortal.getValue(), IGNORECASE)
   if span:
    self.VVVYLv(self, span.group(1), span.group(2))
    return
  else:
   span = iSearch(r"(http.+\/\/.+\/.+username=.+&password=.+)", CFG.favServerPlaylist.getValue(), IGNORECASE)
   if span:
    self.VVSgqw(self, "Favourite Playlist Server", span.group(1))
    return
  FFU9uk(self, "Incorrect server data !")
 @staticmethod
 def VVTaN9(SELF, isPortal, line, selectionObj, item):
  path = FFY5i9()
  if isPortal : path += "Portal_Bookmarks.txt"
  else  : path += "Playlist_Bookmarks.txt"
  title = "Bookmark Current Server"
  try:
   if FFf0vs(path):
    with ioOpen(path, "r", encoding="utf-8") as f:
     for fLine in f:
      if str(line) in str(fLine):
       FFU9uk(SELF, "Already added to file:\n\n%s" % path, title=title)
       return
   with open(path, "a") as f:
    f.write(line + "\n")
   FFSQn9(SELF, "Added to file:\n\n%s" % path, title=title)
  except Exception as e:
   FFU9uk(SELF, "Error:\n\n%s" % str(e), title=title)
 def VVU0BK(self, source, mode, VVCx62, VV5ybN, title, txt, colList):
  isMulti = VV5ybN.VVbbT0
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VV5ybN.VVQrKf()
   totTxt = "%d Service%s" % (tot, FFEnJs(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFITtK(totTxt, VV6UAe)
  VVCx622 = ""
  if self.VVmrz9:
   name = iUrlparse(self.VVmrz9).netloc
   if name:
    VVCx622 = "%s (%s)" % (VVCx62, name.split(":")[0])
  mSel = CCZALl(self, VV5ybN, addSep=False, setsOk=True, setsBlue=True)
  VVXXzc, cbFncDict = [], None
  VVXXzc.append(VVzg1X)
  if itemsOK:
   title = "Add to Bouquet"
   thTxt = "Adding Services ..."
   VVXXzc.append(("Add %s to New Bouquet : %s"    % (totTxt, FFITtK(VVCx62 , VV8QGw)), "addToCur1"))
   if VVCx622: VVXXzc.append(("Add %s to New Bouquet : %s" % (totTxt, FFITtK(VVCx622, VVi4ay)) , "addToCur2"))
   VVXXzc.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Save %s to M3U File" % (totTxt), "toM3u" ))
   cbFncDict = { "addToCur1": BF(self.VVTstj, source, mode, VVCx62 , VV5ybN, title)
      , "addToCur2": BF(self.VVTstj, source, mode, VVCx622, VV5ybN, title)
      , "toM3u"  : BF(self.VVI5TS   , source, mode, VVCx622, VV5ybN, "Save to M3U File")
      , "addToNew" : BF(self.VV488l, source, mode, VVCx62, VV5ybN, title)
      }
  else:
   VVXXzc.append(("Add to Bouquet (nothing selected)", ))
  mSel.VVejOk(VVXXzc, cbFncDict, width=1400)
 @FFHF2S("Adding Services ...", par=4)
 def VVTstj(self, source, mode, VVCx62, VV5ybN, Title):
  chUrlLst = self.VVo8xC(source, mode, VV5ybN)
  CC41Tt.VVsLIN(self, Title, VVCx62, "", chUrlLst)
 def VV488l(self, source, mode, VVCx62, VV5ybN, Title):
  picker = CC41Tt(self, VV5ybN, Title, BF(self.VVo8xC, source, mode, VV5ybN), VVJ2id=VVCx62)
 def VVo8xC(self, source, mode, VV5ybN):
  isMulti = VV5ybN.VVbbT0
  chUrlLst = []
  rowNum = 0
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   if not isMulti or VV5ybN.VVAkKb(ndx):
    chUrl = VVeZBd = ""
    if source in ("pEp", "pCh"):
     VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, row)
     VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
    elif source in ("lv", "v", "s", "fnd"):
     VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, row)
    if chUrl and VVeZBd:
     chUrlLst.append(chUrl)
  return chUrlLst
 @FFHF2S("Adding Services ...", par=4)
 def VVI5TS(self, source, mode, VVCx62, VV5ybN, Title):
  chUrlLst = []
  outF = "%s%s_%s.m3u" % (FFY5i9(), FF80BW(VVCx62), FF6eWd())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for ndx, row in enumerate(VV5ybN.VVTq0J()):
    if not VV5ybN.VVbbT0 or VV5ybN.VVAkKb(ndx):
     chUrl = VVeZBd = ""
     if source in ("pEp", "pCh"):
      VVeZBd, catID, stID, chNum, chCm, serCode, serId, VVKCwZ = self.VVaK5d(mode, row)
      VVDhju, chUrl = self.VVfwKQ(self.VVD5zt, self.VV0Iab, mode, VVeZBd, catID, stID, chNum, chCm, serCode, serId)
     elif source in ("lv", "v", "s", "fnd"):
      VVeZBd, chUrl, VVKCwZ, VVDhju = self.VVxQwi(mode, row)
     if VVeZBd and chUrl:
      chR = chUrl.replace(":" + VVeZBd, "").strip()
      span = iSearch(r'^(?:[A-Fa-f0-9]+:){10}(.*)', chR, IGNORECASE)
      if span:
       totCh += 1
       pUrl = (' tvg-logo="%s"' % VVKCwZ) if VVKCwZ else ""
       f.write('#EXTINF:-1 group-title="%s"%s,%s\n' % (VVCx62, pUrl, VVeZBd))
       f.write("%s\n" % FF0rS9(span.group(1)))
  if totCh:
   FFSQn9(self, "Exported %s Channel%s to:\n\n%s" % (totCh, FFEnJs(totCh), outF), title=Title)
  else:
   FFU9uk(self, "Nothing to save.", title=Title)
   FFqlCI(outF)
 @staticmethod
 def VVsg7z():
  return {"1": "DVB Stream", "4097": "ServiceMp3", "5001": "GST Player", "5002": "ExtEPlayer3", "8192": "HDMI input", "8193": "eServiceUri", "8793": "ServiceUrl"}
 @staticmethod
 def VV0JA5():
  return sorted(tuple(CCSB3R.VVsg7z()))
 @staticmethod
 def VVUGUR(rt):
  return CCSB3R.VVsg7z().get(str(rt), "")
 @staticmethod
 def VVJXHo(VVDhju):
  span = iSearch(r"(?:([A-Fa-f0-9]+):){1}(?:[A-Fa-f0-9]+:){8}", VVDhju)
  return span.group(1) if span else ""
 @staticmethod
 def VVKwA7(VVDhju):
  return CCSB3R.VVUGUR(CCSB3R.VVJXHo(VVDhju))
 @staticmethod
 def VV25ja(rt):
  if   rt == "1"  : return True
  elif rt == "4097": return True
  elif rt == "5001": return FFf0vs("/usr/bin/gstplayer") or FFf0vs("/usr/bin/gstplayer_gst-1.0")
  elif rt == "5002": return FFf0vs("/usr/bin/exteplayer3")
  elif rt == "8192": return False
  elif rt == "8193": return FFf0vs("/usr/bin/apt-get")
  elif rt == "8793": return FFf0vs("/usr/bin/apt-get")
  else    : return False
 @staticmethod
 def VVb38U(SELF, cbFnc):
  def VVNyo4(rt, selectionObj, item):
   FFHsPu(SELF, BF(VVfhX5, rt, selectionObj), "Save as Default Player ?", title="Current Player : %s (%s)" % (rt, CCSB3R.VVUGUR(rt)))
  def VVfhX5(rt, selectionObj):
   FFDDwF(CFG.iptvAddToBouquetRefType, rt)
   selectionObj.cancel()
   FFar20(SELF, "Saved", 800)
  curRt = CCaZ62(SELF.session).refType
  defRt = CFG.iptvAddToBouquetRefType.getValue()
  VVXXzc = []
  for ndx, rt in enumerate(CCSB3R.VV0JA5()):
   if   rt == curRt: color, txt = VV6UAe, "(Current)"
   elif rt == defRt: color, txt = VVkLs0, "(Default)"
   else   : color = txt = ""
   VVXXzc.append(FFwjWO("%s\t%s %s" % (CCSB3R.VVUGUR(rt), rt, txt), rt, CCSB3R.VV25ja(rt), color))
   if ndx < 4 and ndx % 2: VVXXzc.append(VVzg1X)
  VVI6TY = ("Save", BF(VVNyo4, curRt)) if curRt != defRt else None
  FFw2XU(SELF, cbFnc, VVXXzc=VVXXzc, width=700, title="Select Player", VVI6TY=VVI6TY, VVVzvS="#11220000", VVhHWW="#11220000")
 @staticmethod
 def VVmpeB(VVu69c):
  if not FFOr4F(VVu69c) and iMatch(r"(.+)(?:(?:\/live)*|\/movie|\/series)\/(.+)\/(.+)\/(.+):(.+)", VVu69c):
   return True
  else:
   return bool(CCSB3R.VV6RmU(VVu69c))
 @staticmethod
 def VV6RmU(VVu69c):
  if "/timeshift/" in VVu69c:
   span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/.+\/.+\/(.+)\.ts:(.+)(?:\s>>)?", VVu69c)
   if span and all(span.groups()): return span.groups()
  else:
   span = iSearch(r"(.+)\/(.+)\/(.+)\/(\d+):(.+)", VVu69c)
   if span and all(span.groups()):
    return span.groups()
   elif "chCode" in VVu69c:
    span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+&end=:(.+)", VVu69c)
    if span and all(span.groups()):
     return span.groups()
  return None
 @staticmethod
 def VVmGzj():
  return "Mozilla/5.0 (U; Linux; C; Emulator/1.2.12) AppleWebKit/533.3 (KHTML, like Gecko) Safari/533.3"
 @staticmethod
 def VVY3r9():
  return { 'User-Agent': CCSB3R.VVmGzj() }
class CCRuGd(object):
 def __init__(self, SELF):
  SELF["mySbFrm"] = Label()
  SELF["mySbBak"] = Label()
  SELF["mySbSld"] = Label()
  self.frm, self.bak, self.sld = SELF["mySbFrm"], SELF["mySbBak"], SELF["mySbSld"]
  self.frmI = self.bakI = self.sldI = None
  self.sldX = self.sldY = self.sldW = self.sldH = 0
  for obj in (self.frm, self.bak, self.sld): obj.hide()
 def VVyPvk(self, x, y, w, h, bW=1, frmColor="#11aaaaaa", bakColor="#11003344", sldColor="#11ff8000"):
  x, y, w, h = int(x), int(y), int(w), int(h)
  FFu0W6(self.frm, frmColor)
  FFu0W6(self.bak, bakColor)
  FFu0W6(self.sld, sldColor)
  self.frmI, self.bakI, self.sldI = self.frm.instance, self.bak.instance, self.sld.instance
  self.frmI.move(ePoint(x, y))
  self.frmI.resize(eSize(w, h))
  self.bakI.move(ePoint(x + bW, y + bW))
  self.bakI.resize(eSize(w - bW * 2, h - bW * 2))
  self.sldX = x + bW
  self.sldY = y + bW
  self.sldW = w - bW * 2
  self.sldH = h - bW * 2
  self.sldI.move(ePoint(self.sldX, self.sldY))
  self.sldI.resize(eSize(self.sldW, self.sldH))
 def VVlYhw(self, val, maxN):
  if maxN < 2:
   for obj in (self.frm, self.bak, self.sld): obj.hide()
  else:
   for obj in (self.frm, self.bak, self.sld): obj.show()
   visH = max(self.sldH / maxN, self.sldH * 0.05)
   self.sldI.resize(eSize(self.sldW, int(visH)))
   y = FFPSde(val, 1, maxN, 0, self.sldH - visH)
   self.sldI.move(ePoint(self.sldX, int(self.sldY + y)))
class CCofSh(CCRuGd):
 def __init__(self, VVqkBb=""):
  self.VVRQlw  = self.VVuaAL["VVZ5LV"]["rows"]
  self.VVwnUG  = self.VVuaAL["VVZ5LV"]["cols"]
  self.VVqdrD  = self.VVRQlw * self.VVwnUG
  self.VVqkBb  = VVqkBb
  self.VVj06Q  = self.VVuaAL["VVZ5LV"].get("percBar", 0)
  self.VVFM7Z  = 0
  self.VVvADQ  = 0
  self.VVZqoj  = 0
  self.curRow   = 0
  self.curCol   = 0
  self.VVlBZZ  = 0
  self.VVAlFM  = 0
  self.VVZeeA  = 0
  self.VVW4YW  = 0
  self.VVq1GA   = False
  self.VVDveF   = {}
  self.VVGWmt  = None
  self.VVE9w5  = {}
  self.VVrH8l  = 0
  self.VVXbPe  = 0
  self.VVkgKR  = ""
  self.VVf2q6 = True
  self.VVkuAn = False
  CCRuGd.__init__(self, self)
  self["myCursorLbl"]  = Label()
  self["myCursorPic"]  = Pixmap()
  self["myPiconF"]  = Label()
  self["myPiconBG"]  = Label()
  self["myPiconPic"]  = Pixmap()
  self["myPiconF"].hide()
  self["myPiconBG"].hide()
  self["myPiconPic"].hide()
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    self["myPosterBak%d%d" % (row, col)] = Pixmap()
    self["myPosterRep%d%d" % (row, col)] = Label()
    self["myPosterPic%d%d" % (row, col)] = Pixmap()
    self["myPosterPic%d%d" % (row, col)].hide()
    self["myPosterBak%d%d" % (row, col)].hide()
    self["myPosterLbl%d%d" % (row, col)] = Label()
    self["myPosterLbl%d%d" % (row, col)].hide()
    if self.VVj06Q:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)] = Label()
      self[nm + "%d%d" % (row, col)].hide()
  self.VVbfZP()
  VVNGHW, boxT, boxW, boxH, infT, infH, totInf, bGap = self.VVuaAL["retPar"]
  for i in range(totInf):
   self["myPiconInf%d" % i] = Label()
  FFewq4(self,
  {
   "up"  : self.VVY6L2   ,
   "down"  : self.VVgn7U  ,
   "left"  : self.VVT8GX  ,
   "right"  : self.VVMljc  ,
   "next"  : self.VVNZhV ,
   "last"  : self.VVeXT6  ,
   "pageUp" : self.VVeXT6  ,
   "chanUp" : self.VVeXT6  ,
   "pageDown" : self.VVNZhV ,
   "chanDown" : self.VVNZhV ,
   "0"   : self.VVbcNU
  })
 def VV5IQC(self, sbDim=None, sbFrmW=1, sbFrmColor="#11aaaaaa", sbBg="#11003344", sbSldBg="#11ff8000", shade="", cursor="#00ffff55"):
  self.VVrTYZ(shade)
  if cursor == "swap" : self.VVkuAn = True
  else    : self.VV7yvY(cursor)
  self.VV8I7a()
  self["myPiconPic"].instance.setScale(1)
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    self["myPosterPic%d%d" % (row, col)].instance.setScale(1)
    sz = self["myPosterPic%d%d" % (row, col)].instance.size()
    pos= self["myPosterPic%d%d" % (row, col)].instance.position()
    self.VVDveF[(row, col)] = ((pos.x(), pos.y()))
    self.VVGWmt = (sz.width(), sz.height())
  gap = int(self.VVuaAL["VVNGHW"] / 1)
  topBox = self["myPosterPic%d%d" % (0, 0)].instance
  sz = topBox.size()
  self.VVrH8l = sz.width()
  self.VVXbPe = sz.height()
  boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVuaAL["retPar"]
  if sbDim:
   x, y, w, h = sbDim
  elif self.VVuaAL["VVZ5LV"].get("upSBar", False):
   x, y, w, h = self.VVuaAL["width"] - 22, self.VVuaAL["titleH"] + 8, 15, infH - 12
  else:
   w = 20
   y = infT + infH + 3
   h = self.VVuaAL["height"] - self.VVuaAL["VVZ3ZU"] - y - 2
   x = self.VVuaAL["width"] - w - 2
  self.VVyPvk(x, y, w, h, bW=sbFrmW, frmColor=sbFrmColor, bakColor=sbBg, sldColor=sbSldBg)
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    FFiZTW(self["myPosterLbl%d%d" % (row, col)], "#000000", 2)
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
 def VVrTYZ(self, val):
  self.VVkgKR = val
  if val:
   p = CCHa3c.VVR0sK(self["myPosterBak00"], val, toPng=True) or VV30Jg + "frm2.png"
   png = FF0T82(p)
  else:
   png = None
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    pic = self["myPosterBak%d%d" % (row, col)]
    pic.instance.setPixmap(png)
    pic.instance.invalidate()
    if self.VVkgKR:
     pic.show()
 def VV7yvY(self, cursor):
  if not cursor or cursor.startswith("/"):
   self["myCursorLbl"].hide()
   self["myCursorPic"].show()
   FFbO0w(self["myCursorPic"], cursor if FFf0vs(cursor) else VV30Jg + "frm1.png")
  else:
   self.VVf2q6 = False
   self["myCursorPic"].hide()
   self["myCursorLbl"].show()
   if iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", cursor):
    FFu0W6(self["myCursorLbl"], cursor)
 def VVcP1n(self):
  if not self.VVGWmt:
   return
  normC, cursC = "#00444444", "#00ffff00"
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    ndx = self.VVeJc6(row, col)
    picInst = self["myPosterPic%d%d" % (row, col)].instance
    cursInst = self["myCursorPic"].instance
    cPos, cSz = cursInst.position(), cursInst.size()
    if (row, col) == (self.curRow, self.curCol):
     x, y, w, h = cPos.x(), cPos.y(), cSz.width(), cSz.height()
     if ndx in self.VVE9w5:
      _, y, w1, h1 = self.VVE9w5[ndx]
      _, _, w, h = self.VVKT8T(w1, h1, w, h)
      x, w = x + 6, w - 12
      self["myCursorPic"].show()
      cursInst.setBorderColor(parseColor(cursC))
      cursInst.setBorderWidth(4)
     else:
      picInst.setBorderColor(parseColor(cursC))
      picInst.setBorderWidth(4)
    elif ndx in self.VVE9w5:
     x, y, w, h = self.VVE9w5[ndx]
    else:
     (x, y), (w, h) = self.VVDveF[(row, col)], self.VVGWmt
     if self.VVAlFM == self.VVeJc6(row, col):
      picInst.setBorderColor(parseColor(normC))
      picInst.setBorderWidth(1)
    picInst.move(ePoint(x, y))
    picInst.resize(eSize(*(w, h)))
 def VVLBdY(self, ndx, row, col, pic, path, reset=False):
  inst = pic.instance
  if reset:
   if (row, col) == (self.curRow, self.curCol):
    curs = self["myCursorPic"].instance
    cPos, cSz = curs.position(), curs.size()
    boxX, boxY, boxW, boxH = cPos.x(), cPos.y(), cSz.width(), cSz.height()
   else:
    (boxX, boxY), (boxW, boxH) = self.VVDveF[(row, col)], self.VVGWmt
   if ndx in self.VVE9w5:
    del self.VVE9w5[ndx]
  else:
   boxX, boxY = self.VVDveF[(row, col)]
   boxW, boxH = self.VVGWmt
  png = FF0T82(path) or FF0T82(VV30Jg + "noPic.png")
  if png:
   inst.setBorderWidth(0)
  else:
   inst.setBorderColor(parseColor("#00ff8055"))
   inst.setBorderWidth(2)
   return False
  pngSz = png.size()
  pngW, pngH = pngSz.width(), pngSz.height()
  inst.setPixmap(png)
  if (pngW > pngH and boxH > boxW) or (pngH > pngW and boxW > boxH) or (pngW == pngH and boxW != boxH):
   x, y, w, h = CCofSh.VVKT8T(pngW, pngH, boxW, boxH)
   x += boxX
   y += boxY
   self.VVE9w5[ndx] = (x, y, w, h)
  else:
   x, y, w, h = boxX, boxY, boxW, boxH
   inst.setBorderColor(parseColor("#00444444"))
   inst.setBorderWidth(1)
  inst.resize(eSize(*(w, h)))
  inst.move(ePoint(x, y))
  return True
 def VV0akf(self, colors):
  for i, (fg, bg) in enumerate(colors):
   if fg: FFcfsH(self["myPiconInf%d" % i], fg)
   if bg: FFu0W6(self["myPiconInf%d" % i], bg)
 def VVDVSE(self, inf0, inf1):
  self["myPiconInf0"].setText("  %s  " % inf0 )
  self["myPiconInf1"].setText("   %s   " % inf1)
  self["myPiconInf2"].setText("Num. : %d / %d" % (self.VVlBZZ + 1, self.VVFM7Z))
  self["myPiconInf3"].setText("Page: %d / %d"  % (self.VVZqoj  + 1, self.VVvADQ))
 def VVOJsy(self):
  f1 = self.VVZqoj * self.VVqdrD
  f2 = f1 + self.VVqdrD
  if f1 > self.VVFM7Z: f1 = self.VVFM7Z
  if f2 > self.VVFM7Z: f2 = self.VVFM7Z
  return f1, f2
 def VVY6L2(self):
  if self.VVZqoj == self.curRow == self.curCol == 0:
   self.VVEqam()
  else:
   if self.VVZqoj == 0 and self.curRow == 0: self.curCol = 0
   else          : self.curRow -= 1
   self.VVeRhA()
 def VVgn7U(self):
  if self.VVZqoj == self.VVvADQ - 1 and self.curRow == self.VVZeeA and self.curCol == self.VVW4YW:
   self.VVC7oq()
  else:
   if self.VVZqoj == self.VVvADQ - 1 and self.curRow == self.VVZeeA:
    self.curCol = self.VVW4YW
   else:
    self.curRow += 1
   self.VVeRhA()
 def VVT8GX(self):
  if self.VVZqoj == self.curRow == self.curCol == 0:
   self.VVEqam()
  else:
   self.curCol -= 1
   self.VVeRhA()
 def VVMljc(self):
  if self.VVZqoj == self.VVvADQ - 1 and self.curRow == self.VVZeeA and self.curCol == self.VVW4YW:
   self.VVC7oq()
  else:
   self.curCol += 1
   self.VVeRhA()
 def VVeXT6(self):
  oldPage = self.VVZqoj
  if self.VVZqoj == 0:
   self.curRow = 0
   self.curCol = 0
  else:
   self.VVZqoj -= 1
  self.VVeRhA(oldPage != self.VVZqoj)
 def VVNZhV(self):
  oldPage = self.VVZqoj
  if self.VVZqoj == self.VVvADQ - 1:
   self.curRow = self.VVZeeA
   self.curCol = self.VVW4YW
  else:
   self.VVZqoj += 1
  self.VVeRhA(oldPage != self.VVZqoj)
 def VVbcNU(self):
  if self.VVlBZZ == 0: self.VVEqam()
  else     : self.VVC7oq()
 def VVC7oq(self):
  force = self.VVZqoj != 0
  self.curRow  = 0
  self.curCol  = 0
  self.VVZqoj = 0
  self.VVeRhA(force)
 def VVEqam(self):
  force = self.VVZqoj != self.VVvADQ - 1
  self.VVZqoj = self.VVvADQ - 1
  self.curRow  = (self.VVRQlw - 1)
  self.curCol  = (self.VVwnUG - 1)
  self.VVeRhA(force)
 def VVeRhA(self, force=False):
  if self.VVq1GA:
   return
  oldPage = self.VVZqoj
  if self.curCol > self.VVwnUG - 1:
   self.curCol = 0
   self.curRow += 1
  elif self.curCol < 0:
   self.curCol = self.VVwnUG - 1
   self.curRow -= 1
  if self.curRow > self.VVRQlw - 1:
   self.curRow = 0
   self.VVZqoj += 1
  elif self.curRow < 0:
   self.curRow = self.VVRQlw - 1
   self.VVZqoj -= 1
  VV1AjE = self.VVvADQ -1
  if   self.VVZqoj < 0  : self.VVZqoj = 0
  elif self.VVZqoj > VV1AjE: self.VVZqoj = VV1AjE
  if self.curRow > self.VVRQlw - 1: self.curRow = self.VVRQlw - 1
  if self.curCol < 0     : self.curCol = 0
  self.VVHjFJ()
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
  self.VVlYhw(self.VVZqoj + 1, self.VVvADQ)
  FFDiNL(BF(self.VVm9zK, force or not oldPage == self.VVZqoj, VV1AjE))
 def VVm9zK(self, force, VV1AjE):
  try:
   if force:
    self.VVE9w5 = {}
    self.VVDAhu()
   if self.VVZqoj == VV1AjE:
    if self.curRow > self.VVZeeA:
     self.curRow = self.VVZeeA
    if self.curRow == self.VVZeeA and self.curCol > self.VVW4YW:
     self.curCol = self.VVW4YW
   self.VVAlFM = self.VVlBZZ
   self.VVlBZZ = self.VVZqoj * self.VVqdrD + self.curRow * self.VVwnUG + self.curCol
   self.VVHjFJ()
   boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVuaAL["retPar"]
   self["myCursorLbl"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   self["myCursorPic"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   if self.VVkuAn:
    self.VVcP1n()
   else:
    if self.VVf2q6 : self["myCursorPic"].show()
    else    : self["myCursorLbl"].show()
  except:
   pass
 def VVeJc6(self, row, col):
  return self.VVZqoj * self.VVqdrD + row * self.VVwnUG + col
 def VVsLEr(self, ndx):
  if ndx > -1 and ndx < self.VVFM7Z:
   oldPage   = self.VVZqoj
   self.VVZqoj = int(ndx / self.VVqdrD)
   firstInPage  = self.VVZqoj * self.VVqdrD
   diff   = ndx - firstInPage
   self.curRow  = int(diff / self.VVwnUG)
   firstInRow  = self.curRow * self.VVwnUG
   diff   = ndx - firstInPage
   self.curCol  = diff - self.curRow * self.VVwnUG
   self.VVeRhA(False if oldPage == self.VVZqoj else True)
  else:
   FF8PJn(self, "Not found", 1000)
 def VVgmoH(self):
  if self.VVqkBb:
   for row in range(self.VVRQlw):
    for col in range(self.VVwnUG):
     self["myPosterRep%d%d" % (row, col)].hide()
 def VVbfZP(self):
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    for nm in ("myPosterBak", "myPosterRep", "myPosterPic", "myPosterLbl"):
     self[nm + "%d%d" % (row, col)].hide()
    if self.VVj06Q:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)].hide()
 def VVzYds(self, row, col):
  if self.VVkgKR:
   self["myPosterBak%d%d" % (row, col)].show()
  if not self.VVkuAn:
   self["myPosterRep%d%d" % (row, col)].show()
  pic = self["myPosterPic%d%d" % (row, col)]
  lbl = self["myPosterLbl%d%d" % (row, col)]
  pic.show()
  lbl.show()
  return pic, lbl
 def VVjylC(self, row, col, perc):
  if self.VVj06Q and perc > -1:
   if perc > -1:
    bgLbl = self["myPercBG%d%d" % (row, col)]
    fgLbl = self["myPercFG%d%d" % (row, col)]
    sz = bgLbl.instance.size()
    fgLbl.instance.resize(eSize(*(min(perc, 100) * sz.width() // 100, sz.height())))
    for nm in ("myPercFr", "myPercBG", "myPercFG"):
     self[nm + "%d%d" % (row, col)].show()
 def VVu35y(self):
  if self.VVqkBb:
   fg = bg = self.VVqkBb.getValue()
   self.session.openWithCallback(self.VVaesc, CCYGxc, defFG=fg, defBG=bg, onlyBG=True)
 def VVaesc(self, fg, bg):
  if self.VVqkBb and bg:
   FFDDwF(self.VVqkBb, bg)
   self.VV8I7a()
 def VV8I7a(self):
  if self.VVqkBb:
   for row in range(self.VVRQlw):
    for col in range(self.VVwnUG):
     FFu0W6(self["myPosterRep%d%d" % (row, col)], self.VVqkBb.getValue())
 def VV92ci(self, lbl, txt, color=""):
  CCofSh.VVYmVQ(lbl, txt, color)
 @staticmethod
 def VVYmVQ(lbl, txt, color=""):
  lbl.show()
  lbl.setText(txt)
  txtW = lbl.instance.calculateSize().width()
  lblW = lbl.instance.size().width() - 15
  if txtW > lblW:
   for i in range(len(txt), 5, -1):
    txt = txt[:-1]
    lbl.setText("%s.." % txt)
    txtW = lbl.instance.calculateSize().width()
    if txtW < lblW:
     break
  if color:
   lbl.setText("%s%s" % (color, txt))
 @staticmethod
 def VVKT8T(pngW, pngH, boxW, boxH):
  r_old = float(pngW) / pngH
  r_new = float(boxW) / boxH
  if (r_old > r_new):
   w = boxW
   h = int(float(w) / r_old)
   x = 0
   y = int((boxH - h) / 2.0) + 4
  else:
   h = boxH
   w = int(h * r_old)
   y = 2
   x = int((boxW - w) / 2.0)
  return x, y, w, h
class CCw9hJ(Screen, CCofSh):
 CANCEL_POSTER_DOWNLOAD = False
 def __init__(self, session, VV5ybN, pPath, nameCol, picCol, descCol, descTxt):
  self.skin, self.VVuaAL = FFJH4U(VVe7bi, 1870, 1030, 50, 20, 20, "#06112a33", "#06112a33", 50, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":35, "gapY":35})
  self.session   = session
  self.VV5ybN  = VV5ybN
  self.pPath    = pPath
  self.nameCol   = nameCol
  self.picCol    = picCol
  self.descCol   = descCol
  self.descTxt   = descTxt
  self.Title    = VV5ybN.Title or "Server Browser"
  self.timer_updPic  = eTimer()
  self.totThreads   = 0
  self.VVUNvQ = set()
  self.totDownloads  = 0
  self.VV5dDF    = []
  self.postersNdxLst  = []
  self.totPosterUrls  = 0
  self.VVFM7Z   = 0
  self.VV1V0y  = True
  self.isInPlayer   = False
  FFfmZP(self, self.Title)
  CCofSh.__init__(self)
  if not VVrRHR(self.pPath):
   FF6usE("mkdir -p '%s'" % self.pPath)
   if not VVrRHR(self.pPath):
    self.pPath = "/tmp/"
  FFyNtd(self,
  {
   "ok" : self.VVTOku    ,
   "cancel": self.close    ,
   "menu" : self.VVOmm2 ,
   "info" : self.VVLFP9
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  if self.VV1V0y:
   self.VV1V0y = False
   FF1uow(self)
   FFE1T7(self)
   self.VV5IQC(cursor="swap", sbSldBg="#00777777")
   for i in range(4):
    FFu0W6(self["myPiconInf%s" % i], "#0a001a22")
   self.VVKahs()
  elif self.isInPlayer:
   self.isInPlayer = False
   VVZqoj, curRow, curCol = self.VVZqoj, self.curRow, self.curCol
   self.VV2Z0k()
   if (VVZqoj, curRow, curCol) != (self.VVZqoj, self.curRow, self.curCol):
    self.VVeRhA(False if VVZqoj == self.VVZqoj else True)
 def VV2Z0k(self):
  ndx = self.VV5ybN.VVfkJL()
  self.VVZqoj = int(ndx / self.VVqdrD)
  ndx     -= self.VVZqoj * self.VVqdrD
  self.curRow  = int((ndx / self.VVwnUG))
  ndx     -= self.curRow * self.VVwnUG
  self.curCol  = int((ndx % self.VVwnUG))
 def onExit(self):
  CCw9hJ.CANCEL_POSTER_DOWNLOAD = True
  self.timer_updPic.stop()
 def VVOmm2(self):
  VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[self.VVlBZZ]
  picOk = FFf0vs(self.pPath + fName)
  VVXXzc = []
  VVXXzc.append(FFwjWO("Show Selected Picture"        , "VVO63u"  , picOk))
  VVXXzc.append(FFwjWO("Export Selected Picture"        , "VVSu4F" , picOk))
  VVXXzc.append(FFwjWO("Set Selected Picture as a Poster for a Local Media" , "VVMQFy", picOk))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Cache details"       , "VV7mBz"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Help (Keys)"        , "help"     ))
  FFw2XU(self, self.VVgjRD, title=self.Title, VVXXzc=VVXXzc)
 def VVgjRD(self, item=None):
  if item is not None:
   if   item == "VVO63u"   : self.VVO63u()
   elif item == "VVSu4F"   : self.VVSu4F()
   elif item == "VVMQFy"  : self.VVMQFy()
   elif item == "VV7mBz"  : self.VV7mBz()
   elif item == "help"     : FFpIdO(self, "_help_servBr", "Server Browser (Keys)")
 def VVTOku(self):
  self.VV5ybN.VV43d2(self.VVlBZZ)
  self.VV5ybN.VVGOIe()
  self.isInPlayer = True
 def VVLFP9(self):
  self.VV5ybN.VV43d2(self.VVlBZZ)
  self.VV5ybN.VVoCI2()
 def VVl3YL(self, url):
  span = iSearch(r".+\.(png|jpg|jpeg)", url, IGNORECASE)
  if span:
   ext = span.group(1)
  else:
   ext = "jpg"
   for ex in (".jpg", ".png", ".jpeg"):
    if ex in url.lower():
     ext = ex[1:]
     break
  ext = ext.lower()
  if ext == "jpeg": ext = "jpg"
  return "%s.%s" % (FFEkBW(url), ext)
 def VVKahs(self):
  for colList in self.VV5ybN.VVTq0J():
   VVeZBd = colList[self.nameCol]
   url  = colList[self.picCol]
   desc = colList[self.descCol]
   fName = VVKCwZ = ""
   if url:
    tmpFile = self.VVl3YL(url)
    if FFf0vs(self.pPath + tmpFile):
     fName = tmpFile
    else:
     VVKCwZ = url
     self.totPosterUrls += 1
   self.VV5dDF.append((VVeZBd, self.descTxt, desc, fName, VVKCwZ))
  self.VVFM7Z = len(self.VV5dDF)
  self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
  self.VV2Z0k()
  self.VVeRhA(True)
  for ndx, (VVeZBd, subj, desc, fName, VVKCwZ) in enumerate(self.VV5dDF):
   if VVKCwZ and not fName:
    self.postersNdxLst.append(ndx)
  CCw9hJ.CANCEL_POSTER_DOWNLOAD = False
  try: self.timer_updPic_conn = self.timer_updPic.timeout.connect(self.VVV3ut)
  except: self.timer_updPic.callback.append(self.VVV3ut)
  self.timer_updPic.start(50, False)
 def VVXQ4e(self):
  if self.postersNdxLst and self.totThreads < 8:
   iThread(name="ajp_DnldPic", target=self.VVaJt1).start()
 def VVaJt1(self):
  try:
   if CCw9hJ.CANCEL_POSTER_DOWNLOAD: return
   self.totThreads += 1
   ndx = self.postersNdxLst[0]
   self.postersNdxLst.pop(0)
   VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[ndx]
   if VVKCwZ and not fName:
    if CCw9hJ.CANCEL_POSTER_DOWNLOAD: return
    VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[ndx]
    fName = self.VVl3YL(VVKCwZ)
    if not fName in self.VVUNvQ:
     self.VVUNvQ.add(fName)
     path, err = FFEyUQ(VVKCwZ, fName, timeout=2, VVtOxO=True, VVJplu=False)
     if path:
      if CCw9hJ.CANCEL_POSTER_DOWNLOAD:
       FFqlCI(path)
       return
      cmd = CCISy5.VVomfz(path, 500)
      cmd += FFDTPf("mv -f '%s' '%s'" % (path, self.pPath + fName))
      FF6usE(cmd)
    if CCw9hJ.CANCEL_POSTER_DOWNLOAD: return
    self.totDownloads += 1
    self.VV5dDF[ndx] = (VVeZBd, subj, desc, fName, "-")
   self.totThreads -= 1
  except:
   pass
 def VVV3ut(self):
  if self.postersNdxLst:
   if self.totThreads < 8:
    iThread(name="ajp_DnldPic", target=self.VVaJt1).start()
   txt = VVsm0W + "   >> Downloading %d/%d ..." % (self.totDownloads, self.totPosterUrls)
  else:
   txt = ""
  self["myTitle"].setText("  %s%s" % (self.Title, txt))
  last = self.VVFM7Z
  f1 = self.VVZqoj * self.VVqdrD
  f2 = f1 + self.VVqdrD
  if f1 > last: f1 = last
  if f2 > last: f2 = last
  row = col = remain = 0
  for ndx in range(f1, f2):
   VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[ndx]
   if fName and VVKCwZ == "-":
    path = self.pPath + fName
    if FFf0vs(path):
     self.VV5dDF[ndx] = (VVeZBd, subj, desc, fName, "")
     pic, lbl = self.VVzYds(row, col)
     self.VVLBdY(ndx, row, col, pic, path, reset=True)
     if ndx == self.VVlBZZ and self.VVkuAn:
      self.VVcP1n()
   if VVKCwZ and not fName:
    remain += 1
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
  if not txt:
   self.VVUNvQ = set()
   FFUttZ(self, 2000, self.timer_updPic.stop)
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  row = col = 0
  for ndx in range(f1, f2):
   VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[ndx]
   pic, lbl = self.VVzYds(row, col)
   self.VV92ci(lbl, VVeZBd)
   self.VVLBdY(ndx, row, col, pic, self.pPath + fName)
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 def VVHjFJ(self):
  VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[self.VVlBZZ]
  self.VVDVSE(VVeZBd, "%s : %s" % (subj, desc) if desc else "")
 def VVO63u(self):
  VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[self.VVlBZZ]
  if fName and FFf0vs(self.pPath + fName) : CCC0Lg.VVESKQ(self, self.pPath + fName)
  else          : FF8PJn(self, "File not found", 1500)
 def VVSu4F(self):
  title = "Copy Poster/PIcon"
  VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[self.VVlBZZ]
  if fName:
   dstPath = FF7GbY()
   dstF = dstPath + (FF80BW(VVeZBd) + os.path.splitext(fName)[1] if VVeZBd else fName)
   if FF6usE("cp -f '%s' '%s'" % (self.pPath + fName, dstF)):
    FFSQn9(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFU9uk(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstPath), title=title)
  else:
   FFU9uk(self, "No Poster/PIcon found", title=title)
 def VVMQFy(self):
  self.session.openWithCallback(self.VVZMO6, BF(CCQdsv, VVmysg="movies", VV82pi=CFG.MovieDownloadPath.getValue()))
 def VVZMO6(self, path):
  if path:
   title = "Set Selected Picture as a Poster for a Local Media"
   VVeZBd, subj, desc, fName, VVKCwZ = self.VV5dDF[self.VVlBZZ]
   if fName:
    srcF = self.pPath + fName
    dstF = "%s%s" % (os.path.splitext(path)[0], os.path.splitext(srcF)[1])
    if FF6usE("cp -f '%s' '%s'" % (srcF, dstF)):
     FFSQn9(self, "File copied to:\n\n%s" % dstF, title=title)
    else:
     FFU9uk(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstF), title=title)
    CCBgul.VVg2w6(dstF)
   else:
    FFU9uk(self, "No Poster/PIcon found", title=title)
 @FFHF2S("Calculating ...")
 def VV7mBz(self):
  txt = "\n"
  totSize = 0
  for path in ("Live/", "VOD/", "Series/", "M3U/"):
   path = "%sPosters/%s" % (FFmAG5(), path)
   size = "Dir. not found !"
   if VVrRHR(path):
    size = FFhWCj("find '%s' ! -type d -print0 2> /dev/null | xargs -0 ls -lsa 2> /dev/null | awk '{sum+=$6;} END {print sum;}'" % path)
    if size.isdigit():
     size = int(size)
     totSize += size
     size = CCQdsv.VVAcha(size)
   txt += "%s\n    %s\n\n" % (FFITtK(path, VV6UAe), size)
  mainPath = "%sPosters" % FFmAG5()
  totFiles = FFhWCj("find '%s' ! -type d | wc -l" % mainPath)
  totFTxt = " (%s file%s)" % (totFiles, FFEnJs(int(totFiles))) if totFiles.isdigit() else ""
  txt += "%s\n    %s\n\n" % (FFITtK("Total space used by Posters/PIcons%s:" % totFTxt, VVaR8d), CCQdsv.VVAcha(totSize))
  mountPath = CCQdsv.VVZBjZ(mainPath)
  if VVrRHR(mountPath):
   total, used, free, avail, err = CCQdsv.VV87Qo(mountPath)
   total, used, free, avail = [CCQdsv.VVAcha(x) for x in (total, used, free, avail)]
   txt += "%s\n" % SEP
   txt += FFITtK("Media Space:\n", VVCBkQ)
   txt += "    Media Path\t: %s\n" % FFITtK(mountPath, VVkLs0)
   txt += "    Total Size\t: %s\n" % total
   txt += "    Used Size\t: %s\n" % used
   txt += "    Free Size\t: %s\n" % free
   if free != avail: txt += "    Available\t: %s" % avail
  FFyijw(self, txt, title="Cache Used Size", height=1000)
class CCBgul(Screen, CCofSh):
 def __init__(self, session, title, lst):
  self.skin, self.VVuaAL = FFJH4U(VVe7bi, 1870, 1030, 50, 20, 20, "#06112233", "#06112233", 50, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":30, "gapY":30, "percBar":1})
  self.session   = session
  self.Title    = title
  self.VV5dDF    = lst
  self.VVLTov   = -1
  FFfmZP(self, self.Title)
  CCofSh.__init__(self)
  FFyNtd(self,
  {
   "ok" : self.VVb2mu ,
   "cancel": self.close   ,
   "menu" : self.VVNRhQ,
   "info" : self.VVXb2V
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  FFE1T7(self)
  self.VV5IQC(cursor="swap", sbSldBg="#00777777")
  for i in range(4):
   FFu0W6(self["myPiconInf%s" % i], "#0a001122")
  self.VVsZl1()
 def VVsZl1(self):
  self.VVFM7Z = len(self.VV5dDF)
  self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
  self.VVeRhA(True)
  self.VVq7jo(VVqUOx=False)
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  mPath = CFG.MovieDownloadPath.getValue()
  row = col = 0
  for ndx in range(f1, f2):
   path, movie, poster = self.VV5dDF[ndx]
   movie = os.path.join(mPath, path, movie)
   poster = os.path.join(mPath, path, poster)
   pic, lbl = self.VVzYds(row, col)
   self.VV92ci(lbl, os.path.splitext(os.path.basename(movie))[0])
   self.VVLBdY(ndx, row, col, pic, poster)
   d = CCzCR1.VVxvlA(CCzCR1.VVlenf(FFEkBW(movie)))
   if d:
    self.VVjylC(row, col, int(round(100.0 * d["pos"] / d["dur"])))
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 def VVoM8d(self, ndx=-1):
  if ndx == -1:
   ndx = self.VVlBZZ
  path, movie, poster = self.VV5dDF[ndx]
  path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
  path = os.path.join(path, movie)
  if poster:
   poster = os.path.join(os.path.dirname(path), poster)
  return path, poster
 def VVHjFJ(self):
  path, poster = self.VVoM8d()
  self.VVDVSE(os.path.splitext(os.path.basename(path))[0], os.path.dirname(path))
 def VVNRhQ(self):
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  cur = False
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VV5dDF):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     cur = True
     break
  path, poster = self.VVoM8d()
  c1, c2, c3 = VVnQYw, VVkLs0 , VV6UAe
  VVXXzc = []
  VVXXzc.append((c1 + "Find a movie ..."   , "VVRyqe"  ))
  VVXXzc.append(FFwjWO("Go to Current Movie" , "VVq7jo", cur, c1 ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Add Selected Movie to Bouquet", "VVFiEF0"))
  VVXXzc.append(("Add All Movies to Bouquet" , "VVFiEF1"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Show Poster" , "VVO63u" , poster))
  VVXXzc.append(FFwjWO("Export Poster", "VVSu4F", poster))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Change Poster (locate manually) ..." , "VV93Yl"  ))
  VVXXzc.append((c3 + "Change Poster (Download)"   , "VVmTFZ" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Help (Keys)", "help"))
  FFw2XU(self, self.VV7ezm, width=900, title=self.Title, VVXXzc=VVXXzc)
 def VV7ezm(self, item=None):
  if item is not None:
   if   item == "VVRyqe"  : self.VVRyqe()
   elif item == "VVq7jo"    : self.VVq7jo()
   elif item == "VVFiEF0": self.VVFiEF(False)
   elif item == "VVFiEF1": self.VVFiEF(True)
   elif item == "VVSu4F"    : self.VVSu4F()
   elif item == "VVO63u"    : self.VVO63u()
   elif item == "VV93Yl"  : self.VV93Yl()
   elif item == "VVmTFZ"  : self.VVmTFZ()
   elif item == "help"      : FFpIdO(self, "_help_movBr", "Movies Browser (Keys)")
 def VVRyqe(self):
  VVJwgn = []
  for ndx, (path, movie, poster) in enumerate(self.VV5dDF):
   path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
   VVJwgn.append((os.path.splitext(movie)[0], path, str(ndx)))
  VVJwgn.sort(key=lambda x: x[0].lower())
  VVI3Oq = ("Select" , self.VVV5Vc, [])
  header  = ("Name" , "Path", "NDX.")
  widths  = (60  , 40 , 0  )
  FFdCaM(self, None, title="Select Movie", width=1800, height=1000, header=header, VV5dDF=VVJwgn, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV7VIQ=CFG.lastFindMovie)
 def VVV5Vc(self, VV5ybN, title, txt, colList):
  self.VVsLEr(int(colList[2].strip()))
  VV5ybN.cancel()
 def VVq7jo(self, VVqUOx=True):
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VV5dDF):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     self.VVsLEr(ndx)
     return
  if VVqUOx:
   FF8PJn(self, "Not found", 1000)
 def VVb2mu(self):
  self.VVLTov = self.VVlBZZ
  VVDhju = self.VVnzh2()
  CC2lVw.VVbVSZ(self.session, VViMad=False, VV7GTU=VVDhju, zapFnc=self.VVnzh2, cbFnc=self.VVOybE)
 def VVOybE(self):
  Len = len(self.VV5dDF)
  mPath = CFG.MovieDownloadPath.getValue()
  self.VV5dDF = [(path, movie, poster) for path, movie, poster in self.VV5dDF if FFf0vs(os.path.join(mPath, path, movie))]
  if Len != len(self.VV5dDF):
   self.VVsZl1()
  else:
   self.VVsLEr(self.VVLTov)
 def VVnzh2(self, val=0):
  ndx = self.VVLTov + val
  if   ndx > self.VVFM7Z -1: ndx = 0
  elif ndx < 0     : ndx = self.VVFM7Z - 1
  self.VVLTov = ndx
  path, poster = self.VVoM8d(ndx)
  VVDhju = "%s:%s%s" % (CFG.iptvAddToBouquetRefType.getValue(), "0:" * 9, path)
  return VVDhju
 def VVXb2V(self):
  lst = []
  path, poster = self.VVoM8d()
  size = FFX42v(path)
  lst.append(("Media Path", path))
  if size > -1: lst.append(("Media Size", CCQdsv.VVAcha(size)))
  lst.append(("Poster Path", poster))
  size = FFX42v(poster)
  if size > -1: lst.append(("Poster Size", CCQdsv.VVAcha(size)))
  d = CCzCR1.VVxvlA(CCzCR1.VVlenf(FFEkBW(path)))
  if d:
   lst.append(("Duration", FF79L2(d["dur"] / 90000.0)))
   lst.append(("Watched", FFMYsv(d["w"])))
   lst.append(("Resume Position", FF79L2(d["pos"] / 90000.0)))
  bg="#11001122"
  FFdCaM(self, None, title="Media File Information", VV5dDF=lst, VV1PTZ=(20, 80), VV1Wwb=30, VV4HrS=1, VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVaqdB=0)
 def VVO63u(self):
  path, poster = self.VVoM8d()
  if FFf0vs(poster): CCC0Lg.VVESKQ(self, poster)
  else     : FF8PJn(self, "No Poster", 1500)
 def VVSu4F(self):
  title = "Copy Poster"
  path, poster = self.VVoM8d()
  if poster:
   dstPath = FF7GbY()
   dstF = os.path.join(dstPath, os.path.basename(poster))
   if FF6usE("cp -f '%s' '%s'" % (poster, dstF)):
    FFSQn9(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFU9uk(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (poster, dstPath), title=title)
  else:
   FF8PJn(self, "No Poster", 1500)
 def VV93Yl(self):
  path, poster = self.VVoM8d()
  sDir = FFA4GT(os.path.dirname(path))
  self.session.openWithCallback(BF(self.VV0QSt, sDir, path), BF(CCQdsv, VVmysg="poster", VV82pi=sDir))
 def VVQO2Q(self, VVZzW8, txt, ref, ndx):
  CCC0Lg.VVESKQ(self, VV0hkT=ref)
 def VV0QSt(self, sDir, path, pPath=None):
  if pPath:
   newPath = sDir + os.path.splitext(os.path.basename(path))[0] + os.path.splitext(pPath)[1].lower()
   if   pPath == newPath : FF8PJn(self, "No change", 1000)
   elif FFf0vs(newPath): FFHsPu(self, BF(self.VVYrRx, pPath, newPath), "Overwrite exiting file ?\n\n%s" % os.path.basename(newPath), title="Change Poster")
   else     : self.VVYrRx(pPath, newPath)
 def VVYrRx(self, pPath, newPath):
  if FF6usE("cp -f '%s' '%s'" % (pPath, newPath)):
   path, movie, poster = self.VV5dDF[self.VVlBZZ]
   self.VV5dDF[self.VVlBZZ] = (path, movie, os.path.basename(newPath))
   FFTSvN(self, BF(self.VVeRhA, True))
   CCBgul.VVg2w6(newPath)
  else:
   FF8PJn(self, "Cannot copy file.", 1000)
 def VVmTFZ(self):
  path, poster = self.VVoM8d()
  evName = os.path.splitext(os.path.basename(path))[0]
  dstP = os.path.splitext(path)[0] + ".jpg"
  self.session.openWithCallback(BF(self.VVg6Tl, dstP), CC7qmh, dstP=dstP, evName=evName)
 def VVg6Tl(self, dstP, pPath=None):
  if pPath:
   path, movie, poster = self.VV5dDF[self.VVlBZZ]
   self.VV5dDF[self.VVlBZZ] = (path, movie, os.path.basename(dstP))
   FFTSvN(self, BF(self.VVeRhA, True))
 def VVFiEF(self, isAll):
  pathLst = []
  if isAll:
   for ndx, (path, movie, poster) in enumerate(self.VV5dDF):
    path = os.path.join(CFG.MovieDownloadPath.getValue(), path, movie)
    pathLst.append(path)
  else:
   path, poster = self.VVoM8d()
   pathLst = [path]
  picker = CC41Tt(self, self, "Add to Bouquet", BF(self.VV5oQU, pathLst))
 def VV5oQU(self, pathLst):
  return CC41Tt.VVONdL(pathLst)
 @staticmethod
 def VVg2w6(path):
  if path.endswith(".png"):
   fileNoExt = path[:-4]
   jpgF = fileNoExt + ".jpg"
   if FFf0vs(jpgF):
    c = 1
    newF = "%s_%d.jpg" % (fileNoExt, c)
    while FFf0vs(newF):
     c += 1
     newF = "%s_%d.jpg" % (fileNoExt, c)
    FF6usE("mv -f '%s' '%s'" % (jpgF, newF))
 @staticmethod
 @FFHF2S()
 def VVPSpu(SELF):
  eLst = CCf9Gq.VVl1a5()["mov"]
  mPath = CFG.MovieDownloadPath.getValue()
  lst = []
  for (Dir, dirs, files) in os.walk(mPath):
   for f in files:
    if os.path.splitext(f)[1].lstrip(".").lower() in eLst:
     path = os.path.join(Dir, f)
     poster = ""
     for ext in ("jpg", "png"):
      pic = "%s.%s" % (os.path.splitext(path)[0], ext)
      if FFf0vs(pic):
       poster = os.path.basename(pic)
       break
     lst.append((os.path.dirname(path).replace(mPath, ""), os.path.basename(path), poster))
  title = "Movies Browser"
  lst.sort(key=lambda x: x[1].lower())
  if lst: SELF.session.open(CCBgul, title, lst)
  else  : FFU9uk(SELF, "No movies found in:\n\n%s\n\nYou can change the path from settings." % mPath, title=title)
class CCdo8n(Screen, CCofSh):
 def __init__(self, session, bName, lst):
  self.skin, self.VVuaAL = FFJH4U(VVe7bi, 1750, 1040, 50, 3, 3, "#22003344", "#22001122", 45, VVZ3ZU=40, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":4, "cols":6, "picR":0.75, "lblR":0.25, "w1R":0.80, "w2R":0.20, "gapX":15, "gapY":15})
  self.session   = session
  self.Title    = bName
  self.VV5dDF    = lst
  self.pPath    = CCUNc6.VVQ490()
  self.VVFM7Z   = 0
  self.VV1V0y  = True
  self.VV2zij  = False
  FFfmZP(self, self.Title)
  FFrvOP(self["keyRed"] , "OK = Zap")
  FFrvOP(self["keyGreen"] , "Current Channel")
  FFrvOP(self["keyBlue"] , "Preview")
  CCofSh.__init__(self, CFG.transpColorChannels)
  FFyNtd(self,
  {
   "ok"  : BF(self.VVSl5h, True),
   "cancel" : self.VVkIEK      ,
   "menu"  : self.VVGUaN   ,
   "info"  : self.VVUAoV    ,
   "red"  : self.VVkIEK      ,
   "green"  : BF(self.VVbH1f, True)  ,
   "blue"  : BF(self.VVSl5h, False)
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  if self.VV1V0y:
   force = True
   self.VV1V0y = False
   FF1uow(self)
   FFE1T7(self)
   FFu0W6(self["keyRed"], "#0a333333")
   self.VV5IQC()
  elif self.VV2zij:
   self.VV2zij = False
   return
  else:
   pName, srvLst = CCdo8n.VVqWFI()
   if srvLst and not srvLst == self.VV5dDF:
    force = True
    self.Title = pName
    self["myTitle"].setText("  %s  " % self.Title)
    self.VV5dDF = srvLst
   else:
    force = False
  self.VVFM7Z = len(self.VV5dDF)
  self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
  self.VVeRhA(force)
  self.VVbH1f()
 def VVGUaN(self):
  VVXXzc = []
  VVXXzc.append(("Find Name (sorted list)" , "findSrt"  ))
  VVXXzc.append(("Find Name (as listed)" , "findNoSrt"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Change Background Color" , "VVu35y"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Help (Keys)", "help"))
  FFw2XU(self, self.VVm8GJ, title="Options", VVXXzc=VVXXzc)
 def VVm8GJ(self, item=None):
  if item:
   if   item == "findSrt"    : self.VVdaid(True)
   elif item == "findNoSrt"   : self.VVdaid(False)
   elif item == "VVu35y": self.VVu35y()
   elif item == "help"     : FFpIdO(self, "_help_srvcBr", "Services Browser (Keys)")
 def VVdaid(self, isSort):
  VVXXzc = []
  for ndx, item in enumerate(self.VV5dDF):
   VVXXzc.append((item[1], ndx))
  if isSort:
   VVXXzc.sort(key=lambda x: x[0].lower())
  FFw2XU(self, self.VVLa18, title="Find Name", VVXXzc=VVXXzc, width=1300)
 def VVLa18(self, ndx=None):
  if ndx is not None:
   self.VVsLEr(ndx)
 def VVUAoV(self):
  VVDhju, VVeZBd = self.VV5dDF[self.VVlBZZ]
  txt  = "Service Name\t: %s\n" % VVeZBd
  txt += "Referrence\t: %s" % VVDhju
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVgoj6, params=(VVDhju, VVeZBd, txt))
  self.VV2zij = True
 def VVkIEK(self):
  if self.shown: self.close()
  else   : self.show()
 def VVSl5h(self, isExit):
  try:
   if self.shown:
    chUrl = self.VV5dDF[self.VVlBZZ][0]
    if isExit:
     self.VVAxqq(chUrl)
    else:
     FF5deK(self.session, chUrl)
     FFb7ob(self, "Cancel to go back")
   else:
    self.show()
  except:
   pass
 @FFHF2S("Starting ...")
 def VVAxqq(self, chUrl):
  FF5deK(self.session, chUrl, VVlFbr=True)
  self.close()
 def VVbH1f(self, VVqUOx=False):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  err = ""
  if serv:
   curRef = serv.toString()
   for ndx, item in enumerate(self.VV5dDF):
    if curRef == item[0]:
     self.VVsLEr(ndx)
     return ndx
   else:
    err = "Not found"
  else:
   err = "No active service"
  if VVqUOx and err:
   FF8PJn(self, err, 500)
  return -1
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  row = col = 0
  for ndx in range(f1, f2):
   ref, name = self.VV5dDF[ndx]
   pic, lbl = self.VVzYds(row, col)
   self.VV92ci(lbl, name)
   path = CCUNc6.VVjFPF(self.pPath, ref, name)
   self.VVLBdY(ndx, row, col, pic, path)
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 def VVHjFJ(self):
  ref, name = self.VV5dDF[self.VVlBZZ]
  span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", ref)
  if span: ref = span.group(1)
  self.VVDVSE(name, ref)
 @staticmethod
 def VVe8dV():
  VVDhju = refName = rootRef = rootName = ""
  inBouquet = False
  VVI3vF = InfoBar.instance
  if VVI3vF:
   csel = VVI3vF.servicelist
   if csel:
    currSel  = csel.getCurrentSelection()
    rootRef  = csel.getRoot().toString()
    VVDhju  = currSel.toString()
    rootName = FFCbnj(rootRef)
    refName  = FFCbnj(VVDhju)
    inBouquet = csel.inBouquet()
    if   inBouquet        : rootSrc = "Favourites"
    elif "(satellitePosition == " in rootRef : rootSrc = "Satellites"
    elif "name:Current transponder" in rootRef : rootSrc = "Transponder"
    elif "(provider == " in rootRef    : rootSrc = "Provider"
    else          : rootSrc = "ALL"
  return VVDhju, refName, rootRef, rootName, inBouquet, rootSrc
 @staticmethod
 def VVqWFI(VVDhju="", refName="", rootRef="", rootName="", inBouquet=False):
  VVDhju, rootRef = VVDhju.strip(), rootRef.strip()
  if not VVDhju and not rootRef:
   VVDhju, refName, rootRef, rootName, inBouquet, rootSrc = CCdo8n.VVe8dV()
   VVDhju, rootRef = VVDhju.strip(), rootRef.strip()
  pName, srvLst = "", []
  if VVDhju and rootRef:
   if   VVDhju.startswith("1:7:") : ref, name = VVDhju, refName
   elif rootRef.startswith("1:7:") : ref, name = rootRef, rootName
   else       : return "", []
   srvLst = FFaKV3(eServiceReference(ref))
   pName = name or "No-Name"
   if not inBouquet: srvLst.sort(key=lambda x: x[1].lower())
  else:
   srvLst = CC41Tt.VVSaEJ()
   pName  = CC41Tt.VVkU5R() or "ALL (Group)"
  return pName, srvLst
 @staticmethod
 def VVhcdr(SELF, cbFnc=None):
  pName, srvLst = CCdo8n.VVqWFI()
  if srvLst: SELF.session.openWithCallback(cbFnc, CCdo8n, pName, srvLst)
  else  : FFU9uk(SELF, "No services found in:\n\n%s" % pName, title="Channels Browser")
class CCF1F0(Screen, CCofSh):
 def __init__(self, session, title, lst):
  self.skin, self.VVuaAL = FFJH4U(VVe7bi, 1600, 1000, 50, 20, 20, "#2200202a", "#11202020", 45, VVZ3ZU=40, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":4, "cols":5, "picR":0.65, "lblR":0.35, "w1R":0.85, "w2R":0.15, "bGap":8, "gapX":25, "gapY":25, "mGap":8, "lblTr":1, "picBgTr":1})
  self.session   = session
  self.Title    = title
  self.VV5dDF    = CCF1F0.VVX7x2(lst)
  self.VVFM7Z   = 0
  self.useOrigSize  = False
  self.firstTime   = True
  FFfmZP(self, self.Title)
  FFrvOP(self["keyRed"] , "Remove Plugins")
  FFrvOP(self["keyGreen"] , "Download New Plugins")
  FFrvOP(self["keyYellow"], "Package Info.")
  FFrvOP(self["keyBlue"] , "Plugins Group")
  CCofSh.__init__(self)
  FFyNtd(self,
  {
   "ok"  : self.VVZIM5   ,
   "cancel" : self.close    ,
   "menu"  : self.VVc99p ,
   "info"  : self.VVMeF0  ,
   "red"  : BF(self.VVJ9Zb, False),
   "green"  : BF(self.VVJ9Zb, True),
   "yellow" : self.VVkiZw ,
   "blue"  : self.VVbBS8
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  FFE1T7(self)
  self.VV5IQC(shade="yes", cursor="")
  self.VV0akf([("", "#22000a0b")] * 4)
  self.VVSRKi()
 def VVSRKi(self):
  self.VVFM7Z = len(self.VV5dDF)
  self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
  self.VVeRhA(True)
 def VVkaqO(self):
  lst = CCF1F0.VVY2TM(PluginDescriptor.WHERE_PLUGINMENU)
  if lst:
   lst = CCF1F0.VVX7x2(lst)
   if lst != self.VV5dDF:
    self.VV5dDF = lst
    self.VVSRKi()
  else:
   self.close()
 def VVJ9Zb(self, isInstall):
  FF8PJn(self, "Processing ...")
  try:
   from Screens.PluginBrowser import PluginDownloadBrowser as pb
   if isInstall:
    self.session.openWithCallback(self.VVkaqO, pb, pb.DOWNLOAD, self.firstTime)
    self.firstTime = False
   else:
    self.session.openWithCallback(self.VVkaqO, pb, pb.REMOVE)
  except:
   try:
    from Screens.PluginBrowser import PluginAction as pa
    if hasattr(pa, "DOWNLOAD") and hasattr(pa, "REMOVE"):
     self.session.openWithCallback(self.VVkaqO, pa, pa.DOWNLOAD if isInstall else pa.REMOVE)
    else:
     self.session.openWithCallback(self.VVkaqO, pa, pa.MODE_INSTALL if isInstall else pa.MODE_REMOVE)
   except:
    try:
     from Plugins.SystemPlugins.SoftwareManager.plugin import PluginManager as pb
     self.session.openWithCallback(self.VVkaqO, pb)
    except Exception as e:
     FFU9uk(self, 'Cannot open "Extensions Management" !', title=self.Title)
  FF8PJn(self)
 def VVZIM5(self):
  name, desc = self.VVD1ff(self.VVlBZZ)
  if name == VVryLp and "VVwjls" in globals() and VVwjls:
   FF8PJn(self, "Already running.", 500)
  else:
   try:
    p = self.VV5dDF[self.VVlBZZ]
    p(session=self.session)
   except:
    FFU9uk(self, "Cannot start from here !", title="Error in : %s" % name)
 def VVMeF0(self):
  def VVEQGt(key, val):
   return key + "\t: " + str(val) + "\n"
  p = self.VV5dDF[self.VVlBZZ]
  txt = ""
  try:
   txt += VVEQGt("Path"  , p.path  )
   txt += VVEQGt("Description" , p.description )
   txt += VVEQGt("Icon"  , p.iconstr  )
   txt += VVEQGt("Wakeup Fnc" , p.wakeupfnc )
   txt += VVEQGt("NeedsRestart", p.needsRestart)
   txt += VVEQGt("Internal" , p.internal )
   txt += VVEQGt("Weight"  , p.weight  )
  except:
   pass
  name, desc = self.VVD1ff(self.VVlBZZ)
  if txt : FFyijw(self, txt, title=name)
  else : FFU9uk(self, "Could not read plugin info.", title=name)
 @FFHF2S()
 def VVkiZw(self):
  p = self.VV5dDF[self.VVlBZZ]
  name, desc = self.VVD1ff(self.VVlBZZ)
  path = p.path
  pkg, err = CCJFyo.VVY854(path)
  if pkg : CCJFyo.VVeFdT(self, pkg, name)
  else : FFk1YE(self, err, 1000)
 def VVc99p(self):
  path = self.VV5dDF[self.VVlBZZ].path
  VVXXzc = []
  txt = "Open Plugin Path in File Manager"
  VVXXzc.append(FFwjWO("Open Plugin Path in File Manager", "inFileMan", VVrRHR(path)))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Use Original Icon Size", "setOrigSize"))
  FFw2XU(self, self.VVRbCk, title="Plugins Group", VVXXzc=VVXXzc)
 def VVRbCk(self, item=None):
  if item:
   if item == "inFileMan":
    self.session.open(CCQdsv, mode=CCQdsv.VV6W2c, VV82pi=self.VV5dDF[self.VVlBZZ].path)
   elif item == "setOrigSize":
    self.useOrigSize = True
    self.VVeRhA(True)
 def VVbBS8(self):
  FFw2XU(self, self.VVCfAE, title="Plugins Group", VVXXzc=CCF1F0.VVWLK6(True, True), width=700, VVfP2Q=True)
 def VVCfAE(self, item=None):
  if item:
   title, where, ndx = item
   self["myTitle"].setText("  %s (%s)" % (self.Title, title))
   lst = CCF1F0.VVY2TM(where)
   if lst:
    self.VV5dDF = CCF1F0.VVX7x2(lst)
    self.VVZqoj = self.curCol = self.curRow = self.VVlBZZ = 0
    self.VVFM7Z = len(self.VV5dDF)
    self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
    self.VVeRhA(True)
   else:
    FFU9uk(self, "Not found !", title=self.Title)
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  row = col = 0
  for ndx in range(f1, f2):
   name, desc = self.VVD1ff(ndx)
   pic, lbl = self.VVzYds(row, col)
   self.VV92ci(lbl, name)
   iconOk = False
   pngSz = None
   if self.VV5dDF[ndx].icon:
    try:
     pngSz = self.VV5dDF[ndx].icon.size()
     pic.instance.setScale(1)
     pic.instance.setPixmap(self.VV5dDF[ndx].icon)
     pic.show()
     iconOk = True
    except:
     pass
   if not iconOk:
    icons = []
    path = self.VV5dDF[ndx].path
    if VVrRHR(path):
     for f in ("iconfhd.png", "iconhd.png", "icon.png"):
      icons.append(os.path.join(path, f))
    icons.append(resolveFilename(SCOPE_CURRENT_SKIN, "icons/plugin.png"))
    icons.append(VV30Jg + "plugin.png")
    for path in icons:
     pixMap = FFbO0w(pic, path)
     if pixMap:
      pngSz = pixMap.size()
      break
   if self.useOrigSize and pngSz:
    try:
     boxSz = pic.instance.size()
     VVDveF = pic.instance.position()
     pngW, pngH = pngSz.width(), pngSz.height()
     boxW, boxH = boxSz.width(), boxSz.height()
     if boxW > pngW and boxH > pngH:
      pic.instance.resize(pngSz)
      pic.instance.move(ePoint(VVDveF.x() + (boxW - pngW) // 2, VVDveF.y() + (boxH - pngH) // 2))
    except:
     pass
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 def VVD1ff(self, ndx):
  name = str(self.VV5dDF[ndx].name).strip()
  desc = str(self.VV5dDF[ndx].description).strip().replace("\n", " >> ")
  if not name or name == "Plugin":
   name = desc or FFVUvT(self.VV5dDF[ndx].path)
  return name, desc
 def VVHjFJ(self):
  name, desc = self.VVD1ff(self.VVlBZZ)
  self.VVDVSE(name, desc)
 @staticmethod
 def VVWLK6(isMenu=False, addTot=False):
  lst =[("Plugin Menu"   , PluginDescriptor.WHERE_PLUGINMENU    )
   , ("Audio Menu"    , PluginDescriptor.WHERE_AUDIOMENU    )
   , ("Auto-Start Menu"  , PluginDescriptor.WHERE_AUTOSTART    )
   , ("Channel Context Menu" , PluginDescriptor.WHERE_CHANNEL_CONTEXT_MENU )
   , ("Event Info"    , PluginDescriptor.WHERE_EVENTINFO    )
   , ("Extensions Menu"  , PluginDescriptor.WHERE_EXTENSIONSMENU   )
   , ("File Scan"    , PluginDescriptor.WHERE_FILESCAN    )
   , ("Main Menu"    , PluginDescriptor.WHERE_MAINMENU    )
   , ("Menu"     , PluginDescriptor.WHERE_MENU     )
   , ("Movie List"    , PluginDescriptor.WHERE_MOVIELIST    )
   , ("Network Configuration" , PluginDescriptor.WHERE_NETWORKCONFIG_READ  )
   , ("Network Setup"   , PluginDescriptor.WHERE_NETWORKSETUP   )
   , ("Session Start"   , PluginDescriptor.WHERE_SESSIONSTART   )
   , ("Software Manager"  , PluginDescriptor.WHERE_SOFTWAREMANAGER  )
   , ("Teletext"    , PluginDescriptor.WHERE_TELETEXT    )
   , ("Wizard"     , PluginDescriptor.WHERE_WIZARD     )]
  if addTot:
   for ndx, item in enumerate(lst):
    tot = len(CCF1F0.VVY2TM(item[1]))
    lst[ndx] = ("%s   %s(%d)" % (lst[ndx][0], VVVAvR, tot), lst[ndx][1])
  if isMenu: lst.insert(1, VVzg1X)
  else  : lst.sort(key=lambda x: x[0].lower())
  return lst
 @staticmethod
 def VVY2TM(where):
  try: return iPlugins.getPlugins(where)
  except: return []
 @staticmethod
 def VVX7x2(lst):
  tmp = []
  for item in lst:
   name = str(item.name).strip()
   if not name or name == "Plugin":
    name = str(item.description).strip() or FFVUvT(item.path)
   tmp.append((name, item))
  tmp.sort(key=lambda x: x[0].lower())
  lst = []
  for nm, obj in tmp:
   lst.append(obj)
  return lst
 @staticmethod
 def VVvLoF(session):
  title = "Plugins Browser"
  lst = CCF1F0.VVY2TM(PluginDescriptor.WHERE_PLUGINMENU)
  if lst : session.open(CCF1F0, title, lst)
  else : FFZMNU(session, "No plugins found !", title=title)
class CCNm9T(Screen, CCofSh):
 VV0xhz  = "Custom Menu"
 VV0hPw = "ajpanel_menu.xml"
 VV9xwR  = {}
 def __init__(self, session, subFile="", subName="", picpath="", startItem=0):
  self.session  = session
  self.VVDhjuPatt = r"^((?:[A-Fa-f0-9]+(?::|_)){9}(?:[A-Fa-f0-9]+))(.*)"
  self.startItem  = startItem
  self.def_cursor_fg = "#11ffccaa"
  self.def_cursor_bg = "#11442244"
  self.def_title_fg = "#00ffffaa"
  self.def_title_bg = "#0cff0011"
  self.def_body_bg = "#0c001122"
  self.moveCM_data = None
  self.moveCM_win  = None
  self.VV8Iip = {"title": self.VV0xhz, "mode": "list", "width": -1, "height": -1, "fg": "#00ffffff", "bg": self.def_body_bg, "font_size": 30, "align_items": 0, "title_fg": self.def_title_fg, "title_font_size": 50, "cursor_fg": self.def_cursor_fg, "cursor_bg": self.def_cursor_bg, "line_gap": 0.15, "box_gap": 0, "picpath": picpath, "lst": []}
  for k in ("title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg", "shade", "cursor"):
   self.VV8Iip[k] = ""
  if subFile:
   self.filePath = subFile
  else:
   self.filePath = CCNm9T.VVETDa()
   CCNm9T.VV9xwR = {}
  self.subName = subName
  self.err  = self.VVvmqQ(subName)
  self.Title  = self.VV8Iip["title"]
  self.isGrid, self.isStretch, cols, rows = self.VVAb8m(self.VV8Iip["mode"])
  titleBg = self.VV8Iip["title_bg"] or self.def_title_bg
  bodyBg = self.VV8Iip["bg"] if self.VVaoWn(self.VV8Iip["bg"]) else self.def_body_bg
  cursC = self.VV8Iip["cursor"] if self.VVaoWn(self.VV8Iip["cursor"]) else ""
  bGap = self.VV8Iip["box_gap"]
  lblFR = FFPSde(self.VV8Iip["font_size"], 10, 50, 0.4, 0.8)
  w, h, VVNYa4, VVNGHW, VV8IXD, textFg, VVdJm7 = self.VV8Iip["width"], self.VV8Iip["height"], self.VV8Iip["title_font_size"], 15, 15, self.VV8Iip["fg"], self.VV8Iip["font_size"]
  if self.isGrid : self.skin, self.VVuaAL = FFJH4U(VVe7bi, w, h, VVNYa4, VVNGHW, VV8IXD, titleBg, bodyBg, VVdJm7, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":rows, "cols":cols, "picR":0.65, "lblR":0.35, "lblFR":lblFR, "w1R":0.80, "w2R":0.20, "trC":"", "bGap":bGap, "gapX":22, "gapY":22, "mGap":15, "lblFg":textFg, "lblTr":1, "picBgTr":1, "upSBar":True})
  else   : self.skin, self.VVuaAL = FFJH4U(VVkmr2   , w, h, VVNYa4, VVNGHW, VV8IXD, titleBg, bodyBg, VVdJm7, VV1fgG=2, VVO8hC=self.VV8Iip["line_gap"])
  self.VV5dDF = self.VVDqjP() if self.VV8Iip["lst"] else []
  FFfmZP(self, title=self.Title)
  if self.isGrid:
   CCofSh.__init__(self)
  else:
   self["myMenu"] = MenuList(self.VV5dDF, True, eListboxPythonMultiContent)
   self["myMenu"].l.setFont(0, gFont(VVQVcT, self.VVuaAL["VVdJm7"]))
   FFewq4(self, {})
  FFyNtd(self,
  {
   "ok" : self.VVTOku ,
   "cancel": self.cancel ,
   "menu" : self.VVStvw ,
   "info" : self.VVoUXC
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  if self.err:
   CCYl55.VVKxON(self, os.path.basename(self.filePath), self.err, title=self.VV8Iip["title"])
   self.close()
   return
  space = "  "
  if self.isGrid:
   self.VV5IQC(shade=self.VV8Iip["shade"], cursor=self.VV8Iip["cursor"])
   self.VVFM7Z = len(self.VV5dDF)
   self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
   self.VVeRhA(True)
   if self.startItem > 0:
    self.VVsLEr(min(self.startItem, len(self.VV5dDF) - 1))
  else:
   offset = {0: 20, 1: 0, 2: -20}.get(self.VV8Iip["align_items"])
   FFbm8U(self, offset=offset)
   if self.VV8Iip["align_items"] == 2:
    obj = self["keyInfo"].instance
    pos = obj.position()
    obj.move(ePoint(10, pos.y()))
    space = str(u"\u2007")
   self["myTitle"].instance.setHAlign(self.VV8Iip["align_items"])
   self["myMenu"].instance.setTransparent(True)
   FFcfsH(self["myMenu"], self.VV8Iip["fg"])
   FFTDN6(self["myMenu"], fg=self.VV8Iip["cursor_fg"], bg=self.VV8Iip["cursor_bg"])
   try:
    self["myMenu"].instance.setHAlign(self.VV8Iip["align_items"])
   except:
    pass
   if self.startItem > 0:
    self["myMenu"].moveToIndex(min(self.startItem, len(self.VV5dDF) - 1))
  self["myTitle"].setText("%s%s%s" % (space, self.Title, space))
  self.VVYfKz()
 def onExit(self):
  self.VV9Q0U()
 def VVYfKz(self):
  wp = CCNm9T.VVtwnc(self["myWP"], self.VV8Iip["bg"])
  if wp: self["myWP"].show()
  else : self["myWP"].hide()
  if not wp:
   FFu0W6(self["myBody"], self.VV8Iip["bg"] if self.VVaoWn(self.VV8Iip["bg"]) else self.def_body_bg)
  self["myTitle"].instance.setTransparent(False)
  FFcfsH(self["myTitle"], self.VV8Iip["title_fg"] or self.def_title_fg)
  if self.VV8Iip["title_bg"]: FFu0W6(self["myTitle"], self.VV8Iip["title_bg"])
  else      : self["myTitle"].instance.setTransparent(True)
  self["myTitle"].instance.invalidate()
  if self.isGrid:
   fg1, fg2, bg = "#0088ff88", "#00aaaaaa", "#11000a0b"
   self.VV0akf(((self.VV8Iip["title1_fg"] or fg1, self.VV8Iip["title1_bg"] or bg)
         , (self.VV8Iip["title2_fg"] or fg2, self.VV8Iip["title2_bg"] or bg)
         , (self.VV8Iip["num_fg"]   or fg2, self.VV8Iip["num_bg"]  or bg)
         , (self.VV8Iip["num_fg"]   or fg2, self.VV8Iip["num_bg"]  or bg) ))
   if wp:
    for i, bg in enumerate((self.VV8Iip["title1_bg"], self.VV8Iip["title2_bg"], self.VV8Iip["num_bg"], self.VV8Iip["num_bg"])):
     self["myPiconInf%d" % i].instance.setTransparent(False if bg else True)
     self["myPiconInf%d" % i].instance.invalidate()
 def VVTOku(self):
  if self.moveCM_data:
   self.VVGEFN()
  else:
   txt, ref, itemDict = self.VVjdSn()
   fnc = BF(self.VVVkaW, txt, ref, itemDict)
   if "ask" in itemDict:
    FFHsPu(self, fnc, itemDict.get("ask") or "Continue ?", title=txt)
   else:
    fnc()
 def cancel(self):
  if self.moveCM_data:
   self.VV9Q0U()
  else:
   FFW48g()
   self.close()
 def VVStvw(self, title="Options", mode=0):
  c1, c2, c3, c4, c5 = VV6UAe, VVkLs0, VVnQYw, VVcahY, VVCBkQ
  isGrid, _, _, _ = self.VVAb8m(self.VV8Iip["mode"])
  VVXXzc = []
  if mode == 0:
   if self.moveCM_data:
    VVXXzc.append(("Move to current position"    , "movGo" ))
    VVXXzc.append(("Cancel Move"       , "movNot" ))
   else:
    VVXXzc.append((c1 + "Change Current Icon (File Path)" , "icnFil" ))
    VVXXzc.append((c1 + "Change Current Icon (Base64)" , "icnB64" ))
    VVXXzc.append((c1 + "Reset Current Icon (to Default)" , "icnDef" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c2 + "Main Title"      , "ttl"  ))
    if isGrid:
     VVXXzc.append((c2 + "Information Title-1"   , "ttl1" ))
     VVXXzc.append((c2 + "Information Title-2"   , "ttl2" ))
     VVXXzc.append((c2 + "Scroll Page Number"   , "pg"  ))
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c3 + "Shade"      , "gShad" ))
     VVXXzc.append((c3 + "Shade Gap"     , "bGap" ))
     VVXXzc.append((c3 + "Cursor"      , "gCurs" ))
    else:
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c3 + "Cursor"      , "lCurs" ))
    VVXXzc.append((c3 + "Background Color/Wallpaper"  , "wpMnu" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Clear Cached Picture Files"  , "cach" ))
    VVXXzc.append(FFwjWO("Delete Current Item"  , "del"  , isGrid, c4))
    VVXXzc.append(VVzg1X)
    VVXXzc.append(FFwjWO("Move Selected Item"   , "movGo" , isGrid and not self.subName, c5))
    VVXXzc.append((c5 + "Change Current Menu Pictures Path", "pPath" ))
    VVXXzc.append(FFwjWO("Insert Menu XML File"   , "impX" , not self.subName, c5))
   FFw2XU(self, self.VVeB2r, width=800, height=1050, title="Options", VVXXzc=VVXXzc, VVfP2Q=True, VVVzvS="#0a111111", VVhHWW="#0a111111")
  else:
   if mode == 2:
    VVXXzc.append(("Change Wallpaper (File Path)" , "wpFil" ))
    VVXXzc.append(("Change Wallpaper (Base64)" , "wpB64" ))
    VVXXzc.append(("Change to a Color"   , "wpCol" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset Wallpaper"   , "wpRm" ))
   elif mode == 3:
    VVXXzc.append(("Change Picture (File Path)" , "shFil" ))
    VVXXzc.append(("Change Picture (Base64)"  , "shB64" ))
    VVXXzc.append(("Change Picture to default" , "shDef" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Remove Shade"   , "shRm" ))
   elif mode == 4:
    VVXXzc.append(("Change Picture (File Path))" , "crsFil" ))
    VVXXzc.append(("Change Picture (Base64)"  , "crsB64" ))
    VVXXzc.append(("Change Color"     , "crsCol" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset to Default"  , "crsRm" ))
   elif mode == 5:
    VVXXzc.append(("Change Text Color"   , "lColF" ))
    VVXXzc.append(("Change Background Color"  , "lColB" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset to Default"  , "lRm"  ))
   elif mode == 6:
    VVXXzc.append(("Change Text Color"   , "ttlF" ))
    VVXXzc.append(("Change Background Color"  , "ttlB" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset Text Color"  , "ttlRf" ))
    VVXXzc.append((c4 + "Reset Background Color" , "ttlRb" ))
   elif mode == 7:
    VVXXzc.append(("Change Text Color"   , "ttl1F" ))
    VVXXzc.append(("Change Background Color"  , "ttl1B" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset Text Color"  , "ttl1Rf" ))
    VVXXzc.append((c4 + "Reset Background Color" , "ttl1Rb" ))
   elif mode == 8:
    VVXXzc.append(("Change Text Color"   , "ttl2F" ))
    VVXXzc.append(("Change Background Color"  , "ttl2B" ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset Text Color"  , "ttl2Rf" ))
    VVXXzc.append((c4 + "Reset Background Color" , "ttl2Rb" ))
   elif mode == 9:
    VVXXzc.append(("Change Text Color"   , "pgF"  ))
    VVXXzc.append(("Change Background Color"  , "pgB"  ))
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c4 + "Reset Text Color"  , "pgRf" ))
    VVXXzc.append((c4 + "Reset Background Color" , "pgRb" ))
   elif mode == 100:
    for i in range(0, 110, 10):
     VVXXzc.append((str(i)      , "bGap%d" % i))
   else:
    return
   FFw2XU(self, self.VVeB2r, title=title, width=700, VVXXzc=VVXXzc, VVfP2Q=True, VVVzvS="#0a222222", VVhHWW="#0a222222")
 def VVeB2r(self, item=None):
  if item:
   title, ref, ndx = item
   if   ref == "icnFil": self.VVPqZf(title, 1, False)
   elif ref == "icnB64": self.VVPqZf(title, 1, True )
   elif ref == "icnDef": self.VV47nI(title, 1, False, "")
   elif ref == "wpMnu" : self.VVStvw(title, 2)
   elif ref == "wpFil" : self.VVPqZf(title, 2, False)
   elif ref == "wpB64" : self.VVPqZf(title, 2, True )
   elif ref == "wpCol" : self.VVOeGL(title , 2)
   elif ref == "wpRm" : self.VV47nI(title, 2, False, "")
   elif ref == "gShad" : self.VVStvw(title, 3)
   elif ref == "shFil" : self.VVPqZf(title, 3, False)
   elif ref == "shB64" : self.VVPqZf(title, 3, True )
   elif ref == "shDef" : self.VV47nI(title, 3, False, "yes")
   elif ref == "shRm" : self.VV47nI(title, 3, False, "")
   elif ref == "gCurs" : self.VVStvw(title, 4)
   elif ref == "crsFil": self.VVPqZf(title, 4, False)
   elif ref == "crsB64": self.VVPqZf(title, 4, True )
   elif ref == "crsCol": self.VVOeGL(title , 4)
   elif ref == "crsRm" : self.VV47nI(title, 4, False, "")
   elif ref == "lCurs" : self.VVStvw(title, 5)
   elif ref == "lColF" : self.VVOeGL(title , 50)
   elif ref == "lColB" : self.VVOeGL(title , 51)
   elif ref == "lRm" : self.VV47nI(title, 51, False, "")
   elif ref == "ttl" : self.VVStvw(title, 6)
   elif ref == "ttlF" : self.VVOeGL(title , 60)
   elif ref == "ttlB" : self.VVOeGL(title , 61)
   elif ref == "ttlRf" : self.VV47nI(title, 60, False, "")
   elif ref == "ttlRb" : self.VV47nI(title, 61, False, "")
   elif ref == "ttl1" : self.VVStvw(title, 7)
   elif ref == "ttl1F" : self.VVOeGL(title , 70)
   elif ref == "ttl1B" : self.VVOeGL(title , 71)
   elif ref == "ttl1Rf": self.VV47nI(title, 70, False, "")
   elif ref == "ttl1Rb": self.VV47nI(title, 71, False, "")
   elif ref == "ttl2" : self.VVStvw(title, 8)
   elif ref == "ttl2F" : self.VVOeGL(title , 80)
   elif ref == "ttl2B" : self.VVOeGL(title , 81)
   elif ref == "ttl2Rf": self.VV47nI(title, 80, False, "")
   elif ref == "ttl2Rb": self.VV47nI(title, 81, False, "")
   elif ref == "pg" : self.VVStvw(title, 9)
   elif ref == "pgF" : self.VVOeGL(title , 90)
   elif ref == "pgB" : self.VVOeGL(title , 91)
   elif ref == "pgRf" : self.VV47nI(title, 90, False, "")
   elif ref == "pgRb" : self.VV47nI(title, 91, False, "")
   elif ref == "bGap"   : self.VVStvw(title, 100)
   elif ref.startswith("bGap") : self.VVAazT(title, mainAttr=("box_gap", ref[4:]))
   elif ref == "cach" : FFHsPu(self, self.VVMwIs, "Continue ?", title=title)
   elif ref == "del" : FFHsPu(self, BF(self.VVAazT, title, delItem=True), "Continue ?", title=title)
   elif ref == "movGo" : self.VVGEFN()
   elif ref == "movNot": self.VV9Q0U()
   elif ref == "pPath" : self.session.openWithCallback(BF(self.VV2eC6, title), BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=self.VVOT5Q(), width=1200, height=840, pickTitleBG="#11221122", pickBodyBG="#11221122", VVlIBH="#0a552255"))
   elif ref == "impX" : self.session.openWithCallback(BF(self.VVTFcJ, title), BF(CCQdsv, VVmysg="custMnu", VV82pi=self.VVeYcK()))
 def VVGEFN(self):
  title = "Move Selected Item"
  curPos = self.VV6Bsv()
  if not self.moveCM_data:
   self.moveCM_data = self.VVAazT(title, getItem=True)
   pos = self.instance.position()
   x, y = pos.x(), pos.y()
   self.moveCM_win = CCAt9K.VVuHy6(self.session, "Move cursor and click OK", 35, shadW=2, bg="#00880000", x=x, y=y+20)
   FFZV7X(self.moveCM_win, 0)
  else:
   oldNdx, elem = self.moveCM_data
   newNdx, _ = self.VVAazT(title, getItem=True)
   if oldNdx == newNdx:
    FF8PJn(self, "Try another position", 1000)
   else:
    self.VV9Q0U()
    self.VVsLEr(newNdx)
    self.VVAazT(title, moveItem=(oldNdx, newNdx, elem))
 def VV9Q0U(self):
  if self.moveCM_win:
   self.session.deleteDialog(self.moveCM_win)
  self.moveCM_data = self.moveCM_win = None
 def VVOT5Q(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   picP: return picP
  elif xmlP: return xmlP
  else  : return CCNm9T.VVP4uP()
 def VVeYcK(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   xmlP: return xmlP
  elif picP: return picP
  else  : return CCNm9T.VVP4uP()
 def VVTFcJ(self, title, path=None):
  if path:
   FFDDwF(CFG.lastCustMenuXmlDir, os.path.dirname(path))
   err = ""
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      mName = FFOW7Q(elem, "title") or CCNm9T.VV0xhz
      icon, err = self.VVn5ZZ(elem, "icon", False)
      if not err:
       fName = os.path.basename(path)
       if not mName:
        err = "No menu name in:\n\n%s" % fName
       elif fName == CCNm9T.VV0hPw or fName in CCNm9T.VV9xwR.keys():
        err = "File is already used:\n\n%s" % fName
       else:
        el = iElem.Element("item")
        el.set("name", mName)
        if icon:
         el.set("icon", icon)
        el.text = path
        el.tail = "\n\n\t"
        self.VVAazT(title, newElem=el)
     else:
      err = "Invalid Custom Menu file.\n\nCannot get menu name."
     break
   except Exception as e:
    err = "Invalid Custom Menu file.\n\n%s" % str(e)
   if err:
    FFU9uk(self, err, title=title)
 def VVkujI(self, mode):
  return {  1: "icon"
    , 2: "bg"
    , 3: "shade"
    , 4: "cursor"
    , 50: "cursor_fg" , 51: "cursor_bg"
    , 60: "title_fg" , 61: "title_bg"
    , 70: "title1_fg" , 71: "title1_bg"
    , 80: "title2_fg" , 81: "title2_bg"
    , 90: "num_fg"  , 91: "num_bg"
    }.get(mode, "")
 def VVOeGL(self, title, mode):
  attr  = self.VVkujI(mode)
  isBg  = False if attr.endswith("fg") else True
  fg = self.VV8Iip[attr.replace("bg", "fg")]
  bg = self.VV8Iip[attr.replace("fg", "bg")]
  fg = fg if self.VVaoWn(fg) else "#00ffffff"
  bg = bg if self.VVaoWn(bg) else "#00000040"
  self.session.openWithCallback(BF(self.VVK7jj, title, mode), CCYGxc, defFG=fg, defBG=bg, onlyBG=True, isBgMode=isBg)
 def VVK7jj(self, title, mode, fg, bg):
  if fg or bg:
   attr  = self.VVkujI(mode)
   self.VV47nI(title, mode, False, fg if attr.endswith("fg") else bg)
 def VVPqZf(self, title, mode, isB64):
  self.session.openWithCallback(BF(self.VVfFSi, title, mode, isB64), CCQdsv, VVmysg="poster", VV82pi=self.VVOT5Q())
 def VVfFSi(self, title, mode, isB64, path=None):
  if path:
   FFDDwF(CFG.lastCustMenuPicDir, os.path.dirname(path))
   err = self.VVIBs2(path)
   if err : FFU9uk(self, err, title=title)
   else : self.VV47nI(title, mode, isB64, path)
 def VVIBs2(self, path):
  fName = os.path.basename(path)
  try:
   p = LoadPixmap(path)
   if not p:
    return "Unloadable picture file:\n\n%s" % fName
  except Exception as e:
   return "Unloadable picture file:\n\n%s\n\nError : %s" % (fName, str(e))
  return ""
 @FFHF2S()
 def VV47nI(self, title, mode, isB64, path):
  try:
   pathTxt = path
   if isB64 and path:
    ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
    with open(path, "rb") as f:
     pathTxt = str("data:image/%s;base64,%s" % (ext, b64encode(f.read()).decode()))
   isSubmenu = self.subName and (os.path.basename(self.filePath) != os.path.basename(self.subName))
   mainAttr = childAttr = None
   elemID  = parent = ""
   if mode > 1:
    attr = self.VVkujI(mode)
    if isSubmenu: childAttr, elemID = (attr, pathTxt), FFEkBW(self.subName)
    else  : mainAttr = (attr, pathTxt)
   else:
    childAttr=("icon", pathTxt)
    if isSubmenu:
     elemID = self.VV4MhB()
     parent = self.subName
   self.VVAazT(title, mainAttr=mainAttr, childAttr=childAttr, elemID=elemID, parent=parent)
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 def VV2eC6(self, title, path):
  if path:
   FFDDwF(CFG.lastCustMenuPicDir, path)
   self.VVAazT(title, picpath=path)
 def VVAazT(self, title, newElem=None, delItem=False, getItem=False, moveItem=None, picpath="", mainAttr=None, childAttr=None, elemID="", parent=""):
  try:
   head = ""
   xTxt = FF05rJ(self.filePath, encLst="UTF-8")
   ndx = xTxt.find("<ajp_menu")
   if ndx > 0:
    head = xTxt[:ndx]
    xTxt = xTxt[ndx:]
   tree = iElem.ElementTree(iElem.fromstring(xTxt, parser=iElem.XMLParser(target=CCAnLc.CC1gyC())))
   elemID = elemID or self.VV4MhB()
   root = tree.getroot()
   parents = {c:p for p in tree.iter( ) for c in p}
   toSave = False
   if mainAttr:
    att, val = mainAttr
    if val: root.set(att, val)
    else  : root.attrib.pop(att, None)
    toSave = True
   elif picpath:
    toSave = True
    root.set("picpath", picpath)
    p = FFOW7Q(root, "cursor")
    if p.startswith("/"): root.set("cursor", os.path.basename(p))
    p = FFOW7Q(root, "shade")
    if p.startswith("/"): root.set("shade", os.path.basename(p))
    for ndx, elem in enumerate(tree.iter()):
     p = FFOW7Q(elem, "icon")
     if p and not self.VVYmKf(p): elem.set("icon", os.path.basename(p))
     p = FFOW7Q(elem, "bg")
     if p and not self.VVYmKf(p): elem.set("bg", os.path.basename(p))
   elif moveItem:
    oldNdx, newNdx, newElem = moveItem
    if oldNdx != newNdx:
     toSave = True
     for ndx, elem in enumerate(root):
      if ndx == oldNdx:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       break
     root.insert(newNdx, newElem)
   else:
    if not newElem is None or getItem: iterator = root
    else        : iterator = tree.iter()
    for ndx, elem in enumerate(iterator):
     if self.VV9EOX(elem, elemID):
      toSave = True
      if not newElem is None:
       root.insert(ndx, newElem)
      elif delItem:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       else      : toSave = False
      elif getItem:
       return ndx, elem
      elif childAttr:
       if parent and parent != FFOW7Q(parents[elem], "title"):
        continue
       att, val = childAttr
       if val: elem.set(att, val)
       else  : elem.attrib.pop(att, None)
      else:
       toSave = False
      break
    else:
     FFU9uk(self, "Current element not found.", title=title)
     return
   if toSave:
    self.VVEu47(root)
    with open(self.filePath, "w") as f:
     fTxt = str(iElem.tostring(root, encoding="UTF-8").decode())
     line1 = "<?xml version='1.0' encoding='UTF-8'?>\n"
     if fTxt.startswith(line1):
      fTxt = fTxt[len(line1):]
     f.write("%s%s" % (head, fTxt))
    if mainAttr or childAttr: att, val = (mainAttr or childAttr)
    else     : att = val = ""
    if picpath or delItem or not newElem is None or att == "box_gap":
     if delItem:
      txt, ref, itemDict = self.VVjdSn()
      fPath, isMain = self.VVEgLg(ref)
      if fPath:
       fName = os.path.basename(fPath)
       if fName in CCNm9T.VV9xwR.keys():
        CCNm9T.VV9xwR.pop(fName)
     self.close(self.session, self.filePath, self.subName, self.VV6Bsv())
    elif att:
     self.VVFVKV(att, val)
   else:
    FFk1YE(self, "No change", 800)
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 def VVFVKV(self, att, val):
  if self.VVYmKf(val):
   bg, err = self.VV7msB(val)
   if bg: val = bg
   else : return
  if att == "icon":
   self.VV6mM2(val)
   if self.isGrid : self.VVDAhu()
   else   : self["myMenu"].setList(self.VV5dDF)
  else:
   self.VV8Iip[att] = val
   if att in ("bg", "title_fg", "title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
    self.VVYfKz()
   elif att in ("shade"):
    self.VVrTYZ(val)
   elif att in ("cursor"):
    self.VV7yvY(val)
   elif att in ("cursor_fg", "cursor_bg"):
    if   val == ""   : FFTDN6(self["myMenu"], fg=self.def_cursor_fg, bg=val or self.def_cursor_bg)
    elif att == "cursor_fg" : FFTDN6(self["myMenu"], fg=val or self.def_cursor_fg)
    elif att == "cursor_bg" : FFTDN6(self["myMenu"], bg=val or self.def_cursor_bg)
    self["myMenu"].instance.invalidate()
 def VV9EOX(self, elem, compId):
  if   elem.tag == "submenu" : name = FFOW7Q(elem, "title")
  elif elem.tag == "item"  : name = FFOW7Q(elem, "name")
  else      : name = ""
  return name and compId == FFEkBW(name)
 def VV4MhB(self):
  txt, ref, itemDict = self.VVjdSn()
  return itemDict.get("id", "")
 def VV6Bsv(self):
  if self.isGrid : txt, info, ndx, icon = self.VV5dDF[self.VVlBZZ]
  else   : ndx = self["myMenu"].l.getCurrentSelectionIndex()
  return ndx
 def VVjdSn(self):
  return self.VV8Iip["lst"][self.VV6Bsv()]
 def VV6mM2(self, path):
  txt, ref, itemDict = self.VVjdSn()
  itemDict["icon"] = path
  self.VV8Iip["lst"][self.VV6Bsv()] = (txt, ref, itemDict)
  self.VV5dDF = self.VVDqjP()
 def VVoUXC(self):
  txt, ref, itemDict = self.VVjdSn()
  info = itemDict.get("info", "")
  ask  = itemDict.get("ask", "Continue ?") if "ask" in itemDict else ""
  icon = itemDict.get("icon", "")
  tag  = itemDict["tag"]
  fPath, isMain = self.VVEgLg(ref)
  c1 = VV6UAe
  if   self.VVYmKf(ref)   : act1, act2 = "Base64 Image", ref[:60] + " ..."
  elif fPath       : act1, act2 = "External Menu File", fPath
  elif tag == "submenu"    : act1, act2 = "Submenu", ref
  elif ref.startswith("ajp_")   : act1, act2 = "AJPanel Option", ref
  elif iMatch(self.VVDhjuPatt, ref) : act1, act2 = "Play a channel", ref
  elif ref.startswith("/"):
   fExt = os.path.splitext(ref)[1]
   if fExt: fExt = fExt[1:]
   isMedia = fExt in CCf9Gq.VVl1a5()["mov"] or fExt in CCf9Gq.VVl1a5()["mus"]
   isPic = fExt in CCf9Gq.VVl1a5()["pic"]
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
   if span     : act1, act2 = "Execute a Script file", ref
   elif isMedia   : act1, act2 = "Play Media File", ref
   elif isPic    : act1, act2 = "View Picture File", ref
   elif os.path.isdir(ref) : act1, act2 = "Open in File Manager", ref
   elif os.path.isfile(ref): act1, act2 = "Find in File Manager", ref
   else     : act1, act2 = "", ref
  else      : act1, act2 = "Run Command%s" % ("s" if "\n" in ref else ""), ref
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, c1), str(y))
  act = (FFITtK(act1, VVnQYw, c1) if act1 else FFITtK("Path not found", VVcahY, c1))
  s1 = ""
  if info: s1 += ttl("Description", info)
  if icon:
   if self.VVYmKf(icon): icon = icon[:60] + " ..."
   s1 += ttl("Custom Icon", icon)
  s1 += ttl("Action (%s)" % act, VVVAvR + act2)
  s1 += ttl("Source File:", self.filePath)
  FFyijw(self, s1, title=txt)
 def VVDqjP(self):
  menuW = self.VVuaAL["width"] - self.VVuaAL["VVNGHW"] * 2
  lineH = self.VVuaAL["bodyLineH"]
  align = {0: LEFT, 1: CENTER, 2: RIGHT}.get(self.VV8Iip["align_items"])
  gap  = lineH // 8
  pPath = CCUNc6.VVQ490()
  resPath = lambda icn: "%s%s.png" % (VV30Jg, icn)
  VVXXzc = []
  for ndx, (txt, ref, itemDict) in enumerate(self.VV8Iip["lst"]):
   if itemDict["tag"] == "separator":
    if self.isGrid:
     continue
    left = 0
    txt, ref, icon = VVgzFX + SEP, None, None
    isSep = True
   else:
    isSep = False
    icon = itemDict.get("icon", "")
    if not icon:
     fPath, isMain = self.VVEgLg(ref)
     if itemDict["tag"] == "submenu":
      isGrid, isStretch, cols, rows = self.VVAb8m(itemDict.get("mode", ""))
      icon = resPath("menug" if isGrid else "menu")
     elif fPath:
      icon = resPath("menux")
     elif iMatch(self.VVDhjuPatt, ref):
      span = iSearch(self.VVDhjuPatt, ref)
      for ext in ("png", "jpg"):
       picon = "%s%s.%s" % (pPath, span.group(1).rstrip(":_").replace(":", "_").upper(), ext)
       if FFf0vs(picon):
        icon = picon
        break
      else:
       icon = resPath("tv")
     elif ref.startswith("/"):
      fExt = os.path.splitext(ref)[1]
      fExt = fExt[1:] if fExt else fExt
      extLst = CCf9Gq.VVl1a5()
      span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
      if span:
       icon = resPath("scr")
      elif fExt in extLst["mov"] or fExt in extLst["mus"]:
       pathNoExt = os.path.join(os.path.dirname(ref), os.path.join(os.path.dirname(ref), os.path.basename(ref)[:-(len(fExt) + 1)]))
       for ext in ("png", "jpg"):
        poster = "%s.%s" % (pathNoExt, ext)
        if FFf0vs(poster):
         icon = poster
         break
       else:
        icon = resPath("mov" if fExt in extLst["mov"] else "mus")
      elif fExt in extLst["pic"]  : icon = ref if FFf0vs(ref) else resPath("pic")
      elif os.path.isdir(ref)   : icon = resPath("dir")
      elif os.path.isfile(ref)  :
       s = txt.lower()
       if s.startswith("about") : icon = resPath("info")
       else      : icon = resPath("fil")
      else       : icon = resPath("err")
     elif ref.startswith("ajp_")   : icon = resPath("ajp2")
     elif txt.lower().startswith("about"): icon = resPath("info")
     elif "wget" in ref     : icon = resPath("wget")
     else:
      icon = resPath("teln")
   if self.isGrid:
    info = itemDict.get("info", "") or txt
    VVXXzc.append((txt, info, ndx, icon))
   else:
    if   isSep   : x = 0
    elif align == LEFT : x = gap + lineH + lineH // 3
    elif align == CENTER: x = 0
    else    : x = -lineH - gap
    tableRow = [ None if isSep else ndx ]
    tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, x, 0, menuW, lineH, 0, align | RT_VALIGN_CENTER, txt))
    png = FF0T82(icon)
    if png:
     sz = png.size()
     pngW, pngH = sz.width(), sz.height()
     w = h = lineH - 4
     if pngW == pngH: x, y = 0, 2
     else: x, y, w, h = self.VVKT8T(pngW, pngH, lineH - 4, lineH - 4)
     if align == RIGHT:
      x = menuW - w - gap
     if not self.isGrid:
      tableRow.append(CCzs7U.VVUqW9(gap+x, y, w, h, png))
    VVXXzc.append(tableRow)
  if not self.isGrid:
   FFW48g()
  return VVXXzc
 def VVAb8m(self, mode):
  isGrid, isStretch, cols, rows = False, True, 5, 4
  span = iSearch(r"^grid(\d)?(?:_(\d)x(\d))?", mode, IGNORECASE)
  if span:
   isGrid = True
   isStretch = span.group(1) != "1"
   if span.group(2) : cols = FF9BdF(int(span.group(2)), 3, 9)
   if span.group(3) : rows = FF9BdF(int(span.group(3)), 3, 6)
  return isGrid, isStretch, cols, rows
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  row = col = 0
  for ndx in range(f1, f2):
   txt, _, _, icon = self.VV5dDF[ndx]
   pic, lbl = self.VVzYds(row, col)
   self.VV92ci(lbl, txt)
   png = FFbO0w(pic, icon)
   if png:
    boxX, boxY = self.VVDveF[(row, col)]
    pngSz = png.size()
    pngW, pngH = pngSz.width(), pngSz.height()
    if not self.isStretch and self.VVrH8l > pngW and self.VVXbPe > pngH:
     pic.instance.resize(pngSz)
     pic.instance.move(ePoint(boxX + (self.VVrH8l - pngW) // 2, boxY + (self.VVXbPe - pngH) // 2))
    else:
     x, y, w, h = self.VVKT8T(pngW, pngH, self.VVrH8l, self.VVXbPe)
     pic.instance.resize(eSize(*(w, h)))
     pic.instance.move(ePoint(boxX + (self.VVrH8l - w) // 2, boxY + (self.VVXbPe - h) // 2))
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 def VVHjFJ(self):
  txt, info, ndx, icon = self.VV5dDF[self.VVlBZZ]
  self.VVDVSE(txt, info)
 @FFHF2S()
 def VVVkaW(self, txt, ref, itemDict):
  tag = itemDict["tag"]
  fPath, isMain = self.VVEgLg(ref)
  isAbout = txt.lower().startswith("about")
  if fPath:
   if FFf0vs(fPath):
    self.session.openWithCallback(CCNm9T.VVELXN, CCNm9T, subFile=fPath, subName=ref)
   else:
    FFU9uk(self, "Custom Menu file not found:\n\n%s" % fPath, title=txt)
    return
  elif tag == "submenu":
   self.session.openWithCallback(CCNm9T.VVELXN, CCNm9T, subFile=self.filePath, subName=ref, picpath=self.VV8Iip["picpath"])
  elif iMatch(self.VVDhjuPatt, ref):
   span = iSearch(self.VVDhjuPatt, ref)
   VVkcp9 = span.group(1).replace("_", ":").upper() + span.group(2)
   CC2lVw.VVbVSZ(self.session, VV7GTU=VVkcp9)
  elif ref.startswith("/"):
   path = ref
   fExt = os.path.splitext(path)[1]
   if fExt: fExt = fExt[1:]
   if not FFf0vs(path):
    FFU9uk(self, "Path Not found:\n\n%s" % path, title=txt)
    return
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", path, IGNORECASE)
   if span:
    path = span.group(1)
    if FFf0vs(path) : self.session.open(CCz488, VVEkUN=path, VVh54W=True)
    else    : FFbHk5(self, path, title=txt)
   elif fExt in CCf9Gq.VVl1a5()["mov"] or fExt in CCf9Gq.VVl1a5()["mus"]:
    CCQdsv.VVMj5s(self, path)
   elif fExt in CCf9Gq.VVl1a5()["pic"]:
    CCC0Lg.VVESKQ(self, ref)
   elif os.path.isdir(path):
    self.session.open(CCQdsv, mode=CCQdsv.VVp4lf, VVbQPh=path)
   elif os.path.isfile(path):
    if isAbout:
     if CCQdsv.VVAAgR(path) : FFU9uk(self, "Cannot view binary file:\n\n%s" % path, title=txt)
     else        : self.VVzKfB(txt, FF05rJ(path))
    else:
     self.session.open(CCQdsv, mode=CCQdsv.VVp4lf, VVbQPh=path)
   else:
    FFU9uk(self, "Cannot handle path:\n\n%s" % path, title=txt)
  elif ref.startswith("ajp_"):
   s = ref[4:]
   if   s == "fman" : self.session.open(CCQdsv)
   elif s == "iptv" : self.session.open(CCSB3R)
   elif s == "movie" : CCBgul.VVPSpu(self)
   elif s == "chan" : self.session.open(CCAnLc)
   elif s == "chanBr" : CCdo8n.VVhcdr(self)
   elif s == "bouq" : self.session.open(CC5Hkx)
   elif s == "picon" : self.session.open(CCUNc6)
   elif s == "epg"  : self.session.open(CCfClD)
   elif s == "xmltv" : CC2EFP(self)
   elif s == "term" : self.session.open(CCz488)
   elif s == "soft" : self.session.open(CC6pkA)
   elif s == "plugin" : self.session.open(CCJFyo)
   elif s == "plugBr" : CCF1F0.VVvLoF(self.session)
   elif s == "bakup" : self.session.open(CCRex8)
   elif s == "date" : self.session.open(CCWwVN)
   elif s == "net"  : self.session.open(CC5LkQ)
   elif s == "info" : self.session.open(CC6z2a)
   elif s == "inet" : self.session.open(CC5l7M)
   else    : FFU9uk(self, "Option not found in %s" % VVryLp, title=txt)
  elif isAbout:
   self.VVzKfB(txt, ref)
  else:
   if len(ref) > 20000 : FFU9uk(self, "The script exceeds 20,000 characters !\n\nMove the script to a script file.", title=txt)
   else    : self.session.open(CCz488, VVEkUN=ref, VVEU4X="Running Multiple Commands ..." if "\n" in ref else "", VVh54W=True)
 def VVzKfB(self, title, txt):
  FFyijw(self, txt.strip()[:60000], title=title, VV1Wwb=30, width=1600, height=1000, titleBg="#11331144", VVpaQ6="#11440044")
 def VVvmqQ(self, subName):
  try:
   tree = iElem.parse(self.filePath)
  except Exception as e:
   return str(e)
  root = newRoot = tree.getroot()
  self.tmpOtherFiles = []
  for ndx, elem in enumerate(tree.iter()):
   tag = elem.tag
   if tag in ("ajp_menu", "submenu"):
    err = self.VV9iDI(elem)
    if err:
     return err
    if tag == "submenu" and FFOW7Q(elem, "title") == subName:
     newRoot = elem
  txt = "Repeated custom menu file in : %s\nMenu File : %s"
  lst = [elem for elem, count in iCounter((f, el) for f, el in self.tmpOtherFiles).items() if count > 1]
  if lst:
   return txt % lst[0]
  else:
   curF = os.path.basename(self.filePath)
   for mnuF, mnuName in self.tmpOtherFiles:
    if mnuF in CCNm9T.VV9xwR:
     tmpF, tmpName = CCNm9T.VV9xwR[mnuF]
     if tmpF != curF:
      return txt % (mnuName, mnuF)
    else:
     CCNm9T.VV9xwR[mnuF] = (curF, mnuName)
  self.VV8Iip["title"] = (FFOW7Q(newRoot, "title") or self.VV0xhz)
  self.VV8Iip["mode"]  = FFOW7Q(newRoot, "mode").lower()
  self.VV8Iip["picpath"] = FFOW7Q(newRoot, "picpath") or self.VV8Iip["picpath"]
  isGrid, _, _, _ = self.VVAb8m(self.VV8Iip["mode"])
  if isGrid:
   self.VVFkhv("width", newRoot, 600, 1920, "1600")
   self.VVFkhv("height", newRoot, 600, 1080, "900")
  else:
   self.VVFkhv("width", newRoot, 500, 1920, "800")
   self.VVFkhv("height", newRoot, 400, 1080, "1000")
  self.VVFkhv("font_size", newRoot, 10, 50)
  self.VVFkhv("title_font_size", newRoot, 20, 50)
  val = FFOW7Q(newRoot, "line_gap")
  if val.isdigit():
   val = FF9BdF(int(val), 0, 100)
   self.VV8Iip["line_gap"] = FFPSde(val, 0, 100, 0.15, 2)
  val = FFOW7Q(newRoot, "box_gap")
  if val.isdigit():
   val = FF9BdF(int(val), 0, 100)
   self.VV8Iip["box_gap"] = FFPSde(val, 0, 100, 0, 30)
  v = newRoot.attrib.get("align_items", "left")
  if   v == "left" : self.VV8Iip["align_items"] = 0
  elif v == "center" : self.VV8Iip["align_items"] = 1
  elif v == "right" : self.VV8Iip["align_items"] = 2
  bg, err = self.VVn5ZZ(newRoot, "bg", True)
  if   bg : self.VV8Iip["bg"] = bg
  elif err: return err
  if isGrid:
   bg, err = self.VVn5ZZ(newRoot, "cursor", True)
   if   bg : self.VV8Iip["cursor"] = bg
   elif err: return err
   if FFOW7Q(newRoot, "shade").lower() == "yes":
    self.VV8Iip["shade"] = "yes"
   else:
    bg, err = self.VVn5ZZ(newRoot, "shade", False)
    if   bg : self.VV8Iip["shade"] = bg
    elif err: return err
  for attr in ("fg", "title_fg", "title_bg", "cursor_fg", "cursor_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
   self.VVPYbg(attr, newRoot)
  for elem in newRoot:
   itemDict = {"tag": elem.tag}
   if "ask" in elem.attrib  : itemDict["ask"] = FFOW7Q(elem, "ask")
   if "info" in elem.attrib : itemDict["info"] = FFOW7Q(elem, "info")
   name = ""
   if elem.tag == "submenu":
    name = FFOW7Q(elem, "title")
    itemDict["mode"] = FFOW7Q(elem, "mode")
    self.VV8Iip["lst"].append((name, name, itemDict))
   elif elem.tag == "item":
    name = FFOW7Q(elem, "name")
    action = FFMX7D(elem)
    action = "\n".join(list(map(str.strip, action.split("\n"))))
    self.VV8Iip["lst"].append((name, action, itemDict))
   elif elem.tag == "separator":
    self.VV8Iip["lst"].append(("", "", itemDict))
   bg, err = self.VVn5ZZ(elem, "icon", False)
   if   bg : itemDict["icon"] = bg
   elif err: return err
   itemDict["id"] = FFEkBW(name)
 def VV9iDI(self, elem):
  mainName = FFOW7Q(elem, "title") or FFOW7Q(elem, "name") or elem.tag
  curIsSep = False
  nameLst = set()
  tot = 0
  curName = ""
  for ndx, elem in enumerate(elem):
   tag = elem.tag
   if tag == "ajp_menu":
    curIsSep = False
    titl  = curName = FFOW7Q(elem, "title")
    if not titl : return "No Main Title in : %s" % tag
    else  : nameLst.add(titl.lower())
   elif tag == "submenu":
    tot += 1
    curIsSep = False
    titl = curName = FFOW7Q(elem, "title")
    if   not titl    : return "Found submenu with no title."
    elif titl.lower() in nameLst: return "Duplicate submenu title : %s" % titl
    else      : nameLst.add(titl.lower())
   elif tag == "item":
    tot += 1
    curIsSep = False
    name = curName = FFOW7Q(elem, "name")
    action = FFMX7D(elem)
    if   not name : return "Found menu item with no name."
    elif not action : return "No action for : %s" % name
    fPath, isMain = self.VVEgLg(action)
    if fPath:
     curName = FFITtK(curName, VVkLs0)
     if   isMain : return "Do not use the main custom file in : %s\n%s" % (curName, fPath)
     else  : self.tmpOtherFiles.append((os.path.basename(fPath), curName))
   elif tag == "separator":
    tName = curName or mainName
    if   ndx == 0 : return "Cannot use Separator as first menu item in : %s" % tName
    elif curIsSep : return "Consecutive Separators are not allowed after : %s" % tName
    else   : curIsSep = True
   else:
    return "Unknown Tag : %s" % tag
  tName = curName or mainName
  if   tot == 0: return "No menu items found in : %s" % tName
  elif curIsSep: return "Cannot use Separator as last menu item after : %s" % tName
  else   : return ""
 def VVFkhv(self, dItem, elem, Min, Max, default=""):
  if dItem in self.VV8Iip:
   val = elem.attrib.get(dItem, default)
   if val.isdigit():
    self.VV8Iip[dItem] =  FF9BdF(int(val), Min, Max)
 def VVPYbg(self, dItem, elem):
  if dItem in self.VV8Iip:
   val = elem.attrib.get(dItem, "")
   if val and self.VVaoWn(val):
    self.VV8Iip[dItem] = val
    return True
  return False
 def VVn5ZZ(self, elem, attr, canColor):
  bg, err = self.VVfZfU(elem, attr, canColor)
  if err:
   c1, c2, c3, c4 = VVkLs0, VVaR8d, VVsm0W, VVgzFX
   val = FFOW7Q(elem, attr)
   txt  = FFITtK(err, c3) + "\n\n"
   txt += "Check : %s\n" % FFITtK(self.VV8Iip["title"], c1)
   txt += '%s="%s"' % (FFITtK(attr, c2), FFITtK(val if len(val) < 80 else val[:80] + " ...", c4))
   return "", txt
  else:
   return bg, err
 def VVfZfU(self, elem, attr, canColor):
  c1, c2, c3 = VVkLs0, VVaR8d, VVcahY
  val = FFOW7Q(elem, attr)
  if not val:
   return "", ""
  elif canColor and self.VVaoWn(val):
   self.VVPYbg(attr, elem)
   return "", ""
  elif val.endswith((".jpg", ".png")):
   if not val.startswith("/"):
    val = os.path.join(self.VV8Iip["picpath"], val)
   fName = os.path.basename(val)
   fil, ext = os.path.splitext(fName)
   if ext == ".png" and fil in ("ajp", "dnld", "ajp2", "pic", "mov", "tv") and not FFf0vs(val):
    val = VV30Jg + fName
   return val, ""
  elif self.VVYmKf(val):
   return self.VV7msB(val)
  else:
   if canColor : txt = "Value must be a color,"
   else  : txt = "Picture files must be a"
   return "", "%s jpg, png or Base64 format." % txt
 def VV7msB(self, b64):
  span = iSearch(r"data:image\/(.+);base64,(.+)", b64)
  if span:
   cacheDir = CCNm9T.VVpsbc()
   ext, b64 = span.groups()
   pFile = "%s%s.%s" % (cacheDir, FFEkBW(b64), ext.replace("jpeg", "jpg"))
   if FFf0vs(pFile):
    return pFile, ""
   else:
    if not FF6usE("mkdir -p '%s'" % cacheDir):
     return "", "Cannot create icons directory:\n%s" % FFITtK(cacheDir, c1)
    try:
     with open(pFile, "wb") as f:
      f.write(b64decode(b64))
    except Exception as e:
     FFqlCI(pFile)
     return "", "Cannot convert Base64 picture file.\n%s" % str(e)
    try:
     png = LoadPixmap(pFile)
     if png:
      return pFile, ""
     else:
      FFqlCI(pFile)
      return "", "Unloadable picture file (or invalid jpg/png format)"
    except Exception as e:
     FFqlCI(pFile)
     return "", "Unloadable picture file.:\n%s" % str(e)
  else:
   return "",
 def VVEgLg(self, path):
  fName = os.path.basename(path)
  if fName.startswith(CCNm9T.VV0hPw[:-4]):
   isMain = fName == CCNm9T.VV0hPw
   if path.startswith("/") : fPath = path
   else     : fPath = CCNm9T.VVP4uP() + fName
   return fPath, isMain
  else:
   return "", False
 def VVaoWn(self, c):
  return bool(iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", c))
 def VVYmKf(self, txt):
  return bool(iMatch(r"data:image\/.+;base64,.+", txt))
 def VVMwIs(self):
  lst = FFunRV(r"find '%s' -type f \( -name '*.png' -o -name '*.jpg' \)" % CCNm9T.VVpsbc())
  tot = 0
  for f in lst:
   if iMatch(r"(.+_ajp_.+|.+[A-Fa-f0-9]{32})\.(?:png|jpg)$", f):
    tot += 1
    FFqlCI(f)
  if tot > 0 : FFar20(self, "%s deleted" % tot, 2000)
  else  : FF8PJn(self, "No cached files", 1000)
 @staticmethod
 def VVtwnc(pixMap, path, toPng=False):
  newPath = CCHa3c.VVR0sK(pixMap, path, toPng=toPng)
  inst = pixMap.instance
  inst.setScale(1)
  if FFf0vs(newPath):
   inst.setAlphatest(0)
   FFbO0w(pixMap, newPath)
   return newPath
  elif FFf0vs(path):
   inst.setAlphatest(1)
   FFbO0w(pixMap, path)
   return path
  else:
   return ""
 @staticmethod
 def VVP4uP():
  return FFA4GT(CFG.customMenuPath.getValue())
 @staticmethod
 def VVETDa():
  return CCNm9T.VVP4uP() + CCNm9T.VV0hPw
 @staticmethod
 def VVpsbc():
  return CCNm9T.VVP4uP() + "ajpanel_menu/"
 @staticmethod
 def VV9PgW():
  return str(u"\u00A4")
 @staticmethod
 def VVQ894():
  path = CCNm9T.VVETDa()
  cmTitle = CCNm9T.VV0xhz
  mrk = CCNm9T.VV9PgW()
  if FFf0vs(path):
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      cmTitle = FFOW7Q(elem, "title") or CCNm9T.VV0xhz
     break
   except:
    pass
  return "%s %s %s" % (mrk, cmTitle, mrk)
 def VVEu47(self, tree, space="\t", level=0):
  if isinstance(tree, iElem.ElementTree): tree = tree.getroot()
  if not len(tree): return
  indents = ["\n" + level * space]
  def VVjJzY(elem, level):
   chLevel = level + 1
   try:
    chInd = indents[chLevel]
   except IndexError:
    chInd = indents[level] + space
    indents.append(chInd)
   if not elem.text or not elem.text.strip() : elem.text = chInd
   for ch in elem:
    if len(ch)        : VVjJzY(ch, chLevel)
    if not ch.tail or not ch.tail.strip() : ch.tail = chInd
    if len(ch)        : ch.tail = "\n" + chInd
   if not ch.tail.strip()      : ch.tail = indents[level]
  VVjJzY(tree, 0)
 @staticmethod
 def VVVT2N(SELF, VVMjFx=False):
  if VVMjFx: fnc, session = FFHDdB, SELF
  else    : fnc, session = FFTSvN , SELF.session
  path = CCNm9T.VVETDa()
  Dir = os.path.dirname(path)
  fil = os.path.basename(path)
  if not VVrRHR(Dir) : FFZMNU(session, "%s\n\nPlease change %s path in Settings." % (Dir, FFITtK("Custom Menu", VV6UAe)), title="Custom Menu path not found")
  elif FFf0vs(path) : fnc(SELF, BF(session.openWithCallback, CCNm9T.VVELXN, CCNm9T), title="Loading ...")
  else     : FFHsPu(session, BF(fnc, SELF, BF(CCNm9T.VVl28R, session, Dir, fil)), "Try a sample file ?\n\n%s" % path, title="Custom Menu file not found", VVMjFx=True)
 @staticmethod
 def VVl28R(session, Dir, fil):
  if FF6usE("cp -f '%s%s' '%s'" % (VV30Jg, fil, Dir)):
   session.openWithCallback(CCNm9T.VVELXN, CCNm9T)
  else:
   FFZMNU(session, "Cannot copy template file to backup directory.", title=CCNm9T.VV0xhz)
 @staticmethod
 def VVELXN(session=None, subFile="", subName="", startItem=0):
  if session and (subFile or subName):
   FFDiNL(BF(session.openWithCallback, CCNm9T.VVELXN, CCNm9T, subFile=subFile, subName=subName, startItem=startItem))
class CCV3QD(Screen):
 def __init__(self, session, title="", csel=None, VVDhju="", servName="", isFind=False):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, 700, 800, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session     = session
  self.csel      = csel
  self.VVDhju     = VVDhju
  self.servName     = servName
  self.findTxt     = servName
  self.isFindMode     = isFind
  self.VV6LK9  = 0
  self.VVySiH = 1
  self.VVMlDW  = 2
  VVXXzc = []
  VVXXzc.append(("Find in All Service (from filter)" , "VVFUju" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Find in All (Manual Entry)"   , "VVgj8C"    ))
  VVXXzc.append(("Find in TV"       , "VVOKpP"    ))
  VVXXzc.append(("Find in Radio"      , "VVD3QX"   ))
  if self.VVYVaa():
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Hide Channel: %s" % self.servName , "VVLUqo"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Zap History"       , "zapH"      ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("IPTV Tools"       , "iptv"      ))
  VVXXzc.append(("PIcons Tools"       , "PIconsTools"     ))
  VVXXzc.append(("Services/Channels Tools"    , "ChannelsTools"    ))
  VVXXzc.append(("EPG Tools"       , "epgTools"     ))
  FFfmZP(self, VVXXzc=VVXXzc, title=title)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"])
  FFbm8U(self)
  if self.isFindMode:
   self.VVNJgN(self.VVciYU())
 def VVTOku(self):
  item = FFiaTH(self)
  if item is not None:
   if   item == "VVgj8C"    : self.VVgj8C()
   elif item == "VVFUju" : self.VVFUju()
   elif item == "VVOKpP"    : self.VVOKpP()
   elif item == "VVD3QX"   : self.VVD3QX()
   elif item == "VVLUqo"   : self.VVLUqo()
   elif item == "zapH"       : self.session.open(CC48aY)
   elif item == "iptv"       : self.session.open(CCSB3R)
   elif item == "PIconsTools"     : self.session.open(CCUNc6)
   elif item == "ChannelsTools"    : self.session.open(CCAnLc)
   elif item == "epgTools"      : self.session.open(CCfClD)
   if item in ("iptv", "PIconsTools", "ChannelsTools"):
    self.close()
 def VVOKpP(self) : self.VVNJgN(self.VV6LK9)
 def VVD3QX(self) : self.VVNJgN(self.VVySiH)
 def VVgj8C(self) : self.VVNJgN(self.VVMlDW)
 def VVNJgN(self, mode):
  title = "Find %s Service" % ("TV", "Radio", "All")[mode]
  FFttdT(self, BF(self.VVut3P, mode), defaultText=self.findTxt, title=title, message="Enter Name:")
 def VVFUju(self):
  filterObj = CCrT1G(self)
  filterObj.VVMhxB(self.VVncB3)
 def VVncB3(self, item):
  self.VVut3P(self.VVMlDW, item)
 def VVYVaa(self):
  if self.servName.strip() == ""      : return False
  if self.VVDhju.strip()  == ""      : return False
  if self.VVDhju.startswith("1:7:1:0:0:0:0:0:0:0:") : return False
  if FFPrVr(self.VVDhju)        : return False
  return True
 @FFHF2S("Searching ...")
 def VVut3P(self, mode, VV04Z2):
  if VV04Z2:
   VV04Z2 = VV04Z2.strip()
  if VV04Z2:
   self.findTxt = VV04Z2
   CFG.lastFindContextFind.setValue(VV04Z2)
   if   mode == self.VV6LK9  : titlTxt, servTypes = "TV"  , service_types_tv
   elif mode == self.VVySiH : titlTxt, servTypes = "Radio"  , service_types_radio
   else          : titlTxt, servTypes = "All" , "1:7:"
   title = 'Find %s : "%s"' % (titlTxt, VV04Z2)
   if len(title) > 55:
    title = title[:55] + ".."
   VVJwgn = self.VVJmSK(VV04Z2, servTypes)
   if self.isFindMode or mode == self.VVMlDW:
    VVJwgn += self.VVDgrw(VV04Z2)
   if VVJwgn:
    VVJwgn.sort(key=lambda x: x[0].lower())
    VVLj1d = self.VVOtfU
    VVI3Oq  = ("Zap"   , self.VVeo1W    , [])
    VV5CrJ = ("Current Service", self.VVvS6v , [])
    VVbQ6N = ("Options"  , self.VVHCf1 , [])
    VV4dTm = (""    , self.VVqmim , [])
    header   = ("Name" , "Type", "Ref.", "Sat.", "Freq." , "Pol.", "FEC" , "SR" , "Bouq")
    widths   = (38  , 17 , 0  , 10 , 10  , 7  , 8  , 10 , 0.01 )
    VVgKQc  = (LEFT  , CENTER, LEFT  , CENTER, CENTER , CENTER, CENTER, CENTER, CENTER)
    FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VV4dTm=VV4dTm, VV7VIQ=CFG.lastFindContextFind)
   else:
    self.VVNJgN(self.VVciYU())
    FFSQn9(self, "Not found", title=title)
  elif self.isFindMode:
   self.close()
  else:
   self.findTxt = self.servName
 def VVJmSK(self, VV04Z2, servTypes):
  VV5dDF = CCAnLc.VVLOo7(servTypes)
  VVJwgn = []
  if VV5dDF:
   VVUg5o, VVgAfG = FFhJdE()
   tp = CCAAmm()
   words, asPrefix = CCrT1G.VVYDJw(VV04Z2)
   colorYellow  = CCWKcF.VVmivZ(VVaR8d)
   colorWhite  = CCWKcF.VVmivZ(VVHFlX)
   for s in VV5dDF:
    name = s[1]
    for word in words:
     ok = False
     tName = name.lower()
     if asPrefix:
      if tName.startswith(word):
       ok = True
     elif word in tName:
      ok = True
     if ok:
      VVDhju = s[0]
      if VVDhju.count(":") > 8:
       if asPrefix:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, count=1, flags=IGNORECASE)
       else:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, flags=IGNORECASE)
       sat = FFkz1q(VVDhju, False)
       STYPE  = VVDhju.split(":")[2]
       sTypeInt = int(STYPE, 16)
       if sTypeInt in VVUg5o:
        STYPE = VVgAfG[sTypeInt]
       freq, pol, fec, sr, syst = tp.VVFGh6(VVDhju)
       if not "-S" in syst:
        sat = syst
       VVJwgn.append((name, STYPE, VVDhju, sat, freq, pol, fec, sr, ""))
  return VVJwgn
 def VVDgrw(self, VV04Z2):
  VV04Z2 = VV04Z2.lower()
  VVJwgn = []
  colorYellow  = CCWKcF.VVmivZ(VVaR8d)
  colorWhite  = CCWKcF.VVmivZ(VVHFlX)
  for b in CC41Tt.VVSXbP():
   VVzhkp  = b[0]
   VVR9XM  = b[1].toString()
   VVEWiG = eServiceReference(VVR9XM)
   VVq3wX = FFaKV3(VVEWiG)
   for service in VVq3wX:
    VVDhju  = service[0]
    if FFPrVr(VVDhju):
     servName = service[1]
     if VV04Z2 in servName.lower():
      servName = iSub(r"(%s)" % iEscape(VV04Z2), r"%s\1%s" % (colorYellow, colorWhite), servName, flags=IGNORECASE)
      VVJwgn.append((servName, "IPTV", VVDhju, "-", "-", "-", "-", "-", VVzhkp))
  return VVJwgn
 def VVciYU(self):
  mode = CC5Hkx.VVPzfc(default=-1)
  return self.VVMlDW if mode == -1 else mode
 def VVOtfU(self, VV5ybN):
  self.close()
  VV5ybN.cancel()
 def VVeo1W(self, VV5ybN, title, txt, colList):
  FF5deK(VV5ybN.session, colList[2], checkParentalControl=True)
 def VVvS6v(self, VV5ybN, title, txt, colList):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(VV5ybN)
  if VVDhju:
   VV5ybN.VVp9iQ(2, FFKQxn(VVDhju, VVLZ0Z, VVeZBd), True)
 def VVHCf1(self, VV5ybN, title, txt, colList):
  servName = colList[0]
  mSel = CCZALl(self, VV5ybN)
  VVXXzc, cbFncDict = CCAnLc.VVbh8T(self, VV5ybN, servName, 2)
  mSel.VVejOk(VVXXzc, cbFncDict)
 def VVqmim(self, VV5ybN, title, txt, colList):
  Name, Type, Ref, Sat, Freq, Pol, FEC, SR, Bouq = colList
  Name = FFes9J(Name)
  txt  = ""
  txt += "Name\t: %s\n" % Name
  txt += "Type\t: %s\n" % Type
  if Bouq: txt += "Bouquet\t: %s" % Bouq
  if Sat != "-": txt += "Tuner\t: %s" % " ".join((Sat, Freq, Pol, FEC, SR))
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVyuhj, params=(Ref, Name, txt))
 def VVLUqo(self):
  FFHsPu(self, self.VVNh2y, 'Hide "%s" ?' % self.servName, title="Hide Channel")
 def VVNh2y(self):
  ret = FFYzNS(self.VVDhju, True)
  if ret:
   self.VVE48t()
   self.close()
  else:
   FF8PJn(self, "Cannot change state" , 1000)
 def VVE48t(self):
  if self.csel:
   self.csel.servicelist.removeCurrent()
  try: CC48aY.VVgqqJ(self.VVDhju)
  except: CC48aY.VVSvh0()
  if self.VVDhju.count(":") > 8:
   servRef = self.session.nav.getCurrentlyPlayingServiceReference()
   if servRef and self.VVDhju in servRef.toString():
    self.session.nav.stopService()
    if self.csel:
     serviceRef = self.csel.servicelist.getCurrent()
     if serviceRef:
      FFi8da(self.session, serviceRef)
 @staticmethod
 def VVAChB():
  global VVbGhJ
  try:
   VVbGhJ      = ChannelContextMenu.__init__
   ChannelContextMenu.__init__   = CCV3QD.VV2ooA
   ChannelContextMenu.VVh3fm = CCV3QD.VVh3fm
  except:
   pass
 @staticmethod
 def VV2ooA(SELF, session, csel):
  from Components.ChoiceList import ChoiceEntryComponent
  VVbGhJ(SELF, session, csel)
  if CFG.showInChannelListMenu.getValue():
   for ndx, title in enumerate(("Channels Browser", "Find", "Bouquet Editor", "Channels Tools")):
    title = "%s - %s" % (VVryLp, title)
    SELF["menu"].list.insert(ndx, ChoiceEntryComponent(key=" ", text=(title , BF(SELF.VVh3fm, csel, ndx, title))))
 @staticmethod
 def VVh3fm(SELF, csel, mode, title):
  try:
   currSel  = csel.getCurrentSelection()
   VVDhju  = currSel.toString()
   refName  = FFCbnj(VVDhju)
  except:
   VVDhju = refName = ""
  if   mode == 0: CCdo8n.VVhcdr(SELF, SELF.close)
  elif mode == 2: SELF.session.openWithCallback(SELF.close, CC5Hkx)
  else    : SELF.session.openWithCallback(SELF.close, CCV3QD, title=title, csel=csel, VVDhju=VVDhju, servName=refName, isFind=True if mode == 1 else False)
class CC48aY(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 10, 10, 30, 0, 0, "#22004455", "#00ff0000", 30)
  self.session = session
  self.Title  = "Zap History"
  FFfmZP(self)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVvkBQ()
 def cancel(self, VV5ybN):
  VV5ybN.cancel()
  self.close()
 def VVvkBQ(self):
  VVI3vF = InfoBar.instance
  VVJwgn = []
  if VVI3vF:
   VVokbs = VVI3vF.servicelist
   if VVokbs:
    VVUg5o, VVgAfG = FFhJdE()
    for serv in VVokbs.history:
     VVDhju = serv[-1].toString()
     VVeZBd = FFCbnj(VVDhju)
     path = serv[-1].getPath()
     isLocal = path and path.startswith("/")
     isIptv = FFPrVr(VVDhju)
     isSRel = FFOr4F(VVDhju)
     sat = "-" if isIptv and not isSRel or isLocal else FFkz1q(VVDhju, True)
     if isIptv : STYPE = "Stream Relay" if isSRel else "IPTV"
     elif isLocal: STYPE = "Local Media"
     else:
      STYPE  = VVDhju.split(":")[2]
      sTypeInt = int(STYPE, 16)
      if sTypeInt in VVUg5o:
       STYPE = VVgAfG[sTypeInt]
     VVJwgn.append((VVeZBd, sat, STYPE, VVDhju))
  if VVJwgn:
   VVLj1d = self.cancel
   VVI3Oq  = ("Zap"   , self.VVvFhe   , [])
   VVbQ6N = ("Clear History" , self.VVQe9M   , [])
   VV4dTm = (""    , self.VV2cgw , [])
   header   = ("Service Name", "Satellite" , "Type" , "Ref. Code" )
   widths   = (41    , 41   , 18  , 0    )
   VVgKQc  = (LEFT    , LEFT   , CENTER , LEFT   )
   FFdCaM(self, None, title=self.Title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=28, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VVbQ6N=VVbQ6N, VV4dTm=VV4dTm)
  else:
   FFSQn9(self, "Empty", title=self.Title)
   self.close()
 def VVvFhe(self, VV5ybN, title, txt, colList):
  FF5deK(VV5ybN.session, colList[3], checkParentalControl=True)
  self.cancel(VV5ybN)
 def VVQe9M(self, VV5ybN, title, txt, colList):
  FFHsPu(self, BF(self.VVRomv, VV5ybN), "Clear Zap History ?", title=self.Title)
 def VVRomv(self, VV5ybN):
  CC48aY.VVSvh0()
  self.cancel(VV5ybN)
 def VV2cgw(self, VV5ybN, title, txt, colList):
  VVeZBd = colList[0]
  VVDhju = colList[3]
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVgoj6, params=(VVDhju, VVeZBd, txt))
 @staticmethod
 def VVSvh0():
  inst = InfoBar.instance
  csel = inst and inst.servicelist
  if csel:
   csel.history  = []
   csel.history_pos = 0
 @staticmethod
 def VVgqqJ(VVDhju):
  if not VVDhju: return
  servRef = eServiceReference(VVDhju)
  VVI3vF = InfoBar.instance
  if VVI3vF:
   VVokbs = VVI3vF.servicelist
   if VVokbs:
    hList = VVokbs.history
    newList = []
    for rec in hList:
     for servRef in rec:
      if VVDhju in servRef.toString():
       break
     else:
      newList.append(rec)
    if newList:
     oldLen = len(hList)
     newLen = len(newList)
     diff = oldLen - newLen
     if not diff == 0:
      pos = VVokbs.history_pos - diff
      if pos > newLen -1 : pos = newLen - 1
      if pos < 0   : pos = 0
      VVokbs.history  = newList
      VVokbs.history_pos = pos
class CC5Hkx(Screen):
 def __init__(self, session, VVDhju="", servName=""):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 10, 10, 30, 0, 0, "#ff000000", "#ff000000", 30)
  self.session = session
  self.Title  = "Bouquet Editor"
  self.pPath  = CCUNc6.VVQ490()
  self.bTables = []
  FFfmZP(self)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVLiUv()
 def VVFGWG(self, tbl, bName, bRef):
  self.bTables.append(tbl)
  tbl.bouqName = bName
  tbl.bouqRef  = bRef
  self.VVt1yi(tbl)
 def VVLiUv(self):
  rootStr = CC5Hkx.VVNjDQ()
  rows = self.VVcAW8(rootStr)
  if rows :
   self.VVgsLh(self, "Main Bouquets List", rootStr, rows)
   VVDhju, refName, rootRef, rootName, inBouquet, rootSrc = CCdo8n.VVe8dV()
   if not self.bTables[-1].VVdP7o({3:VVDhju}):
    self.bTables[-1].VVdP7o({3:rootRef})
  else:
   FFU9uk(self, "No bouquets Found !", title=self.Title)
   self.close()
 def VV43sr(self):
  self.bTables[-1].cancel()
  if len(self.bTables) > 0: del self.bTables[-1]
  if not len(self.bTables): self.close()
 def VVcAW8(self, bRef=None):
  blkLst = CC5Hkx.VVOh7z()
  rows = []
  for ndx, row in enumerate(FFaKV3(eServiceReference(bRef), mode=1), start=1):
   ref, name, flags = row
   fTxt, fColor = CC5Hkx.VV3Xzd(flags)
   lck = "1" if CC5Hkx.VVI0kr(ref, blkLst) > -1 else ""
   rows.append((str(ndx), "", fColor + name, ref, fTxt, str(flags), lck))
  return rows
 def VVgsLh(self, selfObj, bName, bRef, rows):
  totTbl = len(self.bTables)
  title = {0:"Main Bouquets List", 1:"%s %s" % (FFITtK("Fav: ", VVVAvR), bName), 2:"%s %s" % (FFITtK("Sub: ", VVVAvR), bName)}.get(totTbl, bName)
  bg  = {0:"#11002233", 1:"#0a112222"}.get(totTbl, "#0a131111")
  VVLj1d = self.VVXMBb
  VVzH0q = self.VVSOft
  VV4dTm = (""     , self.VVZM2Y   , [])
  VVI3Oq  = ("Enter Bouquet"  , self.VVUiVI  , [])
  VVEyDE = ("Delete"    , self.VVXySJ  , [])
  VV5CrJ = ("Bouquets Importer" , self.VVV4H0 , [])
  VVbQ6N = ("Options"   , self.VVqJUZ  , [])
  VVvrJb = ("Move Here"   , self.VV1h2S  , [])
  VVLQWC  = (1, self.VVrW11, None)
  widths  = (12   , 7   , 81 , 0  , 0   , 0   , 0   )
  VVgKQc = (CENTER  , CENTER , LEFT , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFdCaM(self, None, title=title, VV5dDF=rows, VVgKQc=VVgKQc, width=1500, height=1000, VV1PTZ=widths, VV1Wwb=28, VVq6oU=False, VV4dTm=VV4dTm, VVI3Oq=VVI3Oq, VVLj1d=VVLj1d, VVzH0q=VVzH0q, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVrpeX=True, VVylFd=2, VVLQWC=VVLQWC, VV7VIQ=CFG.lastFindServices
     , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#0a005566", VVaqdB=0, VVsOjr="#11330000")
  tbl.VVIl4g(BF(self.VVSOft, tbl))
  self.VVFGWG(tbl, bName, bRef)
 def VVLrEW(self, VV5ybN, mutableList, tot, jumpDict=None):
  if tot:
   if mutableList:
    mutableList.flushChanges()
   FFfve1()
   rows = self.VVcAW8(VV5ybN.bouqRef)
   if rows:
    VV5ybN.VVUVWk()
    VV5ybN.VVxhz9(rows, isSort=False, VVK0Fc=BF(self.VVjCLe, jumpDict))
   else:
    self.VV43sr()
    totTbl = len(self.bTables)
    FF8PJn(self.bTables[-1] if totTbl > 0 else self, "Empty List !", 1500)
  else:
   FFk1YE(VV5ybN, "No change !", 1500)
 def VVjCLe(self, jumpDict, VV5ybN, title, txt, colList):
  if jumpDict:
   VV5ybN.VVdP7o(jumpDict)
 def VVSOft(self, VV5ybN):
  VV5ybN["keyRed"].hide()
  VV5ybN["keyBlue"].hide()
  if VV5ybN.VVbbT0:
   if VV5ybN.VVQrKf() > 0:
    VV5ybN["keyRed"].show()
    VV5ybN["keyBlue"].show()
  else:
   VV5ybN["keyRed"].show()
  self.VVt1yi(VV5ybN)
 def VVt1yi(self, VV5ybN):
  if len(self.bTables) == 1 and not VV5ybN.VVyPTg():
   VV5ybN.VVW6Cx()
  else:
   VV5ybN.VVcilR()
 def VVZM2Y(self, VV5ybN, title, txt, colList):
  c1, c2, c3 = VVaR8d, VVi4ay, VVcahY
  ttl = lambda x, y, color=c1: "%s:\n%s\n\n" % (FFITtK(x, color), y) if y else ""
  num, picon, name, ref, rem, flags, lck = colList
  path = CC5Hkx.VVyhp8(ref, mode=1)
  txt  = ttl("Name"    , name)
  txt += ttl("Bouquet File"  , path if path.startswith("/") else "")
  txt += ttl("Parent Bouquet"  , VV5ybN.bouqName, c2)
  txt += ttl("Parent Bouquet File", CC5Hkx.VVyhp8(VV5ybN.bouqRef, mode=1), c2)
  txt += ttl("Ref."    , ref, c3) if VVpSLv else ""
  txt += ttl("Remarks"   , rem, c3) if VVpSLv else ""
  path = CCUNc6.VVjFPF(self.pPath, ref, name)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVoTT4, params=(txt, path))
 @FFHF2S(par=1)
 def VVUiVI(self, VV5ybN, title, txt, colList):
  maxLev = 2
  num, picon, name, ref, rem, flags, lck = colList
  flags = CC5Hkx.VVim8o(ref)
  if FFDGYu(ref):
   if len(self.bTables) <= maxLev:
    rows = self.VVcAW8(ref)
    if rows : self.VVgsLh(VV5ybN, name, ref, rows)
    else : FFk1YE(VV5ybN, "Empty list !", 1500)
   else:
    FFU9uk(self, "Maximum Level of Recursive Bouquets (%d) !" % maxLev, title=self.Title)
  elif flags & 64:
   FFk1YE(VV5ybN, "Cannot play markers", 500)
  else:
   FF5deK(self.session, ref)
   FFb7ob(self, "Cancel to go back to table")
 def VVXMBb(self, VV5ybN):
  self.VV43sr()
 def VVqJUZ(self, VV5ybN, title, txt, colList):
  VVXXzc = []
  iMulSel = VV5ybN.VVyPTg()
  sortItem = ("Sort", )
  if iMulSel:
   tot = VV5ybN.VVQrKf()
   if tot > 1: sortItem = ("Sort", "sort")
   isSel = tot > 0
   bTxt = "Bouquet%s" % FFEnJs(tot)
  else:
   isSel = True
   bTxt = "Bouquet"
  inMain = len(self.bTables) == 1
  okToMain = False
  if not inMain:
   for ref in self.VVcjNe(VV5ybN):
    if not FFDGYu(ref) and not ref.startswith("1:64:"): break
   else:
    okToMain = True
  totDel = len(self.VVN3f0())
  c1, c2, c3, c4 = VVi4ay, VVnQYw, VV6UAe, VVcahY
  VVXXzc.append(FFwjWO("Rename"   , "renm" , not iMulSel, c1))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Add Marker"  , "mrkr" , not iMulSel, c2))
  VVXXzc.append(FFwjWO("Add Empty Bouquet", "addBouq" , not iMulSel and inMain, c2))
  if totDel:
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c4 + 'Delete %d Unused ".del" Bouquets File%s' % (totDel, FFEnJs(totDel)), "unused"))
  if inMain:
   VVVzvS, VVhHWW = "#22001122", "#22000a15"
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Hide %s" % bTxt , "hidOn" , isSel, c3))
   VVXXzc.append(FFwjWO("Unhide %s" % bTxt , "hidOff" , isSel, c3))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Protect %s" % bTxt , "lckOn" , isSel, c3))
   VVXXzc.append(FFwjWO("Unprotect %s" % bTxt , "lckOff" , isSel, c3))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(FFwjWO("Save Selected %s to M3U File" % bTxt , "toM3u", isSel, c2))
   VVXXzc.append((c1 + "Fix Local Media Path (ALL Bouquets)"   , "fixMed"))
   VVXXzc.append((c1 + "Set Local Media PIcons (ALL Bouquets)"  , "fixPic"))
  else:
   VVVzvS, VVhHWW = "#2200120a", "#2200120a"
  VVXXzc.append(VVzg1X)
  VVXXzc.append(sortItem)
  VVXXzc.append(FFwjWO("Copy to Main Bouquets List" , "toMain", okToMain))
  VVXXzc.append(FFwjWO("Copy to a Bouquet"   , "toBouq", isSel))
  cbFncDict = { "renm" : BF(self.VV1t32  , VV5ybN)
     , "fixMed" : BF(self.VVPcty, VV5ybN)
     , "fixPic" : BF(self.VV6WAH, VV5ybN)
     , "toM3u" : BF(self.VVUHhI , VV5ybN)
     , "mrkr" : BF(self.VVruIe , VV5ybN)
     , "addBouq" : BF(self.VVsF7A, VV5ybN)
     , "unused" : BF(self.VVMSG7 , VV5ybN)
     , "hidOn" : BF(self.VVbRXY  , VV5ybN, True)
     , "hidOff" : BF(self.VVbRXY  , VV5ybN, False)
     , "lckOn" : BF(self.VVepIS  , VV5ybN, True)
     , "lckOff" : BF(self.VVepIS  , VV5ybN, False)
     , "sort" : BF(self.VVyV4U  , VV5ybN)
     , "toMain" : BF(self.VVrh2J , VV5ybN)
     , "toBouq" : BF(self.VVWNnb , VV5ybN) }
  mSel = CCZALl(self, VV5ybN)
  mSel.VVejOk(VVXXzc, cbFncDict, height=1000, VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVO8hC=0.08)
 def VVXySJ(self, VV5ybN, title, txt, colList):
  txt, totSel = "", 0
  if VV5ybN.VVyPTg():
   totSel = VV5ybN.VVQrKf()
   if totSel:
    txt = "Delete %s item%s" % (FFITtK(totSel, VVaR8d), FFEnJs(totSel))
  else:
   num, picon, name, ref, rem, flags, lck = colList
   txt = "Delete : %s" % FFITtK(name, VVaR8d)
  if txt:
   FFHsPu(self, BF(self.VV5RR8, VV5ybN), "%s\n\nContinue ?" % txt, title=self.Title)
 def VVV4H0(self, VV5ybN, title, txt, colList):
  CC9j6t.VVLTQG(self, cbFnc=BF(self.VVr4Uf, VV5ybN))
 def VVr4Uf(self, VV5ybN):
  self.VVLrEW(VV5ybN, None, 1)
 @FFHF2S(par=1)
 def VV5RR8(self, VV5ybN):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  if mutableList is not None:
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.removeService(serv):
     tot += 1
     bFile = CC41Tt.VV790N(ref)
     if bFile:
      bFile = VVHX6T + bFile
      FF6usE("rm -f '%s' '%s.del'" % (bFile, bFile))
   self.VVLrEW(VV5ybN, mutableList, tot)
 @FFHF2S(par=1)
 def VV1h2S(self, VV5ybN, title, txt, colList):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  if mutableList is not None:
   curNdx = VV5ybN.VVfkJL()
   if curNdx <= VV5ybN.VV4e0j(): lst = reversed(lst)
   else             : curNdx -= 1
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVLrEW(VV5ybN, mutableList, tot)
 @FFHF2S(par=1)
 def VVyV4U(self, VV5ybN):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  if mutableList is not None:
   nmlst = VV5ybN.VVaOdg(2)
   lst = list(zip(nmlst, lst))
   lst.sort(key=lambda x: x[0].lower())
   curNdx = VV5ybN.VV4e0j()
   tot = 0
   for name, ref in reversed(lst):
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVLrEW(VV5ybN, mutableList, tot)
 def VV1t32(self, VV5ybN, item=None):
  name = VV5ybN.VVqY3Q()[2]
  FFttdT(self, BF(self.VVNvwa, VV5ybN), defaultText=name, title="Rename", message="Enter new name")
 def VVNvwa(self, VV5ybN, name):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  if name and csel and mutableList:
   name = name.strip()
   if name:
    ref = VV5ybN.VVqY3Q()[3]
    if FFDGYu(ref):
     CC41Tt.VVUDZY(ref, name)
    else:
     serv = eServiceReference(ref)
     if serv.valid():
      serv.setName(name)
      mutableList.removeService(serv)
      mutableList.addService(serv)
      mutableList.moveService(serv, VV5ybN.VVfkJL())
    self.VVLrEW(VV5ybN, mutableList, 1)
 def VVPcty(self, VV5ybN):
  title = "Fix Media Path (for All Bouquets)"
  newP = FFA4GT(CFG.MovieDownloadPath.getValue())
  txt = FFITtK("/media/.../movie/", VVaR8d)
  FFHsPu(self, BF(FFTSvN, VV5ybN, BF(self.VVPULr, title, newP)), "Change Media path (%s) to:\n\n%s" % (txt, newP), title=title)
 def VVPULr(self, title, newP):
  totF = totRepl = 0
  for path in CC41Tt.VVyuHO():
   txt = FF05rJ(path)
   exp = iCompile(r"(\/media\/.+\/movie\/)", IGNORECASE)
   lst = set()
   for Str in exp.findall(txt):
    if Str != newP:
     lst.add(Str)
   save = False
   for Str in lst:
    txt, tot = exp.subn(newP, txt)
    totRepl += tot
    save = True
   if save:
    totF += 1
    with open(path, "w") as f:
     f.write(txt)
  if totF or totRepl:
   txt  = "Total Files\t: %s\n"  % totF
   txt += "Total Fixes\t: %s\n"  % totRepl
   FFyijw(self, txt, title=title)
   FFfve1()
  else:
   FFSQn9(self, "All OK (no changes).", title=title)
 def VV6WAH(self, VV5ybN):
  title = "Fix Movies PIcons"
  if FFsGnd("ffmpeg"):
   FFHsPu(self, BF(self.VVMzpV, VV5ybN, title), "Set PIcons to local media services (from posters) ?", title=title)
  else:
   FFHsPu(self, BF(CCSB3R.VVkD2h, self), '"FFmpeg" is required for this process.\n\nInstall FFmpeg ?', title=title)
 @FFHF2S(par=1)
 def VVMzpV(self, VV5ybN, title):
  lst = []
  for bPath in CC41Tt.VVyuHO():
   txt = FF05rJ(bPath)
   exp = iCompile(r"#SERVICE\s+((?:[a-f0-9]+:){10})(\/.+):(.+)", IGNORECASE)
   piconPath = CCUNc6.VVQ490()
   for ref, path, VVeZBd in exp.findall(txt):
    for ext in ("jpg", "png"):
     poster = "%s.%s" % (os.path.splitext(path)[0], ext)
     picon = piconPath + ref.strip(":").replace(":", "_").upper() + ".png"
     if FFf0vs(poster) and not FFf0vs(picon):
      lst.append((poster, picon))
  if len(lst) :
   CCXRxc.VVJ9VK(self
       , VVCJhW  = BF(self.VV949I, title, lst)
       , VVuQkS = BF(self.VVhMZy, title, len(lst)))
  else:
   FFSQn9(self, "Nothing to fix", title=title)
 def VV949I(self, title, lst, VVM2wn):
  VVM2wn.VVqMKy(len(lst))
  VVM2wn.VViN1g = 0
  for poster, picon in lst:
   if not VVM2wn or VVM2wn.isCancelled: return
   VVM2wn.VVwOHf(1)
   if FF6usE("cp -f '%s' '%s'" % (poster, picon)):
    if FF6usE(CCISy5.VVomfz(picon)):
     if not VVM2wn or VVM2wn.isCancelled: return
     VVM2wn.VViN1g += 1
    else:
     FFqlCI(picon)
 def VVhMZy(self, title, tot, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  FFSQn9(self, "Added PIcons = %s" % VViN1g, title=title)
 @FFHF2S(par=1)
 def VVUHhI(self, VV5ybN):
  if VV5ybN.VVbbT0 : rows = VV5ybN.VVwKf5()
  else        : rows = [VV5ybN.VVqY3Q()]
  bName = rows[0][2]
  outF = "%s%s_%s.m3u" % (FFY5i9(), FF80BW(bName), FF6eWd())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for num, picon, name, ref, rem, flags, lck in rows:
    if ref and name and rem == "Directory":
     for chR, chNm, chFlags in FFaKV3(eServiceReference(ref), mode=1):
      if chR and chNm:
       chR = chR.replace(":" + chNm, "").strip()
       span = iSearch(r'^((?:[A-Fa-f0-9]+:){10})(.*)', chR, IGNORECASE)
       if span:
        totCh += 1
        ref, url = span.groups()
        url = FF0rS9(url)
        url = url or ref
        if FFOr4F(url):
         url = ref + url
        f.write('#EXTINF:-1 group-title="%s",%s\n' % (name, chNm))
        f.write("%s\n" % url)
  title = "Save to M3U File"
  if totCh:
   totB = len(rows)
   FFSQn9(self, "Exported %s Channel%s (from %s Bouquet%s) to:\n\n%s" % (totCh, FFEnJs(totCh), totB, FFEnJs(totB), outF), title=title)
  else:
   FFU9uk(self, "Nothing to save.", title=title)
   FFqlCI(outF)
 @FFHF2S(par=1)
 def VVruIe(self, VV5ybN):
  name = "%s Marker %s" % ("=" * 7, "=" * 7)
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  if mutableList is not None:
   curServ = eServiceReference(VV5ybN.VVqY3Q()[3])
   cnt = tot = 0
   while mutableList:
    serv = eServiceReference("1:64:%d:0:0:0:0:0:0:0::%s" % (cnt, name))
    if curServ and curServ.valid():
     if not mutableList.addService(serv, curServ):
      csel.servicelist.addService(serv, True)
      tot += 1
      break
    elif not mutableList.addService(serv):
     csel.servicelist.addService(serv, True)
     tot += 1
     break
    cnt += 1
   self.VVLrEW(VV5ybN, mutableList, tot)
 def VVsF7A(self, VV5ybN):
  names = VV5ybN.VVlL5a(2)
  name = "Bouquet-1"
  num = 0
  while name in names:
   num += 1
   name = "Bouquet-%s" % num
  FFttdT(self, BF(self.VV0zn5, VV5ybN), defaultText=name, title="New Bouquet", message="Enter Bouquet name")
 def VV0zn5(self, VV5ybN, name=None):
  if name and name.strip():
   self.VVBwTJ(VV5ybN, name.strip())
 @FFHF2S(par=1)
 def VVBwTJ(self, VV5ybN, bName):
  CC41Tt.VViR6s(bName)
  self.VVLrEW(VV5ybN, None, 1, jumpDict={2:bName})
 def VVN3f0(self):
  lst = []
  for fil in os.listdir(VVHX6T):
   if fil.endswith(".tv.del") or fil.endswith(".radio.del"):
    lst.append(fil)
  return lst
 def VVMSG7(self, VV5ybN):
  lst = self.VVN3f0()
  for fil in lst:
   FFqlCI(VVHX6T + fil)
  VV5ybN.VVjSys("Done")
 def VVcjNe(self, VV5ybN):
  if VV5ybN.VVbbT0 : return VV5ybN.VVaOdg(3)
  else        : return [VV5ybN.VVqY3Q()[3]]
 def VVrh2J(self, VV5ybN):
  dstFile = "bouquets.%s" % ("tv" if CC5Hkx.VVPzfc() == 0 else "radio")
  self.VV0BMo(VV5ybN, "Main Bouquets List", dstFile, True)
 def VVWNnb(self, VV5ybN):
  bRows = CC41Tt.VVuaoj()
  lst = self.VVcjNe(VV5ybN)
  VVXXzc = []
  for name, ref in bRows:
   if not ref in lst:
    VVXXzc.append((name, ref))
  if VVXXzc : FFw2XU(self,  BF(self.VVMhjc, VV5ybN), VVXXzc=VVXXzc, width=1100, height=900, VVVzvS="#22220000", VVhHWW="#22110000", title="Destination Bouquet", VVfP2Q=True)
  else  : FF8PJn(VV5ybN, "No bouquets left !", 1000)
 def VVMhjc(self, VV5ybN, item=None):
  if item:
   bName, bRef, ndx = item
   dstFile = CC41Tt.VV790N(bRef)
   self.VV0BMo(VV5ybN, bName, dstFile)
 @FFHF2S(par=1)
 def VV0BMo(self, VV5ybN, bName, dstFile, mainToo=False):
  lst = self.VVcjNe(VV5ybN)
  tot = 0
  for ref in lst:
   ok = CC41Tt.VVe71H(ref, dstFile)
   if ok:
    tot += 1
  self.VVLrEW(VV5ybN, None, tot)
  if mainToo:
   rootStr = CC5Hkx.VVNjDQ()
   rows = self.VVcAW8(rootStr)
   self.bTables[0].VVxhz9(rows)
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFITtK(x, VV6UAe), y)
  txt  = ttl("Source Bouquet"  , VV5ybN.bouqName)
  txt += ttl("Destination Bouquet", bName)
  txt += ttl("Copied Services" , tot)
  FFyijw(VV5ybN, txt, title="Copy Services")
 @FFHF2S(par=1)
 def VVbRXY(self, VV5ybN, isHide):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  mode = CC5Hkx.VVPzfc()
  path = VVHX6T + "bouquets.%s" % ("tv" if mode==0 else "radio")
  if FFf0vs(path):
   tot = 0
   lines = list(map(str.strip, FF2iRW(path)))
   for ref in lst:
    if FFDGYu(ref):
     ref = "#SERVICE " + ref
     nrm = ref.replace("1:519:", "1:7:")
     hid = ref.replace("1:7:"  , "1:519:")
     if isHide: r1, r2 = nrm, hid
     else  : r1, r2 = hid, nrm
     if r1 in lines:
      ndx = lines.index(r1)
      lines[ndx] = r2
      tot += 1
   if tot:
    with open(path, "w") as f:
     for line in lines:
      f.write("%s\n" % line)
    self.VVLrEW(VV5ybN, None, tot)
 @FFHF2S(par=1)
 def VVepIS(self, VV5ybN, isLck):
  lst, mutableList, csel, bServ = self.VVj4mB(VV5ybN)
  blkLst = CC5Hkx.VVOh7z()
  tot = 0
  for ref in lst:
   if FFDGYu(ref):
    ndx = CC5Hkx.VVI0kr(ref, blkLst)
    if isLck:
     if ndx == -1:
      ref = ref.replace("1:519:", "1:0:").replace("1:7:", "1:0:")
      blkLst.append(ref)
      tot += 1
    else:
     if ndx > -1:
      blkLst[ndx] = ""
      tot += 1
  if tot:
   with open(VVlCrP, "w") as f:
    for line in blkLst:
     if line.strip():
      f.write("%s\n" % line)
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   self.VVLrEW(VV5ybN, None, tot)
 def VVj4mB(self, VV5ybN, bServ=None):
  lst = self.VVcjNe(VV5ybN)
  mutableList = csel = None
  VVI3vF = InfoBar.instance
  if VVI3vF:
   csel = VVI3vF.servicelist
   if csel:
    if not bServ:
     bServ = eServiceReference(VV5ybN.bouqRef)
    if bServ.valid():
     mutableList = csel.getMutableList(bServ)
  return lst, mutableList, csel, bServ
 def VVrW11(self, colList):
  num, picon, name, ref, rem, flags, lck = colList
  png = lambda x: "%s%s.png" % (VV30Jg, x)
  if   rem == "Marker"   : return png("mrk1")
  elif rem == "Numbered Marker" : return png("mrk2")
  elif rem == "Group"    : return png("grp")
  elif FFDGYu(ref):
   if   lck == "1" and rem == "Invisible" : return png("dirLckInvis")
   elif lck == "1"       : return png("dirLck")
   elif rem == "Invisible"     : return png("dirInvis")
   else         : return png("dir1")
  else:
   return CCUNc6.VVjFPF(self.pPath, ref, name)
 @staticmethod
 def VV3Xzd(flag):
  t = c = ""
  try:
   if   flag & eServiceReference.isInvisible  : t, c = "Invisible"  , "#f#00ff7722#"
   elif flag & eServiceReference.isNumberedMarker : t, c = "Numbered Marker" , "#f#00ffffaa#"
   elif flag & eServiceReference.isGroup   : t, c = "Group"   , "#f#00bbffbb#"
   elif flag & eServiceReference.isMarker   : t, c = "Marker"   , "#f#00ffffaa#"
   elif flag & eServiceReference.isDirectory  : t, c = "Directory"  , ""
  except:
   pass
  return t, c
 @staticmethod
 def VVyhp8(ref, mode=0):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   path = serv.getPath()
   if path and not VVpSLv:
    path = iSub(r"[&?]mode=.+end=", r"", path, flags=IGNORECASE)
   if mode == 1:
    span = iSearch(r'FROM\s+BOUQUET\s+"(.+)"\s+ORDER\s+BY\s+bouquet', path, IGNORECASE)
    if span:
     path = VVHX6T + span.group(1)
  return path
 @staticmethod
 def VVim8o(ref):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   return serv.flags
  return -1
 @staticmethod
 def VVPzfc(default=0):
  VVI3vF = InfoBar.instance
  if VVI3vF:
   csel = VVI3vF.servicelist
   if csel:
    return csel.mode
  return default
 @staticmethod
 def VVNjDQ():
  VVI3vF = InfoBar.instance
  if VVI3vF:
   csel = VVI3vF.servicelist
   if csel:
    return csel.bouquet_rootstr
  return ""
 @staticmethod
 def VVOh7z():
  return FF2iRW(VVlCrP) if FFf0vs(VVlCrP) else []
 @staticmethod
 def VVI0kr(ref, lst=None):
  if not lst:
   lst = CC5Hkx.VVOh7z()
  if FFDGYu(ref):
   ref1 = ref.replace("1:7:", "1:0:")
   ref2 = ref.replace("1:519:", "1:0:")
   if   ref1 in lst: return lst.index(ref1)
   elif ref2 in lst: return lst.index(ref2)
  return -1
class CCUNc6(Screen, CCofSh, CClqOe):
 VVwzkY   = 0
 VVrld1  = 1
 VVUXtl  = 2
 VVjFaT  = 3
 VVM9kR  = 4
 VVbwyA  = 5
 VVlaa4  = 6
 VV367A = 7
 VVxliL = 8
 VV0gvd = 9
 VVoRFI = 10
 VVXXPh  = 11
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVKSTX, 1800, 950, 30, 0, 0, "#22201000", "#33000000", 30, VVZ3ZU=40, VV1fgG=2, VVKMHf=20, VVZ5LV={"rows":4, "cols":7, "picR":0.75, "lblR":0.25, "w1R":0.45, "w2R":0.55, "gapX":10, "gapY":10})
  self.session   = session
  self.Title    = "PIcons Tools"
  self.pPath    = CCUNc6.VVQ490()
  self.curChanName  = ""
  self.curChanFile  = ""
  self.curChanIndex  = -1
  self.curChanRefCode  = 0
  self.curChanIptvRef  = ""
  self.VV5dDF    = []
  self.nsList    = set()
  self.lastSortCol  = 0
  self.lastMode   = 0
  self.lastWords   = ['']
  self.lastAsPrefix  = False
  self.lastTimeStamp  = 0
  self.lastSTypeList  = []
  self.lastFind   = ""
  self.filterTitle  = ""
  self.firstTime   = True
  self.rTypeLst   = set()
  FFfmZP(self, self.Title)
  FFrvOP(self["keyRed"] , "OK = Zap")
  FFrvOP(self["keyYellow"], "Page Options")
  FFrvOP(self["keyBlue"] , "Filter")
  CCofSh.__init__(self, CFG.transpColorPicons)
  CClqOe.__init__(self)
  FFyNtd(self,
  {
   "ok"  : self.VVaYq3     ,
   "green"  : self.VV4a7C    ,
   "yellow" : self.VVIanZ     ,
   "blue"  : self.VVbNU9     ,
   "menu"  : self.VV0MdO     ,
   "info"  : self.VVO6La    ,
   "cancel" : self.close
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  if self.firstTime:
   self.firstTime = False
   FF1uow(self)
   FFE1T7(self)
   FFu0W6(self["keyRed"], "#0a333333")
   self.VV5IQC()
   self.VVchi3("Loading ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, VV1V0y=True)
  else:
   self.VVVet3()
   self.VVHjFJ()
 def VV0MdO(self):
  if not self.VVq1GA:
   c1, c2 = VV8QGw, VVnQYw
   VVXXzc = []
   VVXXzc.append(("Statistics"          , "VVK7Gm"    ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c1 + "Suggest PIcons for Current Channel"   , "VVhiH1"   ))
   VVXXzc.append((c2 + "Set to Current Channel (copy file)"   , "VVSLOO_file"  ))
   VVXXzc.append((c2 + "Set to Current Channel (as SymLink)"   , "VVSLOO_link"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Export Current File Names List"     , "VVxi8a" ))
   VVXXzc.append(CCUNc6.VVJ98d())
   VVXXzc.append(VVzg1X)
   c, cond = VVu50a, self.filterTitle == "PIcons without Channels"
   VVXXzc.append(FFwjWO("Move Unused PIcons to a Directory", "VVvTkY" , cond, c ))
   VVXXzc.append(FFwjWO("DELETE Unused PIcons"    , "VVZ6nJ" , cond, c ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Delete Broken PIcons SymLinks (in PIcons Directory)" , "VV52Mn"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc += CCUNc6.VVXCd0()
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Change Poster/Picon Transparency Color"    , "VVu35y" ))
   VVXXzc.append(("Keys Help"           , "VV5tQO"    ))
   FFw2XU(self, self.VVFJs1, width=1100, height=1050, title=self.Title, VVXXzc=VVXXzc, VVVzvS="#22001020", VVhHWW="#22001020")
 def VVFJs1(self, item=None):
  if item is not None:
   if   item == "VVK7Gm"    : self.VVK7Gm()
   elif item == "VVhiH1"   : self.VVhiH1()
   elif item == "VVSLOO_file"  : self.VVSLOO(0)
   elif item == "VVSLOO_link"  : self.VVSLOO(1)
   elif item == "VVxi8a"  : self.VVxi8a()
   elif item == "VVStbS"  : CCUNc6.VVStbS(self)
   elif item == "VVvTkY"   : self.VVvTkY()
   elif item == "VVZ6nJ"  : self.VVZ6nJ()
   elif item == "VV52Mn"  : self.VV52Mn()
   elif item == "VV6cOK"  : CCUNc6.VV6cOK(self)
   elif item == "findPiconBrokenSymLinks" : CCUNc6.VV1PjS(self, True)
   elif item == "FindAllBrokenSymLinks" : CCUNc6.VV1PjS(self, False)
   elif item == "VVu35y" : self.VVu35y()
   elif item == "VV5tQO"     : FFpIdO(self, "_help_picons", "PIcons Tools (Keys Help)")
 def VVIanZ(self):
  if not self.VVq1GA:
   VVXXzc = []
   VVXXzc.append(("Go to First PIcon"  , "VVC7oq"  ))
   VVXXzc.append(("Go to Last PIcon"   , "VVEqam"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Sort by Channel Name"     , "sortByChan" ))
   VVXXzc.append(("Sort by File Name"  , "sortByFile" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Find from File List .." , "VVjmrb" ))
   FFw2XU(self, self.VVtBrh, title=self.Title, VVXXzc=VVXXzc)
 def VVtBrh(self, item=None):
  if item is not None:
   if   item == "VVC7oq"   : self.VVC7oq()
   elif item == "VVEqam"   : self.VVEqam()
   elif item == "sortByChan"  : self.VVgmbI(2)
   elif item == "sortByFile"  : self.VVgmbI(0)
   elif item == "VVjmrb"  : self.VVjmrb()
 def VVjmrb(self):
  VVXXzc = []
  for item in self.VV5dDF:
   VVXXzc.append((item[0], item[0]))
  FFw2XU(self, self.VVLtJJ, title='PIcons ".png" Files', VVXXzc=VVXXzc, VVfP2Q=True)
 def VVLtJJ(self, item=None):
  if item:
   txt, ref, ndx = item
   self.VVsLEr(ndx)
 def VVaYq3(self):
  if not self.VVq1GA and self["keyRed"].getVisible():
   filName, VVDhju, VVeZBd, sat, inDB = self.VVlzxv()
   if VVDhju:
    CC2lVw.VVbVSZ(self.session, VV7GTU=VVDhju)
 def VV4a7C(self):
  if self["keyGreen"].getVisible():
   self.VVsLEr(self.curChanIndex)
 def VVgmbI(self, col):
  reverseSort = self.lastSortCol == col
  self.lastSortCol = col
  self.VVchi3("Sorting ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, reverseSort=reverseSort)
 def VVSLOO(self, mode):
  title = "Change Current Channel PIcon"
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  curChF = "%s%s.png" % (self.pPath, VVDhju.replace(":", "_"))
  if VVDhju:
   filName, VVDhju, VVeZBd, sat, inDB = self.VVlzxv()
   selPiconF = "%s%s"  % (self.pPath, filName)
   if not curChF == selPiconF:
    if FFf0vs(curChF):
     VVXXzc = []
     VVXXzc.append(("Overwrite current PIcon"    ,  "overwrite" ))
     VVXXzc.append(('Rename current PIcon to ".bak.png"' ,  "backup" ))
     FFw2XU(self, BF(self.VVphtu, mode, curChF, selPiconF), VVXXzc=VVXXzc, title="Current Channel PIcon (already exists)")
    else:
     self.VVphtu(mode, curChF, selPiconF, "overwrite")
   else:
    FFU9uk(self, "Cannot change PIcon to itself !", title=title)
  else:
   FFU9uk(self, "Could not read current channel info. !", title=title)
 def VVphtu(self, mode, curChF, selPiconF, item=None):
  if item is not None:
   cmd  = ""
   if item == "backup" : cmd += "mv -f '%s' '%s';" % (curChF, curChF + ".bak.png")
   else    : cmd += "rm -f '%s';" % curChF
   if mode == 0: cmd += "cp -f '%s' '%s'" % (selPiconF, curChF)
   else  : cmd += "ln -sf '%s' '%s'" % (selPiconF, curChF)
   FF6usE(cmd)
   self.VVchi3("PIcon Changed.\nRefreshing ...", goToFirst=False)
 def VVvTkY(self):
  defDir = FFA4GT(CCUNc6.VVQ490() + "picons_backup")
  FF6usE("mkdir '%s'" % defDir)
  self.session.openWithCallback(BF(self.VV21tt, defDir), BF(CCQdsv
         , mode=CCQdsv.VVx2Yd, VV82pi=CCUNc6.VVQ490()))
 def VV21tt(self, defDir, path):
  if len(path) > 0:
   title = "Move Unused PIcons"
   if path == CCUNc6.VVQ490():
    FFU9uk(self, "Cannot move to same directory !", title=title)
   else:
    if not FFA4GT(path) == FFA4GT(defDir):
     self.VVF9Se(defDir)
    FFHsPu(self, BF(self.VVvl1m, title, defDir, path), "Move %d files to:\n\n%s" % (len(self.VV5dDF), path), title=title)
  else:
   self.VVF9Se(defDir)
 @FFHF2S("Moving Files ...")
 def VVvl1m(self, title, defDir, toPath):
  if not iMove:
   self.VVF9Se(defDir)
   FFU9uk(self, "Module not found:\n\nshutil", title=title)
   return
  toPath = FFA4GT(toPath)
  pPath = CCUNc6.VVQ490()
  err  = ""
  totOK = 0
  for fName, fType, VVeZBd, sat, inDB in self.VV5dDF:
   if fName:
    fName += ".png"
    From = "%s%s" % (pPath, fName)
    try:
     iMove(From, "%s%s" % (toPath, fName))
     totOK +=1
    except Exception as e:
     err  = "\nError while moving the file:\n   %s\n\n" % From
     err += "Error:\n   %s" % str(e)
     break
  txt  = "Files\t: %d\n" % len(self.VV5dDF)
  txt += "Moved\t: %d\n" % totOK
  txt += err
  FFyijw(self, txt, title=title, VVpaQ6="#22330000" if err else "#22002020")
  if totOK > 0:
   self.VVAluA("all")
 def VVF9Se(self, defDir):
  try:
   os.rmdir(defDir)
  except:
   pass
 def VVZ6nJ(self):
  title = "Delete Unused PIcons"
  tot = len(self.VV5dDF)
  FFHsPu(self, BF(self.VV4tGz, title), "Delete %s unused PIcon file%s ?" % (tot, FFEnJs(tot)), title=title)
 @FFHF2S("Deleting Files ...")
 def VV4tGz(self, title):
  pPath = CCUNc6.VVQ490()
  totErr = 0
  for fName, fType, VVeZBd, sat, inDB in self.VV5dDF:
   if fName:
    fName = "%s%s.png" % (pPath, fName)
    try:
     os.remove(fName)
    except:
     totErr += 1
  tot = len(self.VV5dDF)
  txt  = "Found\t: %d\n"  % tot
  txt += "Deleted\t: %d\n" % (tot - totErr)
  if totErr:
   txt += "Errors\t: %s" % FFITtK(totErr, VVcahY)
  FFyijw(self, txt, title=title)
 def VV52Mn(self):
  lines = FFunRV("find -L '%s' -type l -print" % self.pPath)
  if lines:
   tot = len(lines)
   FFHsPu(self, BF(self.VV030x, lines), "\n".join(lines), title="Delete %d Broken SymLink%s ?" % (tot, FFEnJs(tot)), VVys8X=True)
  else:
   FFSQn9(self, "No broken SymLinks in:\n\n%s" % self.pPath)
 def VV030x(self, fList):
  FF6usE("find -L '%s' -type l -delete" % self.pPath)
  FFSQn9(self, "Files deleted:\n\n%s" % "\n".join(fList), title=self.Title)
 @FFHF2S()
 def VVO6La(self):
  if self.VVq1GA:
   return
  txt = ""
  filName, VVDhju, VVeZBd, sat, inDB = self.VVlzxv()
  if filName:
   path = self.pPath + filName
   txt += FFITtK("PIcon Directory:\n", VVi4ay)
   txt += "  Path\t: %s\n"  % self.pPath
   target = FF7Qtj(self.pPath)
   if target:
    txt += "  Target\t: %s\n" % target
   txt += "\n"
   target = FF7Qtj(path)
   txt += FFITtK("PIcon File:\n", VVi4ay)
   if target:
    txt += "  SymLink\t: %s\n"   % filName
    txt += "  Target File\t: %s\n" % (os.path.dirname(target) + "/" + os.path.basename(target))
   else:
    txt += "  File\t: %s\n" % filName
   txt += "\n"
   slLst = []
   if not os.path.islink(FFHP0y(path)):
    OrigRealPath = os.path.realpath(path)
    for fName in os.listdir(self.pPath):
     fPath = os.path.join(self.pPath, fName)
     if os.path.islink(FFHP0y(fPath)):
      fRealPath = os.path.realpath(fPath)
      if fRealPath == OrigRealPath:
       slLst.append(fRealPath)
    if slLst:
     tot = len(slLst)
     txt += FFITtK("Found %d SymLink%s to this file from:\n" % (tot, FFEnJs(tot)), VVi4ay)
     for fPath in slLst:
      txt += "  %s\n" % FFITtK(fPath, VVVAvR)
     txt += "\n"
   if VVeZBd:
    txt += FFITtK("Channel:\n", VVi4ay)
    if VVDhju:
     txt += "  Reference\t: %s\n" % (VVDhju)
    txt += "  Channel\t: %s\n" % FFITtK(VVeZBd, VV8QGw)
    if sat and not sat == "IPTV":
     txt += "  Satellite\t: %s" % sat
   elif not slLst:
    txt += FFITtK("Remarks:\n", VVi4ay)
    txt += "  %s\n" % FFITtK("Unused", VVcahY)
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVeEZ1, title="Picon Info", params=(VVDhju, VVeZBd, txt, self.pPath + filName))
 def VVlzxv(self):
  fName = VVDhju = VVeZBd = sat = inDB = ""
  if self.VVlBZZ > -1 and self.VVlBZZ < self.VVFM7Z:
   fName, fType, VVeZBd, sat, inDB = self.VV5dDF[self.VVlBZZ]
   if fName.count("_") > 8 : VVDhju = fName.replace("_", ":").upper()
   else     : VVDhju = ""
   fName += ".png"
   sat  = FFYWFN(sat)
  return fName, VVDhju, VVeZBd, sat, inDB
 def VVVet3(self):
  vLst = ("myPiconF", "myPiconBG", "myPiconPic")
  for v in vLst: self[v].hide()
  self["keyGreen"].hide()
  self.curChanName = ""
  self.curChanFile = ""
  self.curChanIndex = -1
  self.curChanRefCode = ""
  self.curChanIptvRef = ""
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  if VVDhju:
   self.curChanRefCode = VVDhju
   self.curChanName = VVeZBd
   self.curChanIptvRef = VVLZ0Z
   path = CCUNc6.VVjFPF(self.pPath, VVDhju, VVeZBd)
   if path:
    self.curChanFile = os.path.splitext(os.path.basename(path))[0]
    if FFbO0w(self["myPiconPic"], path):
     for v in vLst: self[v].show()
    for ndx, item in enumerate(self.VV5dDF):
     if item[0] == self.curChanFile:
      self.curChanIndex = ndx
      if self.curChanFile.startswith(os.path.splitext(VVDhju)[0].replace(":", "_")) : txt = "Current Service"
      else                   : txt = "Current PIcon"
      self["keyGreen"].show()
      self["keyGreen"].setText(txt)
      break
 def VVHjFJ(self):
  title = "  " + self.Title
  if self.filterTitle:
   title += "  ..  Filter = " + self.filterTitle
  if len(title) > 65:
   title = title[:65] + ".."
  self["myTitle"].setText(title)
  tabLft = " " * 4
  filName, VVDhju, VVeZBd, sat, inDB = self.VVlzxv()
  fNum = "Num. : %d / %d" % (self.VVlBZZ + 1, self.VVFM7Z)
  page = "Page: %d / %d"  % (self.VVZqoj + 1, self.VVvADQ)
  self["myPiconInf0"].setText(FFITtK("%s%s%s%s" % (tabLft, fNum, " " * 12, page), VVi4ay))
  self["myPiconInf1"].setText("%sFile : %s" % (tabLft, filName))
  self["myPiconInf2"].setText("%sRef. : %s" % (tabLft, self.VVlzxv()[1]))
  if self.curChanIptvRef : typ = "Stream Relay" if FFOr4F(self.curChanIptvRef) else "IPTV"
  else     : typ = "Current Ch."
  self["myPiconInf3"].setText("%s%s : %s" % (tabLft, typ, FFITtK(self.curChanName, VVaR8d)))
  self["myPiconInf4"].setText("%sFile : %s\n" % (tabLft, (self.curChanFile + ".png")))
  self["myPiconInf5"].setText("%sRef. : %s" % (tabLft, self.curChanRefCode))
  filName, VVDhju, VVeZBd, sat, inDB = self.VVlzxv()
  if inDB and not sat == "IPTV" : self["keyRed"].show()
  else       : self["keyRed"].hide()
 @FFHF2S()
 def VVK7Gm(self):
  VVUg5o, VVgAfG = FFhJdE()
  sTypeNameDict = {}
  for key, val in VVgAfG.items():
   sTypeNameDict[key] = 0
  totUsedFiles = 0
  totUsedLinks = 0
  totSymLinks  = 0
  totInDB   = 0
  totNoRefCode = 0
  totNoSType  = 0
  sTypeDict  = {}
  for fName, fType, VVeZBd, sat, inDB in self.VV5dDF:
   if VVeZBd:
    if fType == 0 : totUsedFiles += 1
    else   : totUsedLinks += 1
   if fType == 1:
    totSymLinks += 1
   if inDB == 1:
    totInDB += 1
   span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
   if span:
    stNum = int(span.group(1), 16)
    if stNum in VVgAfG: sTypeDict[VVgAfG[stNum]] = sTypeDict.get(VVgAfG[stNum], 0) + 1
    else     : totNoSType += 1
   else:
    totNoRefCode += 1
  totBrokSL = FFhWCj("find -L '%s' -type l -print | wc -l" % self.pPath)
  VVJwgn = []
  c = "#b#11003333#"
  VVJwgn.append((c + "PIcons" , "%d\tUsed = %s" % (self.VVFM7Z, totUsedFiles + totUsedLinks)))
  VVJwgn.append((c + "Files" , "%d\tUsed = %s" % (self.VVFM7Z - totSymLinks, totUsedFiles)))
  VVJwgn.append((c + "SymLinks" , "%d\tUsed = %s" % (totSymLinks, totUsedLinks)))
  c = "#b#11004040#"
  VVJwgn.append((c + "In Database (lamedb)"  , str(totInDB)))
  VVJwgn.append((c + "Not In Database (lamedb)" , str(self.VVFM7Z - totInDB)))
  VVJwgn.append((c + "Satellites"    , str(len(self.nsList))))
  VVJwgn.append((c + "Broken SymLinks"   , str(totBrokSL)))
  if totNoRefCode : VVJwgn.append((c + "File name is not a Reference Code" , str(totNoRefCode)))
  if totNoSType : VVJwgn.append((c + "Unknown Service Type"    , str(totNoSType)))
  s = "Service Type "
  if sTypeDict:
   sTypeRows = []
   for key, val in sTypeDict.items():
    sTypeRows.append(("Service Type (%s)" % key, str(val)))
   sTypeRows.sort(key=lambda x: x[0].lower())
   VVJwgn.extend(sTypeRows)
  FFdCaM(self, None, title=self.Title, VV5dDF=VVJwgn, VV1Wwb=28, VVI4UA="#00003333", VVcv6F="#00222222")
 def VVxi8a(self):
  if self.filterTitle:
   txt = FFFoIQ(self.filterTitle, r"_")
   txt = "FilteredBy_%s_" % FF7h5n(txt, "_")
  else:
   txt = "All_"
  path = "%sPIconsList_%s%s.txt" % (FFg1mx(), txt, FF6eWd())
  with open(path, "w") as f:
   for fName, fType, VVeZBd, sat, inDB in self.VV5dDF:
    f.write("%s%s.png\n" % (self.pPath, fName))
  FFSQn9(self, "List exported to file:\n\n%s" % path, title=self.Title)
 def VVbNU9(self):
  if not self.VVq1GA:
   VVXXzc = []
   VVXXzc.append(("All"        , "all"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Used by Channels"     , "used" ))
   VVXXzc.append(("Unused PIcons"     , "unused" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("PIcons Files (no SymLinks)"  , "pFiles" ))
   VVXXzc.append(("SymLinks to PIcons"    , "pLinks" ))
   VVXXzc.append(("PIcons Files Targeted by SymLinks", "pTargets"))
   VVXXzc.append(("By Files Date ..."    , "pDate" ))
   VVXXzc.append(("By Service Type ..."    , "servType"))
   if self.rTypeLst:
    VVXXzc.append(("Reference Type ..."   , "rType" ))
   if self.nsList:
    VVXXzc.append(FFAiun("Satellites (Reference in PIcon name)"))
    satsHex = list(self.nsList)
    satsHex.sort()
    for sHex in satsHex:
     val = int(sHex, 16)
     if val > 0:
      sat = FFhCU0(val)
      VVXXzc.append((sat, "__s__" + sHex + "__sat__" + sat))
   filterObj = CCrT1G(self)
   filterObj.VVoKta(VVXXzc, self.nsList, self.VV7md9)
 def VV7md9(self, item=None):
  if item is not None:
   self.VVAluA(item)
 def VVAluA(self, item=None):
   if   item == "all"    : mode, words, self.filterTitle = self.VVwzkY   , ""  , ""
   elif item == "used"    : mode, words, self.filterTitle = self.VVrld1   , ""  , "PIcons with Channels"
   elif item == "unused"   : mode, words, self.filterTitle = self.VVUXtl  , ""  , "PIcons without Channels"
   elif item == "pFiles"   : mode, words, self.filterTitle = self.VVjFaT  , ""  , "PIcons Files"
   elif item == "pLinks"   : mode, words, self.filterTitle = self.VVM9kR  , ""  , "SymLinks"
   elif item == "pTargets"   : mode, words, self.filterTitle = self.VVbwyA  , ""  , "Targets"
   elif item == "pDate"   : mode, words, self.filterTitle = self.VV0gvd , ""  , "Date"
   elif item == "servType"   : mode, words, self.filterTitle = self.VVoRFI , ""  , "Service Type"
   elif item == "rType"   : mode, words, self.filterTitle = self.VVXXPh  , ""  , "Reference Type"
   elif item.startswith("__s__") : mode, words, self.filterTitle = self.VVlaa4   , item[5:].split("__sat__")[0] , item[5:].split("__sat__")[1]
   elif item.startswith("__w__") : mode, words, self.filterTitle = self.VV367A , item[5:] , item[5:]
   else       : return
   asPrefix = self.lastAsPrefix
   if mode == self.VVbwyA:
    words = []
    pngFiles = self.pPath + "*.png"
    lines = FFunRV("find %s -type l | while read -r FILE; do if [ -L \"$FILE\" ] && [ -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=\"\";print}' | xargs; fi; done" % pngFiles)
    if lines:
     for f in lines:
      fName = FFVUvT(f)
      if fName.endswith(".png"):
       fName = fName[:-4]
       words.append(fName)
    if not words:
     FF8PJn(self, "Not found", 1000)
     return
   elif mode == self.VV0gvd:
    self.VVCoe6(mode)
    return
   elif mode == self.VVoRFI:
    self.VV2GI2(mode)
    return
   elif mode == self.VVXXPh:
    err = self.VVpjvM(mode, self.filterTitle)
    if err: FF8PJn(self, "No valid Reference Type", 1000)
    return
   elif mode == self.VVxliL:
    return
   else:
    words, asPrefix = CCrT1G.VVYDJw(words)
   if not words and mode in (self.VVlaa4, self.VV367A):
    FF8PJn(self, "Incorrect filter", 2000)
   elif not self.lastMode == mode or not self.lastWords == words or not self.lastAsPrefix == asPrefix:
    self.VVchi3("Filtering ...", mode=mode, words=words, asPrefix=asPrefix)
 def VVCoe6(self, mode):
  VVXXzc = []
  VVXXzc.append(("Today"   , "today" ))
  VVXXzc.append(("Since Yesterday" , "yest" ))
  VVXXzc.append(("Since 7 days"  , "week" ))
  FFw2XU(self, BF(self.VVxs54, mode), VVXXzc=VVXXzc, title="Filter by Added/Modified Date")
 def VVxs54(self, mode, item=None):
  if item:
   if   item == "today": stamp, self.filterTitle = FFjgCu(0) , "Today"
   elif item == "yest" : stamp, self.filterTitle = FFjgCu(-1), "Yesterday"
   elif item == "week" : stamp, self.filterTitle = FFjgCu(-7), "Last 7 Days"
   self.filterTitle = "File Date (%s)" % self.filterTitle
   if not self.lastMode == mode or not self.lastTimeStamp == stamp:
    self.VVchi3("Filtering ...", mode=mode, timeStamp=stamp)
 def VVpjvM(self, mode, title):
  FFw2XU(self, BF(self.VVY2do, mode), VVXXzc=[(x,x) for x in sorted(list(self.rTypeLst))], width=400, title=title)
 def VVY2do(self, mode, rt=None):
  if rt and (mode, [rt]) != (self.lastMode, self.lastWords):
   self.VVchi3("Filtering ...", mode=mode, words=[rt])
 def VV2GI2(self, mode):
  VVUg5o, VVgAfG = FFhJdE()
  lst = set()
  for key, val in VVgAfG.items():
   lst.add(val)
  VVXXzc = []
  for item in lst:
   VVXXzc.append((item, item))
  VVXXzc.sort(key=lambda x: x[0])
  FFw2XU(self, BF(self.VVJ81w, mode), VVXXzc=VVXXzc, title="Filter by Service Type")
 def VVJ81w(self, mode, item=None):
  if item:
   VVUg5o, VVgAfG = FFhJdE()
   sTypeList = []
   for key, val in VVgAfG.items():
    if item == val:
     self.filterTitle = val
     sTypeList.append(("%01x" % key).upper())
   if not self.lastMode == mode or not self.lastSTypeList == sTypeList:
    self.VVchi3("Filtering ...", mode=mode, sTypeList=sTypeList)
 def VVhiH1(self):
  CCXRxc.VVJ9VK(self
      , VVCJhW  = self.VVzA8j
      , VVuQkS = self.VVIXgX)
 def VVzA8j(self, VVM2wn):
  VVzpSM, err = CCAnLc.VV0Bni(self, CCAnLc.VVXIul, VVAomI=False, VVw9e0=False)
  files = []
  words = []
  if not VVM2wn or VVM2wn.isCancelled:
   return
  VVM2wn.VViN1g = []
  VVM2wn.VVqMKy(len(VVzpSM))
  if VVzpSM:
   curCh = self.VV0ApM(self.curChanName)
   for VVDhju in VVzpSM:
    if not VVM2wn or VVM2wn.isCancelled: return
    VVM2wn.VVwOHf(1, True)
    VVeZBd, sat, inDB = VVzpSM.get(VVDhju, ("", "", 0))
    ratio = CCUNc6.VVZ29q(VVeZBd.lower(), curCh)
    if ratio > 50:
     allPath, fName, VVPug6, pList = CCUNc6.VVbFI5(VVDhju.replace("_", ":"), self.curChanName, addSimilar=True)
     if pList:
      for f in pList:
       f = FFVUvT(f)
       fil = f.replace(".png", "")
       if not VVM2wn or VVM2wn.isCancelled: return
       if not fil in VVM2wn.VViN1g:
        VVM2wn.VViN1g.append(fil)
 def VVIXgX(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if VViN1g : self.VVchi3("Loading ...", mode=self.VVxliL, words=VViN1g)
  else   : FF8PJn(self, "Not found", 2000)
 @FFHF2S(tNdx=1)
 def VVchi3(self, wTxt, mode=0, words=None, asPrefix=False, reverseSort=False, VV1V0y=False, goToFirst=True, timeStamp=None, sTypeList=None):
  if not self.VVXSXd(VV1V0y):
   return
  self.VVq1GA = True
  VVw9e0 = True if VV1V0y else False
  VVzpSM, err = CCAnLc.VV0Bni(self, CCAnLc.VVXIul, VVAomI=False, VVw9e0=VVw9e0)
  if err:
   self.close()
  VVQI2u = self.VVmnpl()
  tList = []
  for fName, fType in CCUNc6.VVaXg8(self.pPath):
   fName = fName[:-4]
   namSp = ""
   if fName.count("_") > 8 and VVzpSM:
    if fName in VVzpSM:
     VVeZBd, sat, inDB = VVzpSM.get(fName)
     VVeZBd = VVeZBd or "?"
     namSp = fName.split("_")[6].zfill(8)[:4]
     if VV1V0y and namSp: self.nsList.add(namSp)
    elif fName in VVQI2u:
     VVeZBd = VVQI2u.get(fName) or "?"
     sat, inDB = "IPTV", 1
    else:
     VVeZBd, sat, inDB = "", "", 0
    if VV1V0y:
     span = iSearch(r"^([a-f0-9]+)(?:_[a-f0-9]+){9}", fName, IGNORECASE)
     if span: self.rTypeLst.add(span.group(1))
   else:
    VVeZBd, sat, inDB = "", "", 0
   entry = (fName, fType, VVeZBd, sat, inDB)
   isAdd = False
   if mode == self.VVwzkY              : isAdd = True
   elif mode == self.VVrld1  and VVeZBd         : isAdd = True
   elif mode == self.VVUXtl and not VVeZBd        : isAdd = True
   elif mode == self.VVjFaT  and fType == 0        : isAdd = True
   elif mode == self.VVM9kR  and fType == 1        : isAdd = True
   elif mode == self.VVbwyA  and fName in words       : isAdd = True
   elif mode == self.VVxliL and fName in words       : isAdd = True
   elif mode == self.VVlaa4  and namSp.lower() == words[0]    : isAdd = True
   elif mode == self.VV367A:
    if asPrefix:
     if any(VVeZBd.lower().startswith(x) for x in words)       : isAdd = True
    elif any(x in VVeZBd.lower() for x in words)         : isAdd = True
   elif mode == self.VV0gvd:
    try:
     if os.stat("%s%s.png" % (self.pPath, fName)).st_ctime >= timeStamp   : isAdd = True
    except:
     pass
   elif mode == self.VVoRFI:
    span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
    if span and span.group(1) in sTypeList           : isAdd = True
   elif mode == self.VVXXPh:
    if iMatch(r"^(%s(?:_[a-f0-9]+){9})" % words[0], fName, IGNORECASE)    : isAdd = True
   if isAdd:
    tList.append(entry)
  if tList:
   self.VV5dDF   = list(tList)
   tList    = None
   self.lastMode  = mode
   self.lastWords  = words
   self.lastAsPrefix = asPrefix
   self.lastTimeStamp = timeStamp
   self.lastSTypeList = sTypeList
  else:
   self.VVq1GA = False
   FFk1YE(self, "Not found", 1000)
   return
  self.VV5dDF.sort(key=lambda x: x[self.lastSortCol], reverse=reverseSort)
  self.VVVet3()
  self.VVFM7Z = len(self.VV5dDF)
  self.VVvADQ = int(self.VVFM7Z / self.VVqdrD) + (self.VVFM7Z % self.VVqdrD > 0)
  if goToFirst:
   self.VVZqoj = 0
   self.curRow  = 0
   self.curCol  = 0
   self.VVlBZZ = 0
   self.VVZeeA = 0
   self.VVW4YW = 0
  self.VVq1GA = False
  self.VVeRhA(True)
 def VVXSXd(self, VV1V0y):
  if FFf0vs(self.pPath):
   for fName, fType in CCUNc6.VVaXg8(self.pPath):
    if fName:
     return True
   if VV1V0y : FFU9uk(self, 'No ".png" files in path:\n\n%s' % self.pPath, title=self.Title)
   else   : FF8PJn(self, "Not found", 1000)
  else:
   FFU9uk(self, "PIcons path not found.\n\n%s" % self.pPath)
  if VV1V0y:
   self.close()
  return False
 def VVmnpl(self):
  VVJwgn = {}
  files  = CCSB3R.VVt2XK()
  if files:
   for path in files:
    txt = FF05rJ(path)
    list = iFindall(r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8}).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE)
    if list:
     for item in list:
      VVDhju = item[0].upper().replace(":", "_").strip("_")
      VVJwgn[VVDhju] = item[1]
  return VVJwgn
 def VVDAhu(self):
  self.VVbfZP()
  f1, f2 = self.VVOJsy()
  row = col = 0
  for ndx in range(f1, f2):
   fName, fType, VVeZBd, sat, inDB = self.VV5dDF[ndx]
   fName = self.VV5dDF[ndx][0]
   path  = self.pPath + fName + ".png"
   VVDhju  = fName.replace("_", ":").upper()
   pic, lbl = self.VVzYds(row, col)
   ok = self.VVLBdY(ndx, row, col, pic, path)
   if ok   : color = VV8QGw if inDB else ""
   elif not VVeZBd : color = ""
   else   : color = VVUPyu
   self.VV92ci(lbl, VVeZBd or "-", color)
   self.VVZeeA = row
   self.VVW4YW = col
   col += 1
   if col > (self.VVwnUG - 1):
    col = 0
    row += 1
 @staticmethod
 def VVZ29q(s1, s2):
  row = -1
  rows, cols, dist = len(s1) + 1, len(s2) + 1, []
  for i in range(rows): dist.append([0.] * cols)
  for i in range(1, rows):
   for j in range(1,cols): dist[i][0], dist[0][j] = i, j
  for col in range(1, cols):
   for row in range(1, rows):
    cost = 0 if s1[row-1] == s2[col-1] else 2
    dist[row][col] = min(dist[row-1][col] + 1, dist[row][col-1] + 1, dist[row-1][col-1] + cost)
  return int( ( ( len(s1) + len(s2) ) - dist[row][col] ) / ( len(s1) + len(s2) ) * 100 ) if row != -1 else 0
 @staticmethod
 def VVJ98d():
  return ("Export Current Channel PIcon File", "VVStbS")
 @staticmethod
 def VVXCd0():
  VVXXzc = []
  VVXXzc.append(("Find SymLinks (to PIcon Directory)"   , "VV6cOK"  ))
  VVXXzc.append(("Find Broken SymLinks (to PIcon Directory)" , "findPiconBrokenSymLinks" ))
  VVXXzc.append(("Find all Broken SymLinks"      , "FindAllBrokenSymLinks" ))
  return VVXXzc
 @staticmethod
 def VVStbS(SELF):
  png, path = CCUNc6.VVJkx7(CCaZ62(SELF.session).VV6phL)
  if path : CCUNc6.VVBH30(SELF, png, path)
  else : FFU9uk(SELF, "No PIcon found for current channel in:\n\n%s" % CCUNc6.VVQ490())
 @staticmethod
 def VV6cOK(SELF):
  if VVaR8d:
   sed1 = FF0VVA("->", VVaR8d)
   sed2 = FF0VVA("picon", VVcahY)
   sed3 = r"| sed 's/... Broken Link/\\t\\%s&\%s/gI'" % (VVUPyu, VVHFlX)
  else:
   sed1 = sed2 = sed3 = ""
  grep = "| grep -i 'picon'"
  FF3BM3(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then BROK='... Broken Link'; else BROK=''; fi; ls -l \"$FILE\" 2> /dev/null | sed \"s/$/${BROK}/\" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; done %s %s %s" % (FFoSAW(1), grep, sed1, sed2, sed3))
 @staticmethod
 def VV1PjS(SELF, isPIcon):
  sed1 = FF0VVA("->", VVUPyu)
  if isPIcon:
   grep = "| grep -i 'picon'"
   sed2 = FF0VVA("picon", VVcahY)
  else:
   grep = "| grep -v /proc | grep -v /run | grep -v /etc/rcS.d"
   sed2 = ""
  FF3BM3(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; fi; done %s %s" % (FFoSAW(1), grep, sed1, sed2))
 @staticmethod
 def VVBH30(SELF, png, path):
  dest = FF7GbY()
  andTxt = "echo -e 'PIcon file copied to:\n\n%s%s' %s" % (dest, png, FF0VVA("%s%s" % (dest, png), VV8QGw))
  errTxt = "Could not copy PIcon file!"
  orTxt = "echo -e '%s' %s" % (errTxt, FF0VVA(errTxt, VVsm0W))
  cmd = "cp -f '%s' '%s' &> /dev/null && %s || %s" % (path, dest, andTxt, orTxt)
  FFpL0U(SELF, cmd)
 @staticmethod
 def VVaXg8(path):
  for f in os.listdir(path):
   if f.endswith(".png"):
    p = path + f
    if os.path.islink(FFHP0y(p)) and os.path.exists(p) : yield f , 1
    elif os.path.isfile(p)          : yield f , 0
 @staticmethod
 def VVQ490():
  return FFA4GT(CFG.PIconsPath.getValue())
 @staticmethod
 def VVJkx7(VVDhju, VVeZBd=""):
  if FFPrVr(VVDhju):
   VVDhju, VVu69c, VVQwVu, VVLZ0Z = CCaZ62.VVXPhc(VVDhju)
  allPath, fName, VVPug6, pList = CCUNc6.VVbFI5(VVDhju, VVeZBd)
  if pList:
   if VVPug6 : return fName, VVPug6
   else   : return fName, pList[0]
  else:
   return "", ""
 @staticmethod
 def VVjFPF(pPath, VVDhju, VVeZBd):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVDhju.strip(), IGNORECASE)
  if span:
   exts = ("png", "jpg")
   VVDhju = span.group(1).replace(":", "_")
   tPath = "%s%s." % (pPath, VVDhju)
   for ext in exts:
    path = tPath + ext
    if FFf0vs(path):
     return path
   refParts = VVDhju.split("_", 1)
   for rType in CCSB3R.VV0JA5():
    if not rType == refParts[0]:
     for ext in exts:
      path = "%s%s_%s.%s" %  (pPath, rType, refParts[1], ext)
      if FFf0vs(path):
       return path
   VVeZBd = FFes9J(VVeZBd)
   VVeZBd1 = VVeZBd.replace(" ", "")
   for name in (VVeZBd, VVeZBd.lower(), VVeZBd.upper(), VVeZBd1.lower(), VVeZBd1.upper()):
    for ext in exts:
     path = "%s%s.%s" % (pPath, name, ext)
     if FFf0vs(path):
      return path
  return ""
 @staticmethod
 def VVbFI5(VVDhju, VVeZBd, addSimilar=False):
  allPath = fName = VVPug6 = pList = None
  if VVDhju.count(":") > 8:
   VVDhju = VVDhju.rstrip(":")
   fName = VVDhju.strip()
   fName = fName.rstrip(":")
   fName = VVDhju.replace(":", "_") + ".png"
   allPath = CCUNc6.VVQ490()
   pList = []
   lst = FFYjQm(allPath, "*_" + "_".join(fName.split("_")[3:]))
   if lst:
    pList += lst
   if VVeZBd:
    pList.extend(CCUNc6.VVA1df(FFes9J(VVeZBd), addSimilar=addSimilar))
   VVPug6 = ""
   if pList:
    for item in pList:
     if fName == FFVUvT(item):
      VVPug6 = item
    pList.sort()
  return allPath, fName, VVPug6, pList
 @staticmethod
 def VVA1df(VVeZBd, addSimilar=False):
  lst  = []
  pPath = CCUNc6.VVQ490()
  if VVrRHR(pPath):
   VVeZBd = VVeZBd.lower()
   exts = ("png", "jpg")
   fLst = os.listdir(pPath)
   if addSimilar:
    for s in ("sd", "hd", "hd+", "fhd", "fhd+", "4k", "tv"):
     VVeZBd = VVeZBd.replace(s, "")
    VVeZBd = VVeZBd.strip()
    for x in fLst:
     tName = x[:-4].lower()
     if (VVeZBd in tName or tName in VVeZBd) and x[-3:] in exts:
      lst.append(x)
   else:
    lst = [x for x in fLst if VVeZBd == x[:-4].lower() and x[-3:] in exts]
  return lst
class CCMbAF():
 def __init__(self):
  self.VV1VyB()
 def VV1VyB(self):
  noService = "No data"
  self.VVnAUN = ""
  self.VVZcnO  = noService
  self.VVwpBq = 0
  self.VV8J5z  = noService
  self.VVAnDV = 0
  self.VVuueV  = "-"
  self.VVz8pm = 0
  self.VVjUyK  = ""
  self.serviceName = ""
  self.infoAvailable = False
  self.VVanSR  = None
 def VVQepD(self, service):
  self.VV1VyB()
  if service:
   feinfo = service.frontendInfo()
   if feinfo:
    self.infoAvailable = True
    frontEndStatus = feinfo.getFrontendStatus()
    if frontEndStatus:
     self.VVanSR = frontEndStatus
     self.VVzK7R()
   info = service.info()
   if info:
    self.serviceName = info.getName()
 def VVzK7R(self):
  if self.VVanSR:
   val = self.VVanSR.get("tuner_signal_quality_db", 0x12345678)
   if val is not None and val != 0x12345678: self.VVnAUN = "%3.02f dB" % (val / 100.0)
   else         : self.VVnAUN = ""
   val = self.VVanSR.get("tuner_signal_quality", 0) * 100 / 65536
   self.VVwpBq = int(val)
   self.VVZcnO  = "%d%%" % val
   val = self.VVanSR.get("tuner_signal_power" , 0) * 100 / 65536
   self.VVAnDV = int(val)
   self.VV8J5z  = "%d%%" % val
   val = self.VVanSR.get("tuner_bit_error_rate", 0)
   if not val:
    val = 0
   self.VVuueV  = "%d" % val
   val = int(val * 100 / 500)
   self.VVz8pm = min(500, val)
   val = self.VVanSR.get("tuner_locked", 0)
   if val == 1 : self.VVjUyK = "Locked"
   else  : self.VVjUyK = "Not locked"
 def VVlXRM(self)   : return self.VVnAUN
 def VVtZGF(self)   : return self.VVZcnO
 def VVtlTo(self)  : return self.VVwpBq
 def VV7VKU(self)   : return self.VV8J5z
 def VV1sKa(self)  : return self.VVAnDV
 def VVdxXJ(self)   : return self.VVuueV
 def VV1qIQ(self)  : return self.VVz8pm
 def VV2qxi(self)   : return self.VVjUyK
 def VVM5jL(self) : return self.serviceName
class CCAAmm():
 def __init__(self):
  self.sat1 = self.sat2 = self.freq = self.sr = self.syst = self.inv = self.pol = self.fec    = ""
  self.mod = self.rolof = self.pil = self.plsMod = self.plsCod = self.iStId = self.t2PlId = self.t2PId = ""
  self.data  = None
  self.namespace = ""
  self.txMedia = ""
  self.D_POL  = {0:"Horizontal" , 1:"Vartical" , 2:"Left" , 3:"Right"}
  self.D_SYS_S = {0:"DVB-S", 1:"DVB-S2"}
  self.D_SYS_T = {0:"DVB-T", 1:"DVB-T2"}
  self.D_SYS_C = {0:"DVB-C", 1:"DVB-C2", 2:"DVB-C3", 3:"ATSC"}
  self.D_PIL_INV = {0:"Off" , 1:"On" , 2:"Auto"}
  self.D_PLS_MOD = {0:"Root" , 1:"Gold" , 2:"Combo" , 3:"Unknown"}
  self.D_ROLOF = {0:"35%" , 1:"25%" , 2:"20%" , 3:"Auto"}
  self.D_MOD  = {0:"Auto" , 1:"QPSK" , 2:"8PSK" , 3:"QAM16" , 4:"16APSK", 5:"32APSK"}
  self.D_FEC  = {0:"Auto" , 1:"1/2" , 2:"2/3" , 3:"3/4" , 4:"5/6" , 5:"7/8", 6:"8/9", 7:"3/5", 8:"4/5", 9:"9/10", 10:"6/7", 15:"None"}
  self.FREQ  = "frequency"
  self.SR   = "symbol_rate"
  self.POL  = "polarization"
  self.FEC  = "fec_inner"
  self.ORPOS  = "orbital_position"
  self.SYST  = "system"
  self.INV  = "inversion"
 def VVf07e(self, VVDhju):
  self.data = None
  if not VVDhju: return
  self.namespace = FFC21b(VVDhju)
  if   self.namespace.startswith("EEEE") : self.txMedia, syst = "DVB-T", self.D_SYS_T
  elif self.namespace.startswith("FFFF") : self.txMedia, syst = "DVB-C", self.D_SYS_C
  else         : self.txMedia, syst = "DVB-S", self.D_SYS_S
  servRef = eServiceReference(VVDhju)
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.sat1  = self.VVCVFJ(self.ORPOS  , mod=1   )
     self.sat2  = self.VVCVFJ(self.ORPOS  , mod=2   )
     self.freq  = self.VVCVFJ(self.FREQ  , mod=3   )
     self.sr   = self.VVCVFJ(self.SR   , mod=4   )
     self.inv  = self.VVCVFJ(self.INV  , self.D_PIL_INV)
     self.pol  = self.VVCVFJ(self.POL  , self.D_POL )
     self.fec  = self.VVCVFJ(self.FEC  , self.D_FEC )
     self.syst  = self.VVCVFJ(self.SYST  , syst   )
     if "S2" in self.syst:
      self.mod = self.VVCVFJ("modulation" , self.D_MOD )
      self.rolof = self.VVCVFJ("rolloff"  , self.D_ROLOF )
      self.pil = self.VVCVFJ("pilot"   , self.D_PIL_INV)
      self.plsMod = self.VVCVFJ("pls_mode"  , self.D_PLS_MOD)
      self.plsCod = self.VVCVFJ("pls_code"  )
      self.iStId = self.VVCVFJ("is_id"   )
      self.t2PlId = self.VVCVFJ("t2mi_plp_id" )
      self.t2PId = self.VVCVFJ("t2mi_pid"  )
 def VVCVFJ(self, key, valDict=None, mod=0):
  val = self.data.get(key, "?")
  if   val in ("?", -1) : return ""
  elif valDict   : return valDict.get(val, str(val))
  elif mod == 1   : return FFhCU0(val)
  elif mod == 2   : return FF3CFU(val)
  elif mod == 3   : return str(int(val) // 1000)
  elif mod == 4   : return str(int(val) // 1000)
  else     : return str(val)
 def VVPHbt(self, refLst):
  for VVDhju in refLst:
   self.VVf07e(VVDhju)
   if self.data: break
  txt = ""
  if self.data:
   def VVEQGt(subj, val):
    if val : return "%s\t: %s\n" % (subj, val)
    else : return ""
   if self.txMedia == "DVB-S":
    txt += VVEQGt("System"   , self.syst)
    txt += VVEQGt("Satellite"  , self.sat2)
    txt += VVEQGt("Frequency"  , self.freq)
    txt += VVEQGt("Inversion"  , self.inv)
    txt += VVEQGt("Symbol Rate"  , self.sr)
    txt += VVEQGt("Polarization" , self.pol)
    txt += VVEQGt("FEC"    , self.fec)
    if "S2" in self.syst:
     txt += VVEQGt("Modulation" , self.mod)
     txt += VVEQGt("Roll-Off" , self.rolof)
     txt += VVEQGt("Pilot"  , self.pil)
     txt += VVEQGt("Input Stream", self.iStId)
     txt += VVEQGt("T2MI PLP ID" , self.t2PlId)
     txt += VVEQGt("T2MI PID" , self.t2PId)
     txt += VVEQGt("PLS Mode" , self.plsMod)
     txt += VVEQGt("PLS Code" , self.plsCod)
   else:
    txt += VVEQGt("System"   , self.txMedia)
    txt += VVEQGt("Frequency"  , self.freq)
  return txt, self.namespace
 def VVG37d(self, refLst, maxLen=0, nonTxt="-"):
  for VVDhju in refLst:
   self.VVf07e(VVDhju)
   if self.data: break
  if self.data:
   if self.txMedia == "DVB-S":
    txt1, txt2, txt3 = ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip(), "  ", self.sat2.strip()
    len1, len2, len3 = len(txt1), 2, len(txt3)
    if maxLen and (len1 + len2 + len3 > maxLen):
     txt3 = txt3[:maxLen - len1 - len2] + ".."
    return (txt1 + txt2 + (FFITtK(txt3, VVkLs0) if txt3 else "")).strip()
   else:
    return "Freq = %s  (%s)" % (self.freq, FFITtK(self.txMedia, VVkLs0))
  elif nonTxt : return FFITtK(nonTxt, VVu50a)
  else  : return ""
 def VVklm3(self, VVDhju):
  self.VVf07e(VVDhju)
  if self.data:
   if all((self.pol[:1], self.fec, self.sr)): return ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip()
   else          : return ("Freq=%s" % self.freq).strip()
  else           : return ""
 def VVFGh6(self, VVDhju):
  if VVDhju and VVDhju.count(":") > 8: servRef = eServiceReference(VVDhju)
  else         : servRef = None
  self.data = None
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.namespace = FFC21b(VVDhju)
     if   self.namespace.startswith("EEEE") : isSat, syst = False, self.VVCVFJ(self.SYST, self.D_SYS_T)
     elif self.namespace.startswith("FFFF") : isSat, syst = False, self.VVCVFJ(self.SYST, self.D_SYS_C)
     else         : isSat, syst = True , self.VVCVFJ(self.SYST, self.D_SYS_S)
     freq = self.VVCVFJ(self.FREQ , mod=3  )
     if isSat:
      pol = self.VVCVFJ(self.POL , self.D_POL)
      fec = self.VVCVFJ(self.FEC , self.D_FEC)
      sr = self.VVCVFJ(self.SR  , mod=4  )
      return freq, pol[:1], fec, sr, syst
     else:
      return freq, "-", "-", "-", syst
  return "-", "-", "-", "-", ""
 def VV8YJD(self, VVDhju):
  self.data = None
  self.VVf07e(VVDhju)
  if self.data and self.freq : return True
  else      : return False
class CCAvJY():
 def __init__(self, VVo57Z, path, VVuQkS=None, VVSkE3=-1):
  self.VVo57Z  = VVo57Z
  self.origFile   = path
  self.Title    = "File Editor: " + FFVUvT(path)
  self.VVuQkS  = VVuQkS
  self.tmpFile   = "/tmp/ajp_edit"
  self.fileChanged  = False
  self.fileSaved   = False
  self.insertMode   = 0
  self.lastLineNum  = -1
  self.editorTable  = None
  self.starterRow   = VVSkE3
  if FF6usE("cp -f '%s' '%s'" % (self.origFile, self.tmpFile)):
   self.VVKY3X(self.VVo57Z)
  else:
   FFU9uk(self.VVo57Z, "Error while preparing edit!")
 @FFHF2S("Loading file ...", par=1)
 def VVKY3X(self, wObj):
  VVJwgn = self.VVTpac()
  VV5CrJ = ("Save Changes" , self.VV0uGf   , [])
  VVI3Oq  = ("Edit Line"  , self.VVSZ8n    , [])
  VV4dTm = (""    , self.VVkEmO   , [])
  VVbQ6N = ("Options"  , self.VVdpgT  , [])
  VVvrJb = ("Go to Line No." , self.VVAXtH   , [])
  VVsB8G = (""    , self.VVqdYd , [])
  VVLj1d = self.VVUfdv
  VVzs8Z  = self.VVn0NZ
  header   = ("Line No." , " Text" )
  widths   = (8   , 92  )
  VVgKQc  = (CENTER  , LEFT  )
  bg    = "#0a001111"
  self.editorTable = FFdCaM(self.VVo57Z, None, title=self.Title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, width=1600, height=1000, VV1Wwb=26, VV1UVb=True, VV5CrJ=VV5CrJ, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VVLj1d=VVLj1d, VVzs8Z=VVzs8Z, VVsB8G=VVsB8G, VVrpeX=True, VVylFd=1, VV7VIQ=CFG.lastFindEditor
        , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#06334444", VVcv6F="#00222222", VVsOjr="#06333322")
 def VVn0NZ(self, VV5ybN):
  VV5ybN.VVcilR()
 def VVkEmO(self, VV5ybN, title, txt, colList):
  txt = "File\t: %s\n%s" % (self.origFile, txt)
  FFyijw(self.VVo57Z, txt, title=title)
 def VVdpgT(self, VV5ybN, title, txt, colList):
  c1, c2, c3 = VVnQYw, VV6UAe, VVcahY
  isMulti = VV5ybN.VVbbT0
  tot  = VV5ybN.VVQrKf()
  lineNum = int(colList[0])
  totRows = VV5ybN.VVvmd7()
  isPaste = not isMulti and VVIo9e and len(VVIo9e) > 0
  isSel = not isMulti or tot > 0
  selTxt =  ("Selected " if isMulti else "", FFEnJs(tot))
  VVXXzc = []
  VVXXzc.append(FFwjWO("Insert Empty Line (before line-%d)" % lineNum, "ins1" , not isMulti      , c1))
  VVXXzc.append(FFwjWO("Insert Empty Line (after line-%d)"  % lineNum, "ins2" , not isMulti and lineNum == totRows, c1))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Copy %sLine%s to Clipboard" % selTxt , "VV6fZu" , isSel  , c2))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Insert lines from clipboard"   , "paste2"   , isPaste , c2))
  VVXXzc.append(FFwjWO("Paste from clipboard (overwrite line)", "paste1"   , isPaste , c2))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Delete %sLine%s" % selTxt, "del", isSel, c3))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Find & Replace" , "repl", not isMulti ))
  cbFncDict = { "ins1"   : BF(self.VVNRYG, "sed -i '%d i %s' '%s'" % (lineNum, "", self.tmpFile))
     , "ins2"   : BF(self.VVwjUk, lineNum)
     , "VV6fZu" : self.VV6fZu
     , "paste1"   : BF(FFTSvN, self.editorTable, BF(self.VV4k2e, lineNum, "\n".join(VVIo9e), 1))
     , "paste2"   : BF(FFTSvN, self.editorTable, BF(self.VV4k2e, lineNum, "\n".join(VVIo9e), 2))
     , "del"    : BF(FFTSvN, self.editorTable, self.VVFGWO)
     , "repl"   : BF(self.VVpkQ8, title) }
  mSel = CCZALl(self.VVo57Z, VV5ybN, setsOk=True)
  mSel.VVejOk(VVXXzc, cbFncDict, width=750, height=1000)
 def VVpkQ8(self, title):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  lst = [(" Find", fnd, str(len(fnd))), (" Replace with", rpl, str(len(rpl)))]
  bg = "#11101010"
  VVI3Oq  = ("Change" , BF(self.VVZTqw, title, lst) , [])
  VV5CrJ = ("Start" , BF(self.VVZXea, title)  , [])
  header  = (" Subject", " Text" , "Len.")
  widths  = (20   , 70  , 10 )
  VVgKQc = (LEFT   , LEFT  , CENTER)
  FFdCaM(self.VVo57Z, None, title=title, VV5dDF=lst, header=header, VVgKQc=VVgKQc, VV1PTZ=widths, width=1200, VV1Wwb=30, VV1UVb=True, VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VV4HrS=2
    , VVVzvS=bg, VVhHWW=bg, VVpaQ6=bg, VVI4UA="#06224455", VVcv6F="#0a303030")
 def VVZTqw(self, Title, lst, VV5ybN, title, txt, colList):
  title = VV5ybN.VVVWWJ(0)
  ndx = VV5ybN.VVfkJL()
  txt = CFG.lastFindRepl_fnd.getValue() if ndx == 0 else CFG.lastFindRepl_rpl.getValue()
  FFttdT(self.VVo57Z, BF(self.VVKhfR, VV5ybN, ndx), title=title, defaultText=txt, message="New entry")
 def VVKhfR(self, VV5ybN, ndx, newTxt=None):
  if newTxt:
   if ndx == 0 : FFDDwF(CFG.lastFindRepl_fnd, newTxt)
   else  : FFDDwF(CFG.lastFindRepl_rpl, newTxt)
   VV5ybN.VVDWD7({1:newTxt, 2:len(newTxt)})
 def VVZXea(self, Title, VV5ybN, title, txt, colList):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  if len(fnd) > 0:
   txt = FF05rJ(self.tmpFile)
   tot = txt.count(fnd)
   if tot > 0:
    FFHsPu(self.VVo57Z, BF(self.VVHXsg, VV5ybN, fnd, rpl), "Replace %d occurrences ?" % tot, title=Title)
   else:
    FF8PJn(VV5ybN, "Not found in file !", 1000)
    VV5ybN.VV43d2(0)
  else:
   FF8PJn(VV5ybN, "Nothing to find", 1000)
 @FFHF2S("Replacing ...", par=1)
 def VVHXsg(self, VV5ybN, fnd, rpl):
  txt = FF05rJ(self.tmpFile)
  txt = txt.replace(fnd, rpl)
  with open(self.tmpFile, "w") as f:
   f.write(txt)
  VV5ybN.cancel()
  self.fileChanged = True
  self.editorTable.VVW6Cx()
  VVJwgn = self.VVTpac()
  self.editorTable.VVxhz9(VVJwgn)
 def VVAXtH(self, VV5ybN, title, txt, colList):
  totRows = self.editorTable.VVJPu5()
  lineNum = self.editorTable.VVfkJL() + 1 if self.lastLineNum == -1 else self.lastLineNum
  FFttdT(self.VVo57Z, BF(self.VVSUCl, lineNum, totRows), title="Go to Line Num (1 - %d)" % totRows, defaultText="%d" % lineNum, message="Enter Line Number")
 def VVSUCl(self, lineNum, totRows, VVAQKp):
  if VVAQKp:
   VVAQKp = VVAQKp.strip()
   if VVAQKp.isdigit():
    num = FF9BdF(int(VVAQKp) - 1, 0, totRows - 1)
    self.editorTable.VV43d2(num)
    self.lastLineNum = num + 1
   else:
    FF8PJn(self.editorTable, "Incorrect number", 1500)
 def VVqdYd(self, VV5ybN, title, txt, colList):
  if   self.starterRow > -1: VV5ybN.VV43d2(self.starterRow)
  elif self.insertMode == 1: VV5ybN.VVvSt4()
  elif self.insertMode == 2: VV5ybN.VVU4Vz()
  self.insertMode = 0
  self.starterRow = -1
 def VVwjUk(self, lineNum):
  if lineNum == self.editorTable.VVvmd7():
   self.insertMode = 1
   self.VVNRYG("echo '' >> '%s'" % self.tmpFile)
  else:
   self.insertMode = 2
   self.VVNRYG("sed -i '%d i %s' '%s'" % (lineNum + 1, "", self.tmpFile))
 def VV6fZu(self):
  global VVIo9e
  isMulti = self.editorTable.VVbbT0
  if isMulti : VVIo9e = self.editorTable.VVaOdg(1, isStrip=False)
  else  : VVIo9e = [self.editorTable.VVVWWJ(1, isStrip=False)]
  FFar20(self.editorTable, "Copied to clipboard", 800)
 def VV0uGf(self, VV5ybN, title, txt, colList):
  if self.fileChanged:
   if FFyxsN(self.origFile):
    if FF6usE("cp -f '%s' '%s'" % (self.tmpFile, self.origFile)):
     FFar20(VV5ybN, "Saved", 800)
     self.fileSaved   = True
     self.fileChanged = False
     VV5ybN.VVcilR()
    else:
     FFU9uk(self.VVo57Z, "Cannot save file!")
   else:
    FFU9uk(self.VVo57Z, "Cannot create backup copy of original file!")
 def VVUfdv(self, VV5ybN):
  if self.fileChanged:
   FFHsPu(self.VVo57Z, BF(self.VVOGLR, VV5ybN), "Cancel changes ?")
  else:
   FF6usE("cp -f '%s' '%s'" % (self.tmpFile, self.origFile))
   self.VVOGLR(VV5ybN)
 def VVOGLR(self, VV5ybN):
  VV5ybN.cancel()
  FFqlCI(self.tmpFile)
  if self.VVuQkS:
   self.VVuQkS(self.fileSaved)
 def VVSZ8n(self, VV5ybN, title, txt, colList):
  lineNum = int(VV5ybN.VVVWWJ(0))
  lineTxt = VV5ybN.VVVWWJ(1, isStrip=False)
  message = VVHFlX + "ORIGINAL TEXT:\n" + VVVAvR + lineTxt
  FFttdT(self.VVo57Z, BF(self.VVlR3g, lineNum), title="File Line", defaultText=lineTxt, message=message)
 def VVlR3g(self, lineNum, VVAQKp):
  if not VVAQKp is None:
   if self.editorTable.VVvmd7() <= 1:
    self.VVNRYG("echo %s > '%s'" % (VVAQKp, self.tmpFile))
   else:
    self.VV4k2e(lineNum, VVAQKp, 1)
 def VV4k2e(self, lineNum, newTxt, mode):
  self.editorTable.VVrGNL("Saving ...")
  lines = FF2iRW(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if lineNum == ndx:
     if   mode == 1: line = newTxt
     elif mode == 2: f.write(newTxt + "\n")
    f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVW6Cx()
  VVJwgn = self.VVTpac()
  self.editorTable.VVxhz9(VVJwgn)
 def VVFGWO(self):
  isMulti = self.editorTable.VVbbT0
  if isMulti : lst = self.editorTable.VVaOdg(0)
  else  : lst = [self.editorTable.VVVWWJ(0)]
  self.editorTable.VVUVWk()
  lines = FF2iRW(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if not str(ndx) in lst:
     f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVW6Cx()
  VVJwgn = self.VVTpac()
  self.editorTable.VVxhz9(VVJwgn)
 def VVNRYG(self, cmd):
  FFtPqW(cmd, self.VVr52p)
  self.fileChanged = True
  self.editorTable.VVW6Cx()
 def VVr52p(self, result, retval):
  VVJwgn = self.VVTpac()
  self.editorTable.VVxhz9(VVJwgn)
 def VVTpac(self):
  if FFf0vs(self.tmpFile):
   lines = FF2iRW(self.tmpFile)
   VVJwgn = []
   if lines:
    for ndx, line in enumerate(lines, start=1):
     VVJwgn.append((str(ndx), line))
   if not VVJwgn:
    VVJwgn.append((str(1), ""))
   return VVJwgn
  else:
   FFbHk5(self.VVo57Z, self.tmpFile)
class CCrT1G():
 def __init__(self, VVo57Z, VVVzvS="#22003344", VVhHWW="#22002233"):
  self.VVo57Z = VVo57Z
  self.VVXXzc  = []
  self.satList  = []
  self.VVVzvS  = VVVzvS
  self.VVhHWW   = VVhHWW
 def VVMhxB(self, VVuQkS):
  self.VVXXzc = []
  VVXXzc, VVfUoq = CCrT1G.VV8C49(self.VVo57Z, False, True)
  if VVXXzc:
   self.VVXXzc += VVXXzc
   self.VVmdNq(VVuQkS, VVfUoq)
 def VVxr3c(self, mode, VV5ybN, satCol, VVuQkS, inFilterFnc=None):
  VV5ybN.VVrGNL("Loading Filters ...")
  self.VVXXzc = []
  self.VVXXzc.append(("All Services" , "all"))
  if mode == 1:
   self.VVXXzc.append(VVzg1X)
   self.VVXXzc.append(("Parental Control", "parentalControl" ))
   self.VVXXzc.append(("Hidden Services" , "hiddenServices" ))
   self.VVXXzc.append(VVzg1X)
   self.VVXXzc.append(("Radio Services", "radio"))
   if CCAnLc.VV6w46() or FFf0vs(VVSz7C):
    self.VVXXzc.append(("Stream Relay Services", "streamRelay"))
  elif mode == 2:
   self.VVXXzc.append(VVzg1X)
   self.VVXXzc.append(("Selected Transponder"  , "selectedTP" ))
   self.VVXXzc.append(("Channels with no Transponder", "emptyTP"  ))
  self.VVXwuP(VV5ybN, satCol)
  VVXXzc, VVfUoq = CCrT1G.VV8C49(self.VVo57Z, True, False)
  if VVXXzc:
   VVXXzc.insert(0, FFAiun("Custom Words"))
   self.VVXXzc += VVXXzc
  VV5ybN.VV8SQf()
  self.VVmdNq(VVuQkS, VVfUoq, inFilterFnc)
 def VVoKta(self, VVXXzc, sats, VVuQkS, inFilterFnc=None):
  self.VVXXzc = VVXXzc
  VVXXzc, VVfUoq = CCrT1G.VV8C49(self.VVo57Z, True, False)
  if VVXXzc:
   self.VVXXzc.append(FFAiun("Custom Words"))
   self.VVXXzc += VVXXzc
  self.VVmdNq(VVuQkS, VVfUoq, inFilterFnc)
 def VVmdNq(self, VVuQkS, VVfUoq, inFilterFnc=None):
  VVBztL  = ("Filter in Filter", inFilterFnc) if inFilterFnc else None
  VVI6TY = ("Edit Filter"  , BF(self.VVRJ9m, VVfUoq))
  VViDZz  = ("Filter Help"  , BF(self.VVBQpJ, VVfUoq))
  FFw2XU(self.VVo57Z, BF(self.VVhuYv, VVuQkS), VVXXzc=self.VVXXzc, title="Select Filter", VVBztL=VVBztL, VVI6TY=VVI6TY, VViDZz=VViDZz, VVL6LA=True, VVVzvS=self.VVVzvS, VVhHWW=self.VVhHWW)
 def VVhuYv(self, VVuQkS, item):
  if item:
   VVuQkS(item)
 def VVRJ9m(self, VVfUoq, selectionObj, sel):
  if FFf0vs(VVfUoq) : CCAvJY(self.VVo57Z, VVfUoq, VVuQkS=None)
  else       : FFbHk5(self.VVo57Z, VVfUoq)
  selectionObj.cancel()
 def VVBQpJ(self, VVfUoq, selectionObj, sel):
  FFpIdO(self.VVo57Z, "_help_service_filter", "Service Filter")
 def VVXwuP(self, VV5ybN, satColNum):
  if not self.satList:
   satList = VV5ybN.VVlL5a(satColNum)
   if satList:
    satList = set(satList)
    satList = list(satList)
    if satList:
     sats = []
     for ndx, sat in enumerate(satList):
      if not sat.strip() == "":
       self.satList.append((FFYWFN(sat), "__s__" + sat))
     self.satList.sort(key=lambda x: x[0])
     self.satList.insert(0, FFAiun("Satellites"))
  if self.VVXXzc:
   self.VVXXzc += self.satList
 @staticmethod
 def VV8C49(SELF, addTag, VVqUOx):
  FFH0EA()
  fileName  = "ajpanel_services_filter"
  VVfUoq = FFmAG5() + fileName
  VVXXzc  = []
  if not FFf0vs(VVfUoq):
   FF6usE("cp -f '%s' '%s'" % (VV30Jg + fileName, VVfUoq))
  fileFound = False
  if FFf0vs(VVfUoq):
   fileFound = True
   lines = FF2iRW(VVfUoq)
   if lines:
    for line in lines:
     line = line.strip()
     if line and not line.startswith("#"):
      if "#" in line:
       line = line.split("#")[0].strip()
      if "," in line:
       lst = list(map(str.strip, line.split(",")))
       lst = list(filter(None, lst))
       if lst: line = ",".join(lst)
       else  : line = ""
      if line:
       if addTag: VVXXzc.append((line, "__w__" + line))
       else  : VVXXzc.append((line, line))
  if VVqUOx:
   if   not fileFound : FFbHk5(SELF, VVfUoq)
   elif not VVXXzc : FFMgxa(SELF, VVfUoq)
  return VVXXzc, VVfUoq
 @staticmethod
 def VVYDJw(txt):
  txt = txt.strip()
  lst = []
  prefix = False
  if "," in txt:
   lst = list(map(str.strip, txt.split(",")))
   lst = list(filter(None, lst))
   if lst and len(lst) > 1 and lst[0] == "^":
    lst = lst[1:]
    prefix = True
  else:
   txt = txt.strip()
   if txt:
    if len(txt) > 1 and txt.startswith("^"):
     txt = txt[1:]
     prefix = True
    lst = [txt]
  return tuple(map(str.lower, lst)), prefix
class CCZALl():
 def __init__(self, VVo57Z, VV5ybN, addSep=True, setsOk=False, setsRed=False, setsGreen=False, setsYellow=False, setsBlue=False):
  self.VVo57Z = VVo57Z
  self.VV5ybN = VV5ybN
  self.VV5ybN.VVSuh9  = setsOk
  self.VV5ybN.VV7Zza  = setsRed
  self.VV5ybN.VVXT2q = setsGreen
  self.VV5ybN.VVumTW = setsYellow
  self.VV5ybN.VVp73s = setsBlue
  self.VVXXzc = []
  iMulSel = self.VV5ybN.VVyPTg()
  if iMulSel : self.VVXXzc.append( ("Disable Multi-Select " , "MultSelDisab" ))
  else  : self.VVXXzc.append( ("Enable Multi-Select"  , "multSelEnab"  ))
  tot = self.VV5ybN.VVQrKf()
  self.VVXXzc.append(    ("Select all"    , "selectAll"  ))
  if iMulSel and tot > 0:
   self.VVXXzc.append(   ("Unselect all"    , "unselectAll"  ))
  if addSep:
   self.VVXXzc.append(VVzg1X)
 def VVejOk(self, extraMenu, cbFncDict, width=1000, height=850, VVVzvS="#22003344", VVhHWW="#22002233", VVO8hC=0.15):
  if extraMenu:
   self.VVXXzc.extend(extraMenu)
  FFw2XU(self.VVo57Z, BF(self.VViKno, cbFncDict), width=width, height=height, VVO8hC=VVO8hC, title="Options", VVXXzc=self.VVXXzc, VVVzvS=VVVzvS, VVhHWW=VVhHWW)
 def VViKno(self, cbFncDict, item=None):
  if item:
   if   item == "multSelEnab" : self.VV5ybN.VV1Weh()
   elif item == "MultSelDisab" : self.VV5ybN.VVUVWk()
   elif item == "selectAll" : self.VV5ybN.VVUmcI()
   elif item == "unselectAll" : self.VV5ybN.VVZCQs()
   elif cbFncDict:
    fnc = cbFncDict.get(item)
    if fnc:
     fnc()
class CCWwVN(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVRfWo, 900, 480, 50, 0, 0, "#22660066", "#22330033", 35, VVZ3ZU=40)
  self.session = session
  FFfmZP(self, title="Date/Time -> Manual Mode")
  FFrvOP(self["keyRed"]  , "Exit")
  FFrvOP(self["keyGreen"]  , "Save")
  FFrvOP(self["keyYellow"] , "Refresh")
  FFrvOP(self["keyBlue"]  , "NTP Mode")
  self["curTime"]  = Label()
  self["yearTitle"] = Label("Year")
  self["monthTitle"] = Label("Month")
  self["dayTitle"] = Label("Day")
  self["gapTitle"] = Label()
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["secTitle"] = Label("Sec")
  self["year"]  = Label()
  self["month"]  = Label()
  self["day"]   = Label()
  self["gap"]   = Label()
  self["hour"]  = Label()
  self["min"]   = Label()
  self["sec"]   = Label()
  self.index   = 0
  self.list   = [self["year"], self["month"], self["day"], self["hour"], self["min"], self["sec"]]
  self.timer   = eTimer()
  self["gapTitle"].hide()
  self["gap"].hide()
  FFewq4(self,
  {
   "red" : self.VVZYxu  ,
   "green" : self.VVeyQs ,
   "yellow": self.VVBptl  ,
   "blue" : self.VVrJVZ   ,
   "up" : self.VVY6L2    ,
   "down" : self.VVgn7U   ,
   "left" : self.VVT8GX   ,
   "right" : self.VVMljc   ,
   "cancel": self.VVZYxu
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVBptl()
  self.VV1eHx()
  FFE1T7(self)
  try: self.timer_conn = self.timer.timeout.connect(self.VVddnX)
  except: self.timer.callback.append(self.VVddnX)
  self.timer.start(1000, False)
  self.VVddnX()
 def onExit(self):
  self.timer.stop()
 def VVZYxu(self) : self.close(True)
 def VVQ6om(self) : self.close(False)
 def VVrJVZ(self):
  self.session.openWithCallback(self.VV9Vke, BF(CCgJT2))
 def VV9Vke(self, VVgwCK):
  if VVgwCK:
   self.close()
 def VVddnX(self):
  self["curTime"].setText(str(FFMYsv(iTime())))
 def VVY6L2(self):
  self.VVvSPh(1)
 def VVgn7U(self):
  self.VVvSPh(-1)
 def VVT8GX(self):
  self.index -= 1
  if self.index < 0:
   self.index = 5
  self.VV1eHx()
 def VVMljc(self):
  self.index += 1
  if self.index > 5:
   self.index = 0
  self.VV1eHx()
 def VVvSPh(self, increment):
  year = int(self["year" ].getText())
  month = int(self["month"].getText())
  if   self.index == 0: minVal, maxVal = 2000, 3000
  elif self.index == 1: minVal, maxVal = 1, 12
  elif self.index == 2: minVal, maxVal = 1, self.VVdUBV(month, year)
  elif self.index == 3: minVal, maxVal = 0, 23
  elif self.index == 4: minVal, maxVal = 0, 59
  elif self.index == 5: minVal, maxVal = 0, 59
  val  = int(self.list[self.index].getText()) + increment
  if val < minVal: val = maxVal
  if val > maxVal: val = minVal
  if self.index == 0:
   val = "%04d" % val
  else:
   val = "%02d" % val
  self.list[self.index].setText(val)
  if self.index < 2:
   year = int(self["year" ].getText())
   month = int(self["month"].getText())
   day = int(self["day"].getText())
   monthDays = self.VVdUBV(month, year)
   if day > monthDays:
    self["day"].setText("%02d" % monthDays)
 def VVdUBV(self, month, year):
  MonthList = [31,28,31,30,31,30,31,31,30,31,30,31]
  days = MonthList[month-1]
  if (month == 2) and (self.VV1XkW(year)):
   days += 1
  return days
 def VV1XkW(self, year):
  if year % 4 == 0:
   if year % 100 == 0:
    if year % 400 == 0:
     return True
    else:
     return False
   else:
    return True
  else:
   return False
 def VV1eHx(self):
  for obj in self.list:
   FFu0W6(obj, "#11404040")
  FFu0W6(self.list[self.index], "#11ff8000")
 def VVBptl(self):
  year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
  self["year" ].setText("%04d" % year)
  self["month"].setText("%02d" % month)
  self["day"  ].setText("%02d" % day)
  self["hour" ].setText("%02d" % hour)
  self["min"  ].setText("%02d" % minute)
  self["sec"  ].setText("%02d" % second)
 def VVeyQs(self):
  year = int(self["year" ].getText())
  month = self["month"].getText()
  day  = self["day"  ].getText()
  hour = self["hour" ].getText()
  minute = self["min"  ].getText()
  second = self["sec"  ].getText()
  cmd = "date -s '%s-%s-%s %s:%s:%s'" % (year, month, day, hour, minute, second)
  FFtPqW("echo -e 'System Response:\n'; %s" % cmd, self.VViumh)
 def VViumh(self, result, retval):
  result = str(result.strip())
  if len(result) == 0 : FFSQn9(self, "Nothing returned from the system!")
  else    : FFSQn9(self, str(result))
class CCgJT2(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVusjP, 900, 480, 50, 40, 10, "#22660066", "#22330033", 35, VVZ3ZU=40)
  self.session = session
  FFfmZP(self, title="Date/Time -> NTP Mode", addLabel=True)
  FFrvOP(self["keyRed"]  , "Exit")
  FFrvOP(self["keyGreen"]  , "Sync")
  FFrvOP(self["keyYellow"] , "Refresh")
  FFrvOP(self["keyBlue"]  , "Manual Mode")
  FFewq4(self,
  {
   "red" : self.VVZYxu   ,
   "green" : self.VVOOcE  ,
   "yellow": self.VVBxnU ,
   "blue" : self.VV12Wa  ,
   "cancel": self.VVZYxu
  })
  self.VVMbPm()
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFE1T7(self)
  FFDiNL(self.VVcWEn)
 def VVcWEn(self):
  self.VVtDsk()
  self.VVI1yD(False)
 def VVZYxu(self)  : self.close(True)
 def VV12Wa(self) : self.close(False)
 def VVMbPm(self):
  self["myLabel"].setText("Getting NTP time ... ")
 def VVtDsk(self):
  self.VVpgWN()
  self.VVFaLT()
  self.VVVLmz()
  self.VVLMmx()
 def VVBxnU(self):
  if len(self["keyYellow"].getText()) > 0:
   self.VVMbPm()
   self.VVtDsk()
   FFDiNL(self.VVcWEn)
 def VVOOcE(self):
  if len(self["keyGreen"].getText()) > 0:
   FFHsPu(self, self.VVeypg, "Synchronize with Internet Date/Time ?")
 def VVeypg(self):
  self.VVtDsk()
  FFDiNL(BF(self.VVI1yD, True))
 def VVpgWN(self)  : self["keyRed"].show()
 def VV5S8T(self)  : self["keyGreen"].show()
 def VVmX3q(self) : self["keyYellow"].show()
 def VVgcZ2(self)  : self["keyBlue"].show()
 def VVFaLT(self)  : self["keyGreen"].hide()
 def VVVLmz(self) : self["keyYellow"].hide()
 def VVLMmx(self)  : self["keyBlue"].hide()
 def VVI1yD(self, sync):
  localTime = FFpe77()
  ok = False
  server_list = ['ntp.iitb.ac.in', 'time.nist.gov', 'time.windows.com', 'pool.ntp.org']
  for server in server_list:
   epoch_time = self.VV6VOG(server)
   if epoch_time is not None:
    ntpTime = FFMYsv(epoch_time)
    time1 = mktime(datetime.strptime(localTime, "%Y-%m-%d %H:%M:%S").timetuple())
    time2 = mktime(datetime.strptime(ntpTime  , "%Y-%m-%d %H:%M:%S").timetuple())
    diff = time1 - time2
    if   diff == 0 : timeDiff = "None"
    elif diff == 1 : timeDiff = "%d second"  % diff
    else   : timeDiff = "%d seconds" % diff
    timeDiff = "Difference\t=  %s" % timeDiff
    if sync:
     FFtPqW("echo -e '\nSystem Response:\n'; date -s '%s'" % ntpTime, BF(self.VViumh, True))
    else:
     txt = "Local Time\t= %s\nInternet Time\t= %s\n%s\n" % (localTime, ntpTime, timeDiff)
     self["myLabel"].setText(txt)
    ok = True
    break
   else:
    pass
  self.VVmX3q()
  self.VVgcZ2()
  if ok:
   self.VV5S8T()
  else:
   self["myLabel"].setText("Local Time\t= %s\n\nCould not get NTP time !\n" % localTime)
 def VViumh(self, syncAgain, result, retval):
  result = str(result.strip())
  if   len(result) == 0  : result = "\n\nNothing returned from the system!"
  elif result.count("\n") < 20: result = "\n\n" + result
  try:
   self["myLabel"].setText(result)
   if syncAgain:
    self.VVI1yD(False)
  except:
   pass
 def VV6VOG(self, addr='time.nist.gov'):
  from socket import socket, AF_INET, SOCK_DGRAM
  from struct import unpack as iUnpack
  time1970 = 2208988800
  data  = '\x1b' + 47 * '\0'
  data  = data.encode()
  if CChg05.VVIg8w():
   try:
    client = socket(AF_INET, SOCK_DGRAM)
    client.settimeout(1.0)
    client.sendto(data, (addr, 123))
    data, address = client.recvfrom(1024)
    if data:
     epoch_time = iUnpack('!12I', data)[10]
     epoch_time -= time1970
     return epoch_time
   except:
    pass
  return None
class CC5l7M(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVYVzy, 900, 300, 50, 20, 0, "#22000060", "#22000020", 35)
  self.session  = session
  FFfmZP(self, addLabel=True, addCloser=True)
  self["myTitle"].setText("  Internet Connectivity")
  self["myLabel"].setText("Checking Connection ...")
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFDiNL(self.VVsnU9)
 def VVsnU9(self):
  if CChg05.VVIg8w() : color, txt = "#22002020", "Internet Connection = Successful."
  else     : color, txt = "#22500000", "Cannot connect (or server is down) !"
  try:
   self["myLabel"].setText("  " + txt)
   FFu0W6(self["myBody"], color)
   FFu0W6(self["myLabel"], color)
  except:
   pass
class CCK62W(Screen):
 VVm49H = None
 def __init__(self, session):
  size = CFG.signalSize.getValue()
  screenW = FFUA0v()[0]
  ratio = size / 5.0
  self.skin, self.VVuaAL = FFJH4U(VVCj4p, 650, 320, 26, 20, 20, "#22003040", "#22001122", 25, VVb1Vz=ratio)
  self.session   = session
  self["mySNRdB"]   = Label()
  self["mySNR"]   = Label()
  self["myAGC"]   = Label()
  self["myBER"]   = Label()
  self["mySliderSNR"]  = Pixmap()
  self["mySliderAGC"]  = Pixmap()
  self["mySliderBER"]  = Pixmap()
  self["mySliderCovSNR"] = Label()
  self["mySliderCovAGC"] = Label()
  self["mySliderCovBER"] = Label()
  color     = self.VVuaAL["VVQbHY"]
  self.sliderSNR   = CC1mZN(self, self["mySliderSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC   = CC1mZN(self, self["mySliderAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER   = CC1mZN(self, self["mySliderBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  self["myTPInfo"]  = Label()
  self.timer    = eTimer()
  self.tunerInfo   = CCMbAF()
  self.stateCounter  = 0
  self.top    = 0
  self.left    = 0
  self.curPosNum   = CFG.signalPos.getValue()
  self.curSize   = CFG.signalSize.getValue()
  self.tpData    = CCAAmm()
  FFfmZP(self, title="Signal")
  FFewq4(self,
  {
   "ok"  : self.close      ,
   "up"  : self.VVY6L2       ,
   "down"  : self.VVgn7U      ,
   "left"  : self.VVT8GX      ,
   "right"  : self.VVMljc      ,
   "info"  : self.VVp9lg     ,
   "epg"  : self.VVp9lg     ,
   "menu"  : self.VV5tQO      ,
   "cancel" : self.close      ,
   "red"  : self.close      ,
   "last"  : BF(self.VV9bd2, -1)  ,
   "next"  : BF(self.VV9bd2, 1)  ,
   "pageUp" : BF(self.VV0vCl, True) ,
   "chanUp" : BF(self.VV0vCl, True) ,
   "pageDown" : BF(self.VV0vCl, False) ,
   "chanDown" : BF(self.VV0vCl, False) ,
   "0"   : BF(self.VV9bd2, 0)  ,
   "1"   : BF(self.VVRJFV, pos=1) ,
   "2"   : BF(self.VVRJFV, pos=2) ,
   "3"   : BF(self.VVRJFV, pos=3) ,
   "4"   : BF(self.VVRJFV, pos=4) ,
   "5"   : BF(self.VVRJFV, pos=5) ,
   "6"   : BF(self.VVRJFV, pos=6) ,
   "7"   : BF(self.VVRJFV, pos=7) ,
   "8"   : BF(self.VVRJFV, pos=8) ,
   "9"   : BF(self.VVRJFV, pos=9) ,
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  if not CCK62W.VVm49H:
   CCK62W.VVm49H = self
  self.sliderSNR.VVjD56()
  self.sliderAGC.VVjD56()
  self.sliderBER.VVjD56(isBER=True)
  pos   = self.instance.position()
  self.left = pos.x()
  self.top = pos.y()
  self.VVRJFV()
  self.VVpB5n()
  try: self.timer_conn = self.timer.timeout.connect(self.VVRIrY)
  except: self.timer.callback.append(self.VVRIrY)
  self.timer.start(500, False)
 def VVpB5n(self):
  service = self.session.nav.getCurrentService()
  self.tunerInfo.VVQepD(service)
  serviceName = self.tunerInfo.VVM5jL()
  if not serviceName   : serviceName = "Signal"
  if len(serviceName) > 25 : serviceName = serviceName[:25] + ".."
  self["myTitle"].setText("  " + serviceName)
  s = CCaZ62(self.session)
  self["myTPInfo"].setText(self.tpData.VVG37d([s.VVDhju, s.VV5zMI], maxLen=54))
 def VVRIrY(self):
  s = CCaZ62(self.session)
  self.tunerInfo.VVQepD(s.servPtr)
  if self.tunerInfo.infoAvailable:
   self["mySNRdB"].setText(self.tunerInfo.VVlXRM())
   self["mySNR"].setText(self.tunerInfo.VVtZGF())
   self["myAGC"].setText(self.tunerInfo.VV7VKU())
   self["myBER"].setText(self.tunerInfo.VVdxXJ())
   self.sliderSNR.VVfvKV(self.tunerInfo.VVtlTo())
   self.sliderAGC.VVfvKV(self.tunerInfo.VV1sKa())
   self.sliderBER.VVfvKV(self.tunerInfo.VV1qIQ())
  else:
   self["mySNRdB"].setText("")
   self["mySNR"].setText("?")
   self["myAGC"].setText("?")
   self["myBER"].setText("?")
   self.sliderSNR.VVfvKV(0)
   self.sliderAGC.VVfvKV(0)
   self.sliderBER.VVfvKV(0)
  if self.stateCounter > -1:
   self.stateCounter += 1
   if self.stateCounter > 8:
    self.stateCounter = -1
   else:
    if s.state.startswith("*"):
     FF8PJn(self, s.state.replace("*", ""), 1500)
     self.stateCounter = -1
 def VVp9lg(self):
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVn7qY)
 def VV5tQO(self):
  FFpIdO(self, "_help_signal", "Signal Monitor (Keys)")
 def VVY6L2(self)  : self.VVRJFV(posMap={7:4, 4:1, 8:5, 5:2, 9:6, 6:3})
 def VVgn7U(self) : self.VVRJFV(posMap={1:4, 4:7, 2:5, 5:8, 3:6, 6:9})
 def VVT8GX(self) : self.VVRJFV(posMap={3:2, 2:1, 6:5, 5:4, 9:8, 8:7})
 def VVMljc(self) : self.VVRJFV(posMap={1:2, 2:3, 4:5, 5:6, 7:8, 8:9})
 def VVRJFV(self, posMap=None, pos=-1):
  if pos > -1 or posMap:
   if pos > -1:
    self.curPosNum = pos
   elif posMap:
    self.curPosNum = posMap.get(self.curPosNum, self.curPosNum)
   FFDDwF(CFG.signalPos, self.curPosNum)
  scrSize = getDesktop(0).size()
  gapH = gapV = 20
  w  = self.instance.size().width()
  h  = self.instance.size().height()
  left = self.left
  top  = self.top
  bot  = scrSize.height() - h - gapV
  rigth = scrSize.width()  - w - gapH
  if   self.curPosNum == 1: left, top = gapH , gapV
  elif self.curPosNum == 2: left, top = left , gapV
  elif self.curPosNum == 3: left, top = rigth , gapV
  elif self.curPosNum == 4: left, top = gapH , top
  elif self.curPosNum == 5: left, top = left , top
  elif self.curPosNum == 6: left, top = rigth , top
  elif self.curPosNum == 7: left, top = gapH , bot
  elif self.curPosNum == 8: left, top = left , bot
  elif self.curPosNum == 9: left, top = rigth , bot
  else     : left, top = left , top
  self.instance.move(ePoint(left, top))
 def VV9bd2(self, sizeNum):
  oldSizeNum = CFG.signalSize.getValue()
  if sizeNum == 0:
   sizeNum = 5
  else:
   sizeNum += oldSizeNum
   sizeNum = FF9BdF(sizeNum, 1, 13)
  if not oldSizeNum == sizeNum:
   FFDDwF(CFG.signalSize, sizeNum)
   self.close(True)
 def onExit(self):
  self.timer.stop()
  CCK62W.VVm49H = None
 def VV0vCl(self, isUp):
  FF8PJn(self)
  try:
   if isUp : InfoBar.instance.zapDown()
   else : InfoBar.instance.zapUp()
   self.stateCounter = 0
   self.VVpB5n()
  except:
   pass
class CC1mZN(object):
 def __init__(self, SELF, barObj, covObj, minN=0, maxN=100, covColor="#00440000"):
  self.SELF   = SELF
  self.barObj   = barObj
  self.covObj   = covObj
  self.minN   = minN
  self.maxN   = maxN
  self.covColor  = covColor
  self.isColormode = False
 def VVjD56(self, isBER=False):
  self.barWidth = self.barObj.instance.size().width()
  self.VVZ3ZU = self.barObj.instance.size().height()
  self.barLeft = self.barObj.getPosition()[0]
  self.barTop  = self.barObj.getPosition()[1]
  if isBER:
   FFu0W6(self.covObj, "#0aaa0000")
   self.isColormode = True
  else:
   path = VV30Jg +  "bar_sig.png"
   if FFbO0w(self.barObj, path):
    FFu0W6(self.covObj, self.covColor)
   else:
    FFu0W6(self.covObj, "#00006688")
    self.isColormode = True
  self.VVfvKV(0)
 def VVfvKV(self, val):
  val  = FF9BdF(val, self.minN, self.maxN)
  width = int(FFPSde(val, 0, 100, 0, self.barWidth))
  height = int(self.VVZ3ZU)
  if self.isColormode:
   self.covObj.instance.resize(eSize(*(width, height)))
  else:
   width = int(FF9BdF(self.barWidth - width, 0, self.barWidth))
   top  = int(self.barTop)
   left = int(self.barLeft + self.barWidth - width)
   self.covObj.hide()
   self.covObj.instance.resize(eSize(*(width, height)))
   self.covObj.instance.move(ePoint(left, top))
   self.covObj.show()
class CCXRxc(Screen):
 VVh2Rm = 0
 VVE4fR  = 1
 VVZJj4 = 2
 VVCl0i = 3
 def __init__(self, session, VVmj1O="Processing ...", endTitle="Finishing ...", VVCJhW=None, VV9L2m=VVh2Rm, totBars=1, titleBg="#0a042328", bodyBg="#0a042328", barBg="#0a995533"):
  ratio = self.VVvbAT(VV9L2m)
  if totBars == 1 : h, margT = 150, 20
  else   : h, margT = 200, 15
  self.skin, self.VVuaAL = FFJH4U(VVbJFv, 900, h, 30, 20, margT, titleBg, bodyBg, 30, VVb1Vz=ratio, VVZ5LV={"totBars":totBars})
  self.session  = session
  self.VV9L2m  = VV9L2m
  self.totBars  = totBars
  self.barBg   = barBg
  self.VVmj1O = VVmj1O
  self.newTitle  = self.VVmj1O
  self.endTitle  = endTitle
  self.VVCJhW  = VVCJhW
  self.isCancelled = False
  self.isError  = False
  self.maxValue  = 0
  self.maxValue2  = 0
  self.barWidth  = 0
  self.VVZ3ZU  = 0
  self.counter  = 0
  self.counter2  = 0
  self.VViN1g = None
  self.timer   = eTimer()
  self.myThread  = None
  FFfmZP(self, title=self.VVmj1O)
  for i in range(1, 3):
   self["myProgFr%s"  % i] = Label()
   self["myProgBG%s"  % i] = Label()
   self["myProgFG%s"  % i] = Label()
   self["myProgVal%s" % i] = Label()
  FFewq4(self, {"cancel" : self.cancel})
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVwbny()
  for i in range(1, 3):
   self["myProgVal%s" % i].setText("0%")
  for i in range(1, 3):
   FFu0W6(self["myProgFG%s" % i], self.barBg)
   size = self["myProgVal%s" % i].instance.size()
   self.barWidth = int(size.width())
   self.VVZ3ZU = int(size.height())
   self.VVmK3O()
  try: self.timer_conn = self.timer.timeout.connect(self.VVmK3O)
  except: self.timer.callback.append(self.VVmK3O)
  self.timer.start(50, False)
  self.myThread = iThread(name="ajp_progBar", target=BF(self.VVCJhW, self))
  self.myThread.start()
 def VVqMKy(self, val):
  self.maxValue = val
 def VVFO1V(self, val):
  self.maxValue2 = val
 def VVoScM(self, catName):
  self.newTitle = "Found %d    %d/%d %s" % (len(self.VViN1g), self.counter, self.maxValue, catName)
 def VVAwgW(self, ev, pic):
  self.newTitle = "Downloading ... Events: %s    PIcons: %s" % (ev, pic)
 def VVSD3t(self, tot):
  self.newTitle = "Downloaded %d    Processed : %d of %d" % (tot, self.counter, self.maxValue)
 def VVq2H3(self, tot, evName):
  self.newTitle = "Translated: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, evName)
 def VVvSkU(self, tot, name):
  self.newTitle = "Added: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, name)
 def VVkdWG(self, txt):
  self.newTitle = str(txt)
 def VVwOHf(self, addVal, showFound=False):
  try:
   self.counter += addVal
   if showFound:
    self.newTitle = "Found : %d    .. Processed : %d of %d" % (len(self.VViN1g), self.counter, self.maxValue)
  except:
   pass
 def VVLjbA(self, addVal, totFound):
  try:
   self.counter += addVal
   self.newTitle = "Found : %d    .. Processed : %s of %s" % (totFound, self.counter, self.maxValue)
  except:
   pass
 def VVoreX(self, addVal):
  try:
   self.counter2 += addVal
  except:
   pass
 def VVJyCy(self, val):
  try:
   self.counter = val
  except:
   pass
 def VV75eC(self, val):
  try:
   self.counter2 = val
  except:
   pass
 def VVNQHr(self):
  self.isError = True
  self.cancel()
 def onExit(self):
  self.timer.stop()
 def cancel(self):
  self.timer.stop()
  self.isCancelled = True
  self.VVr7MN(False)
 def VVr7MN(self, isDone):
  self.close(isDone, self.VViN1g, self.counter, self.maxValue, self.isError)
 def VVmK3O(self):
  if   self.newTitle  : self["myTitle"].setText("  %s  " % self.newTitle)
  elif self.maxValue > 0 : self["myTitle"].setText("  %s  ( %d of %d ) ..." % (self.VVmj1O, self.counter, self.maxValue))
  if self.maxValue > 0:
   val = FF9BdF(self.counter, 0, self.maxValue)
   width = int(FFPSde(val, 0, self.maxValue, 0, self.barWidth))
   self["myProgVal1"].setText(str(int(val * 100.0 / self.maxValue)) + "%")
  else:
   width = 0
  self["myProgFG1"].instance.resize(eSize(*(width, self.VVZ3ZU)))
  if self.maxValue2 > 0:
   val = FF9BdF(self.counter2, 0, self.maxValue2)
   width = int(FFPSde(val, 0, self.maxValue2, 0, self.barWidth))
   self["myProgVal2"].setText(str(int(val * 100.0 / self.maxValue2)) + "%")
  else:
   width = 0
  self["myProgFG2"].instance.resize(eSize(*(width, self.VVZ3ZU)))
  if self.myThread and not self.myThread.is_alive():
   self.timer.stop()
   self["myTitle"].setText("  %s  " % self.endTitle)
   self.VVr7MN(True)
 def VVwbny(self):
  if self.totBars == 1:
   self["myProgFr2"].hide()
   self["myProgFG2"].hide()
   self["myProgBG2"].hide()
   self["myProgVal2"].hide()
  scrW = getDesktop(0).size().width()
  winW = self.instance.size().width()
  gap  = 30
  if self.VV9L2m in (self.VVh2Rm, self.VVE4fR):
   self.instance.move(ePoint(int(scrW - winW - gap), gap))
 def VVvbAT(self, VV9L2m):
  if   VV9L2m == self.VVh2Rm : return 0.7
  if   VV9L2m == self.VVE4fR : return 0.5
  if   VV9L2m == self.VVZJj4: return 0.5
  else           : return 1
 @staticmethod
 def VVJ9VK(SELF, **kwargs):
  VVuQkS = kwargs.pop("VVuQkS", None)
  SELF.session.openWithCallback(VVuQkS, CCXRxc, **kwargs)
class CCqTV0(object):
 def __init__(self):
  self.VVJEVG = {}
  self.VVzNEL  = {}
  self.VVYoZD = {}
  self.VVuQkS = {}
  self.VV4Lue = False
  self.VV0fbF  = FFujkg()
 def VVyeGQ(self, cmd, VVuQkS, VVYoZD=None, VVVhOI=None):
  self.VV4Lue = True
  name = cmd
  i  = 0
  while name in self.VVJEVG:
   name = cmd + '_' + str(i)
   i += 1
  self.VVzNEL[name] = ""
  self.VVYoZD[name] = VVYoZD
  self.VVuQkS[name] = VVuQkS
  try:
   from enigma import eConsoleAppContainer
   self.VVJEVG[name] = eConsoleAppContainer()
   if self.VV0fbF:
    self.VVJEVG[name].dataAvail_conn = self.VVJEVG[name].dataAvail.connect(BF(self.VVrrzT, name))
    self.VVJEVG[name].appClosed_conn = self.VVJEVG[name].appClosed.connect(BF(self.VVkGiz , name))
   else:
    self.VVJEVG[name].dataAvail.append(BF(self.VVrrzT, name))
    self.VVJEVG[name].appClosed.append(BF(self.VVkGiz , name))
  except:
   self.VV4Lue = False
   return False
  if isinstance(cmd, str):
   cmd = [cmd]
  if VVVhOI:
   try:
    self.VVJEVG[name].setCWD(VVVhOI)
   except:
    pass
  retval = self.VVJEVG[name].execute(*cmd)
  if retval:
   self.VVkGiz(name, retval)
  return True
 def VVrrzT(self, name, data):
  try:
   data = data.decode("UTF-8")
  except:
   data = "%s%s\n" % ("" if self.VVzNEL[name].endswith("\n") else "\n", FFITtK("[UN-DECODED STRING]", VVu50a))
  self.VVzNEL[name] += data
  if self.VVYoZD[name]:
   self.VVYoZD[name](data)
 def VVkGiz(self, name, retval):
  if not self.VV0fbF:
   del self.VVJEVG[name].dataAvail[:]
   del self.VVJEVG[name].appClosed[:]
  del self.VVJEVG[name]
  del self.VVYoZD[name]
  self.VV4Lue = False
  if self.VVuQkS[name]:
   self.VVuQkS[name](self.VVzNEL[name], retval)
  del self.VVuQkS[name]
 def VVlbct(self):
  return self.VV4Lue
 def kill(self, name):
  if name in self.VVJEVG:
   self.VVJEVG[name].kill()
 def killAll(self):
  for name in self.VVJEVG:
   self.kill(name)
  self.VV4Lue = False
class CCNqUU(Screen):
 def __init__(self, session, title="", VVqx93=None, VV4v81=False, VVwMgk=False, VVuMqi=False, VVZ1IW=False, VVR4HM=False, VVDClQ=False, VVPsQd=VVWqOp, VVUYyP=None, VVjgsF=None, VVo6GU=None, VVTHJE=False, VV1Wwb=30, consFont=True, VV5Sr1=True):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", VV1Wwb, VVtyk2=consFont)
  self.session   = session
  FFfmZP(self, addScrollLabel=True)
  self.VV4v81   = VV4v81
  self.VVwMgk   = VVwMgk
  self.VVuMqi   = VVuMqi
  self.VVZ1IW  = VVZ1IW
  self.VVR4HM = VVR4HM
  self.VVDClQ = VVDClQ
  self.VVPsQd   = VVPsQd
  self.VVUYyP = VVUYyP
  self.VVjgsF = VVjgsF
  self.VVo6GU  = VVo6GU
  self.VVTHJE  = VVTHJE
  self.VV5Sr1  = VV5Sr1
  self.cmdNum    = 0
  self.VVpzFk  = CCqTV0()
  self.justStarted  = True
  self.dataFound   = False
  self.VVTr1L = "Processing ..."
  if len(title) == 0:
   title = FFQfhO()
  self["myTitle"].setText("  %s" % title)
  if isinstance(VVqx93, str):
   self.VVqx93 = [VVqx93]
  else:
   self.VVqx93 = VVqx93
  if self.VVuMqi or self.VVZ1IW:
   restartNote = "%s\\\\nGUI WILL RESTART NOW\\\\n%s" % (SEP, SEP)
   self.VVqx93.append("echo -e '\n%s\n' %s" % (restartNote, FF0VVA(restartNote, VVcahY)))
   if self.VVuMqi : self.VVqx93.append(CCNqUU.VV301r())
   else    : self.VVqx93.append(CCNqUU.VVErT5())
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VVUrKi="console" if self.VV5Sr1 else "", maxChars=40000)
  if self.VVR4HM:
   FF8PJn(self, self.VVTr1L)
  if self.VVTHJE:
   self.VVB7Dr("Checking Internet Access ... ")
   if not CChg05.VVIg8w():
    self.VVRRAG("No connection to internet !", True)
    return
  self.VVB7Dr(self.VVTr1L)
  allOK = self.VVpzFk.VVyeGQ(self.VVqx93[0], self.VVxxzg, VVYoZD=self.VV4t9U)
  if not allOK:
   self.VVB7Dr()
   self.VVRRAG("Console Problem (in cmd-0) !", True)
 def onExit(self):
  if self.VVpzFk.VVlbct():
   self.VVpzFk.killAll()
 def VVB7Dr(self, altTxt=""):
  if self.VVDClQ or self.VVuMqi or self.VVZ1IW:
   self.VVXVnQ(FFiN5A("STARTED", VVVAvR))
   self.VVXQOS(altTxt)
  else:
   self.VVXVnQ(altTxt)
  if self.VV4v81:
   self["myLabel"].VVNtRi()
 def VVRRAG(self, txt="", isErr=False):
  if txt:
   self.VVXQOS("\n%s\n" % (FFITtK(txt, VVcahY) if isErr else txt))
  if not self.dataFound or self.VVs5rJ():
   self.VVB7Dr()
   self.VVXQOS("Done.")
  if self.VVDClQ and not (self.VVuMqi or self.VVZ1IW):
   self.VVXQOS("\n%s" % FFiN5A("FINISHED", VVVAvR))
  if self.VVwMgk:
   self["myLabel"].VVNtRi()
  if self.VVR4HM:
   FF8PJn(self)
  if self.VVUYyP : self.VVUYyP()
  if self.VVjgsF : self.VVjgsF(self)
 def VVXQOS(self, txt) : self["myLabel"].appendText(txt, VVPsQd=self.VVPsQd)
 def VVXVnQ(self, txt) : self["myLabel"].setText(txt)
 def VVNVuC(self)  : return FFes9J(self["myLabel"].getText())
 def VVs5rJ(self, txt=""):
  consTxt = self.VVNVuC().strip()
  return not consTxt or consTxt.strip().endswith(self.VVTr1L)
 def VV4t9U(self, txt):
  if len(txt) > 0:
   self.dataFound = True
  if self.justStarted:
   self.justStarted = False
   if self.dataFound and self.VVs5rJ():
    self.VVB7Dr()
  if self.VVo6GU:
   colorWhite = CCWKcF.VVmivZ(VVHFlX)
   color  = CCWKcF.VVmivZ(self.VVo6GU[0])
   words  = self.VVo6GU[1:]
   for word in words:
    txt = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (color, colorWhite), txt, flags=IGNORECASE)
  self.VVXQOS(txt)
  if self.VV4v81 or self.VVwMgk:
   self["myLabel"].VVNtRi()
 def VVxxzg(self, data, retval):
  self.cmdNum += 1
  if self.cmdNum < len(self.VVqx93):
   allOK = self.VVpzFk.VVyeGQ(self.VVqx93[self.cmdNum], self.VVxxzg, VVYoZD=self.VV4t9U)
   if not allOK:
    self.VVRRAG("Console Problem (in cmd-%s) !" % self.cmdNum, True)
  else:
   self.VVRRAG()
 @staticmethod
 def VV16qe(isInst=False):
  txt  = "apt-get install -f -y > /dev/null 2>&1;" if isInst else ""
  return "sync; sleep 3; if which systemctl > /dev/null 2>&1; then %s systemctl restart enigma2; else killall -9 enigma2; fi" % txt
 @staticmethod
 def VVErT5(): return CCNqUU.VV16qe()
 @staticmethod
 def VV301r(): return CCNqUU.VV16qe(True)
 @staticmethod
 def VVtJwR(SELF):
  from Screens.Standby import TryQuitMainloop
  SELF.session.open(TryQuitMainloop, 3)
class CCz488(Screen):
 def __init__(self, session, VVEkUN="", VVEU4X="", VVh54W=False):
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, 1700, 1000, 40, 20, 20, "#22200010", "#1a000000", 28, VVZ3ZU=40, VVtyk2=True, VV1fgG=2)
  self.session   = session
  self.VVEkUN   = VVEkUN
  self.VVEU4X   = VVEU4X.strip()
  self.VVh54W   = VVh54W
  self.VV9xzM = FFmAG5() + "ajpanel_terminal.history"
  self.VVKzFd = ""
  self.VVQRJ5  = "ls"
  self.VVjXCg   = ">>"
  self.VVVhOI    = FFhWCj("pwd") or "/home/root"
  self.VVpzFk  = CCqTV0()
  self.VVq0Cx  = []
  self.VV5G4e  = ""
  self.VV2dgG   = None
  self.VV1C0a   = (VVgzFX, VVeG3E,VV8QGw,VVaR8d,VV6uFd,VVUPyu,VVi4ay,VVHFlX)
  self.VVcPOf  = 0
  FFfmZP(self, title="Terminal", addScrollLabel=True)
  FFrvOP(self["keyRed"] , "Stop Process")
  FFrvOP(self["keyGreen"] , "Minimize")
  FFrvOP(self["keyYellow"], "Terminal Options")
  FFrvOP(self["keyBlue"] , "New Command")
  FFyNtd(self,
  {
   "ok" : self.VVeWYg ,
   "cancel": self.VVP0kw  ,
   "menu" : self.VVUuuE ,
   "info" : self.VVXC4O  ,
   "red" : self.VVJW8c   ,
   "green" : self.VVIoLI   ,
   "yellow": self.VVp8Nd ,
   "blue" : self.VVIq0v  ,
   "last" : self["myLabel"].VVZQnI ,
   "next" : self["myLabel"].VVof7V ,
   "0"  : self["myLabel"].VVQ4pd  ,
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.VVJW8c)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VVNhgp=False, VVUrKi="terminal", addNewLine=False, hideBtns=True)
  self["myLabel"].VVlCqA(CFG.terminalTextWrap.getValue())
  FFE1T7(self)
  FF1uow(self)
  self.VVniFY(FFhWCj("date"), 5)
  result = FFhWCj("tUSER=$(whoami) || tUSER=""; tHOST=$(hostname) || tHOST=""; echo $tUSER,$tHOST")
  if result and "," in result:
   result = result.replace(",", "@")
   if len(result) < 15:
    self.VVjXCg = "%s: " % result
  self.VVviGk()
  if VVrRHR(FFmAG5()):
   self.VVuLs6()
   if self.VVEkUN:
    self.VVbOur(self.VVEkUN, self.VVEU4X)
  else:
   FFU9uk(self, 'Cannot access the path:\n\n%s' % FFmAG5())
   self.close()
 def VVP0kw(self):
  if   self.VV2dgG     : self.VVIoLI()
  elif self.VVpzFk.VVlbct()  : self.VV7IjR()
  elif self.VVh54W      : self.close()
  elif CFG.ConfirmTerminalExit.getValue() : FFHsPu(self, self.close, "Exit ?")
  else         : self.close()
 def VVIoLI(self):
  if self.VV2dgG:
   self.session.deleteDialog(self.VV2dgG)
   self.VV2dgG = None
   self.show()
  else:
   self.VV2dgG = CCAt9K.VVuHy6(self.session, self.VV5G4e, 24, shadW=0, bg="#77000000")
   self.hide()
 def VVuLs6(self):
  userFile = CFG.terminalCmdFile.getValue()
  alterFile = FFmAG5() + "ajpanel_cmd"
  templPath = VV30Jg + "ajpanel_cmd_list"
  if   FFf0vs(userFile) : self.VVKzFd = userFile
  elif FFf0vs(alterFile): self.VVKzFd = alterFile
  else:
   if not FF6usE("cp -f '%s' '%s'" % (templPath, alterFile)):
    FF6BfM("echo -e 'pwd\ncd\ncd /tmp\nls\nls -ls' > '%s'" % alterFile)
   self.VVKzFd = alterFile
 def VVJW8c(self):
  if self.VV2dgG:
   self.VVIoLI()
  elif self.VVpzFk.VVlbct():
   self.VVpzFk.killAll()
   self.VVuFFh("Process killed")
   self.VVviGk()
 def VV7IjR(self):
  if self.VV2dgG:
   self.VVIoLI()
  FF8PJn(self, "Terminal is busy", 800)
 def VVuFFh(self, err):
  txt = self["myLabel"].getText()
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VVniFY("%s---(  %s  )---\n" % (cr, err), 4)
 def VVviGk(self):
  txt = self["myLabel"].getText()
  self.VVcPOf = len(txt)
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VVniFY(cr + self.VVjXCg, 1)
  self["keyRed"].hide()
 def VVniFY(self, txt, mode):
  if   mode == 0 : color = VVHFlX
  elif mode == 1 : color = VVaR8d
  elif mode == 2 : color = VVi4ay
  elif mode == 3 : color = VVHFlX
  elif mode == 4 : color = VVcahY
  elif mode == 5 : color = VVVAvR
  elif mode == 6 : color = VVgzFX
  else   : color = VVHFlX
  txt = iSub(r"\x1B\[0m", CCWKcF.VVmivZ(VVHFlX), txt, flags=IGNORECASE)
  for i, c in enumerate(self.VV1C0a):
   txt = iSub(r"\x1B\[[\d\;]*%sm" % i, CCWKcF.VVmivZ(c), txt, flags=IGNORECASE)
  txt = iSub(r"\x1B\[(\d{,3};?){,3}m", "", txt, flags=IGNORECASE)
  if not txt.strip() or iMatch(r"^\\c.{8}.*", txt):
   color = ""
  try:
   txt = str(txt)
   oldTxt = self["myLabel"].getText()
   done = False
   if chr(13) in txt:
    pos = oldTxt.rfind(chr(13))
    if pos > self.VVcPOf:
     self["myLabel"].setText(oldTxt[:pos] + txt)
     done = True
   if not done:
    self["myLabel"].setText(oldTxt + color + txt)
   txt = txt.strip().rpartition("\n")[2]
   if txt:
    if len(txt) > 20: txt = "%s .. %s" % (txt[:10], txt[-10:])
    self.VV5G4e = color + txt
    if self.VV2dgG:
     CCAt9K.VVEskH(self.VV2dgG, self.VV5G4e)
  except:
   pass
 @FFHF2S("Loading History ...")
 def VVeWYg(self):
  title = "Command History"
  if not FFf0vs(self.VV9xzM) or self.VVcoox() == "":
   self.VVMWh1("cd /tmp")
   self.VVMWh1("ls")
  VVJwgn = []
  if FFf0vs(self.VV9xzM):
   lines  = FF2iRW(self.VV9xzM)
   c  = 0
   lNum = len(lines) + 1
   for line in reversed(lines):
    line = line.strip()
    lNum -= 1
    if line and not line.startswith("#"):
     c += 1
     VVJwgn.append((str(c), line, str(lNum)))
   self.VVOXIf(VVJwgn, title, self.VV9xzM, isHistory=True)
  else:
   FFbHk5(self, self.VV9xzM, title=title)
 def VVcoox(self):
  lastLine = FFhWCj("grep '.' '%s' | tail -1" % self.VV9xzM)
  return lastLine.strip()
 def VVMWh1(self, cmd):
  try:
   with open(self.VV9xzM, "a") as f:
    f.write("%s\n" % cmd)
  except Exception as e:
   FFU9uk(self, str(e))
 def VVUuuE(self, VV5ybN=None):
  FFTSvN(VV5ybN or self, BF(self.VVKpAc, VV5ybN), "Loading Commands ...")
 def VVKpAc(self, VV5ybN=None):
  if FFf0vs(self.VVKzFd):
   lines = FF2iRW(self.VVKzFd)
   VVJwgn = []
   c  = 0
   lNum = 0
   defColor = ""
   for line in lines:
    line = line.strip()
    lNum += 1
    if line:
     c += 1
     color, line = self.VVbCh5(line)
     if not color.startswith("#f#") and iMatch("^[^a-zA-Z0-9_/]", line):
      color = "#f#00FF8055#" + defColor
     if color:
      if line:
       line = color + line
      else:
       defColor = color
       continue
     elif not line:
      defColor = ""
      continue
     else:
      line = defColor + line
     VVJwgn.append((str(c), line, str(lNum)))
   if VV5ybN:
    VV5ybN.VVxhz9(VVJwgn)
    VV5ybN.VV43d2(CFG.lastTerminalCustCmdLineNum.getValue())
   else:
    self.VVOXIf(VVJwgn, "File : %s" % os.path.basename(self.VVKzFd), filePath=self.VVKzFd, isHistory=False)
  else:
   FFbHk5(self, self.VVKzFd, title="Custom Commands")
 def VVbCh5(self, line):
  found = False
  span = iSearch(r"^\s*\[(.+)?\](.+?#.*)", line)
  if span:
   fgBg, line = span.groups()
   found = True
  else:
   span = iSearch(r"^([^#]+)(#)(.+)\[(.+)?\](.*)", line)
   if span:
    line, sep, txt1, fgBg, txt2 = span.groups()
    txt1 = txt1.strip(" #") if txt1 else ""
    txt2 = txt2.strip(" #") if txt2 else ""
    if   txt1 and txt2 : line += "\t%s %s ... %s" % (sep, txt1, txt2)
    elif txt1 or txt2 : line += "\t%s %s" % (sep, txt1 or txt2)
    found = True
   else:
    span = iSearch(r"^\s*\[(.+)?\](.+)?", line)
    if span:
     fgBg, line = span.groups()
     found = True
  if found:
   fg = bg = color = ""
   line = line.strip() if line else ""
   if fgBg:
    fg, _, bg = fgBg.partition(",")
    fg, bg = fg.strip(" #"), bg.strip(" #")
   c = self.VVvBNB(fg)
   if c: color = "#f#%s#" % c
   c = self.VVvBNB(bg)
   if c: color += "#b#%s#" % c
   return color, line
  return "", line
 def VVvBNB(self, txt):
  if txt:
   Dict = {"black": "000000", "red": "FF0000", "green": "00FF00", "blue": "0000FF", "yellow": "FFFF00", "cyan": "00FFFF", "purple": "FF00FF", "grey": "666666", "gray": "666666", "white": "FFFFFF"}
   tc = "22"
   Len = len(txt)
   color = Dict.get(txt.lower(), "")
   if color:
    return tc + color
   elif Len in (6,8) and iMatch("[a-fA-F0-9]", txt):
    if Len == 6 : return tc + txt
    if Len == 8 : return txt
  return ""
 def VVOXIf(self, VVJwgn, title, filePath=None, isHistory=False):
  if VVJwgn:
   if isHistory: VVVzvS = VVhHWW = VVpaQ6 = "#11000020"
   else  : VVVzvS = VVhHWW = VVpaQ6 = "#06002020"
   VVI3Oq   = ("Send"   , BF(self.VVdIgf, isHistory)  , [])
   VV5CrJ  = ("Modify & Send" , self.VV15B4     , [])
   if isHistory:
    VV1Wwb  = CFG.terminalFontSizeHist.getValue()
    VVbQ6N = ("Clear History" , self.VVfya9     , [])
    VVvrJb = None
    VV4dTm = None
   elif filePath:
    VV1Wwb  = CFG.terminalFontSizeCmd.getValue()
    VVbQ6N = ("Options"  , self.VVKnyo      , [])
    VVvrJb = ("Edit File"  , BF(self.VVvsUD, filePath) , [])
    VV4dTm = (""    , self.VVBHx6     , [])
   header  = ("No." , "Commands", "LineNum" )
   widths  = (7  , 93   , 0    )
   VVgKQc = (CENTER , LEFT   , CENTER )
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, height=1000, VV1Wwb=VV1Wwb, VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV4dTm=VV4dTm, VV7VIQ=CFG.lastFindTerminal, VVrpeX=True, VVylFd=1
         , VVVzvS=VVVzvS, VVhHWW=VVhHWW, VVpaQ6=VVpaQ6, VVqecq="#00ffffff", VVI4UA="#0a884400")
   if not isHistory:
    VV5ybN.VV43d2(CFG.lastTerminalCustCmdLineNum.getValue())
  else:
   FFHsPu(self, self.VVdGjI, "File is empty:\n\n%s\n\nSelect another file ?" % self.VVKzFd, title=title)
 def VVBHx6(self, VV5ybN, title, txt, colList):
  txt  = "%s\n%s\n\n" % (FFITtK("Command:", VV6UAe), colList[1])
  txt += "%s\n%s\n\n" % (FFITtK("Line %s in File:" % colList[2], VV6UAe), self.VVKzFd)
  FFyijw(self, txt, title=title)
 def VVKnyo(self, VV5ybN, title, txt, colList):
  if VV5ybN.VVbbT0:
   totSel = VV5ybN.VVQrKf()
   totTxt = str(totSel)
   txt = "Send %s Command%s" % (FFITtK(totTxt, VV6UAe) if totSel else totTxt, FFEnJs(totSel))
   item = (txt, "send") if totSel else (txt,)
  else:
   txt = "Send current line"
   item = (txt, "send")
  CCZALl(self, VV5ybN, setsOk=True, setsBlue=True, setsGreen=True).VVejOk([item], { "send": BF(self.VVdIgf, False, VV5ybN, title, txt, colList) })
 def VVp8Nd(self):
  VVXXzc = []
  VVXXzc.append(("Change Custom Commands File" , "chCmdF" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("%s Text Wrapping"     % ("Disable" if self["myLabel"].VV8nG3 else "Enable"), "wrap" ))
  VVXXzc.append(("%s Terminal-Exit Confirmation" % ("Disable" if CFG.ConfirmTerminalExit.getValue() else "Enable"), "togExit"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Commands Table Font Size" , "cmdFntSz" ))
  VVXXzc.append(("History Table Font Size" , "histFntSz" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Save Terminal Log File"  , "saveLog" ))
  FFw2XU(self, self.VVQJwf, VVXXzc=VVXXzc, title="Terminal Options", width=700)
 def VVQJwf(self, item):
  if item:
   if   item == "chCmdF" : self.VVdGjI()
   elif item == "wrap"  : self.VVLJ3u()
   elif item == "togExit" : FFDDwF(CFG.ConfirmTerminalExit, not CFG.ConfirmTerminalExit.getValue())
   elif item == "cmdFntSz" : self.VVwH6D(True)
   elif item == "histFntSz": self.VVwH6D(False)
   elif item == "saveLog" : self["myLabel"].VVXk7i()
 def VVLJ3u(self):
  self["myLabel"].VVfO3g()
  FFDDwF(CFG.terminalTextWrap, self["myLabel"].VV8nG3)
 def VVwH6D(self, isCmdTbl):
  if isCmdTbl : confItem, txt = CFG.terminalFontSizeCmd , "Commands"
  else  : confItem, txt = CFG.terminalFontSizeHist, "History"
  CC8MwG.VVlTg2(self, confItem, "%s Table Font Size" % txt, cbFnc=BF(FFar20, self, "Saved"), isSave=True, width=700)
 def VVdGjI(self):
  title = "Custom Commands File"
  VVXXzc = []
  bPath = FFmAG5()
  for fName in sorted(os.listdir(bPath), key=lambda x: x[0].lower()):
   path = os.path.join(bPath, fName)
   if fName.lower().startswith(("ajpanel_cmd", "linuxcommands")) and os.path.isfile(path):
    if path == self.VVKzFd:
     fName = FFITtK(fName, VV8QGw)
    VVXXzc.append((fName, path))
  if VVXXzc : FFw2XU(self, BF(self.VVf9qZ, title), VVXXzc=VVXXzc, title=title, VVnojT=3, VVhuPZ="", VVVzvS="#11220000", VVhHWW="#11220000")
  else  : FFU9uk(self, "No valid files found in:\n\n%s" % bPath, title=title)
 def VVf9qZ(self, title, path=None):
  if path:
   oldF = self.VVKzFd
   if CCQdsv.VVAAgR(path):
    FFU9uk(self, "Incorrect file format:\n\n%s" % path, title=title)
   elif path == self.VVKzFd:
    FF8PJn(self, "No change", 1000)
   else:
    self.VVKzFd = path
    FFDDwF(CFG.terminalCmdFile, path)
    FFDDwF(CFG.lastTerminalCustCmdLineNum, 0)
    FFar20(self, "Changed")
 def VVdIgf(self, isHistory, VV5ybN, title, txt, colList):
  if VV5ybN.VVbbT0:
   lst = VV5ybN.VVaOdg(1)
   curNdx = VV5ybN.VV4e0j()
  else:
   lst = [colList[1]]
   curNdx = VV5ybN.VVfkJL()
  if not isHistory:
   FFDDwF(CFG.lastTerminalCustCmdLineNum, curNdx)
  self.VVq0Cx = lst
  VV5ybN.cancel()
  FFDiNL(self.VVJQs3)
 def VVJQs3(self):
  if self.VVq0Cx:
   cmd = self.VVq0Cx[0]
   self.VVq0Cx.pop(0)
   if not iMatch("^[a-zA-Z0-9_/]", cmd):
    self.VVniFY("\n%s\n" % cmd, 6)
    self.VVniFY(self.VVjXCg, 1)
    self.VVJQs3()
   else:
    self.VVbOur(cmd)
 def VVbOur(self, cmd, VVEU4X=""):
  if self.VVpzFk.VVlbct():
   self.VV7IjR()
   return
  self["keyRed"].show()
  if cmd.startswith("passwd"):
   self.VVniFY(cmd, 2)
   self.VVniFY("\nCannot change passwrod from Console this way. Try using:\n", 4)
   txt = r'echo -e "NEW_PASSWORD\#nNEW_PASSWORD" | passwd'
   for ch in txt:
    if not ch == "#":
     self.VVniFY(ch, 0)
   self.VVniFY("\nor\n", 4)
   self.VVniFY("echo root:NEW_PASSWORD | chpasswd\n", 0)
   self.VVviGk()
  else:
   cmd = cmd.strip()
   modCmd = cmd
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", cmd, IGNORECASE)
   if span:
    modCmd = "sh '%s'" % span.group(1)
    FF6usE(FFDTPf("chmod 755 '%s'" % cmd))
    txt = "%s%s\n" % (VVUPyu, cmd)
   elif cmd.endswith((".py", ".pyo", ".pyc")) and os.path.isfile(cmd):
    FF6usE(FFDTPf("chmod 755 '%s'" % cmd))
    modCmd = "python%s '%s'" % ("3" if pyVersion[0] >= 3 else "", cmd)
    txt = "%s%s\n" % (VVUPyu, cmd)
   elif "#" in cmd and not "\n" in cmd:
    parts = cmd.split("#")
    left  = VVi4ay + parts[0].strip()
    right = VVgzFX + "#" + parts[1].strip()
    txt = "%s    %s\n" % (left, right)
   else:
    txt = "%s\n" % cmd
   self.VVniFY(VVEU4X if VVEU4X else txt, 2)
   lastLine = self.VVcoox()
   if not lastLine or not cmd == lastLine:
    self.VVQRJ5 = cmd
    self.VVMWh1(cmd)
   span = iSearch(r".*cd\s+([\/?\w\.+\~]+)", cmd + ";")
   if span:
    self.VVVhOI = span.group(1)
   allOK = self.VVpzFk.VVyeGQ(modCmd, self.VVG7E9, VVYoZD=self.VVjZ6Q, VVVhOI=self.VVVhOI)
   if not allOK:
    FFU9uk(self, "Cannot connect to Console!")
   self.VVQRJ5 = cmd
 def VVjZ6Q(self, data):
  self.VVniFY(data, 3)
 def VVG7E9(self, data, retval):
  if not retval == 0:
   self.VVuFFh("Exit Code : %d" % retval)
  self.VVviGk()
  if self.VVq0Cx:
   self.VVJQs3()
 def VV15B4(self, VV5ybN, title, txt, colList):
  if VV5ybN.VVflb7():
   cmd = colList[1]
   self.VVoS5Q(VV5ybN, cmd)
 def VVfya9(self, VV5ybN, title, txt, colList):
  FFHsPu(self, BF(self.VV6X7Y, VV5ybN), "Reset History File ?", title="Command History")
 def VV6X7Y(self, VV5ybN):
  FF6BfM("> '%s'" % self.VV9xzM)
  VV5ybN.cancel()
 def VVvsUD(self, filePath, VV5ybN, title, txt, colList):
  rowNum = int(colList[2].strip()) - 1
  if FFf0vs(filePath) : CCAvJY(self, filePath, VVuQkS=BF(self.VVm62s, VV5ybN), VVSkE3=rowNum)
  else     : FFbHk5(self, filePath)
 def VVm62s(self, VV5ybN, fileChanged):
  if fileChanged:
   VV5ybN.cancel()
   FFDiNL(self.VVUuuE)
 def VVIq0v(self):
  if self.VVpzFk.VVlbct():
   self.VV7IjR()
  else:
   self.VVoS5Q(None, "")
 def VVoS5Q(self, VV5ybN, cmd):
  if "#" in cmd:
   cmd = cmd.split("#")[0].strip()
  FFttdT(self, BF(self.VVAHHL, VV5ybN), title="Terminal", defaultText=cmd, message="Enter Command:")
 def VVAHHL(self, VV5ybN, cmd):
  if cmd and len(cmd) > 0:
   self.VVbOur(cmd)
   if VV5ybN:
    VV5ybN.cancel()
 def VVXC4O(self):
  FFpIdO(self, "_help_terminal", "Terminal Help")
class CCagnF(Screen):
 def __init__(self, session, title="", message="", VVPsQd=VVWqOp, width=1400, height=900, VV0tn7=False, isErr=False, titleBg="#22002020", VVpaQ6="#22001122", VV1Wwb=30, VVNYa4=50, resize=True, VVUrKi=""):
  if isErr: titleBg, VVpaQ6 = "#22330000", "#22200000"
  self.skin, self.VVuaAL = FFJH4U(VVxEpD, width, height, VVNYa4, 30, 20, titleBg, VVpaQ6, VV1Wwb)
  self.session   = session
  FFfmZP(self, title, addScrollLabel=True)
  self.VVPsQd   = VVPsQd
  self.VV0tn7   = VV0tn7
  self.resize    = resize
  self.VVUrKi = VVUrKi
  if isinstance(message, list):
   try:
    self.message = "\n".join(message)
   except:
    pass
  self.message = str(message)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myLabel"].VVuyIP(VV0tn7=self.VV0tn7, VVUrKi=self.VVUrKi)
  self["myLabel"].setText(self.message, self.VVPsQd)
  self.VVkOJq()
 def VV98tz(self, txt):
  self["myLabel"].appendText(txt)
  self.VVkOJq()
 def VVkOJq(self):
  if self.resize:
   self["myLabel"].VVNtRi()
class CCNHXv(Screen):
 def __init__(self, session, txt):
  self.skin, self.VVuaAL = FFJH4U(VVZjg7, 1800, 60, 30, 30, 20, "#55000000", "#ff000000", 30)
  self.session  = session
  self.txt   = txt
  self["myWinTitle"] = Label()
  FFfmZP(self, " ", addCloser=True)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  CCAt9K.VVEskH(self, self.txt)
  self.instance.move(ePoint((getDesktop(0).size().width() - self.instance.size().width()) // 2, 20))
class CCJzoa(Screen):
 def __init__(self, session, title="", message=""):
  self.skin, self.VVuaAL = FFJH4U(VVyGmA, 1200, 300, 50, 20, 0, "#22330000", "#22200000", 30)
  self.session = session
  FFfmZP(self, title, addLabel=True, addCloser=True)
  self["errPic"] = Pixmap()
  self["myLabel"].setText(message)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFgfSp(self["errPic"], "err")
class CCssxL(Screen):
 def __init__(self, session, fnc, title="Processing ...", fntSize=28, bg="#22331133"):
  self.skin, self.VVuaAL = FFJH4U(VVZjg7, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVJlYA=False)
  self.session = session
  self.fnc  = fnc
  self.Title  = str(title)
  self.fntSize = fntSize
  self.bg   = bg
  FFfmZP(self, " ")
  self["myWinTitle"] = Label()
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VVQVcT, self.fntSize))
  FFu0W6(body, self.bg)
  FFtPqW(":", self.VVqfBo)
 def VVqfBo(self, result, retval):
  self.fnc()
  self.close()
class CCjjKr(Screen):
 def __init__(self, session, title, timeout=1500, fntSize=28, fg="#22ffffaa", bg="#22001100", isRed=False):
  self.skin, self.VVuaAL = FFJH4U(VVZjg7, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVJlYA=False)
  self.session = session
  self.Title  = str(title)
  self.fntSize = fntSize
  self.fg   = fg
  self.bg   = "#00550000" if isRed else bg
  FFfmZP(self, " ", addCloser=True)
  self["myWinTitle"] = Label()
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.close)
  except: self.timer.callback.append(self.close)
  self.timer.start(timeout, True)
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VVQVcT, self.fntSize))
  FFNucL(body, self.fg, self.bg)
class CChRbI(Screen):
 def __init__(self, session, txt, fntSize, bg="#FF000000"):
  self.skin, self.VVuaAL = FFJH4U(VVZjg7, 1000, 50, 20, 30, 20, bg, bg, fntSize, VVJlYA=False)
  self.session  = session
  self["myWinTitle"] = Label()
  FFfmZP(self, " ", addCloser=True)
class CCAt9K():
 def __init__(self, session, txt, timeout=1500, fonSize=24, x=30, y=20):
  self.session = session
  self.win  = CCAt9K.VVuHy6(session, txt, fonSize, x=x, y=y)
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.VVkeLC)
  except: self.timer.callback.append(self.VVkeLC)
  self.timer.start(timeout, True)
 def VVkeLC(self):
  self.session.deleteDialog(self.win)
 @staticmethod
 def VVuHy6(session, txt, fonSize, shadW=2, shadColor="#440000", bg="#FF000000", x=30, y=20):
  win = session.instantiateDialog(CChRbI, str(txt).strip(), fonSize, bg=bg)
  win.show()
  FFiZTW(win["myWinTitle"], shadColor, shadW)
  CCAt9K.VVEskH(win, txt)
  if x < 0: x = (getDesktop(0).size().width() - win.instance.size().width()) // 2
  if y < 0: y = (getDesktop(0).size().height() - win.instance.size().height()) // 2
  win.instance.move(ePoint(x, y))
  return win
 @staticmethod
 def VVEskH(win, txt):
  win["myWinTitle"].setText(str(txt).strip())
  inst = win["myWinTitle"].instance
  w = inst.calculateSize().width() + 30
  h = int(inst.size().height())
  inst.resize(eSize(*(w, h)))
  win.instance.resize(eSize(*(w, h)))
class CChTrx():
 VVxegu    = 0
 VVfsCN  = 1
 VVyQoJ   = ""
 VVJ3Di    = ""
 VVY9st   = {}
 VVYR9N    = "ajpDownload"
 def __init__(self, SELF, mode, title, startDnld, VVu69c=""):
  self.SELF     = SELF
  self.mode     = mode
  self.Title     = title
  self.VV5ybN   = None
  self.timer     = eTimer()
  self.VVCXnr   = 0
  self.VV1d9Q  = 1
  self.VVkumN  = 2
  self.VVUwIQ   = 3
  self.VVByij   = 4
  CChTrx.VVJ3Di = ""
  VVJwgn = self.VV7CdR()
  if VVJwgn:
   self.VV5ybN = self.VVpBsQ(VVJwgn)
  if not VVJwgn and mode == self.VVxegu:
   self.VVqIBc("Download list is empty !")
   self.cancel()
  if mode == self.VVfsCN:
   FFTSvN(self.VV5ybN or self.SELF, BF(self.VVr41v, startDnld, VVu69c), title="Checking Server ...")
  self.VV9kgk(force=True)
  try: self.timer_conn = self.timer.timeout.connect(self.VV9kgk)
  except: self.timer.callback.append(self.VV9kgk)
  self.timer.start(1000, False)
 def VVpBsQ(self, VVJwgn):
  VVJwgn.sort(key=lambda x: int(x[0]))
  VVLj1d = self.VVzSYu
  VVI3Oq  = ("Play"  , self.VVKBo5 , [])
  VV4dTm = (""   , self.VVkEmO  , [])
  VVEyDE = ("Stop"  , self.VVoDm0  , [])
  VV5CrJ = ("Resume"  , self.VVQUsY , [])
  VVbQ6N = ("Options" , self.VV0MdO  , [])
  VVvrJb = ("Play URL" , self.VV4mzH , [])
  header   = ("No." , "Name" , "Type", "File Size", "Status" , "Progress", "Path", "sizeVal" , "URL" , "decoded-Url" , "oldSize" , "Speed" , "m3u8Log" )
  widths   = (5  , 39  , 8  , 13   , 13   , 11   , 0.01 , 0   , 0.01 , 0    , 0   , 11  , 0   )
  VVgKQc  = (CENTER, LEFT  , CENTER, CENTER  , CENTER , CENTER , LEFT , CENTER , LEFT , LEFT   , CENTER , CENTER , LEFT  )
  return FFdCaM(self.SELF, None, title=self.Title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVLj1d=VVLj1d, VVEyDE=VVEyDE, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N, VVvrJb=VVvrJb, VV7VIQ=CFG.lastFindIptv, VVVzvS="#11220022", VVhHWW="#11110011", VVpaQ6="#11110011", VVI4UA="#00223025", VVcv6F="#0a333333", VVsOjr="#0a400040", VVrpeX=True, VVylFd=1)
 def VV7CdR(self):
  lines = CChTrx.VVu28p()
  VVJwgn = []
  if lines:
   for ndx, line in enumerate(lines):
    if "," in line:
     parts  = line.split(",", 1)
     left  = parts[0].strip()
     VVu69c = parts[1].strip()
     if left == "-1" or left.isdigit(): size, m3u8Log = int(left), ""
     else        : size, m3u8Log = -1  , left
     if VVu69c:
      fName, VVeZBd, url = self.VVoRV4(VVu69c)
      if fName:
       if   FFBaXf(VVu69c) : sType = "Movie"
       elif FFJoTR(VVu69c) : sType = "Series"
       else      : sType = ""
       path = self.VVmT4D(VVu69c, fName)
       if size > -1: sizeTxt = CCQdsv.VVAcha(size, mode=4)
       else  : sizeTxt = ""
       status = prog = speed = oldSize = ""
       VVJwgn.append((str(len(VVJwgn) + 1), VVeZBd, sType, sizeTxt, status, prog, path, str(size), url, VVu69c, oldSize, speed, m3u8Log))
  return VVJwgn
 def VVKiXw(self):
  VVJwgn = self.VV7CdR()
  if VVJwgn:
   if self.VV5ybN : self.VV5ybN.VVxhz9(VVJwgn, VVMbPmMsg=False)
   else     : self.VV5ybN = self.VVpBsQ(VVJwgn)
  else:
   self.cancel()
 def VV9kgk(self, force=False):
  if self.VV5ybN:
   thrListUrls = self.VV32Lt()
   VVJwgn = []
   changed = False
   for ndx, row in enumerate(self.VV5ybN.VVTq0J()):
    row = list(map(str.strip, row))
    num, name, typ, fSize, state, progr, path, sizeV, url, VVu69c, oldSize, speed, m3u8Log = row
    flag = self.VVCXnr
    if m3u8Log:
     percent = CChTrx.VVxxiF(m3u8Log)
     if percent > -1:
      if percent < 100: flag, progr = self.VVUwIQ , "%.2f %%" % percent
      else   : flag, progr = self.VVByij , "100 %"
     mPath = m3u8Log[:-9]
     curSize = FFX42v(mPath)
     if curSize > -1:
      fSize = CCQdsv.VVAcha(curSize, mode=4)
     try:
      if not oldSize in ("", "0", "-"):
       diff = int(curSize - int(oldSize))
       if diff:
        speed = CCQdsv.VVAcha(diff, mode=4) + "/s"
     except:
      pass
    else:
     curSize = FFX42v(path)
     if curSize > -1:
      if sizeV.isdigit():
       percent = float(curSize) / float(sizeV) * 100.0
       if percent < 100: flag, progr = self.VVUwIQ , "%.2f %%" % percent
       else   : flag, progr = self.VVByij , "100 %"
       try:
        if not oldSize in ("", "0", "-"):
         diff = int(curSize - int(oldSize))
         if diff:
          speed = CCQdsv.VVAcha(diff, mode=4) + "/s"
       except:
        pass
    if VVu69c in thrListUrls:
     flag = self.VVkumN
     if m3u8Log :
      if not speed and not force : flag = self.VV1d9Q
      elif curSize == -1   : self.VVAUP8(False)
    elif flag == self.VVCXnr  : speed = progr = "-"
    else        : speed = "-"
    color1 = "#f#00FF9999#" if m3u8Log else ""
    if   flag == self.VVCXnr  : color2 = "#f#00555555#"
    elif flag == self.VV1d9Q : color2 = "#f#0000FFFF#"
    elif flag == self.VVkumN : color2 = "#f#0000FFFF#"
    elif flag == self.VVUwIQ  : color2 = "#f#00FF8000#"
    elif flag == self.VVByij  : color2 = "#f#0000FF00#"
    else        : color2 = "#f#00AAAAAA#"
    state = self.VVD4JB(flag)
    oldSize = str(curSize)
    if [num, name, typ, fSize, state, progr, path, sizeV, url, VVu69c, oldSize, speed, m3u8Log] != row:
     changed = True
    row[1]  = color1 + name
    row[2]  = color1 + typ
    row[3]  = color1 + fSize
    row[4]  = color2 + state
    row[5]  = color2 + progr
    row[10] = oldSize
    row[11] = speed if not speed.startswith("-") else "-"
    VVJwgn.append(row)
   if changed or force:
    self.VV5ybN.VVxhz9(VVJwgn, VVMbPmMsg=False)
   if CChTrx.VVJ3Di : title = "%s\t %s%s" % (self.Title, VVsm0W, CChTrx.VVJ3Di)
   else          : title = self.Title
   if self.VV5ybN.VVIdZ2().strip() != title:
    self.VV5ybN.VVq4kA(title)
 def VVD4JB(self, flag):
  tDict = self.VVrE1H()
  return tDict.get(flag, "?")
 def VVhIaj(self, state):
  for flag, txt in self.VVrE1H().items():
   if txt == state:
    return flag
  return -1
 def VVrE1H(self):
  return { self.VVCXnr: "Not started", self.VV1d9Q: "Connecting", self.VVkumN: "Downloading", self.VVUwIQ: "Stopped", self.VVByij: "Completed" }
 def VVJJSj(self, title):
  colList = self.VV5ybN.VVqY3Q()
  path = colList[6]
  url  = colList[8]
  if self.VVVXWc() : self.VVqIBc("Cannot delete while downloading.")
  else      : FFHsPu(self.SELF, BF(self.VVhzO3, path, url), "Delete ?\n\n%s" % path, title=title)
 def VVhzO3(self, path, url):
  m3u8Log = self.VV5ybN.VVqY3Q()[12]
  if m3u8Log : FF6usE("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  else  : FF6usE("rm -rf '%s'" % path)
  self.VVkVcD(False)
  self.VVKiXw()
 def VVkVcD(self, VVqUOx=True):
  if self.VVVXWc():
   FF8PJn(self.VV5ybN, self.VVD4JB(self.VVkumN), 500)
  else:
   colList  = self.VV5ybN.VVqY3Q()
   state  = colList[4]
   VVu69c = colList[9]
   if self.VVhIaj(state) in (self.VVCXnr, self.VVByij, self.VVUwIQ):
    lines = CChTrx.VVu28p()
    newLines = []
    found = False
    for line in lines:
     if CChTrx.VVGyz6(VVu69c, line): found = True
     else            : newLines.append(line)
    if found:
     self.VVamxy(newLines)
     self.VVKiXw()
     FF8PJn(self.VV5ybN, "Removed.", 1000)
    else:
     FF8PJn(self.VV5ybN, "Not found.", 1000)
   elif VVqUOx:
    self.VVqIBc("Cannot remove partial download !\n\nYou can delete the file (from options).")
 def VVTeDr(self, flag, title):
  ques = "Only remove from table (no file deletion).\n\nContinue ?"
  FFHsPu(self.SELF, BF(self.VVfh7e, flag), ques, title=title)
 def VVfh7e(self, flag):
  list = []
  for ndx, row in enumerate(self.VV5ybN.VVTq0J()):
   state  = row[4].strip()
   VVu69c = row[9].strip()
   flagVal  = self.VVhIaj(state)
   if   flag == flagVal == self.VVByij: list.append(VVu69c)
   elif flag == flagVal == self.VVCXnr : list.append(VVu69c)
  lines = CChTrx.VVu28p()
  totRem = 0
  newLines = []
  for line in lines:
   if any(x in line for x in list) : totRem += 1
   else       : newLines.append(line)
  if totRem > 0:
   self.VVamxy(newLines)
   self.VVKiXw()
   FF8PJn(self.VV5ybN, "%d removed." % totRem, 1000)
  else:
   FF8PJn(self.VV5ybN, "Not found.", 1000)
 def VVQ5GD(self):
  colList  = self.VV5ybN.VVqY3Q()
  path  = colList[6]
  VVu69c = colList[9]
  png   = "%s.png" % os.path.splitext(path)[0]
  if FFf0vs(png) : FF8PJn(self.VV5ybN, "Poster exists", 1500)
  else    : FFTSvN(self.VV5ybN, BF(self.VVyLbJ, VVu69c, path, png), title="Checking Server ...")
 def VVyLbJ(self, VVu69c, path, png):
  err = self.VVncVL(VVu69c, path, png)
  if err:
   FFU9uk(self.SELF, err, title="Poster Download")
 def VVncVL(self, VVu69c, path, png):
  epg, evLst, VVKCwZ, err = CCISy5.VV5pXU(VVu69c)
  if not VVKCwZ:
   return "Cannot download poster.\n\nTry downloading it from IPTV the tables."
  ext = os.path.splitext(VVKCwZ)[1] or ".png"
  tPath, err = FFEyUQ(VVKCwZ, "ajp_tmp%s" % ext, timeout=2, VVtOxO=True)
  if err:
   return "Cannot download poster !\n\n%s" % err
  else:
   png = "%s%s" % (os.path.splitext(path)[0], ext)
   FF6usE("mv -f '%s' '%s'" % (tPath, png))
   CCC0Lg.VVESKQ(self.SELF, VV0hkT=png, showGrnMsg="Saved")
   return ""
 def VVkEmO(self, VV5ybN, title, txt, colList):
  def VV2MoW(key, val) : return "%s\t: %s\n" % (key, val.strip())
  def VVEQGt(key, val) : return "\n%s:\n%s\n" % (FFITtK(key, VV6UAe), val.strip())
  heads  = self.VV5ybN.VVBMP2()
  txt = ""
  for i in range(6):
   if i == 3:
    totSize = colList[7].strip()
    curSize = colList[10].strip()
    if totSize and totSize.isdigit(): txt += VV2MoW(heads[i]  , CCQdsv.VVAcha(int(totSize), mode=0))
    if curSize and curSize.isdigit(): txt += VV2MoW("Downloaded" , CCQdsv.VVAcha(int(curSize), mode=0))
   else:
    txt += VV2MoW(heads[i], colList[i])
  if not "j.php" in colList[9]:
   for i in (6, 8):
    txt += VVEQGt(heads[i], colList[i])
  FFyijw(self.SELF, txt, title=title)
 def VVKBo5(self, VV5ybN, title, txt, colList):
  path = colList[6].strip()
  m3u8Log = colList[12].strip()
  if m3u8Log:
   path = m3u8Log[:-9]
  if FFf0vs(path) : CCQdsv.VVMj5s(self.SELF, path)
  else    : FF8PJn(self.VV5ybN, "File not found", 1000)
 def VV4mzH(self, VV5ybN, title, txt, colList):
  VVeZBd = colList[1].strip()
  path = colList[6].strip()
  tUrl = colList[9].strip()
  tUrl = tUrl.replace(":" + VVeZBd, "")
  tUrl = tUrl.replace(":", "%3a")
  Id  = "555"
  VVDhju = CCSB3R.VV7RE0(Id, Id, Id)
  chUrl = "%s%s:%s" % (VVDhju, tUrl, VVeZBd)
  VVthiO = CCISy5.VVj2eY(path)
  CC2lVw.VVbVSZ(self.SELF.session, VV7GTU=chUrl, VVthiO=VVthiO, VVQpKh=False, VViMad=False, VVr3eH=False)
 def VVzSYu(self, VV5ybN):
  self.cancel()
 def cancel(self):
  self.timer.stop()
  if self.VV5ybN:
   self.VV5ybN.cancel()
  del self
 def VV0MdO(self, VV5ybN, title, txt, colList):
  c1, c2, c3 = VVCBkQ, VVcahY, VV6UAe
  path  = colList[6].strip()
  VVu69c = colList[9].strip()
  resumeTxt = "Disable" if CFG.downloadAutoResume.getValue() else "Enable"
  showMonitor = "Disable" if CFG.downloadMonitor.getValue() else "Enable"
  VVXXzc = []
  VVXXzc.append((c1 + "Remove current row"       , "VVkVcD" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c1 + 'Remove all "Completed"'      , "remFinished"   ))
  VVXXzc.append((c1 + 'Remove all "Not started"'     , "remPending"   ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Delete the file (and remove from list)"  , "VVJJSj"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((resumeTxt + " Auto Resume"       , "VVv5l1" ))
  VVXXzc.append((showMonitor + " On-screen Download Monitor"  , "toggleMonitor"  ))
  VVXXzc.append(VVzg1X)
  cond = FFBaXf(VVu69c)
  VVXXzc.append(FFwjWO("Download Movie Poster %s" % ("(from server)" if cond else "... Movies only"), "VVQ5GD", cond, c3))
  VVXXzc.append(FFwjWO("Open in File Manager", "inFileMan,%s" % path, FFf0vs(path), c3))
  FFw2XU(self.SELF, BF(self.VV1I3v, VV5ybN), VVXXzc=VVXXzc, title=self.Title, VVfP2Q=True, width=800, VVL6LA=True, VVVzvS="#1a001122", VVhHWW="#1a001122")
 def VV1I3v(self, VV5ybN, item=None):
  if item:
   txt, ref, ndx = item
   if   ref == "VVkVcD"  : self.VVkVcD()
   elif ref == "remFinished"   : self.VVTeDr(self.VVByij, txt)
   elif ref == "remPending"   : self.VVTeDr(self.VVCXnr, txt)
   elif ref == "VVJJSj" : self.VVJJSj(txt)
   elif ref == "VVQ5GD"  : self.VVQ5GD()
   elif ref == "VVv5l1"  : FFDDwF(CFG.downloadAutoResume, not CFG.downloadAutoResume.getValue())
   elif ref == "toggleMonitor"   : FFDDwF(CFG.downloadMonitor, not CFG.downloadMonitor.getValue())
   elif ref.startswith("inFileMan,") :
    path = ref.split(",", 1)[1]
    if VVrRHR(path) : self.SELF.session.open(CCQdsv, mode=CCQdsv.VVp4lf, VVbQPh=path)
    else    : FF8PJn(VV5ybN, "Path not found !", 1500)
 def VVr41v(self, startDnld, VVu69c):
  refreshToken = True
  if not VVu69c:
   VVu69c = CCaZ62(self.SELF.session).VVu69c
  else:
   ndx = VVu69c.find("j.php")
   if ndx > -1:
    url = CCNREC.VVYuvG(VVu69c)
    if url:
     span = iSearch(r"&.+=", VVu69c)
     if span : VVu69c = url + "&" + VVu69c[ndx + 6:]
     else : VVu69c = url + VVu69c[ndx + 5:]
     refreshToken = False
    else:
     self.VVqIBc("Could not get download link !\n\nTry again later.")
     return
  for line in CChTrx.VVu28p():
   if CChTrx.VVGyz6(VVu69c, line):
    if self.VV5ybN:
     self.VVoig7(VVu69c)
     FFDiNL(BF(FF8PJn, self.VV5ybN, "Already listed !", 2000))
    break
  else:
   fnc = self.cancel if self.mode == self.VVfsCN else None
   params = self.VV1aOD(VVu69c, refreshToken)
   if len(params) == 1:
    self.VVqIBc(params[0])
    if fnc:
     fnc()
   elif len(params) == 2:
    resp, VVeZBd = params
    FFHsPu(self.SELF, BF(self.VVO9I0, resp, VVu69c), "Start downloading ?\n\n%s" % VVeZBd, callBack_No=fnc, title="Download (m3u8)")
   else:
    url, fSize, path, resp, resumable = params
    title= "Download : %s" % CCQdsv.VVAcha(fSize)
    FFHsPu(self.SELF, BF(self.VVb2D8, VVu69c, url, fSize, path, resp, startDnld), "Download to\n\n%s" % path, callBack_No=fnc, title=title)
 def VVb2D8(self, VVu69c, url, fSize, path, resp, startDnld):
  with open(CChTrx.VV6GoI(), "a") as f:
   f.write("%s,%s\n" % (fSize, VVu69c))
  self.VVKiXw()
  if self.VV5ybN:
   self.VV5ybN.VVU4Vz()
  if startDnld:
   threadName = "%s{%s,Sz,}%s" % (CChTrx.VVYR9N, path, VVu69c)
   self.VV1v3j(threadName, url, VVu69c, path, resp)
 def VVoig7(self, VVu69c):
  if self.VV5ybN:
   for ndx, row in enumerate(self.VV5ybN.VVTq0J()):
    VVu69c2 = row[9].strip()
    if VVu69c == VVu69c2 and self.VV5ybN:
     self.VV5ybN.VV43d2(ndx)
     break
 def VV1aOD(self, VVu69c, checkExist=True, resumeByte=-1, refreshToken=True):
  fName = ""
  if VVu69c:
   fName, VVeZBd, url = self.VVoRV4(VVu69c)
  if not fName:
   return ["Cannot process URL parameters !"]
  path = self.VVmT4D(VVu69c, fName)
  if checkExist and FFf0vs(path):
   return ["File already exists:\n\n%s" % path]
  if refreshToken and "chCode" in VVu69c:
   url = CCNREC.VVYuvG(VVu69c)
   if not url:
    return ["Could not get download link from server!"]
  fSize = 0
  resumable = False
  try:
   headers = CCSB3R.VVY3r9()
   if resumeByte > -1:
    headers["Range"] = "bytes=%d-" % resumeByte
   import requests
   resp = requests.get(url, headers=headers, timeout=3, stream=True, verify=True)
   if not resp.ok:
    return ["Err-%d : %s" % (resp.status_code, resp.reason)]
   head = resp.headers
   fSize = head.get("Content-Length", "")
   cType = head.get("Content-Type", "")
   resumable = CChTrx.VVAvee(resp)
  except:
   return ["Could not get file info from server !"]
  if not fSize or not fSize.isdigit():
   return ["Cannot get file size from server !"]
  fSize = int(fSize)
  if not "video" in cType and not "application/octet-stream" in cType:
   if ".m3u8" in resp.url:
    return [resp, VVeZBd]
   elif path and resp.url and fSize:
    pass
   else:
    return ["Cannot download this video !\n\nIncorrect download data (or not allowed by server)."]
  err = CChTrx.VV5SvN(fSize)
  if err:
   return [err]
  return [url, fSize, path, resp, resumable]
 def VVO9I0(self, resp, VVu69c):
  if not FFsGnd("ffmpeg"):
   FFHsPu(self.SELF, BF(CCSB3R.VVkD2h, self.SELF), '"FFmpeg" not found !\n\nInstall FFmpeg ?', title=VVeZBd)
   return
  fName, VVeZBd, url = self.VVoRV4(VVu69c)
  dest = os.path.join(CFG.MovieDownloadPath.getValue(), fName)
  self.m3u8_params = resp, VVu69c, dest, fName, VVeZBd, url
  rTxt = str(resp.text)
  rUrl = str(resp.url)
  if "#EXT-X-STREAM-INF" in rTxt:
   self.VVZHCV(rTxt, rUrl)
  elif "#EXTINF:" in rTxt:
   if FFf0vs(dest) : FFHsPu(self.SELF, BF(self.VVV6Ud, rTxt, rUrl), "Overwrite existing file ?\n\n%s" % dest, title=VVeZBd)
   else    : self.VVV6Ud(rTxt, rUrl)
  else:
   self.VVqIBc("Cannot process m3u8 file !")
 def VVZHCV(self, rTxt, rUrl):
  lst   = iFindall(r"RESOLUTION=(\d+x\d+).*\n(.+)", rTxt, IGNORECASE)
  VVXXzc = []
  for resol, fPath in lst:
   resol = str(resol).replace("x", " x ")
   fPath = str(fPath)
   fullUrl = CCSB3R.VV3BSK(rUrl, fPath)
   VVXXzc.append((resol, fullUrl))
  if VVXXzc:
   FFw2XU(self.SELF, self.VVrU2Y, VVXXzc=VVXXzc, title="Resolution", VVfP2Q=True, VVL6LA=True)
  else:
   self.VVqIBc("Cannot get Resolutions list from server !")
 def VVrU2Y(self, item=None):
  if item:
   txt, resolUrl, ndx = item
   resp, VVu69c, dest, fName, VVeZBd, url = self.m3u8_params
   resol = txt.replace(" ", "")
   fPath, fExt = os.path.splitext(fName)
   fName = "%s_%s%s" % (fPath, resol, fExt)
   fPath, fExt = os.path.splitext(dest)
   dest = "%s_%s%s" % (fPath, resol, fExt)
   self.m3u8_params = resp, VVu69c, dest, fName, VVeZBd, url
   if FFf0vs(dest):
    FFHsPu(self.SELF, BF(FFDiNL, BF(self.VVKSxw, resolUrl)), "Overwrite existing file ?\n\n%s" % dest, title=VVeZBd)
   else:
    FFDiNL(BF(self.VVKSxw, resolUrl))
 def VVKSxw(self, resolUrl):
  resp, txt, err = CCNREC.VVJPQJ(resolUrl)
  if err : self.VVqIBc(err)
  else : self.VVV6Ud(txt, resolUrl)
 def VVlwqD(self, logF, VVu69c):
  found = False
  lines = CChTrx.VVu28p()
  with open(CChTrx.VV6GoI(), "w") as f:
   for line in lines:
    if CChTrx.VVGyz6(VVu69c, line):
     line = "%s,%s" % (logF, VVu69c)
     found = True
    f.write(line + "\n")
  if not found:
   with open(CChTrx.VV6GoI(), "a") as f:
    f.write("%s,%s\n" % (logF, VVu69c))
  self.VVKiXw()
  if self.VV5ybN:
   self.VV5ybN.VVU4Vz()
 def VVV6Ud(self, rTxt, rUrl):
  resp, VVu69c, dest, fName, VVeZBd, url = self.m3u8_params
  fName = FF80BW(fName)
  dest  = FF80BW(dest)
  m3u8File = os.path.join(CFG.MovieDownloadPath.getValue(), "%s.m3u8" % fName)
  with open(m3u8File, "w") as f:
   lines = rTxt.splitlines()
   for line in lines:
    line = line.strip()
    if line.startswith(("#EXTM", "#EXT-")) and not line.startswith("#EXT-X-ENDLIST"):
     f.write(line + "\n")
  lst = iFindall(r"(#EXTINF:.+)\n(.+)", rTxt, IGNORECASE)
  if lst:
   with open(m3u8File, "a") as f:
    for extInf, fPath in lst:
     extInf = str(extInf)
     fPath = str(fPath)
     fPath = CCSB3R.VV3BSK(rUrl, fPath)
     f.write(extInf + "\n")
     f.write(fPath + "\n")
    f.write("#EXT-X-ENDLIST\n")
  else:
   self.VVqIBc("Incorrect m3u8 file from server !")
   return
  logF = "%s.log" % m3u8File
  self.VVlwqD(logF, VVu69c)
  cmd  = "ffmpeg -y -hide_banner -protocol_whitelist file,http,https,tcp,tls,crypto -i '%s' -c copy '%s' > '%s' 2>&1" % (m3u8File, dest, logF)
  cmd += " && %s" % FFDTPf("rm -f '%s' '%s'" % (m3u8File, logF))
  threadName = "%s{%s,,%s}%s" % (CChTrx.VVYR9N, dest, logF, VVu69c)
  myThread = iThread(name=threadName, target=BF(os.system, cmd))
  myThread.start()
 @staticmethod
 def VVxxiF(dnldLog):
  if FFf0vs(dnldLog):
   dur = CChTrx.VVOlS5(dnldLog)
   if dur > -1:
    tim = CChTrx.VVk6zN(dnldLog)
    if tim > -1:
     return float(tim) / float(dur) * 100
  elif FFf0vs(dnldLog[:-9]):
   return 100
  return -1
 @staticmethod
 def VVOlS5(dnldLog):
  lines = FFunRV("head -n 15 %s" % dnldLog)
  for line in lines:
   span = iSearch(r"Duration:\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 @staticmethod
 def VVk6zN(dnldLog):
  lines = FFunRV("tail -n 15 %s" % dnldLog)
  for line in reversed(lines):
   span = iSearch(r"time=\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 def VVmT4D(self, url, fName):
  path = CFG.MovieDownloadPath.getValue()
  if FFJoTR(url):
   span = iSearch(r"(.+)S\d\dE\d\d|(.+)Season_\d{1,2}_\d{1,2}", fName, IGNORECASE)
   if span:
    path1 = path + (span.group(1) or span.group(2)).strip("_(")
    FF6usE("mkdir '%s'" % path1)
    if VVrRHR(path1):
     return path1 + "/" + fName
  return path + fName
 def VV1v3j(self, threadName, url, VVu69c, path, resp, isAppend=False):
  totFileSize = int(self.VV5ybN.VVqY3Q()[7])
  threadName = threadName.replace(",Sz,", ",%s," % totFileSize)
  myThread = iThread(name=threadName, target=BF(self.VVJhSL, url, VVu69c, path, resp, totFileSize, isAppend))
  myThread.start()
 def VVJhSL(self, url, VVu69c, path, resp, totFileSize, isAppend):
  CChTrx.VVJ3Di = ""
  totBytes = 0
  try:
   with open(path, "ab" if isAppend else "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if FFf0vs(path):
      if chunk:
       try:
        f.write(chunk)
        self.VVOjZw(path)
       except Exception as e:
        CChTrx.VVJ3Di = str(e)
        return
      if CChTrx.VVyQoJ == path:
       CChTrx.VVyQoJ = ""
       return
     else:
      break
  except Exception as e:
   if not self.VVlwVi(path, e):
    return
  if CFG.downloadAutoResume.getValue():
   curSize = FFX42v(path)
   if curSize > -1 and not curSize == totFileSize:
    params = self.VV1aOD(VVu69c, checkExist=False, resumeByte=curSize)
    if len(params) > 1:
     url, fSize, path, resp, resumable = params
     if resumable:
      self.VVJhSL(url, VVu69c, path, resp, totFileSize, True)
 def VVlwVi(self, path, e):
  if "IncompleteRead" in str(e):
   now = iTime()
   cnt, tm = 0, now
   if path in CChTrx.VVY9st:
    cnt, tm = CChTrx.VVY9st[path]
    if cnt > 2 and now > tm + 3:
     self.VVOjZw(path)
     return False
    else:
     iSleep(1)
   self.VVG5a9(path, cnt + 1, tm)
  return True
 def VVG5a9(self, path, cnt, tm):
  CChTrx.VVY9st[path] = (cnt, tm)
 def VVOjZw(self, path):
  if path in CChTrx.VVY9st: CChTrx.VVY9st.pop(path)
 def VVoDm0(self, VV5ybN, title, txt, colList):
  m3u8Log = colList[12].strip()
  VVu69c = colList[9].strip()
  if       self.VVKe5l() : FF8PJn(self.VV5ybN, self.VVD4JB(self.VVByij), 500)
  elif not self.VVVXWc() : FF8PJn(self.VV5ybN, self.VVD4JB(self.VVUwIQ), 500)
  elif m3u8Log      : FFHsPu(self.SELF, self.VVAUP8, "This may stop other non-resumable files !\n\nStop anyway ?", title="Stopping non-resumable download")
  else:
   if VVu69c in self.VV32Lt():
    CChTrx.VVyQoJ = colList[6]
    FF8PJn(self.VV5ybN, "Stopping ...", 1000)
   else:
    FF8PJn(self.VV5ybN, "Stopped", 500)
 def VVAUP8(self, withMsg=True):
  if withMsg:
   FF8PJn(self.VV5ybN, "Stopping ...", 1000)
  FF6usE("killall -INT ffmpeg")
 def VVQUsY(self, *args):
  if   self.VVKe5l() : FF8PJn(self.VV5ybN, self.VVD4JB(self.VVByij) , 500)
  elif self.VVVXWc() : FF8PJn(self.VV5ybN, self.VVD4JB(self.VVkumN), 500)
  else:
   resume = False
   m3u8Log = self.VV5ybN.VVqY3Q()[12]
   if m3u8Log:
    if FFf0vs(m3u8Log) : FFHsPu(self.SELF, BF(self.VVmrsw, m3u8Log), "Cannot resume m3u8 type !\n\nDelete file and restart download ?", title="Resume")
    else     : resume = True
   elif self.VVAmW1():
    resume = True
   if resume: self.VVPFJW(self.VV5ybN)
   else  : FF8PJn(self.VV5ybN, "Cannot resume !", 500)
 def VVmrsw(self, m3u8Log):
  FF6usE("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  self.VVPFJW(self.VV5ybN)
 @FFHF2S("Checking Server ...", par=1)
 def VVPFJW(self, tbl):
  colList  = self.VV5ybN.VVqY3Q()
  path  = colList[6]
  size  = colList[7]
  VVu69c = colList[9]
  if "j.php" in VVu69c:
   url = CCNREC.VVYuvG(VVu69c)
   if url:
    VVu69c = self.VVwbrm(VVu69c, url)
   else:
    self.VVqIBc("Could not get download link !\n\nTry again later.")
    return
  curSize = FFX42v(path)
  params = self.VV1aOD(VVu69c, checkExist=False, resumeByte=curSize)
  if len(params) == 1:
   self.VVqIBc(params[0])
   return
  elif len(params) == 2:
   self.VVO9I0(params[0], VVu69c)
   return
  url, fSize, path, resp, resumable = params
  if size == "-1":
   VVu69c = self.VVwbrm(VVu69c, url, fSize)
  threadName = "%s{%s,Sz,}%s" % (CChTrx.VVYR9N, path, VVu69c)
  if resumable: self.VV1v3j(threadName, url, VVu69c, path, resp, isAppend=True)
  else  : self.VVqIBc("Cannot resume from server !")
 def VVoRV4(self, VVu69c):
  span = iSearch(r"\?ext=(\..{3})", VVu69c)
  fileExt = CCSB3R.VVHGMA(VVu69c) or (span.group(1) if span else "") or ".mp4"
  fixName = True
  url = fName = VVeZBd = ""
  tUrl = iSub(r"[&?]mode=.+end=", r"", VVu69c, flags=IGNORECASE)
  span = iSearch(r"(https?:\/\/.+\/(?:movie|series).+\/.+\/)(.+)(:.+)", tUrl, IGNORECASE)
  if span:
   url  = span.group(1)
   fName = span.group(2)
   VVeZBd = span.group(3)
  elif "j.php" in tUrl:
   span = iSearch(r"(.+j.php)(:.+)", tUrl, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = "tmp"
    VVeZBd = span.group(2)
  elif "/play/" in VVu69c:
   span = iSearch(r"(.+)&mode.+&end=(:.+)", VVu69c, IGNORECASE)
   if span:
    url = span.group(1)
    VVeZBd = span.group(2)
   span = iSearch(r".+movie.php?.+stream=(.+\..{3,4})&.+", VVu69c, IGNORECASE)
   if span     : fName = span.group(1)
   elif fileExt == ".php" : fName = ".mkv" if ".mkv" in VVu69c else ".mp4"
   else     : fName = fileExt
  elif "get_download_link" in VVu69c:
   span = iSearch(r"(.+)&mode.+chCm=(.+)&end=(:.+)", VVu69c, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = os.path.basename(span.group(2))
    VVeZBd = span.group(3).replace(":", "_").strip("_")
    fixName = False
  elif "/timeshift/" in VVu69c:
   span = iSearch(r"(http.+\/timeshift\/.+(\..+)):(.+)(?:\s>>\s(.+))", VVu69c, IGNORECASE)
   if span:
    url, ext, VVeZBd, movNm = span.groups()
    fName = movNm + (ext or ".ts")
    fixName = False
  else:
   ok = False
   span = iSearch(r"(.+\/(.+.mp4).+m3u8).+:(.+)", VVu69c, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = span.group(2)
    VVeZBd = span.group(3)
    fixName = False
    ok  = True
   if not ok:
    span = iSearch(r"(.+\/.+m3u8).*:(.+)", VVu69c, IGNORECASE)
    if span:
     url  = span.group(1)
     VVeZBd = span.group(2)
     fName = VVeZBd + fileExt
     fixName = False
     ok  = True
   if not ok and FFzNJJ(VVu69c):
    span = iSearch(r"(.+)\?\:(.+)", VVu69c, IGNORECASE)
    if span:
     url  = span.group(1)
     VVeZBd = span.group(2)
     fName = VVeZBd + fileExt
     fixName = False
    else:
     span = iSearch(r"(.+):(.+)", VVu69c, IGNORECASE)
     if span:
      url  = span.group(1)
      VVeZBd = span.group(2)
      fName = VVeZBd + fileExt
      fixName = False
  if url and fName and VVeZBd:
   if fixName:
    mix  = fName + VVeZBd
    parts = mix.split(":", 1)
    fName = parts[0]
    VVeZBd = parts[1]
    fName = iSub(r"[?]play_token.+", r"", fName, flags=IGNORECASE)
    url += fName
   VVeZBd1 = VVeZBd.replace(" ", "_")
   fName = VVeZBd1 + "_" + fName.lstrip("_")
   fName = FF80BW(fName)
   if fName.endswith(".vod"): fName += ".mp4"
   return fName, VVeZBd, url
  else:
   return "", "", ""
 def VVqIBc(self, txt):
  FFU9uk(self.SELF, txt, title=self.Title)
 def VV32Lt(self):
  thrListUrls = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{.+})*(.+)" % CChTrx.VVYR9N, thr.name, IGNORECASE)
   if span:
    thrListUrls.append(span.group(1))
  return thrListUrls
 def VVVXWc(self):
  VVu69c = self.VV5ybN.VVqY3Q()[9]
  return VVu69c in self.VV32Lt()
 def VVKe5l(self):
  colList = self.VV5ybN.VVqY3Q()
  path = colList[6]
  size = colList[7]
  m3u8Log = colList[12]
  if m3u8Log:
   return FFf0vs(m3u8Log[:-9]) and not FFf0vs(m3u8Log)
  else:
   if size == "-1" : return False
   else   : return str(FFX42v(path)) == size
 def VVAmW1(self):
  colList = self.VV5ybN.VVqY3Q()
  path = colList[6]
  size = int(colList[7])
  curSize = FFX42v(path)
  if curSize > -1:
   size -= curSize
  err = CChTrx.VV5SvN(size)
  if err:
   FFU9uk(self.SELF, err, title=self.Title)
   return False
  return True
 def VVamxy(self, list):
  with open(CChTrx.VV6GoI(), "w") as f:
   for line in list:
    f.write(line + "\n")
 def VVwbrm(self, VVu69c, newUrl, newSize=-1):
  found = False
  lines = CChTrx.VVu28p()
  url = VVu69c
  with open(CChTrx.VV6GoI(), "w") as f:
   for line in lines:
    if CChTrx.VVGyz6(VVu69c, line):
     parts = line.split(",", 1)
     oldUrl = parts[1].strip()
     if newSize and not newSize == -1: fSize = str(newSize)
     else       : fSize = parts[0]
     ndx = url.find("j.php")
     if ndx > -1:
      url = newUrl + url[ndx + 5:]
     line = "%s,%s" % (fSize, url)
     found = True
    f.write(line + "\n")
  if found:
   self.VVKiXw()
  return url
 @staticmethod
 def VVu28p():
  list = []
  if FFf0vs(CChTrx.VV6GoI()):
   for line in FF2iRW(CChTrx.VV6GoI()):
    line = line.strip()
    if line:
     list.append(line)
  return list
 @staticmethod
 def VVGyz6(VVu69c, line):
  span = iSearch(r"(mode=.+end=.+)", VVu69c, IGNORECASE)
  if span: VVu69c = span.group(1)
  span = iSearch(r"(mode=.+end=.+)", line, IGNORECASE)
  if span: line = span.group(1)
  return VVu69c in line
 @staticmethod
 def VV5SvN(size, path=""):
  dest = path or CFG.MovieDownloadPath.getValue()
  if VVrRHR(dest):
   total, used, free, avail, err = CCQdsv.VV87Qo(dest)
   if avail > size : return ""
   else   : return "No enough space on mount for:\n%s\n\nFile Size = %s\nAvailable Space = %s" % (dest, CCQdsv.VVAcha(size), CCQdsv.VVAcha(avail))
  else:
   return "Path not found !\n\n%s" % dest
 @staticmethod
 def VVoULt(SELF):
  tot = CChTrx.VVLo8K()
  if tot:
   FFU9uk(SELF, "Cannot change while downloading.", title="")
   return True
  else:
   return False
 @staticmethod
 def VVLo8K():
  c = 0
  for thr in iEnumerate():
   if thr.name.startswith(CChTrx.VVYR9N):
    c += 1
  return c
 @staticmethod
 def VVREwG():
  lst = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{(.+),(.*),(.*)}).+" % CChTrx.VVYR9N, thr.name, IGNORECASE)
   if span:
    lst.append((span.group(1), span.group(2), span.group(3)))
  return lst
 @staticmethod
 def VVnzW8():
  return len(CChTrx.VVu28p()) == 0
 @staticmethod
 def VVjR9g():
  list = []
  for p in harddiskmanager.getMountedPartitions():
   list.append(p.mountpoint)
  return list
 @staticmethod
 def VVjqDw():
  mPoints = CChTrx.VVjR9g()
  list = []
  for mPath in mPoints:
   if not mPath == "/":
    path = mPath + "/movie/"
    if VVrRHR(path) : return path
    else    : list.append(mPath)
  drives = ("/hdd", "/usb", "/sd")
  for mPath in list:
   if any(x in mPath for x in drives):
    path = mPath + "/movie/"
    FF6usE("mkdir '%s'" % path)
    if VVrRHR(path):
     return path
  return "/tmp/"
 @staticmethod
 def VV6GoI():
  return FFmAG5() + "ajpanel_downloads"
 @staticmethod
 def VVWJLc(SELF, waitMsgObj=None):
  FFTSvN(waitMsgObj or SELF, BF(CChTrx.VVhWWI, SELF, CChTrx.VVxegu))
 @staticmethod
 def VVz8Kt(SELF):
  CChTrx.VVhWWI(SELF, CChTrx.VVfsCN, startDnld=True)
 @staticmethod
 def VVlexV(SELF, url):
  CChTrx.VVhWWI(SELF, CChTrx.VVfsCN, startDnld=True, VVu69c=url)
 @staticmethod
 def VVFLlS(SELF):
  added, skipped = CChTrx.VVogaa([CCaZ62(SELF.session).VVu69c])
  FFar20(SELF, "Added", 1000)
 @staticmethod
 def VVogaa(list):
  added = skipped = 0
  for line in CChTrx.VVu28p():
   for ndx, url in enumerate(list):
    if url and CChTrx.VVGyz6(url, line):
     skipped += 1
     list[ndx] = ""
     break
  with open(CChTrx.VV6GoI(), "a") as f:
   for url in list:
    if url:
     added += 1
     f.write("-1,%s\n" % url)
  return added, skipped
 @staticmethod
 def VVhWWI(SELF, mode, startDnld=False, VVu69c=""):
  title = "Download Manager"
  if not CC5ENZ.VVPib3(SELF):
   return
  if mode == CChTrx.VVxegu and CChTrx.VVnzW8():
   FFU9uk(SELF, "Download list is empty !", title=title)
  else:
   inst = CChTrx(SELF, mode, title, startDnld=startDnld, VVu69c=VVu69c)
 @staticmethod
 def VVAvee(res):
  if res.status_code == 206:
   return True
  else:
   hResume = res.headers.get("Accept-Ranges" , "")
   if hResume and not hResume == "none":
    return True
  return False
 @staticmethod
 def VVAHM2(url, timeout=3):
  err = ""
  try:
   import requests
   res = requests.get(url, headers=CCSB3R.VVY3r9(), allow_redirects=True, timeout=timeout)
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except Exception as e:
   err = "Error\n" + str(e)[:120]
  return "", err
class CCNCMt():
 def __init__(self, SELF, url, path, title, pbTxt="", cbFnc=None, timeout=3, showRes=True):
  self.SELF  = SELF
  self.url  = url
  self.Path  = path
  self.Title  = title
  self.pbTxt  = pbTxt or "Checking File Size ..."
  self.cbFnc  = cbFnc
  self.timeout = timeout
  self.showRes = showRes
  self.webFile = ""
  self.webSize = ""
  self.err  = ""
  self.done  = False
  Dir = os.path.dirname(path)
  if not VVrRHR(Dir):
   FFU9uk(SELF, "Path does not exist:\n\n%s" % Dir, title)
   return
  CCXRxc.VVJ9VK(SELF, titleBg="#22110011", bodyBg="#22110011", barBg="#06117722"
      , VVCJhW  = self.VVsqeP
      , VVuQkS = self.VVksss)
 def VVsqeP(self, VVM2wn):
  VVM2wn.VVkdWG(self.pbTxt)
  fSize = wSize = 0
  err = ""
  try:
   import requests
   resp = requests.get(self.url, headers=CCSB3R.VVY3r9(), timeout=self.timeout, stream=True, verify=True)
   if not resp.ok:
    if resp.reason : self.err = "Err-%d : %s" % (resp.status_code, resp.reason)
    else   : self.err = "Cannot download data from server"
    return
   head  = resp.headers
   cType = head.get("Content-Type", "")
   if "stream" in cType:
    fSize = head.get("Content-Length", "")
    fSize = int(fSize) if fSize.isdigit() else 0
   if not fSize: wSize = wSize = 200 * 1000 * 1000
   self.webFile = FFb6rW(head)
  except requests.Timeout as e  : err = "Connection Timeout (> %s sec)" % self.timeout
  except requests.ConnectionError as e: err = "Connection Error"
  except Exception as e    : err = "Error\n" + str(e)[:120]
  if not VVM2wn or VVM2wn.isCancelled:
   return
  if err:
   self.err = err
   return
  self.webSize = fSize or wSize
  if not self.webSize:
   self.err = "Cannot get size from server !"
   return
  err = CChTrx.VV5SvN(self.webSize)
  if err:
   self.err = err
   return
  if not VVM2wn or VVM2wn.isCancelled: return
  VVM2wn.VVqMKy(self.webSize)
  VVM2wn.VVkdWG("Downloading (%s) ..." % CCQdsv.VVAcha(self.webSize, mode=4))
  totBytes = 0
  try:
   with open(self.Path, "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if not FFf0vs(self.Path):
      self.err = "Cannot access file:\n\n%s" % self.Path
      return
     if not VVM2wn or VVM2wn.isCancelled:
      self.err = "Download Cancelled"
      return
     if chunk:
      try:
       f.write(chunk)
       VVM2wn.VVwOHf(len(chunk))
      except:
       self.err = "Cannot write to file:\n\n%s" % self.Path
       return
  except Exception as e:
   self.err = str(e)
 def VVksss(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if self.showRes:
   perc = int(100.0 * threadCounter / threadTotal) if threadTotal else 0
   path = self.Path if FFf0vs(self.Path) else ""
   if not VV9zbx:
    if path:
     if self.cbFnc: self.cbFnc(VV9zbx, self.url, self.webFile, self.Path)
     else   : FFU9uk(self.SELF, "Download cancelled (at %s%%) in:\n\n%s" % (perc, path) if path else ".", self.Title)
   elif self.err:
    FFU9uk(self.SELF, self.err + (" (at %s%%) in:\n\n%s" % (perc, path) if path else ""), self.Title)
   elif self.cbFnc:
    self.cbFnc(VV9zbx, self.url, self.webFile, self.Path)
   else:
    FFSQn9(self.SELF, "Successfully downloaded to:\n\n%s" % path, self.Title)
class CCtrKy():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.VV5GiO = False
  self.scrW, self.scrH = FFUA0v()
  self.X, self.Y, self.W, self.H = FFk61d(self.SELF)
 def VV6VOq(self, x, y): self.SELF.instance.move(ePoint(x, y))
 def VVP7ln(self, w, h): self.SELF.instance.resize(eSize(*(w, h)))
 def VVS1WM(self, fnc=None):
  self.VV6VOq(self.X, self.Y)
  self.VVP7ln(self.W, self.H)
  self.VV5GiO = False
 def VVX3FZ(self, up):
  if self.VV5GiO: return
  self.VV5GiO = True
  origY = -(self.Y + self.H) if up else self.scrH
  self.VV6VOq(self.X, origY)
  self.SELF.show()
  self.VVT1WE(up)
 def VVT1WE(self, up):
  try: y = self.SELF.instance.position().y() + (20 if up else -20)
  except: return
  if up and y < self.Y or not up and y > self.Y:
   self.VV6VOq(self.X, y)
   FFDiNL(BF(self.VVT1WE, up))
  else:
   self.VVS1WM()
 def VVrTcc(self, up):
  if self.VV5GiO: return
  self.VV5GiO = True
  self.VVbaLF(up)
 def VVbaLF(self, up):
  try: y = self.SELF.instance.position().y() + (-20 if up else 20)
  except: return
  if up and y > -(self.Y + self.H) or not up and y < self.scrH:
   self.VV6VOq(self.X, y)
   FFDiNL(BF(self.VVbaLF, up))
  else:
   self.SELF.hide()
   self.VVS1WM()
 def VVHVqs(self):
  if self.VV5GiO: return
  self.VV5GiO = True
  self.VVF1Zg()
 def VVF1Zg(self):
  x, y, w, h = FFk61d(self.SELF)
  x += 70
  w -= 140
  if w > 1:
   self.VVP7ln(w, h)
   self.VV6VOq(x, y)
   FFDiNL(self.VVF1Zg)
  else:
   self.SELF.close()
   self.VV5GiO = False
class CC2lVw(Screen, CCxZ66):
 VVHlBB = None
 def __init__(self, session, VVVQym=None, VVQpKh=True, VViMad=True, VVr3eH=True, VVKvO9=False, VV7GTU="", endRef="", zapFnc=None, VVthiO="", cbFnc=None, VVMjFx=0):
  self.skin, self.VVuaAL = FFJH4U(VVJvMX, 1600, 190, 28, 10, 6, "#1100202a", "#1100202a", 24, VV1fgG=2)
  CCxZ66.__init__(self)
  self.session    = session
  self.VVVQym  = VVVQym
  self.VVQpKh   = VVQpKh
  self.VViMad  = VViMad
  self.VVr3eH  = VVr3eH
  self.VVKvO9  = VVKvO9
  self.VV7GTU    = VV7GTU
  self.endRef     = endRef
  self.zapFnc     = zapFnc
  self.VVthiO    = VVthiO
  self.cbFnc     = cbFnc
  self.VVMjFx   = VVMjFx
  self.Title     = ""
  self.VV1CZl    = "Catch-up"
  self.resetMediaTxt   = 'You can restart media with "<" Button'
  self.VVvsI8    = eTimer()
  self.VVEsDz    = 250
  self.VVXQ1R   = int(CFG.playerTimeout.getValue()) * 1000
  self.VVYvJc   = 0
  self.barWidth    = 0
  self.VVZ3ZU    = 0
  self.VVCaLl   = False
  self.VVgeM2   = 0
  self.VVOMf2   = 0
  self.VVerLQ   = CFG.playerJumpMin.getValue()
  self.VVtZlS    = 0
  self.VVsE0z    = ""
  self.VVNNkl   = 0
  self.VV7ybj  = 0
  self.VVLOqO   = None
  self.VVEdv8  = False
  self.VVnRDm    = False
  self.VVovjG  = ""
  self.VV6Fqi   = False
  self.tpData     = CCAAmm()
  self.tunerInfo    = CCMbAF()
  self.VVU96W   = None
  self.VVOBcf   = ("", "", 0)
  self.lastPIconPath   = None
  self.animate    = None
  self.firstTime    = True
  FFfmZP(self, "")
  self["myPlayBarF"] = Label()
  self["myPlayBarBG"] = Label()
  self["myPlayBar"] = Label()
  self["myPlayMov"] = Label()
  self["myPlayVal"] = Label()
  self["myPlayPos"] = Label()
  self["myPlaySkp"] = Label()
  self["myPlayMsg"] = Label()
  self["myPlayRem"] = Label()
  self["myPlayDur"] = Label()
  self["myPlaySep"] = Label()
  self["myPlayGrn"] = Label("Refresh")
  self["myPlayJmp"] = Label(self.VV0Gzt())
  self["myPlayDat"] = Label("")
  self["myPlayTim"] = Label("")
  self["myPlayRes"] = Label("")
  self["myPlayFps"] = Label()
  self["myPlayAsp"] = Label()
  self["myPlayYel"] = Label("")
  self["myPlayBlu"] = Label("Cut-List")
  self["myPlayTyp"] = Label()
  self["myPlayPic"] = Pixmap()
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   self[nm] = Pixmap()
   self[nm].hide()
  color = self.VVuaAL["VVQbHY"]
  nms = ("SNR", "AGC", "BER")
  for nm in nms: self["mySliderTxt%s" % nm] = Label(nm)
  for nm in nms: self["mySliderFrm%s" % nm] = Label()
  for nm in nms: self["mySliderBak%s" % nm] = Label()
  for nm in nms: self["mySliderCov%s" % nm] = Label()
  for nm in nms: self["mySliderPic%s" % nm] = Pixmap()
  self.sliderSNR = CC1mZN(self, self["mySliderPicSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC = CC1mZN(self, self["mySliderPicAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER = CC1mZN(self, self["mySliderPicBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  FFewq4(self,
  {
   "ok"  : self.VVTOku       ,
   "info"  : self.VVp9lg      ,
   "epg"  : self.VVp9lg      ,
   "pvr"  : self.VVtCux     ,
   "menu"  : self.VV9HRV     ,
   "cancel" : self.cancel       ,
   "red"  : self.VVLTPG    ,
   "green"  : self.VVnjhR  ,
   "blue"  : self.VVCcFr      ,
   "yellow" : self.VVbTZJ ,
   "longPlay" : self.VVnubM    ,
   "play"  : self.VVPZiG      ,
   "pause"  : self.VVPZiG      ,
   "playPause" : self.VVPZiG      ,
   "stop"  : self.VVPZiG      ,
   "stopLong" : self.VVzL6H     ,
   "powerLong" : self.VVzL6H     ,
   "rewind" : self.VVjvFx      ,
   "forward" : self.VVX4hH      ,
   "rewindDm" : self.VVjvFx      ,
   "forwardDm" : self.VVX4hH      ,
   "last"  : self.VVHhYS      ,
   "next"  : self.VVyMcj      ,
   "left"  : BF(self.VViJXe, -1)    ,
   "right"  : BF(self.VViJXe,  1)    ,
   "up"  : BF(self.VV6VXq, True)  ,
   "down"  : BF(self.VV6VXq, False)  ,
   "pageUp" : BF(self.VV6VXq, True)  ,
   "pageDown" : BF(self.VV6VXq, False)  ,
   "chanUp" : BF(self.VV6VXq, True)  ,
   "chanDown" : BF(self.VV6VXq, False)  ,
   "audio"  : BF(self.VVFFMQ, True)  ,
   "subtitle" : BF(self.VVFFMQ, False)  ,
   "text"  : self.VVIpNx  ,
   "0"   : BF(self.VV3Po9 , 10)   ,
   "1"   : BF(self.VV3Po9 , 1)   ,
   "2"   : BF(self.VV3Po9 , 2)   ,
   "3"   : BF(self.VV3Po9 , 3)   ,
   "4"   : BF(self.VV3Po9 , 4)   ,
   "5"   : BF(self.VV3Po9 , 5)   ,
   "6"   : BF(self.VV3Po9 , 6)   ,
   "7"   : BF(self.VV3Po9 , 7)   ,
   "8"   : BF(self.VV3Po9 , 8)   ,
   "9"   : BF(self.VV3Po9 , 9)
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  if self.firstTime:
   self.firstTime = False
   self.VVg4PK()
  else:
   self.VVU3KC()
 def VVg4PK(self):
  FF1uow(self)
  for b in ("myPlayGrn", "myPlayYel", "myPlayBlu"):
   FFiZTW(self[b], "#000000", 3)
  if not CC2lVw.VVHlBB:
   CC2lVw.VVHlBB = self
  for k, v in {"myPlayCc": "cc1", "myPlayAud": "aud", "myPlayDnld": "dnld", "myPlayRpt": "rpt"}.items():
   FFgfSp(self[k], v)
  self.sliderSNR.VVjD56()
  self.sliderAGC.VVjD56()
  self.sliderBER.VVjD56(isBER=True)
  self.VVLCUI()
  self.instance.move(ePoint(40, 40))
  self.VVuG4t(CFG.playerPos.getValue())
  self["myPlayMov"].hide()
  self["myPlaySkp"].hide()
  size = self["myPlayBar"].instance.size()
  self.barWidth = int(size.width())
  self.VVZ3ZU = int(size.height())
  self["myPlayBar"].instance.resize(eSize(*(1, self.VVZ3ZU)))
  try: self.VVvsI8_conn = self.VVvsI8.timeout.connect(self.VV0dV0)
  except: self.VVvsI8.callback.append(self.VV0dV0)
  self.VVvsI8.start(self.VVEsDz, False)
  seekSt, chSt, chStTxt = self.VVs2Ds()
  self.VV0dV0("" if seekSt == "Playing" else "Checking ...")
  if self.VV7GTU:
   VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
   if self.VV7GTU != VVDhju + ":" + VVQwVu:
    self.VVZj8h(self.VV7GTU, "Starting Service ...")
    return
  if not self.VVVQym:
   self.VVk7n9()
 def VVnjhR(self):
  if not self["myPlayGrn"].getVisible():
   return
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  self.VVLOqO = CCBalh.VVmEsO()
  p = CCNREC()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVmjzD(VVu69c)
  if "chCode" in VVLZ0Z and not "deviceMac=" in chCm:
   if CC5ENZ.VVPib3(self):
    self.VVk7n9(True)
  else:
   self.VV0dV0("Refreshing ...")
   self.VVEdv8 = True
   FFDiNL(BF(CCAnLc.VVzv7h, self.session))
  FFDiNL(self.VVLCUI)
 def VVljos(self, VVu69c):
  data = CCSB3R.VV6RmU(VVu69c)
  if data and (not self.VVovjG or data != self.VVovjG):
   iThread(name="ajp_catchup", target=BF(self.VVjYai, data)).start()
 def VVjYai(self, data):
  uHost, uUser, uPass, uId, VVeZBd = data
  if all([uHost, uUser, uPass, uId]) and CChg05.VVIg8w():
   pList, err = CCSB3R.VVRTnq("%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass), uId, mode=0)
   if pList:
    self.VVovjG = data
    self.VV6Fqi = True
 def VVLCUI(self):
  self.VVsE0z = ""
  self.VVovjG = None
  self.VV6Fqi  = False
  self.VVfzak()
  s = self.VVmk3F()
  if self.VVKvO9:
   self.VV6Fqi = True
  elif s._prov in ("Playlist", "Portal") and not FFzNJJ(s.VVu69c):
   FFUttZ(self, 1500, BF(self.VVljos, s.VVu69c))
  s.VVeZBd = FFes9J(s.VVeZBd)
  if s.VVDhju or s.VVeZBd: self.Title = s.VVeZBd.replace("\n", " > ")
  else     : self.Title = VVu50a + "No Service !"
  self["myTitle"].setText("  " + self.Title + "  ")
  FFu0W6(self["myTitle"], s._tColor)
  FFu0W6(self["myBody"], s._tColor)
  for item in ("Pos", "Skp", "Msg", "Rem", "Dur", "Jmp", "Dat", "Tim", "Res", "Fps", "Asp", "Pic", "Typ", "Yel"):
   FFu0W6(self["myPlay%s" % item], s._tColor)
  FFcfsH(self["myPlayYel"], "#0080dddd" if s.isDvb else "#00cccccc")
  for nm in ("SNR", "AGC", "BER"):
   FFu0W6(self["mySliderTxt%s" % nm], s._tColor)
  if s._prov == "Others" : self["myPlayGrn"].hide()
  else     : self["myPlayGrn"].show()
  picFile = self.VVthiO
  if not FFf0vs(picFile):
   if not iMatch(r"^\d*:(0:){9}\/.+", s.VVDhju):
    picFile = CCISy5.VVD1E7(s.VVDhju)
    if not FFf0vs(picFile):
     picFile = CCISy5.VVD1E7(s.VV5zMI)
  if not FFf0vs(picFile):
   fPath, fDir, fName, picFile = CCISy5.VV9Ly5(self)
  if not FFf0vs(picFile):
   pPath = CCUNc6.VVQ490()
   picFile = CCUNc6.VVjFPF(pPath, s.VVDhju, s.VVeZBd)
  if picFile != self.lastPIconPath:
   self["myPlayTyp"].setText(s.streamType)
   self.lastPIconPath = picFile
   self["myPlayPic"].hide()
   self["myPlayTyp"].show()
   if os.path.isfile(picFile) and FFlfvg(self["myPlayPic"], picFile, VVpaQ6=s._tColor):
    self["myPlayPic"].show()
    self["myPlayTyp"].hide()
 def VV0dV0(self, stateTxt="", highlight=False):
  if self.VVXQ1R:
   if self.shown:
    self.VVYvJc += self.VVEsDz
    if self.VVYvJc >= self.VVXQ1R:
     self.VVys0P()
   else:
    self.VVYvJc = 0
  now = datetime.now()
  self["myPlayDat"].setText(now.strftime("%Y-%m-%d"))
  self["myPlayTim"].setText(now.strftime("%H:%M:%S"))
  if CChTrx.VVLo8K() : self["myPlayDnld"].show()
  else         : self["myPlayDnld"].hide()
  s = self.VVmk3F()
  tTitle = self.Title
  if s._prov == self.VV1CZl and " >> " in s.VVeZBd:
   ch, _, ev = s.VVeZBd.partition(" >> ")
   ch, ev = ch.strip(), ev.strip()
   if ch and ev:
    tTitle, s._evName = ch, ev
  if s._evName:
   s._evName = "    %s    " % FFITtK(s._evName, VVVAvR)
  self["myTitle"].setText("  %s%s  " % (tTitle, s._evName))
  self["myPlayYel"].setText(s._prov)
  if s._prov == self.VV1CZl or self.VV6Fqi:
   FFNucL(self["myPlayYel"], "#00ffffff", "#11a08000", inv=False)
  if s._seekable and s._durVal > 60:
   self["myPlayBlu"].show()
   self["myPlayJmp"].show()
  else:
   self["myPlayBlu"].hide()
   self["myPlayJmp"].hide()
  if s.isDvb or s.VV5zMI:
   self.tunerInfo.VVQepD(s.servPtr)
   if self.tunerInfo.infoAvailable:
    self.sliderSNR.VVfvKV(self.tunerInfo.VVtlTo())
    self.sliderAGC.VVfvKV(self.tunerInfo.VV1sKa())
    self.sliderBER.VVfvKV(self.tunerInfo.VV1qIQ())
  if not self.VVCaLl:
   player = CCSB3R.VVKwA7(s.VVDhju)
   if player:
    self["myPlaySkp"].show()
    self["myPlaySkp"].setText(VVgzFX + player)
   else:
    self["myPlaySkp"].hide()
  self["myPlayRes"].setText(s._res)
  self["myPlayFps"].setText(s._fr)
  self["myPlayAsp"].setText(s._ratio)
  self["myPlayPos"].setText(s._posTxt if s._posTxt else "")
  self["myPlayVal"].setText(s._percTxt if s._percTxt else "")
  self["myPlayRem"].setText("-%s" % s._remTxt if s._remTxt else "")
  self["myPlayDur"].setText(s._durTxt if s._durTxt else "")
  if s._durTxt:
   FFu0W6(self["myPlayBarBG"], "#11000000")
   self["myPlayBarBG"].show()
   self["myPlayBarF"].show()
   self["myPlayBar"].show()
   width = 0
   percent = FF9BdF(s._percVal, 0, 100)
   width = int(FFPSde(percent, 0, 100, 0, self.barWidth))
   self["myPlayBar"].instance.resize(eSize(*(width, self.VVZ3ZU)))
  else:
   self["myPlayBarBG"].hide()
   self["myPlayBarF"].hide()
   self["myPlayBar"].hide()
   self["myPlayVal"].setText(">>>>")
   FFu0W6(self["myPlayBarBG"], s._tColor)
  self.VV0klC()
  if stateTxt:
   if highlight: FFcfsH(self["myPlayMsg"], "#0000ffff")
   else  : FFcfsH(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(stateTxt)
   self.VVtZlS = iTime()
  if self.VVtZlS and iTime() - self.VVtZlS < 1:
   return
  else:
   self.VVtZlS = 0
   FFcfsH(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(s._state)
  if s.VVsC9C or s.VV5zMI:
   FFcfsH(self["myPlayMsg"], "#00ffaaff")
   txt = "Stream Relay"
   if len(self.VVsE0z) > 1: txt = "%s - %s%s" % (txt, VVHFlX, self.VVsE0z)
   self["myPlayMsg"].setText(txt)
  elif s.isDvb:
   FFcfsH(self["myPlayMsg"], "#00aaaaaa")
   self["myPlayMsg"].setText(self.VVsE0z)
  stateTxt = ""
  chkResume = False
  seekSt, chSt, chStTxt = self.VVs2Ds()
  if seekSt:
   stateTxt = seekSt
   if s._percVal == 100:
    stateTxt = "End"
    self.VVfzak()
    if self.VVnRDm:
     self.VVHhYS()
   elif seekSt == "Playing":
    if s._posTxt:
     chkResume = True
    elif chSt == CCOwzx.VVVy3B and s.isIptv and s.VVDhju.startswith("1:"):
     stateTxt = seekSt
    else:
     stateTxt = "%sWaiting for state change ..." % (("State: %s - " % chStTxt) if chStTxt else "")
  if chSt == CCOwzx.VVVy3B:
   Id, rt, sIcon = self.VVOBcf
   if (s.uniqueId, s.refType) != (Id, rt):
    sIcon = CCISy5.VVaEpg()
    self.VVOBcf = (s.uniqueId, s.refType, sIcon)
    if sIcon > 0:
     FFgfSp(self["myPlayCc"], "cc%s" % sIcon)
     self["myPlayCc"].show()
    else:
     self["myPlayCc"].hide()
    if CCISy5.VVGOEp(self.session) > 1 : self["myPlayAud"].show()
    else             : self["myPlayAud"].hide()
  if not s._seekable and not s.isIptv:
   return
  if chkResume:
   if not self.VVEdv8:
    self.VVNNkl = s._posVal
   elif not s._durVal:
    self.VVEdv8 = False
   else:
    if self.VVNNkl > 0:
     move = end = False
     s1 = "." * self.VV7ybj
     stateTxt = ("%s Restoring Posistion %s" % (s1, s1)).strip()
     self.VV7ybj += 1
     diff = abs(s._posVal - self.VVNNkl)
     if   diff < 10     : end = True
     elif self.VV7ybj == 1: move = True
     elif self.VV7ybj >= 10:
      if diff > 10:
       move = True
      end = True
     if move and CFG.resumeMovies.getValue() == "off":
      self.VV4I7c(self.VVNNkl * 90000.0)
     if end:
      self.VV7ybj = 0
      self.VVEdv8 = False
      CCBalh.VV88Fx(self.VVLOqO)
    else:
     self.VVEdv8 = False
  bufS = self.VVVJnh()
  if bufS:
   stateTxt = bufS
  FFcfsH(self["myPlayMsg"], "#0000ff00" if stateTxt == "Playing" else "#00FF8F5F" )
  self["myPlayMsg"].setText(stateTxt)
 def VVmk3F(self):
  s = CCaZ62(self.session)
  s._state = s.state.replace("*", "") or "No system info"
  s._seekable, s._percVal, s._durVal, s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = CC2lVw.VVp3Eo(self)
  s._VVenWR = "chCode" in s.VVu69c
  s._VVSEMn = CCSB3R.VVmpeB(s.VVu69c)
  s._VVqgRb = "/timeshift/" in s.VVu69c
  iptv   = s.isIptv or "http" in s.VVu69c
  if   s.isDvb  : s._tColor, cat = "#1100102a", "DVB"
  elif s.isLocal  : s._tColor, cat = "#0a401100", "Local Media"
  elif s._VVenWR : s._tColor, cat = "#1120002a", "Portal"
  elif s.isFtp  : s._tColor, cat = "#11222222", "FTP"
  elif s._VVqgRb : s._tColor, cat = "#11223322", self.VV1CZl
  elif s._VVSEMn : s._tColor, cat = "#11001c1c", "Playlist"
  elif s.VVsC9C  : s._tColor, cat = "#11223344", "S. Relay"
  elif iptv   : s._tColor, cat = "#11113030", "IPTV"
  else    : s._tColor, cat = "#11111111", "Others"
  s._prov = self.VV1CZl if self.VV6Fqi else (s.prov or cat)
  if (s.isDvb or s.VV5zMI) and not self.VVsE0z:
   self.VVsE0z = self.tpData.VVG37d([s.VVDhju, s.VV5zMI], nonTxt="-")
  valid = (s.isDvb and s.isValid) or s.VV5zMI
  for nm1 in ("Txt", "Frm", "Cov", "Bak", "Pic"):
   for nm2 in ("SNR", "AGC", "BER"):
    if valid: self["mySlider%s%s" % (nm1, nm2)].show()
    else : self["mySlider%s%s" % (nm1, nm2)].hide()
  s._evName = s._evNameNext = ""
  evLst = CCfClD.VVwpm8(s.VVDhju)
  if evLst:
   s._evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt = evLst[0]
   if not s._durVal:
    if len(evLst) > 1:
     s._evNameNext = evLst[1][0]
    if evPos >= evDur:
     s._percVal = 100
     percTxt = "%d %%" % s._percVal
    else:
     s._percVal = float(evPos) * 100.0 / float(evDur)
     percTxt = "%.2f %%" % s._percVal
    s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = evPos, evRem, percTxt, evDurTxt, evPosTxt, evRemTxt
  s._res = CCISy5.VVIQXr(s.info)
  s._fr, rate = "", FF7SHi(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   s._fr = "%d fps" % (int(rate) / 1000)
  s._ratio = CCISy5.VVT43R(s.info)
  return s
 @staticmethod
 def VVp3Eo(SELF):
  percVal = durVal = posVal = remVal = seekable = 0
  percTxt = durTxt = posTxt = remTxt = ""
  isEnded = False
  try:
   service = SELF.session.nav.getCurrentService()
   if service:
    pSeek = service.seek()
    if pSeek:
     seekable = pSeek.isCurrentlySeekable()
     durLst  = pSeek.getLength()
     posLst  = pSeek.getPlayPosition()
     if durLst[0] == 0:
      durVal = durLst[1] / 90000.0
      if durVal:
       durTxt = FF79L2(durVal)
     if posLst[0] == 0:
      posVal = posLst[1] / 90000.0
      posTxt = FF79L2(posVal)
     if durVal > 0 and posVal > 0:
      remVal = durVal - posVal + 1
      remTxt = FF79L2(remVal)
     if durVal > 0:
      if round(posVal) >= int(durVal):
       percVal = 100
       percTxt = "%d %%" % percVal
       posVal = durVal
       posTxt = durTxt
       remTxt = ""
      else:
       percVal = float(posVal) * 100.0 / float(durVal)
       percTxt = "%.2f %%" % percVal
  except:
   pass
  return seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt
 def VV9HRV(self):
  s = self.VVmk3F()
  VVXXzc = []
  c1, c2, c3, c4 = VVu50a, VV6UAe, VVkLs0, VVnQYw
  VVXXzc.append(("Service Info.", "info"))
  VVXXzc.append(FFwjWO("Play with ..."   , "playWith", s.VVDhju and not s.isDvb , c4))
  VVXXzc.append(FFwjWO("Restart Current Service" , "restart" , s.VVDhju     , c1))
  VVXXzc.append(FFwjWO("Stop Current Service"  , "stop" , s.VVDhju     , c1))
  VVXXzc.append(VVzg1X)
  if s._durTxt and s._posTxt:
   VVXXzc.append((c2 + "Start Subtitle", "VVqJYe"))
   VVXXzc.append(VVzg1X)
  canDownload = s.VVu69c and s._seekable == 3 and s._durVal > 0
  if canDownload:
   VVXXzc.append((c3 + "File Size (on server)", "fileSize"))
  if self.VViMad:
   if canDownload:
    VVXXzc.append((c3 + "Start Download"  , "dload_cur" ))
    VVXXzc.append((c3 + "Add to Download List", "addToDload" ))
  show = not CChTrx.VVnzW8()
  VVXXzc.append(FFwjWO("Download Manager", "dload_stat", show, c3))
  VVXXzc.append(VVzg1X)
  addSep = False
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  if fPath:
   c = VVnQYw
   if not "VV1Tjj" in globals():
    VVXXzc.append((c + "Open Path in File Manager", "VV2qos"))
   VVXXzc.append((c + "Add to Bouquet"            , "VVU6P7" ))
   VVXXzc.append((c + "%s Auto-Repeat" % ("Disable" if self.VVnRDm else "Enable"), "VVlwms"  ))
   addSep = True
  elif s.isFtp:
   VVXXzc.append((c2 + "Add FTP Media to Bouquet", "VV4VVp"))
   addSep = True
  if addSep: VVXXzc.append(VVzg1X)
  if s.isDvb:
   VVXXzc.append((c4 + "Signal Monitor (Red Button)", "sigMon"))
   VVXXzc.append(VVzg1X)
  if not "VVwjls" in globals() and not "VVjKhK" in globals():
   VVXXzc.append((c4 + "IPTV Menu", "iptv"))
   VVXXzc.append(VVzg1X)
  if self.VVr3eH:
   path, lst, err = CCBoou.VVAjdC()
   if lst:
    VVXXzc.append((c3 + "Movies Resume History", "resume"))
    VVXXzc.append(VVzg1X)
  VVXXzc.append(("Set Bar Visibility Timeout", "timeout"))
  VVXXzc.append(("Set Red Button Action"  , "red" ))
  if CFG.playerPos.getValue() : VVXXzc.append(("Move Bar to Bottom" , "botm"))
  else      : VVXXzc.append(("Move Bar to Top" , "top" ))
  VVpuzu = self.VVHmMi
  FFw2XU(self, self.VVnczd, VVXXzc=VVXXzc, width=650, height=1050, title="Options", VV7tbr=True, VVpuzu=VVpuzu, VVVzvS="#22001122", VVhHWW="#11000919")
 def VVnczd(self, item=None):
  if item:
   if   item == "info"     : self.VVp9lg()
   elif item == "playWith"    : self.VVnubM()
   elif item == "restart"    : self.VVipHn()
   elif item == "stop"     : self.VVzL6H()
   elif item == "VVqJYe"  : self.VVoZB9()
   elif item == "fileSize"    : CCISy5.VVrTOV(self)
   elif item == "dload_cur"   : CChTrx.VVz8Kt(self)
   elif item == "addToDload"   : CChTrx.VVFLlS(self)
   elif item == "dload_stat"   : CChTrx.VVWJLc(self)
   elif item == "VV2qos" : self.VVxvux("VVlGw7")
   elif item == "VVU6P7" : self.VVU6P7()
   elif item == "VVlwms"  : self.VVlwms()
   elif item == "VV4VVp" : self.VV4VVp()
   elif item == "sigMon"    : self.VVbvLb()
   elif item == "iptv"     : self.VVxvux("VVSA3u")
   elif item == "resume"    : self.VVxvux("VVTlDC")
   elif item == "timeout"    : CC8MwG.VVlTg2(self, CFG.playerTimeout, "Bar Timeout (Seconds)" , isSave=True, width=700, cbFnc=self.VVJ7lp)
   elif item == "red"     : CC8MwG.VVlTg2(self, CFG.playerRedBtn , "Red Button Action"  , isSave=True, width=700)
   elif item == "botm"     : self.VVuG4t(0)
   elif item == "top"     : self.VVuG4t(1)
   elif item == "VV7tbr"    : self.VVJu4i()
 def VVJu4i(self):
  VVXXzc = []
  s = self.VVmk3F()
  m2 = s.VVDhju and not s.isDvb and FFK5uM(self)
  VVXXzc.append(FFwjWO("Stop Current Service"       , "st1" , s.VVDhju ))
  VVXXzc.append(FFwjWO("Stop Current Service & Close %s" % VVryLp, "st2" , m2  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Play Last Stopped Channel", "pl", not s.VVDhju))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Channel Selection", "chS" ))
  VVXXzc.append(("Channels Browser" , "chB" ))
  VVXXzc.append(("Zap History"  , "zh" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(FFwjWO("Download Poster (for current event)", "ps0", CCfClD.VVZ1cH(self)))
  if VVpSLv:
   VVXXzc.append(("Find a poster T", "ps1"))
   VVXXzc.append(("Find a poster I", "ps2"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Close %s" % VVryLp, "end"))
  FFw2XU(self, self.VV6EDU, VVXXzc=VVXXzc, width=740, title="More Options", VVVzvS="#22220000", VVhHWW="#11110000")
 def VV6EDU(self, item=None):
  if item:
   if   item == "st1": self.VVzL6H()
   elif item == "st2": self.VVzL6H(True)
   elif item == "pl" : self.VVlPn9()
   elif item == "chS": self.VVtCux()
   elif item == "chB": CCdo8n.VVhcdr(self)
   elif item == "zh" : self.session.open(CC48aY)
   elif item == "ps0": self.session.open(CC7qmh)
   elif item == "ps1": self.session.open(CC7qmh, mode=1)
   elif item == "ps2": self.session.open(CC7qmh, mode=2)
   elif item == "end": FFBHAU(self)
 def VVJ7lp(self):
  self.VVXQ1R = int(CFG.playerTimeout.getValue()) * 1000
 def VVLTPG(self):
  v = CFG.playerRedBtn.getValue()
  if  v == "s": self.VVbvLb()
  elif v == "e": self.VV1wpD()
 def VVbvLb(self):
  if self.shown:
   s = CCaZ62(self.session)
   if s.isDvb : self.VVxvux("VVfbG9")
   else  : self.VV0dV0("No Signal for Current Service")
 def VV1wpD(self):
  s = self.VVmk3F()
  if not s.isDvb or not s.isValid:
   CCAnLc.VV59Kt(self.session, s.servRef)
  self.close()
 def onExit(self):
  self.VVvsI8.stop()
  CC2lVw.VVHlBB = None
  if self.cbFnc: self.cbFnc()
  if self.endRef: FF5deK(self.session, self.endRef)
 def cancel(self):
  if self.VVCaLl: self.VVfzak()
  elif self.shown  : self.VVxvux()
  else    : self.VV0PAq()
 def VV0PAq(self):
  self.animate.VVX3FZ(CFG.playerPos.getValue())
 def VVys0P(self):
  self.animate.VVrTcc(CFG.playerPos.getValue())
 def VVxvux(self, act=None):
  if act     : self.close(act)
  elif self.VVMjFx: self.animate.VVHVqs()
  else     : self.close()
 def VVHmMi(self, VVZzW8, txt, ref, ndx):
  FFpIdO(self, "_help_player", "Player Bar (Keys)")
 def VVipHn(self):
  self.VV0dV0("Restarting Service ...")
  FFDiNL(BF(CCAnLc.VVzv7h, self.session))
 def VVzL6H(self, end=False):
  self.VV0dV0("Stopping current service ...")
  FFDiNL(BF(self.VV7Ibj, end))
 def VV7Ibj(self, end):
  fromTbls = self.VVVQym or self.zapFnc
  zapped = False
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   path = serv.getPath()
   self.session.nav.stopService()
   self.show()
   self.VVLCUI()
   if path.startswith(("/", "http")) or fromTbls:
    zapped = CCAnLc.VV59Kt(self.session, serv)
  if end:
   FFBHAU(self)
  else:
   if fromTbls : self.VVxvux()
   elif zapped : self.VVLCUI()
   else  : self.VVtCux()
 def VVlPn9(self):
  rootR, servR = CCAnLc.VVRKt9()
  if servR:
   self.VVZj8h(servR, "Playing Last Service ...")
 def VVnubM(self):
  CCSB3R.VVb38U(self, self.VVJCjN)
 def VVJCjN(self, rType=None):
  if rType:
   FFDiNL(BF(self.VVFfT4, rType))
 def VVFfT4(self, rType=None):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv : FFi8da(self.session, eServiceReference(rType + ":" + serv.toString().split(":", 1)[1]))
  else : self.VV0dV0("No active service !")
  self.VVLCUI()
 def VVU6P7(self):
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  if fPath: picker = CC41Tt(self, self, "Add Current Movie to a Bouquet", BF(self.VV5oQU, [fPath]))
  else : FF8PJn(self, "Path not found !", 1500)
 def VV5oQU(self, pathLst):
  return CC41Tt.VVONdL(pathLst)
 def VV4VVp(self):
  picker = CC41Tt(self, self, "Add FTP Media to Bouquet", self.VV8e5L)
 def VV8e5L(self):
  VVQwVu = CCaZ62(self.session).VVQwVu
  return CC41Tt.VVONdL([VVQwVu], rType=VVDhju.split(":", 1)[0])
 def VVlwms(self):
  ok = False
  if self.VVnRDm:
   self.VVnRDm = False
   txt = "Auto-Repeat OFF"
   ok = True
  else:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
   if seekable and durVal > 0:
    if durVal >= 60:
     self.VVnRDm = True
     txt = "Auto-Repeat ON"
     ok = True
    else: txt = "Too short (min = 1 minute)"
   else: txt = "Cannot Auto-Repeat"
  if self.VVnRDm : self["myPlayRpt"].show()
  else    : self["myPlayRpt"].hide()
  self.VV0dV0(txt, highlight=ok)
 def VVuG4t(self, pos):
  scrSize = getDesktop(0).size()
  scrW = scrSize.width()
  scrH = scrSize.height()
  x  = (scrW - self.instance.size().width()) / 2.0
  if pos == 0 : y = (scrH - self.instance.size().height() - 20)
  else  : y = 20
  self.instance.move(ePoint(int(x), int(y)))
  if not pos == CFG.playerPos.getValue():
   FFDDwF(CFG.playerPos, pos)
  self.animate = CCtrKy(self)
 def VVoZB9(self):
  self.session.openWithCallback(self.VVBN5H, CCBalh, self)
 def VVIpNx(self):
  if self.shown:
   s = self.VVmk3F()
   if s._posTxt and s._durTxt : self.VVoZB9()
   else      : self.VV0dV0("No duration Info. !")
 def VVBN5H(self, reason):
  if reason == "subtCancel":
   return
  self.VV0PAq()
  txt = ""
  if   reason == "subtExit" : pass
  elif reason == "subtCancel" : pass
  elif reason == "subtInval" : txt = "Invalid srt file"
  elif reason == "subtZapUp" : self.VV6VXq(True)
  elif reason == "subtZapDn" : self.VV6VXq(False)
  elif reason == "longPlay" : self.VVnubM()
  elif reason == "pause"  : self.VVPZiG()
  elif reason == "audio"  : self.VVFFMQ(True)
  elif reason == "subtitle" : self.VVFFMQ(False)
  else      : txt = reason
  if txt:
   FF8PJn(self, txt, 2000)
 def VVTOku(self):
  if self.VVCaLl:
   self.VVfzak()
   self.VV4I7c(self.VVOMf2)
  elif not self.session.nav.getCurrentlyPlayingServiceReference():
   self.VVtCux()
  elif self.shown:
   if CCBalh.VVMEHg(self): self.VVoZB9()
   elif self.shown       : self.VVys0P()
  else:
   self.VV0PAq()
 def VVp9lg(self):
  CCISy5.VVIXmT(self, VVjex7=CCISy5.VVn7qY, VVthiO=self.VVthiO, cbFnc=self.VVLCUI)
 def VVtCux(self):
  CCAnLc.VVLTHQ()
 def VVPZiG(self):
  try: InfoBar.instance.playpauseService()
  except: pass
  self.VV0dV0("Toggling Play/Pause ...")
 def VVhyTC(self):
  try: InfoBar.instance.unPauseService()
  except: pass
 def VVfzak(self):
  try:
   if self.VVCaLl:
    self.VVCaLl = False
    self["myPlayMov"].hide()
    self["myPlaySkp"].hide()
  except:
   pass
 def VViJXe(self, direc):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
  if percVal == 100:
   self.VV0dV0(self.resetMediaTxt)
  elif seekable and durVal > 0:
   if not self.VVCaLl:
    self.VVCaLl = True
    self["myPlayMov"].show()
    self["myPlaySkp"].show()
    self.VVgeM2 = posVal + direc * self.VVFDBH()
   else:
    self.VVgeM2 += direc * self.VVFDBH()
    self.VVgeM2 = FF9BdF(self.VVgeM2, 0, durVal)
   minLeft = self["myPlayBar"].getPosition()[0] - 1
   maxLeft = self["myPlayBarBG"].getPosition()[0] + self["myPlayBarBG"].instance.size().width() - self["myPlayMov"].instance.size().width() + 1
   left = int(FFPSde(self.VVgeM2, 0, durVal, minLeft, maxLeft))
   self["myPlayMov"].instance.move(ePoint(left, int(self["myPlayMov"].getPosition()[1])))
   self["myPlaySkp"].setText(FF79L2(self.VVgeM2))
   self.VVOMf2 = self.VVgeM2 * 90000.0
 def VV3Po9(self, val):
  if not self.VVerLQ == val:
   self.VVerLQ = val
   self["myPlayJmp"].setText(self.VV0Gzt())
   FFDDwF(CFG.playerJumpMin, self.VVerLQ)
  self.VV0dV0("Changed Seek Time to : %d%s" % (val, self.VVYdtI()))
 def VV0Gzt(self):
  return "Seek=%d%s" % (self.VVerLQ, self.VVYdtI())
 def VVYdtI(self) : return "s"   if self.VVerLQ == 10 else "m"
 def VVjnth(self): return "sec" if self.VVerLQ == 10 else "min"
 def VVFDBH(self) : return 10    if self.VVerLQ == 10 else self.VVerLQ * 60
 def VVs2Ds(self):
  chSt = chStTxt = ""
  if "VVHOJs_VAL" in globals():
   global VVHOJs_VAL
   chSt = VVHOJs_VAL
   if chSt != CCOwzx.VVVy3B:
    chStTxt = chSt
  seekSt = ""
  try:
   inst = InfoBar.instance
   seekSt = {inst.SEEK_STATE_PAUSE: "PAUSED", inst.SEEK_STATE_EOF: "END", inst.SEEK_STATE_PLAY: "Playing"}.get(inst.seekstate, "")
   if chSt == CCOwzx.VVYL6l:
    seekSt = chSt
  except:
   pass
  return seekSt, chSt, chStTxt
 def VVCcFr(self):
  self.VV0dV0("Reading Cut-List ...")
  FFDiNL(self.VVrlna)
 def VVrlna(self):
  s = self.VVmk3F()
  if s._percVal == 100:
   self.VV0dV0(self.resetMediaTxt)
   return
  cList = self.VVLJUn()
  VVXXzc = []
  title = "Cut List"
  src = 0
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  if cList:
   canPreview = True
   for pts, what in cList:
    txt = FF79L2(int(pts) / 90000.0)
    if   what == 0 : t = "In"
    elif what == 1 : t = "Out"
    elif what == 2 : t = "Mark"
    elif what == 3 : t = "Last"
    else   : t = ""
    if t: txt += "   %s" % t
    VVXXzc.append((txt, pts))
  elif self["myPlayBlu"].getVisible():
   if fPath:
    VVXXzc = CCHa3c.VVC8cp(fPath)
   elif s.VVu69c and s.VVeZBd:
    path, headers = CCHa3c.VVp5GZ(s.VVu69c, s.VVeZBd)
    if path:
     VVXXzc = CCHa3c.VVC8cp(path, headers)
   if VVXXzc:
    title = "Chapters"
   elif s._durVal > 20:
    for i in range(0, 5):
     pts = min(max((s._durVal * 90000 // 4) * i, 5 * 90000), (s._durVal - 10) * 90000.0)
     subj = "   %s" % (("Start", "1st Quarter", "Half way", "3rd Quarter", "End")[i])
     VVXXzc.append((FF79L2(pts / 90000.0) + subj, pts))
   fName, fTxt, VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.session)
   if fName:
    d = CCzCR1.VVxvlA(CCzCR1.VVlenf(fName))
    if d: VVXXzc.append((FF79L2(d["pos"] / 90000.0) + FFITtK("   Resume Point", VV6UAe), d["pos"]))
   VVXXzc.sort(key=lambda x: x[1])
  if VVXXzc:
   wDir = "%s_Chapters/" % fPath
   VVZzW8 = FFw2XU(self, self.VVBOsc, VVXXzc=VVXXzc, title=title, width=1200, VVnojT=5, VVFHRx=(350, 0), cornerPicFnc=BF(self.VV4rE6, wDir))
   lst = []
   for txt, ref in VVXXzc:
    picF, tm = self.VVi3zT(wDir, txt)
    if picF and not FFf0vs(picF):
     lst.append((picF, tm))
   self.VVU96W = (VVZzW8, title, wDir, len(lst), 0, False)
   iThread(name="ajp_chap", target=BF(self.VVvaS8, lst, wDir, fPath)).start()
  else:
   self.VV0dV0("No Cut-List !")
 def VVBOsc(self, pts=None):
  self.VVU96W = None
  if pts:
   self.VV4I7c(pts)
 def VVvaS8(self, lst, wDir, fPath):
  VVZzW8, title, wDir, totPics, cnt, done = self.VVU96W
  if FF6usE("mkdir -p '%s';" % wDir):
   for picF, tm in lst:
    if not VVZzW8:
     break
    cnt += 1
    self.VVU96W = VVZzW8, title, wDir, totPics, cnt, done
    FF6usE("ffmpeg -hide_banner -ss %s -i '%s' -frames:v 1 -vf scale=350:-1 '%s'" % (tm, fPath, picF))
  self.VVU96W = VVZzW8, title, wDir, totPics, cnt, True
 def VV4rE6(self, wDir, VVZzW8, txt, ref, ndx):
  picF, tm = self.VVi3zT(wDir, txt)
  return picF
 def VVi3zT(self, wDir, txt):
  span = iSearch(r"^(\d\d:\d\d:\d\d)", txt)
  if span:
   tm = span.group(1)
   picF = "%s%s.jpg" % (wDir, tm.replace(":", ""))
   return picF, tm
  return "" ,""
 def VV0klC(self):
  if self.VVU96W:
   try:
    VVZzW8, title, wDir, totPics, cnt, done = self.VVU96W
    if   done   : self.VVU96W = None
    elif totPics >= cnt : title += FFITtK("   %s/%s" % (cnt, totPics), VVgzFX)
    if VVZzW8:
     VVZzW8.FFiaTH(title)
     txt, ref, ndx = VVZzW8.VVytTl()
     picF, tm = self.VVi3zT(wDir, txt)
     if not VVZzW8.VVipBn() and FFf0vs(picF):
      VVZzW8.VVpLGs(picF)
   except:
    pass
 def VVLJUn(self):
  try: return InfoBar.instance.cut_list or []
  except: return []
 def VVX4hH(self) : self.VVVpnv(1)
 def VVjvFx(self) : self.VVVpnv(-1)
 def VVVpnv(self, direc):
  try:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
   if percVal == 100:
    self.VV0dV0(self.resetMediaTxt)
   elif durVal > 0:
    maxPts = (durVal - posVal- 10) * 90000.0
    pts = direc * self.VVFDBH() * 90000.0
    pts = min(maxPts, pts)
    self.VVhyTC()
    inst = InfoBar.instance
    inst.doSeekRelative(int(pts))
    inst.hide()
    if   direc > 0 : txt = "Forawrd"
    else   : txt = "Rewind"
    txt += " (%d %s) ..." % (self.VVerLQ, self.VVjnth())
    self.VV0dV0(txt)
  except:
   self.VV0dV0("Cannot jump")
 def VV4I7c(self, pts, txt=""):
  self.VV0dV0(txt or "Changing Time ...")
  self.VVhyTC()
  try:
   InfoBar.instance.doSeek(int(pts))
  except:
   pass
 def VVHhYS(self):
  s = self.VVmk3F()
  if s._percVal < 100:
   self.VV4I7c(90000, "Jumping to Start ...")
  else:
   fName, fTxt, s.VVeZBd, VVkcp9 = CCzCR1.VVTurn(self.session)
   FFqlCI(CCzCR1.VVlenf(fName))
   self.VVfzak()
   self.VVipHn()
 def VVyMcj(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
  if seekable and durVal > 20:
   self.VV4I7c((durVal - 10) * 90000.0, "Jumping to end ...")
  else:
   self.VV0dV0("Movie is too short ...")
 def VVVJnh(self):
  try:
   service = self.session.nav.getCurrentService()
   info = service and service.info()
   if info:
    val = info.getInfo(iServiceInformation.sBuffer)
    if val and val > 0 and not val == 100:
     return "Buffering %d %%" % val
  except:
   pass
  return ""
 def VV6VXq(self, isUp):
  if self.VVQpKh:
   self.VV0dV0("Starting Service ...")
   FFDiNL(BF(self.VVkHby, isUp))
  else:
   self.VV0dV0("Zap Disabled !")
 def VVkHby(self, isUp):
  self.VVfzak()
  self["myPlayCc"].hide()
  self["myPlayAud"].hide()
  if self.zapFnc:
   VVDhju = self.zapFnc(1 if isUp else -1)
   self.VVZj8h(VVDhju, "")
  elif self.VVVQym:
   self.VVp8M1(isUp)
  else:
   if "/timeshift/" in CCaZ62(self.session).VVu69c:
    c1, c2 = VVHFlX, VVaR8d
    self.VV0dV0(c1 + "To zap, click " + c2 + self.VV1CZl + c1 + " then " + c2 + "Play Latest")
   else:
    try:
     if isUp : InfoBar.instance.zapDown()
     else : InfoBar.instance.zapUp()
    except:
     pass
    self.VVk7n9()
    self.VVU3KC()
 def VVZj8h(self, chUrl, txt):
  if txt:
   self.VV0dV0(txt)
   FFDiNL(BF(self.VVE1gw, chUrl))
  else:
   self.VVE1gw(chUrl)
 def VVE1gw(self, chUrl):
  FF5deK(self.session, chUrl)
  self.VVU3KC()
 def VVU3KC(self):
  self.VVNNkl = 0
  self.VVLCUI()
 def VVp8M1(self, isUp):
  CCSB3R_inatance, VV5ybN, mode = self.VVVQym
  if isUp : VV5ybN.VVVMkx()
  else : VV5ybN.VVycmo()
  colList = VV5ybN.VVqY3Q()
  VVthiO = ""
  if mode == "localIptv":
   VVeZBd, chUrl = CCSB3R_inatance.VVGhX7(VV5ybN, colList)
  elif mode == "localServer":
   VVeZBd, chUrl, VVthiO = CCSB3R_inatance.VVkxWd(VV5ybN, colList, isUp)
  elif isinstance(mode, int):
   VVeZBd, chUrl, VVthiO = CCSB3R_inatance.VVk6GX(mode, VV5ybN, colList)
  elif any(x in mode for x in ("itv", "vod", "series")):
   VVeZBd, chUrl, VVthiO = CCSB3R_inatance.VVc8y9(mode, VV5ybN, colList)
  else:
   self.VV0dV0("Cannot Zap")
   return
  self.VVthiO = VVthiO
  self.VVZj8h(chUrl, "")
 def VV35gS(self, chUrl, endRef="", VVthiO=""):
  self.endRef = endRef
  self.VVthiO = VVthiO
  self.VVZj8h(chUrl, "Starting Service ..." if chUrl else "")
 def VVk7n9(self, forceRefresh=False):
  try:
   if not forceRefresh:
    seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
    if posTxt:
     return
   VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
   if not self.VVWSsA(VVDhju, VVeZBd, VVu69c, VVLZ0Z):
    return
   if forceRefresh or "j.php" in VVu69c:
    self.VV0dV0("Refreshing Portal ...")
    FFDiNL(self.VVBsx3)
  except:
   pass
 def VVBsx3(self):
  self.VVEdv8 = self.VVvzzW(self.session)
 def VVbTZJ(self):
  VVDhju, VVu69c, VVQwVu, VVLZ0Z, VVeZBd = FFGxNQ(self)
  if not VVu69c or FFzNJJ(VVu69c):
   self.VV0dV0("Not a Catch-up TV")
   return
  self.VV0dV0("Checking Catch-up ...")
  uHost = uUser = uPass = streamId = ""
  ok_fnc = None
  if "chCode=" in VVu69c:
   span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+", VVu69c)
   if span: uHost, uUser, uPass, streamId = span.groups()
  else:
   if "/timeshift/" in VVu69c:
    span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/(.+)\/(.+)\/(\d+)", VVu69c, IGNORECASE)
    if span:
     uHost, uUser, uPass = span.group(1), span.group(2), span.group(3)
     streamId = span.group(6)
     ndx = VVeZBd.find(" >> ")
     if ndx > -1:
      VVeZBd = VVeZBd[:ndx]
   else:
    uType, uHost, uUser, uPass, streamId, uChName = CCSB3R.VVsV5B(VVu69c)
  if all([uHost, uUser, uPass, streamId]):
   qUrl = "%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass)
   ok_fnc  = BF(self.VVTFL9, VVDhju, VVeZBd, streamId, uHost, uUser, uPass)
   CCSB3R.VVdW5y(self, qUrl, VVeZBd, streamId, ok_fnc, rst_fnc=self.VVLCUI)
  else:
   self.VV0dV0("Cannot process this channel")
 def VVTFL9(self, VVDhju, VVeZBd, streamId, uHost, uUser, uPass, VV5ybN, title, txt, colList):
  pTitle, sTime, dur = colList[4], colList[6], colList[8]
  VV5ybN.cancel()
  span = iSearch(r"(\d{4}-\d{2}-\d{2})\s(\d{2}):(\d{2})", sTime)
  if span:
   sTime = span.group(1) + ":" + span.group(2) + "-" + span.group(3)
   chUrl = "%s/timeshift/%s/%s/%s/%s/%s.ts" % (uHost, uUser, uPass, dur, sTime, streamId)
   chUrl = chUrl.replace(":", "%3a")
   chUrl = "%s:%s:%s >> %s" % (VVDhju, chUrl, VVeZBd, pTitle)
   self.VVZj8h(chUrl, "Changing Program ...")
  else:
   self.VV0dV0("Incorrect Timestamp !")
 def VVFFMQ(self, isAudio):
  aud, sub = CCISy5.VVGOEp(self.session), CCISy5.VVF21Q()
  if isAudio:
   if aud < 1:
    self.VV0dV0("No Audio Tracks")
    return
  else:
   if sub < 1:
    self.VV0dV0("No Subtitles")
    return
  try:
   inst = InfoBar.instance
   if inst:
    from Screens.AudioSelection import AudioSelection, SubtitleSelection
    if isAudio : self.session.open(AudioSelection, infobar=inst)
    else  : self.session.open(SubtitleSelection, inst)
  except:
   pass
 @staticmethod
 def VVOHPk(session, mode=None):
  if   mode == "VVfbG9"   : FFNSo6(session, reopen=True)
  elif mode == "VVSA3u"  : session.open(CCSB3R)
  elif mode == "VVTlDC" : session.open(CCBoou)
  elif mode == "VVlGw7" : session.open(CCQdsv, VVhacs=True)
 @staticmethod
 def VVbVSZ(session, **kwargs):
  session.openWithCallback(BF(CC2lVw.VVOHPk, session), CC2lVw, **kwargs)
class CCw9aH(Screen):
 def __init__(self, session, title="", VVYjCX="Continue?", VV817A=True, VVys8X=False):
  self.skin, self.VVuaAL = FFJH4U(VVEbHC, 1200, 800, 50, 20, 20, "#11221122", "#11221122", 30)
  self.session = session
  self["myLine"] = Label()
  self.VVYjCX = VVYjCX
  self.VVys8X = VVys8X
  self.maxHeight = 0
  no  = ("No" , "no" )
  yes = ("Yes", "yes")
  if VV817A : VVXXzc = [no , yes]
  else   : VVXXzc = [yes, no ]
  FFfmZP(self, title, VVXXzc=VVXXzc, addLabel=True)
  FFewq4(self,
  {
   "ok" : self.VVTOku ,
   "cancel": self.cancel ,
   "red" : self.cancel ,
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.maxHeight = self.instance.size().height()
  self["myLabel"].setText("\n%s\n" % self.VVYjCX)
  if self.VVys8X:
   self["myLabel"].instance.setHAlign(0)
  self.VVWNFZ()
  FFTDN6(self["myMenu"], fg="#08ffff00", bg="#08223333")
  try: self["myMenu"].instance.setHAlign(1)
  except: FFqz3G(self["myMenu"], 35)
  FFvED5(self, self["myMenu"])
 def VVTOku(self):
  item = self["myMenu"].l.getCurrentSelection()[1]
  if item is not None:
   if   item == "no" : self.close(False)
   elif item == "yes" : self.close(True)
  else:
   self.close(False)
 def cancel(self):
  self.close(False)
 def VVWNFZ(self):
  vGap = 60 if CC6z2a.VVOCgj() else 0
  winW = self.instance.size().width()
  winH = self.instance.size().height()
  labelW = self["myLabel"].instance.size().width()
  labelH = self["myLabel"].instance.size().height()
  textSize= self["myLabel"].instance.calculateSize()
  diff = textSize.height() - labelH + vGap
  winNewH = winH + diff
  if winNewH < winH:
   screenSize = getDesktop(0).size()
   self["myLabel"].instance.resize(eSize(*(labelW, labelH + diff)))
   self.instance.resize(eSize(*(winW, winNewH)))
   self.instance.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winNewH) // 2))
   names = [ "myMenu", "myLine" ]
   for name in names:
    try:
     obj = self[name]
     pos = obj.getPosition()
     obj.instance.move(ePoint(pos[0], pos[1] + diff))
    except:
     pass
class CCMunD(Screen, CC8eoU):
 def __init__(self, session, title="", VVXXzc=None, width=1000, height=850, VV1Wwb=30, VVcIOx="", VVnojT=1, VVO8hC=0.15, VV7tbr=False, VV5LxL=None, VVpuzu=None, VVSuW0=None, VVBztL=None, VVI6TY=None, VViDZz=None, cornerPicFnc=None, VVFHRx=(0, 0), VVfP2Q=False, VVL6LA=False, VVhuPZ=None, VVbCII=True, VVVzvS="#22003344", VVhHWW="#22002233", VVlIBH="#08005555"):
  if   VV7tbr and VVpuzu : VV1fgG = 2
  elif VV7tbr     : VV1fgG = 1
  elif VVpuzu    : VV1fgG = 3
  else      : VV1fgG = 0
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, width, height, 50, 40, 30, VVVzvS, VVhHWW, VV1Wwb, VVZ3ZU=40, VVO8hC=VVO8hC, VV1fgG=VV1fgG, VVFHRx=VVFHRx)
  self.session   = session
  self.VVcIOx   = VVcIOx
  self.VVnojT   = VVnojT
  self.VV7tbr    = VV7tbr
  self.VV5LxL   = VV5LxL
  self.VVpuzu   = VVpuzu
  self.VVSuW0   = VVSuW0
  self.VVBztL  = VVBztL
  self.VVI6TY  = ("Delete File", BF(self.VVM126, VVhuPZ)) if not VVhuPZ is None else VVI6TY
  self.VViDZz   = VViDZz
  self.cornerPicFnc  = cornerPicFnc
  self.VVfP2Q  = VVfP2Q
  self.VVL6LA  = VVL6LA
  self.VVlIBH   = VVlIBH
  self.Title    = title
  FFfmZP(self, title, VVXXzc=VVXXzc)
  CC8eoU.__init__(self)
  FFewq4(self,
  {
   "ok"  : self.VVTOku    ,
   "menu"  : self.VVzTHZ   ,
   "cancel" : self.cancel    ,
   "info"  : self.VVZIew   ,
   "red"  : self.VVCs9Q   ,
   "green"  : self.VVMc5n   ,
   "yellow" : self.VViskZ   ,
   "blue"  : self.VVrv7U   ,
   "pageUp" : self.VVQhoy ,
   "chanUp" : self.VVQhoy ,
   "pageDown" : self.VVdwrx  ,
   "chanDown" : self.VVdwrx  ,
   "0"   : BF(self.VVjoXF, 0) ,
   "1"   : BF(self.VVjoXF, 1) ,
   "2"   : BF(self.VVjoXF, 2) ,
   "3"   : BF(self.VVjoXF, 3) ,
   "4"   : BF(self.VVjoXF, 4) ,
   "5"   : BF(self.VVjoXF, 5) ,
   "6"   : BF(self.VVjoXF, 6) ,
   "7"   : BF(self.VVjoXF, 7) ,
   "8"   : BF(self.VVjoXF, 8) ,
   "9"   : BF(self.VVjoXF, 9)
  })
  if VVbCII:
   CCBUJe(self, self["myMenu"])
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFTDN6(self["myMenu"], bg=self.VVlIBH)
  FFbm8U(self, VVnojT=self.VVnojT)
  FF1uow(self)
  self.VVzLPK(self["keyRed"]  , self.VVSuW0 )
  self.VVzLPK(self["keyGreen"] , self.VVBztL )
  self.VVzLPK(self["keyYellow"] , self.VVI6TY )
  self.VVzLPK(self["keyBlue"]  , self.VViDZz )
  if self.VVcIOx      : self["myBar"].setText("  %s" % self.VVcIOx)
  elif not self["keyRed"].getVisible(): self["myBar"].setText("  OK = Select")
  else        : self["myBar"].setText("")
  FFE1T7(self)
  if self.cornerPicFnc:
   self.VV9PFB(self.VV3FMp)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
 def VVzLPK(self, btnObj, btnFnc):
  if btnFnc:
   FFrvOP(btnObj, btnFnc[0])
 def VV9PFB(self, fnc, callFnc=True):
  self["myMenu"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VV3FMp(self):
  item = self.VVytTl()
  if item:
   txt, ref, ndx = item
   picF = self.cornerPicFnc(self, txt, ref, ndx)
   if FFf0vs(picF):
    if self.VVpLGs(picF):
     return
  self.VVykua()
 def VVmx1U(self, fnc=None):
  self.VVBztL = fnc
  if fnc : self.VVzLPK(self["keyGreen"], self.VVBztL)
  else : self["keyGreen"].hide()
 def VVjoXF(self, digit):
  digit = str(digit)
  VVXXzc = self["myMenu"].list
  for ndx, item in enumerate(VVXXzc):
   if len(item) == 2:
    span = iSearch(r"^\[(\d)\]\s.+", FFes9J(item[0]), IGNORECASE)
    if span and span.group(1) == digit:
     self.VVEaHH(ndx)
     self.VVTOku()
     break
 def VVytTl(self):
  obj = self["myMenu"].l
  ref = obj.getCurrentSelection()[1]
  if ref is not None:
   txt = obj.getCurrentSelection()[0]
   ndx = obj.getCurrentSelectionIndex()
   return (txt, ref, ndx)
  else:
   return None
 def VVTOku(self):
  item = self.VVytTl()
  if item:
   txt, ref, ndx = item
   if self.VV5LxL:
    self.VV5LxL((self, txt, ref, ndx))
   else:
    if self.VVfP2Q: self.close((txt, ref, ndx))
    else     : self.close(ref)
 def VVzTHZ(self):
  if self.VV7tbr: self.close("VV7tbr")
 def VVZIew(self):
  item = self.VVytTl()
  if self.VVpuzu and item:
   txt, ref, ndx = item
   self.VVpuzu(self, txt, ref, ndx)
 def cancel(self):
  self.close(None)
 def VVCs9Q(self)  : self.VVRbNQ(self.VVSuW0)
 def VVMc5n(self) : self.VVRbNQ(self.VVBztL)
 def VViskZ(self) : self.VVRbNQ(self.VVI6TY)
 def VVrv7U(self) : self.VVRbNQ(self.VViDZz)
 def VVRbNQ(self, btnFnc):
  if btnFnc:
   item = self["myMenu"].l.getCurrentSelection()[1]
   fnc = btnFnc[1]
   fnc(self, item)
   if self.VVL6LA:
    self.cancel()
 def VVBvIe(self):
  ndx = self["myMenu"].getSelectedIndex()
  VVXXzc = self["myMenu"].list
  VVXXzc.pop(ndx)
  if len(VVXXzc) > 0: self["myMenu"].setList(VVXXzc)
  else    : self.close()
 def VVPSDX(self, data):
  ndx = self["myMenu"].getSelectedIndex()
  VVXXzc = self["myMenu"].list
  VVXXzc[ndx] = data
  self["myMenu"].setList(VVXXzc)
 def VVM126(self, basePath, menuObj, fName):
  FFHsPu(self, BF(self.VVE4Xv, basePath + fName), "Delete this file ?\n\n%s" % fName, title=self.Title)
 def VVE4Xv(self, path):
  FFqlCI(path)
  if FFf0vs(path) : FF8PJn(self, "Not deleted", 1000)
  else    : self.VVBvIe()
 def VVc7Yd(self):
  return self["myMenu"].list
 def VVEyJ9(self):
  return [x[1] for x in self["myMenu"].list if len(x) > 1]
 def VVEs8Z(self, VVXXzc):
  if len(VVXXzc) > 0:
   newList = []
   for item in VVXXzc:
    newList.append((item, item))
   self["myMenu"].setList(newList)
   FFbm8U(self, VVnojT=self.VVnojT)
  else:
   self.close("")
 def FFiaTH(self, txt):
  self["myTitle"].setText("  %s  " % txt)
 def VVOQoA(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VVgjzO(self, newRow, isSort=False):
  lst = self["myMenu"].list
  lst.append(newRow)
  if isSort:
   lst.sort(key=lambda x: x[0].lower())
  self["myMenu"].setList(lst)
  FFbm8U(self, VVnojT=self.VVnojT)
  for ndx, item in enumerate(self["myMenu"].list):
   if item[1] == newRow[1]:
    self["myMenu"].moveToIndex(ndx)
    break
 def VVhydo(self, isUp):
  ndx = self["myMenu"].getSelectionIndex()
  if   isUp and ndx > 0         : newIndex = ndx - 1
  elif not isUp and ndx < len(self["myMenu"].list) - 1 : newIndex = ndx + 1
  else             : return None
  newList = self["myMenu"].list
  newList.insert(newIndex, newList.pop(ndx))
  self["myMenu"].moveToIndex(newIndex)
  newList = []
  for item in self["myMenu"].list:
   newList.append(item[0])
  return newList
 def VVEaHH(self, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVWDNK(self, refTxt):
  for ndx, item in enumerate(self["myMenu"].list):
   if len(item) > 1 and refTxt == item[1]:
    self.VVEaHH(ndx)
    break
 def VVeehB(self, txt):
  for ndx, item in enumerate(self["myMenu"].list):
   if txt == item[0]:
    self.VVEaHH(ndx)
    break
 def VVQhoy(self) : self["myMenu"].moveToIndex(0)
 def VVdwrx(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CCzs7U(Screen, CC8eoU):
 def __init__(self, session, title="", width=1600, height=900, VVNYa4=50, VV0Jzc=10, VVcCjD=5, header=None, VV5dDF=None, VVgKQc=None, VV1PTZ=None, VV1Wwb=26, VVcIOx="", VVrX9P="", VVVTz9=False, VVnete=False, VV3Vgp=3000, VV1UVb=False, VVq6oU=True, VVPWLU=None, VVrpeX=False, VV3dKD=0, VVLQWC=None, VVNCwd=None, VVFHRx=(0, 0), VVI3Oq=None, VV4dTm=None, VVi7Cl=None, VVEyDE=None, VV5CrJ=None, VVbQ6N=None, VVvrJb=None, VVzs8Z=None, VVsB8G=None, VVLj1d=None, VVzH0q=None, VV9mY2=None, VVuyvr=-1, VV4HrS=0, VVylFd=0, VV7VIQ=None, VVVzvS="#22003344", VVhHWW="#22002233", VVJIK0="#00dddddd", VVpaQ6="#11002233", VVqecq=None, VVI4UA="#0a444033", VVaqdB=1, VVcv6F="#0a555555", VVTtoB="#0affffff", VVsOjr="#11552200", VVykBQ="#0055ff55", VVlU95="#004488ff"):
  VVnete = VVnete or VV4HrS == 1
  barH = 1 if VVnete else 40
  self.skin, self.VVuaAL = FFJH4U(VVDwJ1, width, height, VVNYa4, VV0Jzc, VVcCjD, VVVzvS, VVhHWW, 26, VVZ3ZU=barH, VV1fgG=2, VVO8hC=0.6, VVFHRx=VVFHRx)
  self.session    = session
  self.Title     = title
  self.header     = header
  self.VV5dDF     = VV5dDF
  self.VVBL0Q    = len(VV5dDF[0])
  self.VV3dKD   = VV3dKD
  self.VVLQWC    = VVLQWC
  self.VVNCwd   = VVNCwd
  self.VV1KNJ    = VVNCwd[0] if VVNCwd else -1
  self.VVtSQd = False
  self.VVrpeX   = VVrpeX
  self.VVm2Op   = 0.01
  self.VVjJkz   = 0.02
  self.VVyIjS = 0.03
  self.VV5RXW   = 1
  self.VV1PTZ = VV1PTZ
  self.VV6nWG   = []
  self.VVI3Oq   = VVI3Oq
  self.VVQlSu   = None
  self.VV4dTm   = VV4dTm
  self.VVEyDE   = VVEyDE
  self.VV5CrJ   = VV5CrJ
  self.VVbQ6N  = VVbQ6N
  self.VVvrJb   = VVvrJb
  self.VVzs8Z    = VVzs8Z
  self.VVsB8G   = VVsB8G
  self.VVK0Fc   = None
  self.VVLj1d  = VVLj1d
  self.VVzH0q   = VVzH0q
  self.VVi7Cl   = VVi7Cl
  self.VVuyvr    = VVuyvr
  self.VV4HrS   = VV4HrS
  self.VVylFd    = VVylFd
  self.VVgKQc    = VVgKQc
  self.VVX3gF    = -1
  self.VV9mY2    = VV9mY2
  self.VV1Wwb    = FFl21N(VV1Wwb)
  self.VVcIOx    = VVcIOx
  self.VVrX9P    = VVrX9P
  self.VVVTz9    = VVVTz9
  self.VV3Vgp     = VV3Vgp
  self.VV1UVb    = VV1UVb
  self.VVq6oU    = VVq6oU
  self.VVPWLU    = VVPWLU or {}
  self.VVwOMI    = FFwvYs(self.VV1Wwb, self.VVuaAL["VVO8hC"])
  self.scrollBarWidth   = self.VVuaAL["scrollBarW"]
  self.VVVzvS    = VVVzvS
  self.VVhHWW      = VVhHWW
  self.VVJIK0    = FFEIV2(VVJIK0)
  self.VVpaQ6    = FFEIV2(VVpaQ6)
  self.VVqecq    = VVqecq
  self.VVI4UA    = FFEIV2(VVI4UA)
  self.VVaqdB   = VVaqdB
  self.VVcv6F   = FFEIV2(VVcv6F)
  self.VVTtoB    = FFEIV2(VVTtoB)
  self.VVsOjr    = FFEIV2(VVsOjr)
  self.VVykBQ   = FFEIV2(VVykBQ)
  self.VVlU95  = FFEIV2(VVlU95)
  self.VVbbT0  = False
  self.VVF3eY   = 0
  self.VVcnDd   = FFEIV2("#04764354")
  self.VV7VIQ  = VV7VIQ or CFG.lastFindGeneral
  self.VVSuh9  = False
  self.VV7Zza  = False
  self.VVXT2q  = False
  self.VVumTW = False
  self.VVp73s  = False
  self.VVatfa = CCzs7U.VVUqW9(0, 0, 20, 20, LoadPixmap(VV30Jg + "tick.png"))
  self.VVpaY0 = CCzs7U.VVUqW9(0, 0, 1, 1, LoadPixmap(VV30Jg + "tick_1x1.png"))
  FFfmZP(self, title)
  CC8eoU.__init__(self)
  if VVnete:
   self["myLine"].hide()
  self["myTableH"] = MenuList([], True, eListboxPythonMultiContent)
  self["myTable"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTotSel"] = Label("Sel = 0")
  self["myTotSel"].hide()
  FFewq4(self,
  {
   "ok"  : self.VVGOIe  ,
   "red"  : self.VVdAnm  ,
   "green"  : self.VVE6pz ,
   "yellow" : self.VVzrwN ,
   "blue"  : self.VVzxZd  ,
   "menu"  : self.VVt4Vj ,
   "info"  : self.VVoCI2  ,
   "cancel" : self.VVGNfU  ,
   "up"  : self.VVycmo    ,
   "down"  : self.VVVMkx  ,
   "left"  : self.VVeXT6   ,
   "right"  : self.VVNZhV  ,
   "next"  : self.VV3xNW  ,
   "last"  : self.VVzedO  ,
   "home"  : self.VVx7VB  ,
   "pageUp" : self.VVx7VB  ,
   "chanUp" : self.VVx7VB  ,
   "end"  : self.VVU4Vz  ,
   "pageDown" : self.VVU4Vz  ,
   "chanDown" : self.VVU4Vz
  })
  CCBUJe(self, self["myTable"], colNum=self.VVylFd)
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  if self.VVcIOx:
   self.VVCGR5(self.VVcIOx)
  if self.VV4HrS:
   self["keyMenu"].hide()
   x, y = self["keyMenu"].getPosition()
   self["keyInfo"].instance.move(ePoint(x, y))
  try:
   self.VVLAtp()
  except Exception as e:
   FFU9uk(self, str(e), title=self.Title)
   self.close(None)
 def onExit(self):
  self["myTable"].onSelectionChanged = []
 def VVLAtp(self):
  FFE1T7(self)
  self.VVzLPK(self.VVEyDE , self["keyRed"])
  self.VVzLPK(self.VV5CrJ , self["keyGreen"])
  self.VVzLPK(self.VVbQ6N, self["keyYellow"])
  self.VVzLPK(self.VVvrJb , self["keyBlue"])
  if self.VVI3Oq:
   if   not self["keyRed"].getVisible() : self.VVQlSu = self["keyRed"]
   elif not self["keyBlue"].getVisible() : self.VVQlSu = self["keyBlue"]
   else         : self.VVQlSu = None
   if self.VVQlSu and self.VVI3Oq[0]:
    self.VVQlSu.show()
    self.VVQlSu.setText("OK = %s" % self.VVI3Oq[0])
    FFu0W6(self.VVQlSu, "#11000000")
  if self.VVrX9P and not self["keyBlue"].getVisible():
   self["keyBlue"].show()
   self["keyBlue"].setText(self.VVrX9P)
   FFu0W6(self["keyBlue"], "#11000000")
  self["myTableH"].l.setSelectionClip(eRect(0, 0, 0, 0))
  FFiZTW(self["myTableH"], "#00555500", 2)
  self["myTableH"].l.setItemHeight(self.VVwOMI)
  self["myTableH"].l.setFont(0, gFont(VVQVcT, self.VV1Wwb))
  self["myTable"].l.setItemHeight(self.VVwOMI)
  self["myTable"].l.setFont(0, gFont(VVQVcT, self.VV1Wwb))
  try:
   self["myTable"].instance.setScrollbarSliderBorderWidth(0)
  except:
   pass
  w = self["myTable"].instance.size().width()
  h = self["myTable"].instance.size().height()
  pos = self["myTable"].getPosition()
  if self.header and not self.VVVTz9:
   self["myTableH"].instance.resize(eSize(*(w, self.VVwOMI)))
   self["myTable"].instance.move(ePoint(pos[0], pos[1] + self.VVwOMI))
   self["myTable"].instance.resize(eSize(*(w, h - self.VVwOMI)))
  h = self["myTable"].instance.size().height()
  pos = self["myTable"].getPosition()
  part= self["myTable"].instance.size().height() % self.VVwOMI
  half= int(part / 2)
  self["myTable"].instance.resize(eSize(*(w, h - part)))
  self["myTable"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.header:
   pos = self["myTableH"].getPosition()
   self["myTableH"].instance.move(ePoint(pos[0], pos[1] + half))
  menuWidth = self["myTable"].instance.size().width()
  gapX = 0
  if self.VVwOMI * len(self.VV5dDF) > self["myTable"].instance.size().height():
   menuWidth = menuWidth - int(self.scrollBarWidth) - 5
   gapX = int(self.scrollBarWidth) - 5
  if not self.VV1PTZ:
   self.VV1PTZ = ([float(100.0 / self.VVBL0Q)] * self.VVBL0Q)
  self.VV6nWG = list(self.VV1PTZ)
  if not self.VV6nWG:
   self.VV6nWG = [menuWidth // self.VVBL0Q] * self.VVBL0Q
  else:
   for i, item in enumerate(self.VV6nWG):
    self.VV6nWG[i] = int(item * menuWidth / 100)
  if not self.VVgKQc : self.VVgKQc = [LEFT | RT_VALIGN_CENTER] * self.VVBL0Q
  else     : self.VVgKQc = [x | RT_VALIGN_CENTER for x in self.VVgKQc]
  half = int(self.VVwOMI / 2.0)
  if self.header : gapY = self["myTableH"].getPosition()[1] + half
  else   : gapY = self["myTable"].getPosition()[1] - half
  self.VVQdSA(gapX, gapY)
  self.VVMbfT()
  if self.VVzs8Z:
   self.VVzs8Z(self)
 def VVzLPK(self, btnFnc, btn):
  if btnFnc : FFrvOP(btn, btnFnc[0])
  else  : FFrvOP(btn, "")
 def VVMbfT(self, onlyHeader=False, showProgBar=True, fromRefresh=False):
  if self.header:
   sortedFg = self.VVlU95 if self.VVtSQd else self.VVykBQ
   self["myTableH"].setList([self.VVBzNh(0, self.header, self.VVTtoB, self.VVsOjr, None, self.VVsOjr, sortedFg)])
  if onlyHeader:
   return
  tot = len(self.VV5dDF)
  if showProgBar and tot > self.VV3Vgp:
   CCXRxc.VVJ9VK(self, VVmj1O="Loading Table ( %s row%s ) ..." % (tot, FFEnJs(tot)), endTitle="Loading channels ...", VV9L2m=CCXRxc.VVE4fR, titleBg="#11222222", bodyBg="#11222222", barBg="#06446677"
       , VVCJhW  =  BF(self.VVs5Hn, True, fromRefresh)
       , VVuQkS = self.VVszXX )
  else:
   self.VVs5Hn(False, fromRefresh)
 def VVs5Hn(self, showProgBar, fromRefresh, VVM2wn=None):
  try:
   if showProgBar:
    VVM2wn.VVqMKy(len(self.VV5dDF))
   self["myTable"].list = []
   for c, row in enumerate(self.VV5dDF):
    if showProgBar:
     if not VVM2wn or VVM2wn.isCancelled:
      return
     VVM2wn.VVwOHf(1)
    self["myTable"].list.append(self.VVBzNh(c, row, self.VVJIK0, self.VVpaQ6, self.VVqecq, self.VVI4UA, None))
   self.VV5dDF = []
   self["myTable"].setList(self["myTable"].list)
   if self.VVuyvr > -1:
    self["myTable"].moveToIndex(self.VVuyvr)
   if self.VV4HrS and not fromRefresh:
    tableH = self["myTable"].instance.size().height()
    rowsH = self.VVwOMI * len(self["myTable"].list)
    if rowsH < tableH:
     diff = tableH - rowsH
     newH = self.instance.size().height() - diff
     screenSize = getDesktop(0).size()
     width = self.instance.size().width()
     self.instance.resize(eSize(*(width, newH)))
     self.instance.move(ePoint((screenSize.width() - width) // 2, (screenSize.height() - newH) // 2))
     names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
     for name in names:
      obj = self[name]
      pos = obj.getPosition()
      obj.instance.move(ePoint(pos[0], pos[1] - diff))
     FFDEXp(self, width, newH)
   if self.VVsB8G:
    self.VVRbNQ(self.VVsB8G, None)
   if self.VVK0Fc:
    self.VVRbNQ(self.VVK0Fc, None)
    self.VVK0Fc = None
  except AttributeError as attrErr:
   pass
  except Exception as e:
   try:
    FFU9uk(self, str(e), title=self.Title)
    self.close()
   except:
    pass
 def VVszXX(self, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  if not VV9zbx:
   self.close()
 def VVBzNh(self, keyIndex, columns, VVJIK0, VVpaQ6, VVqecq, VVI4UA, VVykBQ):
  row = [keyIndex]
  if VVqecq:
   VVqecq = FFEIV2(VVqecq)
  posX = 0
  for ndx, entry in enumerate(columns):
   if not VVykBQ:
    textColor = VVJIK0
   elif VVykBQ and (ndx in self.VVPWLU and self.VVPWLU[ndx] == self.VV3dKD) or ndx == self.VV3dKD:
    textColor = VVykBQ
   else:
    textColor = VVJIK0
   while iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", entry):
    span = iSearch(r"\s*#(.)(#[a-fA-F0-9]{8})#(.*)", entry, IGNORECASE)
    if span:
     c = FFEIV2(span.group(2))
     if span.group(1) == "f" : textColor = c
     else     : VVpaQ6 = c
     entry = span.group(3)
   if not self.VV1UVb and self.VVgKQc[ndx] & LEFT:
    entry = " " + entry + " "
   row.append(CCzs7U.VVuz47(  posX, 0
             , self.VV6nWG[ndx], self.VVwOMI
             , 0
             , self.VVgKQc[ndx]
             , entry
             , textColor
             , VVpaQ6
             , VVqecq or textColor
             , VVI4UA
             , self.VVaqdB
             , self.VVcv6F
             ))
   posX += self.VV6nWG[ndx]
  if not VVykBQ:
   if self.VVLQWC:
    VVDveFCol, picFnc, pathCol = self.VVLQWC
    if   picFnc : png = picFnc(columns)
    elif pathCol: png = columns[pathCol].strip()
    else  : png = ""
    if png.startswith("/"):
     try:
      pngX = sum(self.VV6nWG[:VVDveFCol])
      row.append(CCzs7U.VVUqW9(pngX+2, VVDveFCol+2, self.VV6nWG[VVDveFCol]-4, self.VVwOMI-4, LoadPixmap(png)))
     except:
      pass
   if self.VVNCwd:
    pCol, vCol, pW, pH = self.VVNCwd
    perc = int(columns[vCol])
    pX = sum(self.VV6nWG[:pCol])
    w = int(pW / 100.0 * self.VV6nWG[pCol])
    h = int(pH / 100.0 * self.VVwOMI)
    x = pX + (self.VV6nWG[pCol] - w) // 2
    y = (self.VVwOMI - h) // 2
    row.append(CCzs7U.VVsUpe(x, y, w, h, perc, 1, FFEIV2("#00aaccaa")))
   row.append(self.VVpaY0)
  return row
 def VVoCI2(self):
  rowData = self.VVEMwI()
  if rowData:
   title, txt, colList = rowData
   if self.VV4dTm:
    fnc  = self.VV4dTm[1]
    params = self.VV4dTm[2]
    fnc(self, title, txt, colList)
   else:
    FFyijw(self, txt, title)
 def VVGOIe(self):
  if   self.VVbbT0 : self.VVxgrd(self.VVfkJL(), mode=2)
  elif self.VVI3Oq  : self.VVRbNQ(self.VVI3Oq, None)
  else      : self.VVoCI2()
 def VVdAnm(self) : self.VVRbNQ(self.VVEyDE , self["keyRed"])
 def VVE6pz(self) : self.VVRbNQ(self.VV5CrJ , self["keyGreen"])
 def VVzrwN(self): self.VVRbNQ(self.VVbQ6N , self["keyYellow"])
 def VVzxZd(self) : self.VVRbNQ(self.VVvrJb , self["keyBlue"])
 def VVRbNQ(self, buttonFnc, btnObj):
  if btnObj and not btnObj.getVisible():
   return
  if buttonFnc:
   if len(buttonFnc) > 3 and buttonFnc[3]:
    FF8PJn(self, buttonFnc[3])
    FFDiNL(BF(self.VVAL3r, buttonFnc))
   else:
    self.VVAL3r(buttonFnc)
 def VVAL3r(self, buttonFnc):
  fnc   = buttonFnc[1]
  params  = buttonFnc[2]
  rowData = self.VVEMwI()
  if rowData:
   title, txt, colList = rowData
   if not params : fnc(self, title, txt, colList)
   else   : fnc(self, *params)
 def VVxgrd(self, ndx, mode=0, movDn=True):
  try:  row = self["myTable"].list[ndx]
  except: row = None
  if row:
   isSelected = row[1][10] == self.VVcnDd
   if mode == 0 or (mode == 2 and isSelected):
    bg = self.VVpaQ6
    if isSelected:
     self.VVF3eY -= 1
   else:
    bg = self.VVcnDd
    if not isSelected:
     self.VVF3eY += 1
   self.VV0hb0()
   if isSelected: self["myTable"].list[ndx][-1] = self.VVpaY0
   else   : self["myTable"].list[ndx][-1] = self.VVatfa
   for col in range(1, len(row)):
    cols = list(row[col])
    if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
     cols[10] = bg
    row[col] = tuple(cols)
   self["myTable"].l.invalidate()
   if movDn and self.VVfkJL() < len(self["myTable"].list) - 1:
    self.VVVMkx()
   if self.VVzH0q:
    self.VVzH0q(self)
 def VV0hb0(self): self["myTotSel"].setText("Sel = %d" % self.VVF3eY)
 def VVUmcI(self)  : FFTSvN(self, BF(self.VVVMM1, True ), title="Selecting all ..."  )
 def VVZCQs(self) : FFTSvN(self, BF(self.VVVMM1, False), title="Unselecting all ...")
 def VVVMM1(self, isSel=True):
  if isSel:
   bg = self.VVcnDd
   self.VVF3eY = len(self["myTable"].list)
   self.VVUxKE(True)
  else:
   bg = self.VVpaQ6
   self.VVF3eY = 0
  self.VV0hb0()
  for ndx, row in enumerate(self["myTable"].list):
   isPainted = row[1][10] == self.VVcnDd
   if (isSel and not isPainted) or (not isSel and isPainted):
    for col in range(1, len(row)):
     cols = list(self["myTable"].list[ndx][col])
     if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
      cols[10] = bg
     self["myTable"].list[ndx][col] = tuple(cols)
   if isSel: self["myTable"].list[ndx][-1] = self.VVatfa
   else : self["myTable"].list[ndx][-1] = self.VVpaY0
  self["myTable"].l.invalidate()
  if self.VVzH0q:
   self.VVzH0q(self)
 def VVUxKE(self, isOn):
  self.VVbbT0 = isOn
  if isOn:
   color = "#01883366"
   self["myTotSel"].show()
   self["keyMenu"].hide()
   if self.VVSuh9 and self.VVI3Oq and self.VVQlSu:
    self.VVQlSu.setText("OK = Select")
   if self.VV7Zza and self.VVEyDE: self["keyRed"].hide()
   if self.VVXT2q and self.VV5CrJ: self["keyGreen"].hide()
   if self.VVumTW and self.VVbQ6N: self["keyYellow"].hide()
   if self.VVp73s and self.VVvrJb: self["keyBlue"].hide()
  else:
   color = self.VVVzvS
   self["myTotSel"].hide()
   self["keyMenu"].show()
   if self.VVSuh9 and self.VVI3Oq and self.VVQlSu:
    self.VVQlSu.setText("OK = %s" % self.VVI3Oq[0])
   if self.VV7Zza and self.VVEyDE: self["keyRed"].show()
   if self.VVXT2q and self.VV5CrJ: self["keyGreen"].show()
   if self.VVumTW and self.VVbQ6N: self["keyYellow"].show()
   if self.VVp73s and self.VVvrJb: self["keyBlue"].show()
  FFu0W6(self["myTitle"], color)
  FFu0W6(self["myBar"]  , color)
  if self.VVzH0q:
   self.VVzH0q(self)
 def VVAa4i(self, ndx):
  w = self.VV1PTZ[ndx]
  return VVpSLv > 1 or (w > self.VV5RXW or w == self.VVm2Op or w == self.VVyIjS) and ndx != self.VV1KNJ
 def VVioQF(self, ndx):
  w = self.VV1PTZ[ndx]
  return VVpSLv > 1 or (w > self.VV5RXW or w == self.VVyIjS) and ndx != self.VV1KNJ
 def VVC91d(self, ndx):
  w = self.VV1PTZ[ndx]
  return VVpSLv > 1 or (w > self.VV5RXW or w == self.VVjJkz) and ndx != self.VV1KNJ and ndx not in self.VVPWLU.keys()
 def VVEMwI(self):
  item = self["myTable"].getCurrent()
  if item:
   colList = []
   txt = ""
   tot = 0
   for i in range(self.VVBL0Q):
    colTxt = item[i + 1][7].strip()
    colList.append(colTxt)
    if self.VVAa4i(i):
     tot += 1
     if self.header : name = self.header[i].strip()
     else   : name = "Column-%d" % (i + 1)
     txt += "%s\t: %s\n" % (name, colTxt)
   if tot == 1:
    txt = colList[0]
   rowNum = "Row Number\t: %d of %d" % (item[0] + 1, len(self["myTable"].list))
   return rowNum, txt, colList
  else:
   return None
 def VVGNfU(self):
  if self.VVbbT0:
   self.VVUVWk()
  else:
   if self.VVLj1d : self.VVLj1d(self)
   else     : self.close(None)
 def cancel(self):
  self.close(None)
 def VVIdZ2(self):
  return self["myTitle"].getText().strip()
 def VVBMP2(self):
  return self.header
 def VVq4kA(self, title):
  self.Title = title
  self["myTitle"].setText("  " + title.strip() + "  ")
 def VVCGR5(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VVX9Op(self, title, color=None):
  self["myBar"].setText("  " + title.strip() + "  ")
  if color:
   FFcfsH(self["myBar"], color)
 def VVrGNL(self, txt):
  FF8PJn(self, txt)
 def VVjSys(self, txt, Time=1000):
  FF8PJn(self, txt, Time)
 def VVX6lU(self): self["keyRed"].show()
 def VVOKYi(self): self["keyRed"].hide()
 def VVW6Cx(self): self["keyGreen"].show()
 def VVcilR(self): self["keyGreen"].hide()
 def VV7swH(self): self["keyBlue"].show()
 def VVtMif(self): self["keyBlue"].hide()
 def VV2K4r(self): self["keyYellow"].show()
 def VVcX7o(self): self["keyYellow"].hide()
 def VVflb7(self): return self["keyGreen"].visible
 def VV8SQf(self):
  FF8PJn(self)
 def VVIl4g(self, fnc, callFnc=True):
  self["myTable"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VVvmd7(self):
  return len(self["myTable"].list)
 def VVfkJL(self):
  return self["myTable"].l.getCurrentSelectionIndex()
 def VVJPu5(self):
  return len(self["myTable"].list)
 def VVyPTg(self):
  return self.VVbbT0
 def VVQrKf(self):
  return self.VVF3eY
 def VV1Weh(self):
  self.VVUxKE(True)
 def VVUVWk(self):
  self.VVZCQs()
  self.VVUxKE(False)
 def VVvSt4(self):
  curRow = self["myTable"].l.getCurrentSelectionIndex()
  self["myTable"].moveToIndex(curRow + 1)
 def VVFc2A(self, colNum):
  if colNum < self.VVBL0Q:
   if self.header : subj = self.header[colNum]
   else   : subj = ""
   lst = set()
   for item in self["myTable"].list:
    lst.add(item[colNum + 1][7])
   return subj, str(len(lst))
  else:
   return "", ""
 def VVPazr(self):
  txt  = "Total Rows\t: %d\n\n" % self.VVvmd7()
  txt += FFiN5A("Total Unique Items", VVcahY)
  for i in range(self.VVBL0Q):
   if self.VVAa4i(i):
    name, tot = self.VVFc2A(i)
    txt +=  "%s\t: %s\n" % (name, tot)
  FFyijw(self, txt)
 def VVVWWJ(self, colNum, isStrip=True):
  item = self["myTable"].getCurrent()
  if item : return item[colNum + 1][7].strip() if isStrip else item[colNum + 1][7]
  else : return None
 def VVqY3Q(self):
  return self.VVVB7s(self["myTable"].l.getCurrentSelectionIndex())
 def VVVB7s(self, rowNdx):
  colList = []
  item = self["myTable"].list[rowNdx]
  if item:
   for i in range(1, self.VVBL0Q + 1):
    colList.append(item[i][7].strip())
  return colList
 def VVxhz9(self, newList, newTitle="", VVMbPmMsg=True, VVK0Fc=None, isSort=True):
  fnc = BF(self.VV7WIV, newList, newTitle, VVMbPmMsg, VVK0Fc, isSort)
  if VVMbPmMsg : FFTSvN(self, fnc, title="Refreshing ...")
  else   : fnc()
 def VV7WIV(self, newList, newTitle, VVMbPmMsg, VVK0Fc, isSort):
  try: fake = self.VVrpeX
  except: return
  if newTitle:
   self.VVq4kA(newTitle)
  if newList:
   self.VV5dDF = newList
   if VVK0Fc:
    self.VVK0Fc = ("", VVK0Fc, [])
   isNum = False
   if self.VVrpeX and self.VV3dKD == 0:
    isNum = True
   else:
    for cols in self.VV5dDF:
     if not FFjWX8(cols[self.VV3dKD]): break
    else:
     isNum = True
   if isSort:
    patt = r"^\s*#(f|b)#[a-fA-F0-9]{8}#"
    if isNum: self.VV5dDF.sort(key=lambda x: int(x[self.VV3dKD][12:])  if iMatch(patt, x[0]) else int(x[self.VV3dKD]) , reverse=self.VVtSQd)
    else : self.VV5dDF.sort(key=lambda x: x[self.VV3dKD][12:].lower() if iMatch(patt, x[0]) else x[self.VV3dKD].lower() , reverse=self.VVtSQd)
   self.VVMbfT(showProgBar=False, fromRefresh=True)
  else:
   FFU9uk(self, "Cannot refresh list", title=self.Title)
   self.cancel()
 def VVRcvb(self, row, moveCurs=True):
  row = self["myTable"].list.append(self.VVBzNh(self.VVJPu5(), row, self.VVJIK0, self.VVpaQ6, self.VVqecq, self.VVI4UA, None))
  self["myTable"].l.setList(self["myTable"].list)
  if moveCurs: self.VVU4Vz()
 def VVE3Oz(self):
  self["myTable"].list.pop(self.VVfkJL())
  if len(self["myTable"].list) > 0: self["myTable"].l.setList(self["myTable"].list)
  else       : self.close()
 def VVULq3(self, data):
  ndx = self.VVfkJL()
  newRow = self.VVBzNh(ndx, data, self.VVJIK0, self.VVpaQ6, self.VVqecq, self.VVI4UA, None)
  if newRow:
   self["myTable"].list[ndx] = newRow
   self.VV5X9f()
   return True
  else:
   return False
 def VVDWD7(self, tDict):
  ndx = self.VVfkJL()
  for colNum, val in tDict.items():
   txt = str(val)
   if not self.VV1UVb and self.VVgKQc[ndx] & LEFT:
    txt = " %s " % txt.strip()
   col = list(self["myTable"].list[ndx][colNum + 1])
   col[7] = txt
   self["myTable"].list[ndx][colNum + 1] = tuple(col)
  self.VV5X9f()
 def VVZmhU(self, ndx, data):
  if ndx >=0 and ndx < len(self["myTable"].list):
   newRow = self.VVBzNh(ndx, data, self.VVJIK0, self.VVpaQ6, self.VVqecq, self.VVI4UA, None)
   if newRow:
    self["myTable"].list[ndx] = newRow
    self.VV5X9f()
 def VVgyd0(self, rowNdx, colNDx, part, val):
  row = self["myTable"].list[rowNdx]
  col = list(row[colNDx + 1])
  if col[0] == eListboxPythonMultiContent.TYPE_TEXT:
   if col[part] != val:
    col[part] = val
    row[colNDx + 1] = tuple(col)
    self["myTable"].list[rowNdx] = row
    self.VV5X9f()
 def VV5X9f(self):
  self["myTable"].l.invalidate()
 def VVZkXQ(self, colNum=0):
  for ndx, item in enumerate(self["myTable"].list):
   lst = list(self["myTable"].list[ndx][colNum + 1])
   lst[7] = str(ndx + 1)
   self["myTable"].list[ndx][colNum + 1] = tuple(lst)
  self["myTable"].l.setList(self["myTable"].list)
 def VVp9iQ(self, colNum, textToFind, VVqUOx=False):
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   if textToFind in item:
    self["myTable"].moveToIndex(i)
    break
  else:
   if VVqUOx:
    FF8PJn(self, "Not found", 1000)
 def VVdP7o(self, colDict, VVqUOx=False):
  for i in range(len(self["myTable"].list)):
   for colNum, txt in colDict.items():
    if not txt == self["myTable"].list[i][colNum + 1][7].strip():
     break
   else:
    self["myTable"].moveToIndex(i)
    return
  if VVqUOx:
   FF8PJn(self, "Not found", 1000)
  return False
 def VVlL5a(self, colNum):
  tList = []
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   tList.append(item)
  return tList
 def VVFN86(self, colNum):
  for i in range(len(self["myTable"].list)):
   if not FFjWX8(self["myTable"].list[i][colNum + 1][7].strip()):
    return False
  return True
 def VVaOdg(self, colNum, isStrip=True):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVcnDd:
    item = self["myTable"].list[ndx][colNum + 1][7]
    if isStrip: item = item.strip()
    tList.append(item)
  return tList
 def VV4e0j(self):
  if self.VVF3eY:
   for ndx, row in enumerate(self["myTable"].list):
    if row[1][10] == self.VVcnDd:
     return ndx
  return -1
 def VVwKf5(self):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVcnDd:
    item = self["myTable"].list[ndx]
    colList = []
    for i in range(1, self.VVBL0Q + 1):
     colList.append(item[i][7].strip())
    tList.append(colList)
  return tList
 def VVAkKb(self, ndx):
  row = self["myTable"].list[ndx]
  if row[1][10] == self.VVcnDd : return True
  else        : return False
 def VVTq0J(self):
  for ndx, row in enumerate(self["myTable"].list):
   item = self["myTable"].list[ndx]
   colList = []
   for i in range(1, self.VVBL0Q + 1):
    colTxt = item[i][7].strip()
    colList.append(colTxt)
   yield colList
 def VVt4Vj(self):
  if self.VVi7Cl:
   self.VVAL3r(self.VVi7Cl)
   return
  if not self["keyMenu"].getVisible() or self.VV4HrS:
   return
  txt  = self.VV7VIQ.getValue()
  curRow = self.VVfkJL()
  totRows = len(self["myTable"].list)
  itemOf = lambda cond, p1, p2: (p1, p2) if cond else (p1, )
  VVXXzc1, VVfUoq = CCrT1G.VV8C49(self, False, False)
  VVXXzc = []
  VVXXzc.append(itemOf(txt and curRow < totRows - 1 , "Find Next\t\t>"     , "findNext"  ))
  VVXXzc.append(itemOf(txt and curRow > 0   , "Find Previous\t\t<"    , "findPrev"  ))
  VVXXzc.append(("Find ...\t\t%s" % (FFITtK(txt, VVi4ay) if txt else ""), "findNew"   ))
  VVXXzc.append(itemOf(bool(VVXXzc1)    , "Find (from Filter) ..."   , "filter"   ))
  if self.header:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Table Statistcis"            , "tableStat"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((FFITtK("Export Table to .html"     , VVcahY) , "VVRugL" ))
  VVXXzc.append((FFITtK("Export Table to .csv"     , VVcahY) , "VVEAEg" ))
  VVXXzc.append((FFITtK("Export Table to .txt (Tab Separated)", VVcahY) , "VV09Lu" ))
  if self.VVq6oU:
   sList = []
   tot  = 0
   for i in range(self.VVBL0Q):
    if self.VVC91d(i):
     tot += 1
     if self.header : name = self.header[i]
     else   : name = "Column-%d" % (i + 1)
     sList.append(("Sort by : %s" % name, i))
   if tot:
    VVXXzc.append(VVzg1X)
    if tot == 1 : VVXXzc.append(("Sort", sList[0][1]))
    else  : VVXXzc += sList
  VViDZz = ("Keys Help", self.VVlHpD)
  FFw2XU(self, self.VVr8jd, VVXXzc=VVXXzc, VV1Wwb=28,title=self.VVIdZ2(), VViDZz=VViDZz)
 def VVr8jd(self, item=None):
  if item is not None:
   if   item == "findNext"  : self.VVvCpj()
   elif item == "findPrev"  : self.VVvCpj(isPrev=True)
   elif item == "findNew"  : self.VVRohA()
   elif item == "filter"  : self.VVFX1z()
   elif item == "tableStat" : self.VVPazr()
   elif item == "VVRugL": self.VVRugL()
   elif item == "VVEAEg" : self.VVEAEg()
   elif item == "VV09Lu" : self.VV09Lu()
   else:
    if self.VV3dKD == item: self.VVtSQd = not self.VVtSQd
    else      : self.VV3dKD, self.VVtSQd = item, False
    if self.VVrpeX and self.VV3dKD == 0 or self.VVFN86(item):
     self["myTable"].list.sort(key=lambda x: int(x[item + 1][7]), reverse=self.VVtSQd)
    else:
     self["myTable"].list.sort(key=lambda x: x[item + 1][7].lower(), reverse=self.VVtSQd)
    self["myTable"].l.setList(self["myTable"].list)
    self.VVMbfT(onlyHeader=True)
 def VVlHpD(self, VVZzW8, path):
  FFpIdO(self, "_help_table", "Table (Keys Help)")
 def VVycmo(self) : self["myTable"].up()
 def VVVMkx(self): self["myTable"].down()
 def VVeXT6(self) : self["myTable"].pageUp()
 def VVNZhV(self): self["myTable"].pageDown()
 def VVx7VB(self)  : self["myTable"].moveToIndex(0)
 def VVU4Vz(self)  : self["myTable"].moveToIndex(len(self["myTable"].list) - 1)
 def VV43d2(self, rowNdx): self["myTable"].moveToIndex(rowNdx)
 def VV3xNW(self):
  if self.VV7VIQ.getValue():
   if self.VVfkJL() == len(self["myTable"].list) - 1 : FF8PJn(self, "End reached", 1000)
   else              : self.VVvCpj()
  else:
   FF8PJn(self, 'Set "Find" in Menu', 1500)
 def VVzedO(self):
  if self.VV7VIQ.getValue():
   if self.VVfkJL() == 0 : FF8PJn(self, "Top reached", 1000)
   else       : self.VVvCpj(isPrev=True)
  else:
   FF8PJn(self, 'Set "Find" in Menu', 1500)
 def VVfTbt(self, txt):
  FFDDwF(self.VV7VIQ, txt)
 def VVRohA(self):
  FFttdT(self, self.VVuNed, title="Find in Table", defaultText=self.VV7VIQ.getValue(), message="Enter Text:")
 def VVuNed(self, VVAQKp):
  if not VVAQKp is None:
   txt = VVAQKp.strip()
   self.VVfTbt(txt)
   if VVAQKp: self.VVvCpj(reset=True)
   else  : FF8PJn(self, "Nothing to find !", 1500)
 def VVFX1z(self):
  VVXXzc, VVfUoq = CCrT1G.VV8C49(self, False, False)
  VVI6TY = ("Edit Filter", BF(self.VVxsgK, VVfUoq))
  if VVXXzc : FFw2XU(self, self.VV2X6r, VVXXzc=VVXXzc, VVI6TY=VVI6TY, title="Find from Filter")
  else  : FF8PJn(self, "Filter Error !", 1500)
 def VV2X6r(self, item=None):
  if item is not None:
   txt = item.strip()
   if txt:
    self.VVfTbt(txt)
    self.VVvCpj(reset=True)
   else:
    FF8PJn(self, "No entry !", 1500)
 def VVxsgK(self, VVfUoq, selectionObj, sel):
  if FFf0vs(VVfUoq) : CCAvJY(self, VVfUoq, VVuQkS=None)
  else       : FFbHk5(self, VVfUoq)
  selectionObj.cancel()
 def VVvCpj(self, reset=False, isPrev=False):
  curRow = self.VVfkJL()
  totRows = len(self["myTable"].list)
  if   reset : row1, row2, steps = 0, totRows, 1
  elif isPrev : row1, row2, steps = curRow - 1, -1, -1
  else  : row1, row2, steps = curRow + 1, totRows, 1
  tupl, asPrefix = CCrT1G.VVYDJw(self.VV7VIQ.getValue())
  if tupl:
   for i in range(row1, row2, steps):
    line = self["myTable"].list[i][self.VVylFd + 1][7]
    line = line.strip().lower()
    if asPrefix:
     if line.startswith(tupl):
      self.VV43d2(i)
      break
    elif any(x in line for x in tupl):
     self.VV43d2(i)
     break
   else:
    FF8PJn(self, "Not found", 1000)
  else:
   FF8PJn(self, "Check your query", 1500)
 @FFHF2S()
 def VV09Lu(self):
  expFile = self.VV9JTZ() + ".txt"
  with open(expFile, "w") as f:
   filteredHeader = self.VVgRVx()
   if filteredHeader:
    f.write("\t".join(filteredHeader) + "\n")
   for i in range(len(self["myTable"].list)):
    row = self.VVVB7s(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VVioQF(ndx):
      col = self.VVpzme(col)
      col = col.replace("\n", " _ ")
      newRow.append(col)
    f.write("\t".join(newRow) + "\n")
  self.VVKrYJ(expFile)
 @FFHF2S()
 def VVEAEg(self):
  expFile = self.VV9JTZ() + ".csv"
  with open(expFile, "w") as f:
   filteredHeader = self.VVgRVx()
   if filteredHeader:
    f.write(",".join(filteredHeader) + "\n")
   pattern = "^[0-9a-fA-F]*$"
   for i in range(len(self["myTable"].list)):
    row = self.VVVB7s(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VVioQF(ndx):
      if iMatch(pattern, col) : prefix = "'"
      else     : prefix = ""
      col = self.VVpzme(col)
      col = col.replace(",", ";").replace("\n", " _ ")
      newRow.append(prefix + col)
    f.write(",".join(newRow) + "\n")
  self.VVKrYJ(expFile)
 @FFHF2S()
 def VVRugL(self):
  title = FFes9J(self.VVIdZ2()).replace("\t", "&nbsp;" * 4)
  txt   = '<!DOCTYPE html>\n'
  txt  += '<html>\n'
  txt  += ' <head>\n'
  txt  += ' <meta charset="utf-8">\n'
  txt  += ' <meta name="viewport" content="width=device-width, initial-scale=1.0">\n'
  txt  += ' <TITLE>%s - %s (%s)</TITLE>\n' % (title, VVryLp, VVsBow)
  txt  += ' <style>\n'
  txt  += '  table { font-family: arial, sans-serif; border-collapse: collapse; width: 100%; }\n'
  txt  += '  td,th { border: 1px solid #dddddd; text-align: left; padding: 5px; }\n'
  txt  += '  td { font-size: 0.8em; }\n'
  txt  += '  th { color:#006000; background-color:#FFFFaa; font-size: 1.2em; }\n'
  txt  += '  tr:nth-child(even) { background-color: #f8f8f8; }\n'
  txt  += ' </style>\n'
  txt  += ' </head>\n'
  txt  += ' <body>\n'
  txt  += '  <h2 style="color:#006000;">%s</h2>\n' % title
  txt  += '  <table>\n'
  txt  +=     '#colgroup#'
  txt  += '   <tr>#tableHead#</tr>\n'
  txt2  = '  <table>\n'
  txt2 += ' </body>\n'
  txt2 += '</html>\n'
  tableHead  = ""
  filteredHeader = self.VVgRVx()
  if filteredHeader:
   for col in filteredHeader:
    tableHead += '<th>%s</th>' % col
  txt = txt.replace("#tableHead#", tableHead)
  colgroup = ""
  if self.VV1PTZ:
   colgroup += '   <colgroup>'
   for ndx, w in enumerate(self.VV1PTZ):
    if self.VVioQF(ndx):
     colgroup += '<col style="width: %d%s;" />' % (w, "%")
   colgroup += "</colgroup>\n"
  txt = txt.replace("#colgroup#", colgroup)
  expFile = self.VV9JTZ() + ".html"
  with open(expFile, "w") as f:
   f.write(txt)
   for i in range(len(self["myTable"].list)):
    row = self.VVVB7s(i)
    newRow = "   <tr>"
    for ndx, col in enumerate(row):
     if self.VVioQF(ndx):
      col = self.VVpzme(col)
      newRow += '<td>%s</td>' % col
    newRow += "</tr>\n"
    f.write(newRow)
   f.write(txt2)
  self.VVKrYJ(expFile)
 def VVgRVx(self):
  newRow = []
  if self.header:
   for ndx, col in enumerate(self.header):
    if self.VVioQF(ndx):
     newRow.append(col.strip())
  return newRow
 def VVpzme(self, col):
  if col.count(":") > 8:
   col = col.replace(":", "_")
   col = col.rstrip("_")
  col = iSub(r"(#.#[a-fA-F0-9]{8}#)" ,"" , col, flags=IGNORECASE)
  return FFes9J(col)
 def VV9JTZ(self):
  fileName = iSub(r"[^0-9a-zA-Z]+", "_", FFes9J(self.VVIdZ2()))
  fileName = fileName.replace("__", "_")
  expFile  = FFg1mx() + fileName + "_" + FF6eWd()
  return expFile
 def VVKrYJ(self, expFile):
  if self.VV9mY2 and FFf0vs(expFile):
   self.VV9mY2(self, expFile)
  FFSQn9(self, "File exported to:\n\n%s" % expFile, title=self.VVIdZ2())
 @staticmethod
 def VVuz47(x, y, w, h, fnt, flg, txt, fg, bg, sFg, sBg, bW, bC):
  return (eListboxPythonMultiContent.TYPE_TEXT, x, y, w, h, fnt, flg, txt, fg, sFg, bg, sBg, bW, bC)
 @staticmethod
 def VVUqW9(x, y, w, h, png, bg=None, bgSel=None):
  typ = eListboxPythonMultiContent.TYPE_PIXMAP_ALPHATEST
  if VVFzqL: return (typ, x, y, w, h, png, bg, bgSel, VVFzqL | CENTER)
  else   : return (typ, x, y, w, h, png, bg, bgSel)
 @staticmethod
 def VVsUpe(x, y, w, h, percent, bW, fg):
  return (eListboxPythonMultiContent.TYPE_PROGRESS, x, y, w, h, int(percent), bW, fg)
class CC7kfO():
 def __init__(self, pixmap, VVthiO, VVpaQ6, fncCb_ok, fncCb_fail):
  self.pixmap   = pixmap
  self.picInst  = pixmap.instance
  self.VVthiO  = VVthiO
  self.VVpaQ6  = VVpaQ6 or "#2200002a"
  self.fncCb_ok  = fncCb_ok
  self.fncCb_fail  = fncCb_fail
  self.FFujkg  = FFujkg()
  global VVT6xx
  VVT6xx = True
  self.picInst.setPixmap(None)
 def VVoqtB(self):
  from enigma import ePicLoad
  self.picLoad  = ePicLoad()
  self.picload_conn = None
  if not all((self.pixmap, self.VVthiO, FFf0vs(self.VVthiO))):
   return False
  sz = self.picInst.size()
  self.picLoad.setPara((sz.width(), sz.height(), 1, 1, False, 1, self.VVpaQ6))
  try:
   if self.FFujkg:
    res = self.picLoad.startDecode(self.VVthiO, False)
    if res == 0:
     return self.VVLM9B()
    else:
     del self.picLoad
     return False
   else:
    try:
     self.picload_conn = self.picLoad.PictureData.connect(self.VV2kzT)
    except:
     self.picLoad.PictureData.get().append(self.VV2kzT)
    res = self.picLoad.startDecode(self.VVthiO)
    return True if res == 0 else False
  except:
   return False
 def VV2kzT(self, pInfo=""):
  ok = self.VVLM9B()
 def VVLM9B(self):
  ok = False
  ptr = self.picLoad.getData()
  if ptr is not None:
   try:
    self.picInst.setPixmap(ptr)
    ok = True
   except:
    pass
  del self.picLoad
  self.picload_conn = None
  if ok and self.fncCb_ok   : self.fncCb_ok()
  if not ok and self.fncCb_fail: self.fncCb_fail()
  global VVT6xx
  VVT6xx = False
  return ok
class CCC0Lg(Screen):
 def __init__(self, session, VV0hkT, title="", showGrnMsg="", fileList=None, VVlBZZ=0, fakePath=None, cbFnc=None, menuFnc=None):
  scrW, scrH = FFUA0v()
  w = 1700
  h = int(min(w * scrH / scrW + 51, 1040))
  self.skin, self.VVuaAL = FFJH4U(VVfBCq, w, h, 30, 0, 0, "#22000060", "#2200002a", 30, VV1fgG=2 if menuFnc else 3)
  self.session  = session
  self.Title   = title
  self["myPic"]  = Pixmap()
  self.VV0hkT = VV0hkT
  self.showGrnMsg  = showGrnMsg
  self.fileList  = fileList
  self.VVlBZZ  = VVlBZZ
  self.fakePath  = fakePath
  self.cbFnc   = cbFnc
  self.menuFnc  = menuFnc
  FFfmZP(self)
  FFewq4(self,
  {
   "ok" : self.VVkIEK    ,
   "red" : self.VVkIEK    ,
   "cancel": self.VVkIEK    ,
   "info" : self.VVuPfx  ,
   "menu" : self.VVrCIG  ,
   "up" : BF(self.VVsjnI, -1),
   "down" : BF(self.VVsjnI,  1),
   "left" : BF(self.VVsjnI, -1),
   "right" : BF(self.VVsjnI,  1)
  })
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  self.VVZDr6()
 def VVkIEK(self):
  if VVT6xx:
   FFRo1g(self)
   FFk1YE(self, "Closing ...")
   FFUttZ(self, 1000, self.close)
  else:
   self.close("")
 def VVZDr6(self):
  self.VVgufH()
  if os.path.isfile(self.VV0hkT) and CCf9Gq.VVl2HO(self.VV0hkT) == "pic" and FFX42v(self.VV0hkT) > 0:
   if not FFlfvg(self["myPic"], self.VV0hkT, fncCb_ok=self.VVkmbc, fncCb_fail=self.VVSSzd):
    self.VVSSzd()
  else:
   self.VVSSzd()
 def VVkmbc(self):
  if self.showGrnMsg:
   FFar20(self, self.showGrnMsg, 1500)
 def VVSSzd(self):
  if not FFgfSp(self["myPic"], "noPic"):
   FFU9uk(self, "Cannot view picture file:\n\n%s" % self.VV0hkT)
   self.close()
 def VVsjnI(self, direc):
  if self.fileList:
   oldNdx = self.VVlBZZ
   self.VVlBZZ += direc
   if direc == -1 and self.VVlBZZ < 0      : self.VVlBZZ = len(self.fileList) - 1
   if direc ==  1 and self.VVlBZZ > len(self.fileList) - 1 : self.VVlBZZ = 0
   if not oldNdx == self.VVlBZZ:
    fName = self.fileList[self.VVlBZZ][1]
    self.VV0hkT = FFA4GT(os.path.dirname(self.VV0hkT)) + fName
    self.VVZDr6()
 def onExit(self):
  if self.cbFnc:
   if self.fileList: self.cbFnc(self.VV0hkT, self.fileList[self.VVlBZZ][0])
   else   : self.cbFnc(self.VV0hkT)
 def VVuPfx(self):
  txt = "%s:\n  %s" % (FFITtK("Path", VV6UAe), self.fakePath or self.VV0hkT)
  size, sizeTxt, resTxt, form, mode = CCHa3c.VVF76v(self.VV0hkT)
  if any((size, sizeTxt, resTxt, form, mode)):
   txt += "\n\n%s:\n" % FFITtK("Properties", VV6UAe)
   if sizeTxt: txt += "  File Size\t: %s\n" % sizeTxt
   if resTxt : txt += "  Dimensions\t: %s\n" % resTxt
   if form   : txt += "  Format\t: %s\n"  % form
   if mode   : txt += "  Mode\t: %s\n"   % mode
  FFyijw(self, txt, title="File Information")
 def VVrCIG(self):
  if self.menuFnc:
   self.menuFnc(self)
 def VVgufH(self):
  if self.fileList: title = "%d/%d : %s" % (self.VVlBZZ + 1, len(self.fileList), self.fileList[self.VVlBZZ][1])
  elif self.Title : title = self.Title
  else   : title = os.path.basename(self.VV0hkT)
  self["myTitle"].setText("  %s  " % title)
 @staticmethod
 def VVESKQ(SELF, VV0hkT, **kwargs):
  SELF.session.open(CCC0Lg, VV0hkT, **kwargs)
class CC9AHO(Screen):
 def __init__(self, session, mviFile=None):
  self.skin, self.VVuaAL = FFJH4U(VVMfHP, 400, 55, 30, 0, 0, "#22004455", "#00ff0000", 30)
  self.session  = session
  self.mviFile  = mviFile
  FFfmZP(self, "Click Cancel to exit", addCloser=True)
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.curServ = CCaZ62(self.session).servRef
  self.session.nav.stopService()
  if FF6usE("showiframe %s" % self.mviFile):
   self.instance.move(ePoint(20, 20))
  else:
   self.close(-1)
 def onExit(self):
  if self.curServ:
   self.session.nav.playService(self.curServ, checkParentalControl=False, forceRestart=False)
 @staticmethod
 def VVumyd(SELF, mviFile):
  SELF.session.openWithCallback(BF(CC9AHO.VVr7zg, SELF), CC9AHO, mviFile)
 @staticmethod
 def VVr7zg(SELF, reason=None):
  if reason == -1: FFU9uk(SELF, "Error while viewing mvi file.", title="MVI Viewer")
class CC8MwG(Screen, ConfigListScreen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVKdMd, 1400, 1075, 50, 15, 15, "#11201010", "#11101010", 28, VVZ3ZU=40, VV1fgG=1, VVO8hC=0.1)
  self.session  = session
  self.Title   = "%s Settings" % VVryLp
  FFfmZP(self, title=self.Title)
  FFrvOP(self["keyGreen"], "Save")
  sep = SEP * 3
  lst = []
  lst.append(getConfigListEntry("Show in Main Menu"         , CFG.showInMainMenu   ))
  lst.append(getConfigListEntry("Show in Extensions Menu"        , CFG.showInExtensionMenu  ))
  lst.append(getConfigListEntry("Show in Channel List Context Menu"     , CFG.showInChannelListMenu  ))
  lst.append(getConfigListEntry("Show in Events Info Menu"       , CFG.EventsInfoMenu   ))
  lst.append(getConfigListEntry("Input Type"           , CFG.keyboard     ))
  lst.append(getConfigListEntry("Exit-Button Action (in File Manager and FTP)"  , CFG.FileManagerExit   ))
  lst.append(getConfigListEntry("Player Bar Hotkey"         , CFG.hotkey_signal    ))
  lst.append(getConfigListEntry("Screenshot"           , CFG.screenshotFType   ))
  lst.append(getConfigListEntry("Subtitle Files Encoding Priority"     , CFG.subtDefaultEnc   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Default IPTV Reference Type (defines the player)" , CFG.iptvAddToBouquetRefType ))
  lst.append(getConfigListEntry("Auto Reset Frozen IPTV Channels"      , CFG.autoResetFrozenIptvChan ))
  lst.append(getConfigListEntry("Skip Adults Channels (from IPTV Server)"    , CFG.hideIptvServerAdultWords ))
  lst.append(getConfigListEntry("Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)" , CFG.hideIptvServerChannPrefix ))
  lst.append(getConfigListEntry("Portal Servers Connection Timeout (seconds)"   , CFG.portalConnTimeout   ))
  lst.append(getConfigListEntry("IPTV Hosts Files Path (Playlist, Portal, M3U)"  , CFG.iptvHostsMode    ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Auto Resume (Movies)"        , CFG.resumeMovies    ))
  lst.append(getConfigListEntry("Local Movies and IPTV Download Path"     , CFG.MovieDownloadPath   ))
  lst.append(getConfigListEntry("PIcons Path"           , CFG.PIconsPath    ))
  lst.append(getConfigListEntry("Custom Menu Path"         , CFG.customMenuPath   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Main Working Path (Backup/Restore/Screenshot/etc.)" , CFG.backupPath    ))
  ConfigListScreen.__init__(self, lst, session)
  self.VVoXZr()
  self.onShown.append(self.VVvFMs)
 def VVoXZr(self):
  kList = {
    "ok" : self.VVTOku   ,
    "green" : self.VVsxbF ,
    "menu" : self.VVZ8QZ ,
    "cancel": self.VVasjx
    }
  kLeft = kRight = None
  try:
   from Components.config import ConfigSubList, KEY_LEFT as kLeft, KEY_RIGHT as kRight
  except:
   try:
    from Components.config import ConfigSubList, ACTIONKEY_LEFT as kLeft, ACTIONKEY_RIGHT as kRight
   except:
    pass
  if not (kLeft == kRight == None):
   kList["left"] = BF(self["config"].handleKey, kLeft)
   kList["right"] = BF(self["config"].handleKey, kRight)
   try:
    kList["chanUp"]  = self["config"].pageUp
    kList["chanDown"] = self["config"].pageDown
   except:
    try:
     kList["chanUp"]  = BF(self["config"].VVhYbR, 0)
     kList["chanDown"] = BF(self["config"].VVhYbR, len(self["config"].list) - 1)
    except:
     pass
   FFewq4(self, kList, name="config_actions")
  else:
   FFewq4(self, kList, name="actions")
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FF1uow(self)
  FFTDN6(self["config"])
  FFbm8U(self, self["config"])
  FFE1T7(self)
  self["config"].onSelectionChanged.append(self.VVUYM2)
  self.VVUYM2()
  FFu0W6(self["keyRed"], "#11000000")
  self["keyRed"].show()
 def VVUYM2(self):
  cfg = self["config"].getCurrent()[1]
  if isinstance(cfg, ConfigDirectory) and cfg != CFG.subtDefaultEnc: txt = "Change Path"
  else                : txt = "Show Choices"
  self["keyRed"].setText("OK = %s" % txt)
 def VVTOku(self):
  title, item = self["config"].getCurrent()
  if item:
   if   item == CFG.iptvHostsMode   : self.VVICCQ()
   elif item == CFG.MovieDownloadPath   : self.VVzjcc(item, self["config"].getCurrent()[0])
   elif item == CFG.subtDefaultEnc   : self.VVE6lt()
   elif isinstance(item, ConfigDirectory) : self.VVBxt3(item)
   else         : CC8MwG.VVlTg2(self, item, title, width=1100)
 @staticmethod
 def VVlTg2(SELF, confItem, title, lst=None, cbFnc=None, isSave=False, width=800):
  if not lst:
   if   isinstance(confItem, ConfigYesNo)  : lst = [(True, "ON"), (False, "OFF")]
   elif isinstance(confItem, ConfigSelectionNumber):
    lst = confItem.choices.choices
    if not isinstance(lst[0], tuple)  : lst = [(x, x) for x in lst]
   elif isinstance(confItem, ConfigSelection) : lst = confItem.choices.choices
   elif isinstance(confItem, ConfigInteger) : lst = [(x, str(x)) for x in range(confItem.limits[0][0], confItem.limits[0][1] + 1, 1)]
   else          : return
  curNdx = defNdx = -1
  VVXXzc = []
  for ndx, item in enumerate(lst):
   if len(item) == 1:
    val, txt = ("dum",SEP)
   else:
    val, txt = item
    if   val == confItem.value : curNdx, txt = ndx, VVi4ay + txt
    elif val == confItem.default: defNdx, txt = ndx, VVaR8d + txt
   VVXXzc.append((txt, val))
  if defNdx == -1: defNdx = curNdx
  VViDZz  = ("Current", BF(CC8MwG.VVGPap, curNdx))
  VVI6TY = ("Default", BF(CC8MwG.VVGPap, defNdx))
  VVZzW8 = FFw2XU(SELF, BF(CC8MwG.VV7YGs, confItem, cbFnc, isSave), VVXXzc=VVXXzc, width=width, VVI6TY=VVI6TY, VViDZz=VViDZz, title=title, VVVzvS="#22221111", VVhHWW="#22110011", VVlIBH="#11550000")
  VVZzW8.VVEaHH(curNdx)
 @staticmethod
 def VV7YGs(confItem, cbFnc, isSave, item=None):
  if not item == None:
   confItem.setValue(item)
   if isSave: FFDDwF(confItem, item)
   if cbFnc: cbFnc()
 @staticmethod
 def VVGPap(ndx, selectionObj, item):
  selectionObj.VVEaHH(ndx)
 @staticmethod
 def VVzbbR(confItem, lst):
  for ndx, item in enumerate(lst):
   if item[0] == confItem.value:
    return ndx
  return -1
 def VVzjcc(self, item, title):
  tot = CChTrx.VVLo8K()
  if tot : FFU9uk(self, "Cannot change while downloading.", title=title)
  else : self.VVBxt3(item)
 def VVE6lt(self):
  curEnc = CFG.subtDefaultEnc.getValue()
  lst = CC2Ldo.VV9O72(self, "", curEnc)
  if lst:
   VVI6TY = ("Default", self.VVN6eM)
   VViDZz  = ("Current", self.VV0RV8)
   VVZzW8 = FFw2XU(self, self.VVYW4N, title="Select Priority Encoding", VVXXzc=lst, width=1000, height=1000, VViDZz=VViDZz, VVI6TY=VVI6TY, VVVzvS="#22220000", VVhHWW="#22220000", VVfP2Q=True)
   VVZzW8.VVWDNK(curEnc)
 def VVYW4N(self, item=None):
  if item:
   txt, enc, ndx = item
   CFG.subtDefaultEnc.setValue(enc)
 def VVN6eM(self, VVZzW8, item): VVZzW8.VVWDNK(VVMHLG)
 def VV0RV8(self, VVZzW8, item): VVZzW8.VVWDNK(CFG.subtDefaultEnc.getValue())
 def VVICCQ(self):
  VVXXzc = []
  VVXXzc.append(("Auto Find" , "auto"))
  VVXXzc.append(("Custom Path" , "cust"))
  FFw2XU(self, self.VVYz6i, VVXXzc=VVXXzc, title="IPTV Hosts Files Path")
 def VVYz6i(self, item=None):
  if item:
   if item == "auto":
    CFG.iptvHostsMode.setValue(VV1rMY)
   elif item == "cust":
    VVJwgn = self.VVN788()
    if VVJwgn : self.VVXgqK(VVJwgn)
    else  : self.session.openWithCallback(self.VVXWSR, BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi="/"))
 def VVXgqK(self, VVJwgn):
  VVLj1d = self.VVaYCb
  VVEyDE = ("Remove"  , self.VVwOD9 , [])
  VVbQ6N = ("Add "  , self.VV600K, [])
  header   = ("Directory" , "Remarks" )
  widths   = (80   , 20  )
  VVgKQc  = (LEFT   , LEFT  )
  FFdCaM(self, None, title="IPTV Hosts Search Paths", header=header, VV5dDF=VVJwgn, width=1200, height=700, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=26, VVLj1d=VVLj1d, VVEyDE=VVEyDE, VVbQ6N=VVbQ6N
    , VVVzvS="#22220000", VVhHWW="#22110000", VVpaQ6="#22110011", VVI4UA="#11223025", VVcv6F="#0a333333", VVsOjr="#11400040")
 def VVaYCb(self, VV5ybN):
  if CFG.iptvHostsDirs.getValue():
   CFG.iptvHostsMode.setValue(VVUWre)
  VV5ybN.cancel()
 def VVXWSR(self, path):
  if path:
   FFDDwF(CFG.iptvHostsDirs, FFA4GT(path.strip()))
   VVJwgn = self.VVN788()
   if VVJwgn : self.VVXgqK(VVJwgn)
   else  : FF8PJn(self, "Cannot add dir", 1500)
 def VVSE7k(self):
  lst = CFG.iptvHostsDirs.getValue().split(",")
  lst = list(set(list(map(str.strip, lst))))
  if len(lst) == 0 or len(lst[0]) == 0 or lst[0] == VV1rMY:
   return []
  return lst
 def VVN788(self):
  lst = self.VVSE7k()
  if lst:
   VVJwgn = []
   for Dir in lst:
    VVJwgn.append((Dir, "#f#0000ff00#Dir exists" if VVrRHR(Dir) else "#f#00ffa000#Not found"))
   VVJwgn.sort(key=lambda x: x[0].lower())
   return VVJwgn
  else:
   return []
 def VV600K(self, VV5ybN, title, txt, colList):
  sDir = parent = os.path.abspath(os.path.join(colList[0], os.pardir))
  self.session.openWithCallback(BF(self.VVOuKs, VV5ybN)
         , BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=sDir))
 def VVOuKs(self, VV5ybN, path):
  if path:
   path = FFA4GT(path.strip())
   if self.VV3Uuk(VV5ybN, path):
    FF8PJn(VV5ybN, "Already added", 1500)
   else:
    lst = self.VVSE7k()
    lst.append(path)
    FFDDwF(CFG.iptvHostsDirs, ",".join(lst))
    VVJwgn = self.VVN788()
    VV5ybN.VVxhz9(VVJwgn, VVK0Fc=BF(self.VVjIYh, path))
 def VVjIYh(self, path, VV5ybN, title, txt, colList):
  self.VV3Uuk(VV5ybN, path)
 def VV3Uuk(self, VV5ybN, path):
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   if row[0].strip() == path.strip():
    VV5ybN.VV43d2(ndx)
    return True
  return False
 def VVwOD9(self, VV5ybN, title, txt, colList):
  path = colList[0]
  FFHsPu(self, BF(self.VVDQCt, VV5ybN), "Remove this path from list?\n\n%s" % path, title="Remove path from list")
 def VVDQCt(self, VV5ybN):
  row = VV5ybN.VVqY3Q()
  path, rem = row[0], row[1]
  VVJwgn = []
  lst = []
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   tPath, tRem = row[0].strip(), row[1].strip()
   if not path == tPath:
    lst.append(tPath)
    VVJwgn.append((tPath, tRem))
  if len(VVJwgn) > 0:
   FFDDwF(CFG.iptvHostsDirs, ",".join(lst))
   VV5ybN.VVxhz9(VVJwgn)
   FF8PJn(VV5ybN, "Deleted", 1500)
  else:
   FFDDwF(CFG.iptvHostsMode, VV1rMY)
   FFDDwF(CFG.iptvHostsDirs, "")
   VV5ybN.cancel()
   FFDiNL(BF(FF8PJn, self, "Changed to Auto-Find", 1500))
 def VVBxt3(self, configObj):
  sDir = configObj.getValue()
  self.session.openWithCallback(BF(self.VVg0UI, configObj)
         , BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=sDir))
 def VVg0UI(self, configObj, path):
  if len(path) > 0:
   configObj.setValue(path)
 def VVasjx(self):
  for x in self["config"].list:
   if len(x) == 2 and FF0kJX(x[1]):
    FFHsPu(self, self.VVsxbF, "Save Changes ?", callBack_No=self.cancel, title=self.Title)
    break
  else:
   self.cancel()
 def VVsxbF(self):
  for x in self["config"].list:
   if len(x) == 2 and FF0kJX(x[1]):
    x[1].save()
  self.VV5Bm7()
  self.close()
 def cancel(self):
  for x in self["config"].list:
   try:
    x[1].cancel()
   except:
    pass
  self.close()
 def VVZ8QZ(self):
  c1, c2, c3 = VVcahY, VVnQYw, VV6UAe
  VVXXzc = []
  VVXXzc.append(("Change Text Color Scheme (fix Transparent Text)", "changeColorScheme" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c1 + "Reset %s Settings" % VVryLp, "VVcBvQ"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Backup %s Settings" % VVryLp , "VVOt7m"))
  VVXXzc.append((c2 + "Restore %s Settings" % VVryLp, "VVmXwf"))
  VVXXzc.append(VVzg1X)
  if CFG.checkForUpdateAtStartup.getValue() : txt, ref = "Disable", "disableChkUpdate"
  else          : txt, ref = "Enable", "enableChkUpdate"
  VVXXzc.append((c3 + '%s Checking for Update' % txt, ref    ))
  VVXXzc.append((c3 + "Reinstall %s" % VVryLp , "VV7hI0" ))
  VVXXzc.append((c3 + "Update %s" % VVryLp  , "VVrdIB"  ))
  FFw2XU(self, self.VVLwAz, VVXXzc=VVXXzc, title="Config. Options")
 def VVLwAz(self, item=None):
  if item:
   title = "%s Settings" % VVryLp
   if  item == "changeColorScheme": self.session.open(CCWKcF)
   elif item == "VVcBvQ"  : FFHsPu(self, BF(self.VVcBvQ, True), "Clear all settings (including File Manager bookmarks) ?", title=title)
   elif item == "VVOt7m" : self.VVOt7m()
   elif item == "VVmXwf" : self.VVmXwf()
   elif item == "enableChkUpdate" : FFDDwF(CFG.checkForUpdateAtStartup, True)
   elif item == "disableChkUpdate" : FFDDwF(CFG.checkForUpdateAtStartup, False)
   elif item == "VV7hI0" : self.VVxz4h(True )
   elif item == "VVrdIB"  : self.VVxz4h(False)
 def VVOt7m(self):
  path = "%sajpanel_settings_%s" % (FFmAG5(), FF6eWd())
  FF6BfM("grep .%s. %s > %s" % (VVryLp, VVrRe3, path))
  FFSQn9(self, "Saved to file:\n\n%s" % path, title="Export %s Settings" % VVryLp)
 @FFHF2S("Searching for Settings ...")
 def VVmXwf(self):
  title = "Import %s Settings" % VVryLp
  name  = "ajpanel_settings_"
  files = FFunRV("find / %s -iname '%s*' | grep %s" % (FFoSAW(1), name, name))
  if files:
   err = CCQdsv.VVbsXD(files)
   if err:
    FFHsPu(self, BF(self.VVx2tI, title), "No valid settings files found !\n\nLocate Manually ?", title=title)
   else:
    try:
     files = sorted(files, key=lambda t: -os.stat(t).st_mtime)
    except Exception as e:
     FFU9uk(self, "Error:\n\n%s" % str(e), title=title)
     return
    VVXXzc = []
    for line in files:
     VVXXzc.append((line, line))
    FFw2XU(self, BF(self.VVNx9q, title), title=title, VVXXzc=VVXXzc, width=1200, VVhuPZ="")
  else:
   FFU9uk(self, "No settings files found !", title=title)
 def VVx2tI(self, title, path=None):
  sDir = "/"
  for path in (FFmAG5(), "/media/usb/", "/media/hdd/", "/media/"):
   if VVrRHR(path):
    sDir = path
    break
  self.session.openWithCallback(BF(self.VVNx9q, title), BF(CCQdsv, VVmysg="ajpSet", VV82pi=sDir))
 def VVNx9q(self, title, path=None):
  if path:
   if VVrRHR(path):
    lines  = FF2iRW(path)
    self.VVcBvQ()
    for line in lines:
     name, _, val = line.partition("=")
     try:
      confItem = eval(name)
      if confItem is not None:
       if   isinstance(confItem, ConfigInteger)  : val = int(val)
       elif isinstance(confItem, ConfigSelectionNumber): val = int(val)
       elif isinstance(confItem, ConfigYesNo)   : val = { "true": True, "false": False }.get(val.lower())
       if not val is None:
        confItem.setValue(val)
        confItem.save()
     except:
      pass
    FFH0EA(self)
    self.VV5Bm7()
    FFar20(self, "Done", 1500)
   else:
    FFbHk5(self, path, title=title)
 def VVcBvQ(self, exit=False):
  for (key, cfg) in CFG.content.items.items():
   cfg.setValue(cfg.default)
  for x in self["config"].list:
   try:
    x[1].save()
   except:
    pass
  FFH0EA()
  self.VV5Bm7()
  if exit:
   self.close()
 def VV5Bm7(self):
  configfile.save()
  self.VVLOLP(CFG.showInExtensionMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EXTENSIONSMENU), [FFmiJ9(), FFexgg(), FFCzIT(), FFazVz(), FF0Vk6(), FFn1lr(), FFBYWY(), FFOjLJ()])
  self.VVLOLP(CFG.EventsInfoMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EVENTINFO), [ FFA4vG() ])
 @staticmethod
 def VVLOLP(setVal, pluginList, dList):
  try:
   if setVal:
    for item in dList:
     if not item in pluginList:
      iPlugins.addPlugin(item)
   else:
    for item in dList:
     if item in pluginList:
      iPlugins.removePlugin(item)
  except:
   pass
  FFq7xa()
 @FFHF2S("Checking Server ...")
 def VVxz4h(self, force):
  title = "%s %s (from server)" % ("Reinstall" if force else "Update", VVryLp)
  curVer, webVer, url, isHigher, err = CC8MwG.VVkG4j()
  if   err    : FFU9uk(self, err, title)
  elif isHigher or force : FFHsPu(self, BF(self.VV5rqa, webVer, url, title, force), "%s v%s and Restart ?" % ("Reinstall" if force else "Upgrade to", webVer), title=title)
  else     : FFSQn9(self, FFITtK("No update required.", VV8QGw) + "\n\nCurrent Version = v%s\n\nWeb Version = v%s" % (curVer, webVer), title)
 @FFHF2S()
 def VV5rqa(self, webVer, url, title, force):
  fName = "enigma2-plugin-extensions-ajpanel_v%s_all_no_restart.%s" % (webVer, "deb" if FFujkg() else "ipk")
  path, err = FFEyUQ(url + fName, fName, timeout=2)
  if path:
   if force: cmd = FFiD2M(VVV8Uu, path)
   else : cmd = FFiD2M(VVEY1Y, path)
   if cmd:
    cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'; rm -rf '%s'" % (cmd, path)
    FFNQkI(self, cmd, title=title, VVjgsF=self.VVjLed)
   else:
    FFD8hf(self, title=title)
  else:
   FFU9uk(self, err, title=title)
 def VVjLed(self, consObj):
  txt = "SUCCESSFUL"
  if txt in consObj.VVNVuC():
   FFRo1g(consObj)
   consObj.VVXVnQ(consObj.VVNVuC().replace(txt, FFITtK(txt, VV8QGw)))
   FF8PJn(consObj, "Restarting ...")
   FFUttZ(self, 3000, BF(CCNqUU.VVtJwR, self))
 @staticmethod
 def VVkG4j():
  url = CC8MwG.VVMfkC()
  curVer = VVsBow
  path, err = FFEyUQ(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFf0vs(path):
   return curVer, "", url, False, "Cannot get version file from server."
  else:
   webVer = FF05rJ(path)
   FFqlCI(path)
   cVer, wVer, isHigher = CCJFyo.VVhhmr(curVer, webVer)
   return cVer, wVer, url, isHigher, ""
 @staticmethod
 def VVQInW(): return "https://github.com/AMAJamry/AJPanel"
 @staticmethod
 def VVMfkC(): return "https://raw.githubusercontent.com/AMAJamry/AJPanel/main/"
class CCWKcF(Screen):
 def __init__(self, session):
  self.skin, self.VVuaAL = FFJH4U(VVU3Ky, 1200, 620, 50, 20, 0, "#22002020", "#22001122", 30)
  self.cursorPos = VV1DPb
  self.Title  = "Select Color Scheme (for areas with mixed-color text)"
  self.session = session
  FFfmZP(self, title=self.Title)
  sp = "    "
  self["myColorF"] = Label()
  for i in range(4):
   txt = "\n"
   txt += self.VVxRgG(r"\c00FFFFFF", i) + sp + "WHITE\n"
   txt += self.VVxRgG(r"\c00888888", i) + sp + "GREY\n"
   txt += self.VVxRgG(r"\c005A5A5A", i) + sp + "DARK GREY\n"
   txt += self.VVxRgG(r"\c00FF0000", i) + sp + "RED\n"
   txt += self.VVxRgG(r"\c00FF5000", i) + sp + "ORANGE\n"
   txt += self.VVxRgG(r"\c00FFFF00", i) + sp + "YELLOW\n"
   txt += self.VVxRgG(r"\c00FFFFAA", i) + sp + "B. YELLOW\n"
   txt += self.VVxRgG(r"\c0000FF00", i) + sp + "GREEN\n"
   txt += self.VVxRgG(r"\c000066FF", i) + sp + "BLUE\n"
   txt += self.VVxRgG(r"\c0000FFFF", i) + sp + "CYAN\n"
   txt += self.VVxRgG(r"\c00FA55E7", i) + sp + "PURPLE\n"
   txt += self.VVxRgG(r"\c00FF8F5F", i) + sp + "PEACH\n"
   self["myColor%s" % i] = Label(txt)
  FFewq4(self,
  {
   "ok" : self.VVTOku ,
   "green" : self.VVTOku ,
   "left" : self.VVT8GX ,
   "right" : self.VVMljc ,
   "cancel": self.close
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.VVUhAs()
 def VVTOku(self):
  if self.cursorPos == 0 : txt = "No Colors"
  else     : txt = "Color Scheme-%d" % self.cursorPos
  FFHsPu(self, self.VVAOCV, "Change to : %s" % txt, title=self.Title)
 def VVAOCV(self):
  FFDDwF(CFG.mixedColorScheme, self.cursorPos)
  global VV1DPb
  VV1DPb = self.cursorPos
  self.VVnPnw()
  self.close()
 def VVT8GX(self):
  self.cursorPos -= 1
  if self.cursorPos < 0:
   self.cursorPos = 3
  self.VVUhAs()
 def VVMljc(self):
  self.cursorPos += 1
  if self.cursorPos > 3:
   self.cursorPos = 0
  self.VVUhAs()
 def VVUhAs(self):
  left = []
  for i in range(4):
   left.append(self["myColor%s" % i].getPosition()[0])
  left = left[self.cursorPos] - 4
  top = self["myColor0"].getPosition()[1] - 4
  self.cursorPos
  self["myColorF"].instance.move(ePoint(left, top))
 @staticmethod
 def VVxRgG(color, mode):
  if   mode == 1 : return color
  elif mode == 2 : return color.replace("A", "9").replace("B", "9").replace("C", "9").replace("D", "9").replace("E", "9").replace("F", "9")
  elif mode == 3 : return color.replace("A", ":").replace("B", ";").replace("C", "<").replace("D", "=").replace("E", ">").replace("F", "?")
  else   : return ""
 @staticmethod
 def VVmivZ(color):
  if VVaR8d: return "\\" + color
  else    : return ""
 @staticmethod
 def VVnPnw():
  global VVgzFX, VVVAvR, VVsm0W, VVu50a, VVcahY, VVCBkQ, VV6uFd, VVeG3E, VV8QGw, VVnQYw, VVaR8d, VV6UAe, VVi4ay, VVkLs0, VVUPyu, VVHFlX
  VVHFlX   = CCWKcF.VVxRgG(r"\c00FFFFFF", VV1DPb)
  VVVAvR    = CCWKcF.VVxRgG(r"\c00888888", VV1DPb)
  VVgzFX  = CCWKcF.VVxRgG(r"\c005A5A5A", VV1DPb)
  VVeG3E    = CCWKcF.VVxRgG(r"\c00FF0000", VV1DPb)
  VVsm0W   = CCWKcF.VVxRgG(r"\c00FF5000", VV1DPb)
  VVu50a   = CCWKcF.VVxRgG(r"\c00FFBB66", VV1DPb)
  VVaR8d   = CCWKcF.VVxRgG(r"\c00FFFF00", VV1DPb)
  VV6UAe = CCWKcF.VVxRgG(r"\c00FFFFAA", VV1DPb)
  VV8QGw   = CCWKcF.VVxRgG(r"\c0000FF00", VV1DPb)
  VVnQYw  = CCWKcF.VVxRgG(r"\c00AAFFAA", VV1DPb)
  VV6uFd    = CCWKcF.VVxRgG(r"\c000066FF", VV1DPb)
  VVi4ay    = CCWKcF.VVxRgG(r"\c0000FFFF", VV1DPb)
  VVkLs0  = CCWKcF.VVxRgG(r"\c00AAFFFF", VV1DPb)  #
  VVUPyu   = CCWKcF.VVxRgG(r"\c00FA55E7", VV1DPb)
  VVcahY    = CCWKcF.VVxRgG(r"\c00FF8F5F", VV1DPb)
  VVCBkQ  = CCWKcF.VVxRgG(r"\c00FFC0C0", VV1DPb)
CCWKcF.VVnPnw()
class CC41Tt():
 VVKWuU  = "666"
 VVe1BZ   = "888"
 def __init__(self, SELF, VVvGQw, title, VVFhtD, VVJ2id=""):
  self.SELF     = SELF
  self.VVvGQw   = VVvGQw
  self.Title     = title
  self.VVFhtD   = VVFhtD
  self.VVJ2id    = VVJ2id
  self.VVZzW8   = None
  self.VVONnI()
 def VVONnI(self):
  VVXXzc = CC41Tt.VV5FZT()
  bNames = [x[0] for x in VVXXzc if len(x) == 2]
  if VVXXzc:
   VVI6TY = ("Create New", BF(self.VVxdiY, bNames))
   self.VVZzW8 = FFw2XU(self.SELF, self.VVfiJA, VVXXzc=VVXXzc, title=self.Title, VVI6TY=VVI6TY, VVfP2Q=True, VVVzvS="#22222233", VVhHWW="#22222233")
  else:
   self.VVxdiY("")
 def VVfiJA(self, item):
  if item:
   bName, bRef, ndx = item
   self.VVvZXM(bName, bRef)
  else:
   CC41Tt.VVKroi(self)
 def VVxdiY(self, bNames, selectionObj=None, item=None):
  name = self.VVJ2id
  if not name:
   name = "Bouquet1"
   c = 1
   while name in bNames:
    c += 1
    name = "Bouquet%s" % c
  FFttdT(self.SELF, BF(self.VVY55S), defaultText=name, title="Create New Bouquet", message="Enter Bouquet Name:")
 def VVY55S(self, bName):
  if bName:
   bName = bName.strip()
   if bName:
    if self.VVZzW8:
     self.VVZzW8.cancel()
    self.VVvZXM(bName, "")
   else:
    FF8PJn(self.VVZzW8, "Incorrect Bouquet Name !", 2000)
    CC41Tt.VVKroi(self)
 def VVvZXM(self, bName, bRef):
  FFTSvN(self.VVvGQw, BF(self.VVTrbA, bName, bRef), title="Adding Services ...")
 def VVTrbA(self, bName, bRef):
  CC41Tt.VVsLIN(self.SELF, self.Title, bName, bRef, self.VVFhtD())
 @staticmethod
 def VVKroi(classObj):
  del classObj
 @staticmethod
 def VVsLIN(SELF, title, bName, bRef, servRefLst, showRes=True):
  if not servRefLst:
   FFU9uk(SELF, "No services to add !", title=title)
   return
  tvBouquetFile = VVHX6T + "bouquets.tv"
  if not FFf0vs(tvBouquetFile):
   FFbHk5(SELF, tvBouquetFile, title=title)
   return
  if bRef:
   bFile = CC41Tt.VV790N(bRef)
   bPath = VVHX6T + bFile
  else:
   fName = CCSB3R.VVG2ts(bName)
   bFile = "userbouquet.%s.tv" % fName
   bPath = VVHX6T + bFile
   num   = 0
   while FFf0vs(bPath):
    num += 1
    bFile = "userbouquet.%s_%d.tv" % (fName, num)
    bPath = VVHX6T + bFile
   with open(bPath, "w") as f:
    f.write("#NAME %s\n" % bName)
  FFxGSn(bPath)
  with open(bPath, "a") as f:
   for chUrl in servRefLst:
    serv = eServiceReference(chUrl)
    VVeZBd = serv and serv.getName() or ""
    try:
     VVeZBd = VVeZBd.encode("UTF-8", "replace").decode()
    except:
     VVeZBd = FFJQht(VVeZBd, r"?")
    f.write("#SERVICE %s\n"  % chUrl)
    f.write("#DESCRIPTION %s\n" % VVeZBd)
  if not bRef and FFf0vs(bPath):
   FFxGSn(tvBouquetFile)
   with open(tvBouquetFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
  totPicons = 0
  piconPath = CCUNc6.VVQ490()
  for chUrl in servRefLst:
   span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", chUrl.rstrip(":"))
   if span:
    serv = eServiceReference(chUrl)
    if serv:
     picon = piconPath + span.group(1).strip(":").replace(":", "_").upper() + ".png"
     fPath = serv.getPath()
     fNameNoExt = os.path.splitext(serv.getPath())[0]
     for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
      poster = "%s.%s" % (fNameNoExt, ext)
      if FFf0vs(poster):
       totPicons += 1
       FF6usE("cp -f '%s' '%s'" % (poster, picon))
       FF6usE(CCISy5.VVomfz(picon))
       break
  FFfve1()
  if showRes:
   txt  = "Bouquet Name\t\t: %s\n"  % bName
   txt += "Added Services\t\t: %d\n" % len(servRefLst)
   if totPicons:
    txt += "Added PIcons\t\t: %s" % totPicons
   FFyijw(SELF, txt, title=title)
 @staticmethod
 def VViR6s(bName):
  mode = CC5Hkx.VVPzfc(default=-1)
  modeTxt = "tv" if mode == 0 else "radio"
  fName = CCSB3R.VVG2ts(bName)
  bFile = "userbouquet.%s.%s" % (fName, modeTxt)
  num   = 0
  while FFf0vs(VVHX6T + bFile):
   num += 1
   bFile = "userbouquet.%s_%d.%s" % (fName, num, modeTxt)
  with open(VVHX6T + bFile, "w") as f:
   f.write("#NAME %s\n" % bName)
  mainBFile = "%sbouquets.%s" % (VVHX6T, modeTxt)
  if FFf0vs(mainBFile):
   FFxGSn(mainBFile)
   with open(mainBFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
 @staticmethod
 def VVUDZY(ref, bName):
  bFile = CC41Tt.VV790N(ref)
  ok = False
  if bFile:
   bFile = VVHX6T + bFile
   if FFf0vs(bFile):
    lines = FF2iRW(bFile, keepends=True)
    with open(bFile, "w") as f:
     for line in lines:
      if line.startswith("#NAME "):
       f.write("#NAME %s\n" % bName)
       ok = True
      else:
       f.write(line)
  return ok
 @staticmethod
 def VV5FZT(mode=2, showTitle=True, prefix="", onlyIptv=False):
  VVXXzc = []
  if mode in (0, 2): VVXXzc.extend(CC41Tt.VVjd1x(0, showTitle, prefix, onlyIptv))
  if mode in (1, 2): VVXXzc.extend(CC41Tt.VVjd1x(1, showTitle, prefix, onlyIptv))
  return VVXXzc
 @staticmethod
 def VVjd1x(mode, showTitle, prefix, onlyIptv):
  VVXXzc = []
  lst = CC41Tt.VVJ3UY(mode)
  if onlyIptv:
   lst = CC41Tt.VVZtST(lst)
  if lst:
   if showTitle:
    VVXXzc.append(FFAiun("TV Bouquets" if mode == 0 else "Radio Bouquets"))
   if prefix:
    for item in lst : VVXXzc.append((item[0], prefix + item[0]))
   else:
    for item in lst : VVXXzc.append((item[0], item[1].toString()))
  return VVXXzc
 @staticmethod
 def VVZtST(lst):
  fLst = CCSB3R.VVt2XK(onlyFileName=True)
  newLst = []
  if fLst:
   for item in lst:
    span = iSearch(r".+(userbouquet\..+\.(tv|radio))", item[1].toString())
    if span and span.group(1) in fLst:
     newLst.append(item)
  return newLst
 @staticmethod
 def VVSXbP():
  lst = CC41Tt.VVJ3UY(0)
  lst.extend(CC41Tt.VVJ3UY(1))
  return lst
 @staticmethod
 def VVJ3UY(mode=0):
  bList = []
  VVI3vF = InfoBar.instance
  VVokbs = VVI3vF and VVI3vF.servicelist
  if VVokbs:
   curMode = VVokbs.mode
   CC41Tt.VVcLKN(VVokbs, mode)
   bList.extend(VVokbs.getBouquetList() or [])
   CC41Tt.VVcLKN(VVokbs, curMode)
  return bList
 @staticmethod
 def VVcLKN(VVokbs, mode):
  if not mode == VVokbs.mode:
   if   mode == 0: VVokbs.setModeTv()
   elif mode == 1: VVokbs.setModeRadio()
 @staticmethod
 def VVuaoj(isAll=True, onlyMain=False):
  bLst = []
  inst = InfoBar.instance
  if inst:
   csel = inst.servicelist
   if csel:
    root = csel.bouquet_root
    VVTQSe = eServiceCenter.getInstance()
    if onlyMain:
     info = VVTQSe.info(root)
     if info:
      bLst.append((info.getName(root), root.toString()))
    else:
     list = VVTQSe and VVTQSe.list(root)
     if list:
      while True:
       s = list.getNext()
       if not s.valid():
        break
       if isAll or (s.flags & eServiceReference.isDirectory and not s.flags & eServiceReference.isInvisible):
        info = VVTQSe.info(s)
        if info:
         bLst.append((info.getName(s), s.toString()))
  return bLst
 @staticmethod
 def VVyuHO():
  lst = []
  types = ('*.*.tv', '*.*.radio')
  for f in types:
   lst.extend(iGlob(VVHX6T + f))
  return lst
 @staticmethod
 def VV790N(bRef):
  span = iSearch(r'BOUQUET\s+"(.+)"\s+ORDER', bRef, IGNORECASE)
  if span : return span.group(1)
  else : return ""
 @staticmethod
 def VVe71H(ref, dstFile):
  dstFile = VVHX6T + dstFile
  if FFf0vs(dstFile):
   FFxGSn(dstFile)
   bLine = ""
   VVePgW = CC41Tt.VV790N(ref)
   if VVePgW:
    span = iSearch(r"\.(.+)\.(tv|radio)", VVePgW, IGNORECASE)
    if span:
     fName, fType = span.group(1), span.group(2)
     newName = "userSubBouquet.%s.%s" % (fName, fType)
     num = 0
     while FFf0vs(VVHX6T + newName):
      num += 1
      newName = "userSubBouquet.%s_%d.%s" % (fName, num, fType)
     subFile = VVHX6T + newName
     FF6usE("cp -f '%s%s' '%s'" % (VVHX6T, VVePgW, subFile))
     if FFf0vs(subFile):
      bLine = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % newName
   else:
    bLine = ref
   if bLine:
    if FFf0vs(dstFile):
     with open(dstFile, "a") as f:
      f.write("#SERVICE %s\n" % bLine)
     return True
  return False
 @staticmethod
 def VVUMaM():
  try:
   fName = CC41Tt.VV790N(InfoBar.instance.servicelist.getRoot().toString())
   path = "%s%s" % (VVHX6T, fName)
   if FFf0vs(path):
    return path
  except:
   pass
  return ""
 @staticmethod
 def VVkU5R():
  path = CC41Tt.VVUMaM()
  if path:
   txt = FF05rJ(path, maxSize=300)
   span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
   if span:
    return span.group(1).strip()
  return ""
 @staticmethod
 def VVSaEJ(mode=0):
  return FFaKV3(InfoBar.instance.servicelist.getRoot(), mode)
 @staticmethod
 def VVXlbB():
  lst = []
  for b in CC41Tt.VVSXbP():
   bName = b[0]
   bRef  = b[1].toString()
   path = VVHX6T + CC41Tt.VV790N(bRef)
   if FFf0vs(path):
    lines = FF2iRW(path)
    for line in lines:
     if line.startswith("#SERVICE"):
      if not line.startswith("#SERVICE 1:64:"):
       break
    else:
     if not "userbouquet.favourites." in bRef:
      lst.append((bName, bRef))
  return lst
 @staticmethod
 def VVGICV(SID, stripRType):
  if stripRType: return r"(?:[A-Fa-f0-9]+:)((?:[A-Fa-f0-9]+:){2}%s:(?:[A-Fa-f0-9]+:){6})" % SID
  else   : return r"((?:[A-Fa-f0-9]+:){3}%s:(?:[A-Fa-f0-9]+:){6})" % SID
 @staticmethod
 def VVqvMw(SID="", stripRType=False):
  if SID : patt = CC41Tt.VVGICV(SID, stripRType)
  else : patt = r"((?:[A-Fa-f0-9]+:){10})"
  lst = []
  for b in CC41Tt.VVSXbP():
   for service in FFaKV3(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper())
  return lst
 @staticmethod
 def VVH0nc():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CC41Tt.VVSXbP():
   for service in FFaKV3(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper().rstrip(":"))
  return lst
 @staticmethod
 def VV57Su():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CC41Tt.VVSXbP():
   for service in FFaKV3(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append((span.group(1).upper().rstrip(":"), service[1]))
  return lst
 @staticmethod
 def VV36AT(rType, SID, refLst, startId, startNS):
  for Id in range(max(6, startId), 65535):
   hexId = ("%1x" % Id).upper()
   for NS in range(startNS, 65535):
    hexNS = ("FFF%04x" % NS).upper()
    tRef = "0:1:%s:%s:%s:%s:0:0:0:" % (SID, hexId, hexId, hexNS)
    if not tRef in refLst:
     VVDhju = "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, hexId, hexId, hexNS)
     if NS < 65535 - 1: NS += 1
     else    : NS, Id = 6, Id + 1
     return VVDhju, Id, NS
  return "", 0, 0
 @staticmethod
 def VVONdL(pathLst, rType=""):
  refLst = CC41Tt.VVqvMw(CC41Tt.VVKWuU, stripRType=True)
  chUrlLst = []
  startId  = startNS = 0
  rType  = rType or CFG.iptvAddToBouquetRefType.getValue()
  for path in pathLst:
   VVDhju, startId, startNS = CC41Tt.VV36AT(rType, CC41Tt.VVKWuU, refLst, startId, startNS)
   if VVDhju:
    VVeZBd = os.path.splitext(os.path.basename(path))[0].replace("-", " ").replace("_", " ").replace(".", " ")
    chUrl = "%s%s:%s" % (VVDhju, path, VVeZBd)
    chUrlLst.append(chUrl)
   else:
    break
  return chUrlLst
class CCQdsv(Screen, CC8eoU):
 VVp4lf   = 0
 VV6W2c  = 1
 VVx2Yd  = 2
 VVwHJr = 3
 VVIaIN  = 4
 VVpg5v    = 20
 VVyXMk   = 0
 VVj20W   = 1
 VVWJe7   = 2
 def __init__(self, session, VV82pi="/", mode=VVp4lf, VVa5ZQ="Select", width=1400, height=920, VV1Wwb=30, VVVzvS="#22001111", VVhHWW="#22000000", pickTitleBG="#11001144", pickBodyBG="#08002244", VVlIBH="#06004444", VVhacs=False, VVbQPh="", VVmysg="", VVrlSM=False):
  self.skin, self.VVuaAL = FFJH4U(VVkmr2, width, height, 30, 40, 20, VVVzvS, VVhHWW, VV1Wwb, VVZ3ZU=40, VV1fgG=2, VVFHRx=(0, 0))
  self.session   = session
  self.VVVzvS   = VVVzvS
  self.VVhHWW    = VVhHWW
  self.pickTitleBG  = pickTitleBG
  self.pickBodyBG   = pickBodyBG
  FFfmZP(self)
  FFrvOP(self["keyRed"] , "Exit")
  FFrvOP(self["keyYellow"], "More Options")
  FFrvOP(self["keyBlue"] , "Bookmarks")
  CC8eoU.__init__(self, gapX=10, gapY=10)
  self.VVZKXw  = 1000
  self.mode    = mode
  self.VVa5ZQ = VVa5ZQ
  self.VVbQPh   = VVbQPh
  self.VVmysg  = VVmysg
  self.VVhacs   = VVhacs
  self.VVNZEl  = None
  self.VV2DUW   = 300
  self.VVlIBH   = VVlIBH
  self.VVseaV = False
  self.VVrlSM   = VVrlSM
  self.lastViewedPic  = ""
  VVtfG7 = None
  if VVmysg:
   self.mode = self.VVwHJr
   if   VVmysg == "srt"  : VVtfG7 = (r"^.*\.srt$"    , IGNORECASE)
   elif VVmysg == "ajpSet" : VVtfG7 = (r"^.*\/ajpanel_settings_" , 0    )
   elif VVmysg == "poster" : VVtfG7 = (r"^.*\.(jpg|png)$"    , IGNORECASE)
   elif VVmysg == "pkgCtrl": VVtfG7 = (r"^.*\/(control|preinst|prerm|postinst|postrm)$", 0)
   elif VVmysg == "movies" : VVtfG7 = (r"^.*\.(%s)$" % "|".join(CCf9Gq.VVl1a5()["mov"]), IGNORECASE)
   elif VVmysg == "custMnu": VVtfG7 = (r"^.*\/ajpanel_menu.*\.xml$", 0)
   else       : VVtfG7 = None
  if self.VViKGa():
   FFrvOP(self["keyRed"], "Cancel")
  if   self.VVbQPh       : VV0LyP, self.VV82pi = True , FF5AKn(self.VVbQPh, True) or "/"
  elif self.VVhacs        : VV0LyP, self.VV82pi = True , CCQdsv.VVZTzJ(self)[1] or "/"
  elif self.mode == self.VVp4lf  : VV0LyP, self.VV82pi = True , CFG.browserStartPath.getValue()
  elif self.mode == self.VVx2Yd : VV0LyP, self.VV82pi = False, VV82pi
  elif self.mode == self.VVwHJr : VV0LyP, self.VV82pi = True , VV82pi
  elif self.mode == self.VVIaIN : VV0LyP, self.VV82pi = True , VV82pi
  else           : VV0LyP, self.VV82pi = True , VV82pi
  self.VV82pi = FFA4GT(self.VV82pi)
  self["myMenu"] = CCf9Gq(  directory   = None
         , VVtfG7 = VVtfG7
         , VV0LyP   = VV0LyP
         , VVSHAH = True
         , enableWrapAround = True
         , VVVJxU   = self.VVuaAL["width"]
         , VV1Wwb   = self.VVuaAL["VVdJm7"]
         , VVwOMI  = self.VVuaAL["bodyLineH"] )
  FFewq4(self,
  {
   "ok"  : self.VVTOku    ,
   "red"  : self.VVDzHw   ,
   "green"  : self.VViss4  ,
   "yellow" : self.VVNbgT  ,
   "blue"  : self.VVpdl9 ,
   "menu"  : self.VVQfAf  ,
   "info"  : self.VVbp3I  ,
   "cancel" : self.VVWTkJ    ,
   "fav"  : self.VVMahB,
   "back"  : self.VVNHwB   ,
   "pageUp" : self.VVNHwB   ,
   "chanUp" : self.VVNHwB   ,
   "pageDown" : self.VVyBTy  ,
   "chanDown" : self.VVyBTy  ,
   "last"  : self.VVx7VB   ,
   "next"  : self.VVU4Vz
  })
  CCBUJe(self, self["myMenu"])
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVGJGY)
  global VV1Tjj
  VV1Tjj = True
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.mode == self.VVp4lf:
   FFdsOh("VV1Tjj")
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  self.onShown.append(self.VVGJGY)
  FF1uow(self)
  FFTDN6(self["myMenu"], bg=self.VVlIBH)
  FFE1T7(self)
  self.VVZKXw = self["keyInfo"].getPosition()[0] - 40
  if self.VViKGa():
   FFrvOP(self["keyGreen"], self.VVa5ZQ)
   self.VVf5kT(self.VVj20W)
  self.VVGJGY()
  w  = self["myMenu"].instance.size().width()
  h  = self["myMenu"].instance.size().height()
  pos  = self["myMenu"].getPosition()
  part = self["myMenu"].instance.size().height() % self.VVuaAL["bodyLineH"]
  half = int(part / 2)
  self["myMenu"].instance.resize(eSize(*(w, h - part)))
  self["myMenu"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.VVdGlA(self.VV82pi) > self.VV2DUW: FFTSvN(self, self.VVCFaG, title="Changing directory...")
  else              : self.VVCFaG()
 def VVCFaG(self):
  if self.VVbQPh : self.VVIyiO(FFA4GT(self.VVbQPh) if os.path.isdir(self.VVbQPh) else self.VVbQPh)
  elif self.VVhacs : self.VVJrtu(chDir=False)
  else    : self["myMenu"].VV1nvG(self.VV82pi)
 def VViKGa(self):
  return self.mode in (self.VVx2Yd, self.VVwHJr, self.VVIaIN)
 def VV43d2(self, rowNdx):
  self["myMenu"].moveToIndex(rowNdx)
 @FFHF2S("Refreshing list ...")
 def VVCIQw(self, moveTo=""):
  isSel = self["myMenu"].VVJIvj()
  if not isSel: self.VVoNbM(False)
  if moveTo: self.VVJ88V(moveTo)
  FFq7xa()
 def VVy20q(self, saved):
  if saved: self.VVCIQw()
 def VVdGlA(self, path):
  try:
   return len(os.listdir(path))
  except:
   return 0
 def VVTOku(self, isUp=False):
  if self.VVseaV:
   if self.mode == self.VVwHJr and os.path.isdir(self.VVGyXn(self.VVP5Fg())):
    FF8PJn(self, "Files only", 500)
   elif self["myMenu"].VVp8N4(isUp):
    self.VVEXRU()
   else:
    FF8PJn(self, "Cannot select item", 500)
  elif self["myMenu"].VVYfQe(): self.VVjriu()
  else       : self.VVIMxk()
 def VVNHwB(self):
  if self.VVseaV:
   self.VVTOku(isUp=True)
  else:
   self["myMenu"].moveToIndex(0)
   if self["myMenu"].VVubA7():
    self.VVjriu()
 def VVyBTy(self):
  if self.VVseaV:
   self.VVTOku(isUp=False)
  elif self["myMenu"].VVYfQe() and self["myMenu"].getSelectionIndex() > 0:
   self.VVjriu()
 def VVx7VB(self) : self["myMenu"].moveToIndex(0)
 def VVU4Vz(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVjriu(self, isDirUp=False):
  if self["myMenu"].VVYfQe():
   if not self["myMenu"].getSelection() is None: path = self["myMenu"].getSelection()[0]
   else          : path = self.VVGyXn(self.VVP5Fg())
   if self.VVdGlA(path) > self.VV2DUW : FFTSvN(self, self.VV5V0q, title="Changing directory...")
   else           : self.VV5V0q()
 def VV5V0q(self):
  self["myMenu"].descent()
  self.VVGJGY()
 def VVWTkJ(self):
  if   self.VVseaV     : self.VVoNbM(False, True)
  elif CFG.FileManagerExit.getValue() == "e" : self.VVDzHw()
  else          : self.VVNHwB()
 def VVDzHw(self):
  if FF5gvI(self): reutrn
  if VVT6xx:
   FFRo1g(self)
   FFk1YE(self, "Closing ...")
   FFUttZ(self, 1000, self.close)
  else:
   self.close("")
 def VVmbTD(self):
  FFpIdO(self, "_help_fman", "File Manager (Keys)")
 def VViss4(self):
  if self["keyGreen"].getVisible():
   if self.VVrlSM and self.VVseaV:
    lst = []
    path = self["myMenu"].VV0whq()
    for row in self["myMenu"].list:
     if row[2][6]:
      lst.append(os.path.join(path, row[0][0]))
    if lst : self.close(lst)
    else : FF8PJn(self, "Nothing selected", 500)
   else:
    path = self.VVGyXn(self.VVP5Fg())
    isDir = os.path.isdir(path)
    chkFile = False
    if   self.mode == self.VVx2Yd : self.close(path)
    elif self.mode == self.VVwHJr : chkFile = True
    elif self.mode == self.VVIaIN :
     if isDir: self.close(path)
     else : chkFile = True
    if chkFile:
     if os.path.isfile(path) : self.close(path)
     else     : FF8PJn(self, "Cannot access this file", 1000)
 @FFHF2S("Calculating size ...")
 def VVbp3I(self):
  path = self.VVGyXn(self.VVP5Fg())
  param = self.VVBCXe(path)
  if not param:
   FFU9uk(self, "Cannot access information !")
   return
  def VV2MoW(key, val, color=""):
   lineTxt = "%s\t: %s\n" % (key, str(val))
   return FFITtK(lineTxt, color) if color else lineTxt
  c1, c2, c3, c4, c5 = VVCBkQ, VV6UAe, VVnQYw, VVHFlX, VVkLs0
  path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles = param
  mnt_fs = mnt_typ = ""
  contents = totSize = usedSize = freeSize = availSize = ""
  if typeChar == "d":
   exclude = r"-type d \( -ipath '/media' -o -ipath '/mnt' -o -ipath '*boot*' -o -ipath '*/ba' \) -prune -o"
   result = FFhWCj("totDirs=$(find '%s' %s -type d -print | wc -l); totFiles=$(find '%s' %s ! -type d | wc -l); echo $totDirs','$totFiles" % (path, exclude, path, exclude))
   if iMatch("^[0-9]*,[0-9]*", result):
    parts = result.split(",")
    contents += VV2MoW("Directories" , format(int(parts[0]), ',d'), c4)
    contents += VV2MoW("Files"   , format(int(parts[1]), ',d'), c4)
   if os.path.ismount(path):
    inf = CCQdsv.VVZksK().get(FFA4GT(os.path.realpath(path)), "")
    if inf:
     mnt_fs, mnt_typ, isNet = inf
    typeStr += " (Mount)"
    total, used, free, avail, err = CCQdsv.VV87Qo(path)
    totSize, usedSize, freeSize, availSize = [CCQdsv.VVAcha(x) for x in (total, used, free, avail)]
   else:
    usedSize = CCQdsv.VVAcha(FFT3Nn(path))
  else:
   usedSize = CCQdsv.VVAcha(size)
  if len(path) < 58 : pathTxt = path
  else    : pathTxt = "\n" + path
  pathTxt = pathTxt+ "\n"
  if slBroken : fileTime = self.VVTiww(path)
  else  : fileTime = self.VVOAm8(path)
  txt = ""
  txt += VV2MoW("Path"    , pathTxt, c1)
  txt += VV2MoW("Type"    , typeStr, c2)
  if mnt_fs and mnt_typ:
   txt += VV2MoW("Files System" , mnt_fs, c2)
   txt += VV2MoW("VFS Type"  , mnt_typ, c2)
  if len(slTarget) > 0:
   txt += VV2MoW("Target"   , slTarget)
  if os.path.ismount(path):
   txt += VV2MoW("Total Size"  , "%s" % totSize, c3)
   txt += VV2MoW("Used Size"  , "%s" % usedSize, c3)
   txt += VV2MoW("Free Size"  , "%s" % freeSize, c3)
   if free != avail: txt += VV2MoW("Available Size" , "%s" % availSize, c3)
  else:
   txt += VV2MoW("Size"   , "%s" % usedSize, c3)
  txt += contents
  txt += "\n"
  txt += VV2MoW("Owner"    , owner, c5)
  txt += VV2MoW("Group"    , group, c5)
  txt += VV2MoW("Perm. (User)"  , permUser, c5)
  txt += VV2MoW("Perm. (Group)"  , permGroup, c5)
  txt += VV2MoW("Perm. (Other)"  , permOther, c5)
  if len(permExtra) > 0:
   txt += VV2MoW("Perm. (Ext.)" , permExtra)
  txt += "\n"
  txt += VV2MoW("iNode"    , iNode)
  txt += VV2MoW("Hard Links"   , hLinks)
  txt += fileTime
  if hLinkedFiles:
   txt += "\n%s\nHard Linked Files (files with same iNode)\n%s\n" % (SEP, SEP)
   txt += hLinkedFiles
  txt += self.VVCZOy(path)
  txt += CCHa3c.VVbBnJ(path)
  FFyijw(self, txt, height=1000, titleBg="#22001010", VVpaQ6="#11000a1a")
 def VVBCXe(self, path):
  path = path.strip()
  path = FFHP0y(path)
  result = FFhWCj("FILE='%s'; BROKEN=$(if [ ! -e \"$FILE\" ]; then echo 'yes'; else echo 'no'; fi); LINE=$(ls -lid \"$FILE\" 2> /dev/null); PARAM=$(echo $LINE | awk '{print $1\",\"$2\",\"$3\",\"$4\",\"$5\",\"$6}'); SLINK=$(echo $LINE | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=\"\";print}'  | sed 's/ -> /,/g' | xargs); echo $PARAM','$BROKEN','$SLINK" % path)
  parts = result.split(",")
  if not all(parts):
   return None
  if len(parts) > 7:
   iNode  = parts[0]
   perm  = parts[1]
   hLinks  = parts[2]
   owner  = parts[3]
   group  = parts[4]
   size  = parts[5]
   slBroken = parts[6]
   fName  = parts[7]
   slTarget = ""
   if len(parts) > 8:
    slTarget = parts[8]
   size = int(size)
   def VVIQpk(perm, start, end):
    val = perm[start : end]
    p  = { "---": "0" , "--x": "1" , "-w-": "2" , "-wx": "3" , "r--": "4" , "r-x": "5" , "rw-": "6" , "rwx": "7" , "+": "ACL" }
    if val in p : return "%s\t%s" % (val, p[val])
    else  : return val
   permUser = VVIQpk(perm, 1, 4)
   permGroup = VVIQpk(perm, 4, 7)
   permOther = VVIQpk(perm, 7, 10)
   permExtra = VVIQpk(perm, 10, 100)
   typeChar = perm[0:1]
   typeStr = {"-":"File", "b":"Block Device File", "c":"Character Device File", "d":"Directory", "e":"External Link", "l":"Symbolic Link", "n":"Network File", "p":"Named Pipe", "s":"Local Socket File"}.get(typeChar, "Unknown")
   if "yes" in slBroken:
    slBroken = True
    typeStr  = "Broken Symlink (target not found)"
   else:
    slBroken = False
   hLinkedFiles = ""
   if typeChar != "d" and int(hLinks) > 1:
    hLinkedFiles = FFdV6p("find / %s -inum %s -print0 2> /dev/null | xargs -0 ls -i 2> /dev/null | grep %s | awk '{$1=\"\"; print $0}' | awk '{$1=$1};1'" % (FFoSAW(0, ["/dev", "/hdd", "/newroot", "/sys/class"]), iNode, iNode))
   return path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles
  else:
   return None
 def VVCZOy(self, path):
  txt  = ""
  res  = FFhWCj("lsattr -d %s" % path)
  span = iSearch(r"([acdeijstuACDST-]{13})\s", res, IGNORECASE)
  if span:
   res = span.group(1)
   tDict = {"a": "Append only", "c": "Compressed", "d": "No dump", "e": "Extent format", "i": "Immutable", "j": "Data journalling", "s": "Secure deletion (s)", "t": "Tail-merging", "u": "Undeletable", "A": "No atime updates", "C": "No copy on write", "D": "Synchronous directory updates", "S": "Synchronous updates", "T": "Top of directory hierarchy", "h": "Huge file", "E": "Compression error", "I": "Indexed directory", "X": "Compression raw access", "Z": "Compressed dirty file"}
   lst = []
   for key, val in tDict.items():
    if key in res:
     lst.append("%s  ( %s )\n" % (val, key))
   if lst:
    lst.sort()
    for item in lst:
     txt += "    %s" % item
    txt = "\n%s\n%s" % (FFITtK("File Attributes:", VVUPyu), txt)
  return txt
 def VVOAm8(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FFMYsv(os.path.getatime(path))
  txt += "Modified time\t: %s\n" % FFMYsv(os.path.getmtime(path))
  txt += "Change time\t: %s\n" % FFMYsv(os.path.getctime(path))
  return txt
 def VVTiww(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FFhWCj("stat -c %%x '%s'" % path).replace(".000000000", "")
  txt += "Modified time\t: %s\n" % FFhWCj("stat -c %%y '%s'" % path).replace(".000000000", "")
  txt += "Change time\t: %s\n" % FFhWCj("stat -c %%z '%s'" % path).replace(".000000000", "")
  return txt
 def VVGyXn(self, currentSel):
  currentDir  = self["myMenu"].VV0whq()
  if currentDir is None:
   path = currentSel
  elif currentSel is None:
   path = currentDir
  else:
   if currentSel == "/":
    path = currentDir
   else:
    if not self["myMenu"].VVYfQe():
     path = currentDir + currentSel
    else:
     if len(currentDir) > len(currentSel):
      path = currentDir
     else:
      path = currentSel
  return str(path)
 def VVTAnu(self):
  return self["myMenu"].VV0whq() or self.VVGyXn(self.VVP5Fg())
 def VVP5Fg(self):
  sel = self["myMenu"].getSelection()
  if sel : return sel[0]
  else : return None
 def VVGJGY(self):
  path = self.VVGyXn(self.VVP5Fg())
  self["myTitle"].setText("  " + path)
  if self["myTitle"].instance:
   textW = self["myTitle"].instance.calculateSize().width()
   if textW > self.VVZKXw:
    length = len(path)
    tmpPath = path[4:]
    for i in range(length, 40, -1):
     self["myTitle"].setText("  .." + tmpPath)
     textW = self["myTitle"].instance.calculateSize().width()
     if textW > self.VVZKXw: tmpPath = tmpPath[1:]
     else       : break
  self.VVAFvb()
  if self.mode == self.VVp4lf:
   if len(path) > 0: self["keyMenu"].show()
   else   : self["keyMenu"].hide()
  self["keyGreen"].hide()
  if self.VViKGa():
   if self.VVseaV:
    if self["myMenu"].VVID8N() > 0:
     self["keyGreen"].show()
   else:
    if self.mode == self.VVwHJr:
     if os.path.isfile(path):
      self["keyGreen"].show()
    else:
     self["keyGreen"].show()
  FFUttZ(self, 30, self.VV8iwL)
 def VV8iwL(self):
  path = self.VVGyXn(self.VVP5Fg())
  if path != self.lastViewedPic:
   self.VVpLGs(path)
   self.lastViewedPic = path
 def VVQfAf(self):
  c1, c2, c3 = VVCBkQ, VV6UAe, VVkLs0
  totSel = 0
  menuW = 1000
  title = "Options"
  VVXXzc= []
  path = self.VVGyXn(self.VVP5Fg())
  isLink = os.path.islink(path)
  if self.VVseaV:
   menuW = 850
   totSel = self["myMenu"].VVID8N()
   if totSel > 0:
    if iTar:
     txt1 = "Archive to .tar.gz"
     txt2 = " (Preserve Path Structure)"
     title = "Options  (%d item%s)" % (totSel, FFEnJs(totSel))
     VVXXzc.append((c1 + txt1      , "VVilYz1"  ))
     VVXXzc.append((c1 + txt1 + txt2    , "VVilYz2"  ))
     VVXXzc.append(VVzg1X)
    VVXXzc.append(("[6] Copy"       , "copyFileOrDir" ))
    VVXXzc.append(("[7] Move"       , "moveFileOrDir" ))
    VVXXzc.append(("[8] %sDELETE" % VVcahY , "VVpJ1E"  ))
   else:
    FF8PJn(self, "Nothing selected", 700)
    return
  elif self.VViKGa():
   VVXXzc.append(("Properties", "properties" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c3 + "Create New Directory (in current directory)" , "createNewDir"))
  else:
   menuW = 1050
   path  = self.VVGyXn(self.VVP5Fg())
   isEditable = self["myMenu"].VVN01h()
   if not FFaW27(path):
    FFU9uk(self, "Cannot access this object.")
    return
   VVXXzc.append(("Properties", "properties"))
   if os.path.isdir(path):
    addSep = True
    if FF5AKn(path, True) in (VVSaol, VVBSnt):
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c1 + "Show Related Package", "VVaT6M"))
     addSep = False
    if isEditable:
     if addSep:
      VVXXzc.append(VVzg1X)
     VVXXzc.append((c1 + "Archive/Package Tools", "VVjakx_dir"))
     addSep = False
   elif os.path.isfile(path):
    selFile = self.VVP5Fg()
    isArch = selFile.endswith((".tar", ".gz", ".tar.bz2", "tar.xz", "tar.zst", ".zip", ".rar", ".7z"))
    if not isArch:
     VVXXzc.append((c1 + "Archive ...", "VVjakx_file"))
    isText = False
    txt = ""
    if isArch:
     VVXXzc.extend(self.VVd15B(path, True))
    elif selFile.endswith((".ipk", ".deb")) :
     txt = "Package Tools"
    elif selFile.endswith((".m3u", ".m3u8")):
     VVXXzc.extend(self.VVGrS5(True))
    elif selFile.endswith((".sh", ".py", ".pyo", ".pyc")):
     VVXXzc.extend(self.VVQOq2(path, True))
     isText = selFile.endswith((".sh", ".py"))
    elif selFile.endswith(".svg"):
     pass
    elif not isLink and selFile.endswith(".tif"):
     VVXXzc.append((c2 + "Save as ...", "VV3YvW"))
    elif not isLink and self["myMenu"].VVl2HO(path) == "pic":
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c2 + "Set as PIcon (for current channel)", "VVlvYP" ))
     path = self.VVGyXn(self.VVP5Fg())
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c2 + "Rotate Image", "VV31UW"   ))
     VVXXzc.append((c2 + "Flip Image" , "VV6sCd"   ))
     VVXXzc.append((c2 + "Save as ..." , "VV3YvW" ))
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c2 + "Convert to Base64 String", "VV8JgI" ))
     if FFsGnd("ffmpeg") and selFile.lower().endswith((".jpg", ".png")):
      VVXXzc.append((c2 + "Convert to MVI (1280 x 720 )", "VV28dhHd" ))
      VVXXzc.append((c2 + "Convert to MVI (1920 x 1080)", "VV28dhFhd" ))
    elif selFile.endswith((".py", ".xml", ".txt", ".htm", ".html", ".cfg", ".conf")) or not CCQdsv.VVAAgR(path):
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c2 + "View"     , "textView_def"))
     VVXXzc.append((c2 + "View (Select Encoder)" , "textView_enc"))
     VVXXzc.append((c2 + "Edit"     , "text_Edit" ))
     isText = True
    elif selFile.endswith(CCQdsv.VVrKp4(addDot=True)):
     if selFile.endswith(".mvi"):
      if FFsGnd("showiframe"):
       VVXXzc.append(VVzg1X)
       VVXXzc.append((c2 + "View as Bootlogo (will interrupt the playing service)", "viewAsBootlogo"))
      if FFsGnd("ffmpeg"):
       VVXXzc.append((c2 + "Convert to jpg", "mv2jpg"))
       VVXXzc.append((c2 + "Convert to png", "mv2png"))
     else:
      VVXXzc.append(VVzg1X)
      VVXXzc.append((c2 + "Add Media File to a Bouquet"    , "VVgzsG0" ))
      VVXXzc.append((c2 + "Add all Media in Directory to a Bouquet" , "VVgzsG1" ))
      VVXXzc.append((c2 + "Play with ..."       , "playWith"    ))
    if isText:
     VVXXzc.append((c1 + "Save as UTF-8 ..."      , "textSave_encUtf8"))
     VVXXzc.append((c1 + "Save as other Encoding ..."    , "textSave_encOthr"))
     VVXXzc.append((c1 + "Convert Line-Breaks to Unix Format..." , "VVdKJv" ))
    if len(txt) > 0:
     VVXXzc.append(VVzg1X)
     VVXXzc.append((c1 + txt, "VVIMxk"))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("[4] Create SymLink", "VVTYgZ"))
   if isEditable:
    VVXXzc.append(("[5] Rename"      , "VVCPYT" ))
    VVXXzc.append(("[6] Copy"       , "copyFileOrDir" ))
    VVXXzc.append(("[7] Move"       , "moveFileOrDir" ))
    VVXXzc.append(("[8] %sDELETE" % VVcahY , "VVKuqZ" ))
    if FFf0vs(path):
     VVXXzc.append(VVzg1X)
     perm = oct(os.stat(path).st_mode)[-3:]
     if   perm == "644" : show644, show755, show777 = False, True , True
     elif perm == "755" : show644, show755, show777 = True , False , True
     elif perm == "777" : show644, show755, show777 = True , True , False
     else    : show644, show755, show777 = True , True , True
     chmodTxt = "Change Permissions (from %s to " % perm
     if show644 : VVXXzc.append((chmodTxt + "644)", "chmod644"))
     if show755 : VVXXzc.append((chmodTxt + "755)", "chmod755"))
     if show777 : VVXXzc.append((chmodTxt + "777)", "chmod777"))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c3 + "Create New File (in current directory)"  , "createNewFile"))
   VVXXzc.append((c3 + "Create New Directory (in current directory)" , "createNewDir" ))
   fPath, fDir, fName = CCQdsv.VVZTzJ(self)
   if fPath:
    VVXXzc.append(VVzg1X)
    VVXXzc.append((c2 + "Go to Current Movie Dir", "VVJrtu"))
  FFw2XU(self, self.VV1U3o, width=menuW, height=1050, title=title, VVXXzc=VVXXzc, VVO8hC=0.01, VVbCII=False, VVVzvS="#00101020", VVhHWW="#00101A2A")
 def VV1U3o(self, item=None):
  if item is not None:
   path = self.VVGyXn(self.VVP5Fg())
   if   item == "VVilYz1"    : self.VVilYz(False)
   elif item == "VVilYz2"    : self.VVilYz(True)
   elif item == "copyFileOrDir"   : self.VVJliF(False)
   elif item == "moveFileOrDir"   : self.VVJliF(True)
   elif item == "VVpJ1E"    : self.VVpJ1E()
   elif item == "properties"    : self.VVbp3I()
   elif item == "VVaT6M"  : self.VVaT6M(path)
   elif item == "VVjakx_dir" : self.VVjakx(path, True)
   elif item == "VVjakx_file" : self.VVjakx(path, False)
   elif item == "VVzPa5"  : self.VVzPa5(path)
   elif item == "VVVlxY"  : self.VVVlxY(path)
   elif item == "2gz"       : self.VVIEo3(path, "gz")
   elif item == "2xz"       : self.VVIEo3(path, "xz")
   elif item.startswith("extract_")  : self.VVikx4(path, item)
   elif item.startswith("script_")   : self.VVEE5x(path, item)
   elif item.startswith("m3u_")   : self.VVvDJG(path, item)
   elif item.startswith("textView_def") : FFGPHz(self, path)
   elif item.startswith("textView_enc") : self.VVQmKn(path)
   elif item.startswith("text_Edit")  : CCAvJY(self, path, VVuQkS=self.VVy20q)
   elif item.startswith("textSave_encUtf8"): self.VVQRcc(path, "Save as UTF-8"   , True)
   elif item.startswith("textSave_encOthr"): self.VVQRcc(path, "Save as Other Encoding", False)
   elif item.startswith("VVdKJv") : self.VVdKJv(path)
   elif item == "viewAsBootlogo"   : self.VVi9xV(path, True)
   elif item == "mv2jpg"     : self.VVUm3x(path, 0)
   elif item == "mv2png"     : self.VVUm3x(path, 1)
   elif item == "VVgzsG0" : self.VVgzsG(path, False)
   elif item == "VVgzsG1" : self.VVgzsG(path, True)
   elif item == "playWith"     : self.VVk3N9(path)
   elif item == "VVlvYP" : self.VVlvYP(path)
   elif item == "VV31UW"   : self.VV31UW(path)
   elif item == "VV6sCd"    : self.VV6sCd(path)
   elif item == "VV3YvW" : self.VV3YvW(path)
   elif item == "VV28dhHd"   : self.VV28dh(path, False)
   elif item == "VV28dhFhd"   : self.VV28dh(path, True)
   elif item == "VV8JgI"   : self.VV8JgI(path)
   elif item == "VVTYgZ"   : self.VVTYgZ(path)
   elif item == "VVCPYT"   : self.VVCPYT(path)
   elif item == "VVKuqZ"   : self.VVKuqZ(path)
   elif item == "chmod644"     : self.VV26G8(path, "644")
   elif item == "chmod755"     : self.VV26G8(path, "755")
   elif item == "chmod777"     : self.VV26G8(path, "777")
   elif item == "createNewFile"   : self.VVx3r4(path, True)
   elif item == "createNewDir"    : self.VVx3r4(path, False)
   elif item == "VVJrtu"   : self.VVJrtu()
   elif item == "VVIMxk"    : self.VVIMxk()
 def VVIMxk(self):
  if self.mode == self.VVwHJr and not self.VVmysg == "poster":
   return
  path = self.VVGyXn(self.VVP5Fg())
  if os.path.isfile(path):
   cat = self["myMenu"].VVl2HO(path)
   if   cat == "pic"        : self.VVgaya(path)
   elif cat == "txt"        : FFGPHz(self, path)
   elif cat == "m3u"        : self.VVrMoO(path)
   elif cat in ("scr", "py")      : self.VVxo8v(path)
   elif cat in ("tar", "rar", "zip", "p7z", "zst") : self.VV9j22(path)
   elif cat in ("ipk", "deb")      : self.VVB7dL(path)
   elif cat in ("mov", "mus")      : self.VVi9xV(path)
   elif not CCQdsv.VVAAgR(path)  : FFGPHz(self, path)
 @FFHF2S()
 def VVgaya(self, path):
  VVlBZZ = 0
  curFile = os.path.basename(path)
  lst = []
  for ndx, item in enumerate(self["myMenu"].list):
   if not item[0][1]:
    category = self["myMenu"].VVl2HO(item[1][7])
    if category == "pic":
     if curFile == item[1][7]:
      VVlBZZ = len(lst)
     lst.append((ndx, item[1][7]))
  CCC0Lg.VVESKQ(self, path, fileList=lst, VVlBZZ=VVlBZZ, cbFnc=self.VVRgTg)
 def VVRgTg(self, path, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVi9xV(self, path, asLogo=False):
  if asLogo : CC9AHO.VVumyd(self, path)
  else  : FFTSvN(self, BF(self.VVMj5s, self, path), title="Playing Media ...")
 def VVpdl9(self):
  if self["keyBlue"].getVisible():
   VV5dDF = self.VVmzFr()
   if VV5dDF:
    path = self.VVGyXn(self.VVP5Fg())
    enableGreenBtn = False if path in self.VVmzFr() else True
    newList = []
    for line in VV5dDF:
     newList.append((line, line))
    VVSuW0  = ("Delete"    , self.VVmsvC    )
    VVBztL  = ("Add Current Dir"   , BF(self.VVNXBc, path) ) if enableGreenBtn else None
    VVI6TY = ("Move Up"     , self.VVJ0zt    )
    VViDZz  = ("Move Down"   , self.VV0cWr    )
    self.VVNZEl = FFw2XU(self, self.VVt4lX, width=1200, title="Bookmarks", VVXXzc=newList, VVnojT=10 ,VVSuW0=VVSuW0, VVBztL=VVBztL, VVI6TY=VVI6TY, VViDZz=VViDZz, VVVzvS="#00000022", VVhHWW="#00000022")
 def VVmsvC(self, VVZzW8=None, path=None):
  VV5dDF = self.VVmzFr()
  if VV5dDF:
   while path in VV5dDF:
    VV5dDF.remove(path)
   self.VVnXM6(VV5dDF)
  if self.VVNZEl:
   self.VVNZEl.VVEs8Z(VV5dDF)
   self.VVNZEl.VVmx1U(("Add Current Dir", BF(self.VVNXBc, path)))
  else:
   FF8PJn(self, "Removed", 800)
  self.VVAFvb()
 def VVNXBc(self, path, VVZzW8=None, item=None):
  VV5dDF = self.VVmzFr()
  if len(VV5dDF) >= self.VVpg5v:
   FFU9uk(SELF, "Max bookmarks reached (max=%d)." % self.VVpg5v)
  elif not path in VV5dDF:
   if not os.path.isdir(path):
    path = FF5AKn(path, True)
   newList = [path] + VV5dDF
   self.VVnXM6(newList)
   if self.VVNZEl:
    self.VVNZEl.VVEs8Z(newList)
    self.VVNZEl.VVmx1U()
   else:
    FF8PJn(self, "Added", 800)
  self.VVAFvb()
 def VVJ0zt(self, selectionObj, path):
  if self.VVNZEl:
   VV5dDF = self.VVNZEl.VVhydo(True)
   if VV5dDF:
    self.VVnXM6(VV5dDF)
 def VV0cWr(self, selectionObj, path):
  if self.VVNZEl:
   VV5dDF = self.VVNZEl.VVhydo(False)
   if VV5dDF:
    self.VVnXM6(VV5dDF)
 def VVt4lX(self, path=None):
  if path:
   path = FFA4GT(path)
   self.VV2lJl(path)
  self.VVGJGY()
 @FFHF2S("Changing directory ...")
 def VV2lJl(self, path):
  self["myMenu"].VV1nvG(path)
  self["myMenu"].moveToIndex(0)
 def VVmzFr(self):
  line = CFG.browserBookmarks.getValue().strip()
  while " ," in line : line.replace(" ,", ",")
  while ", " in line : line.replace(", ", ",")
  if   "," in line : return line.split(",")
  elif len(line) > 0 : return [line]
  else    : return []
 def VV4PzD(self):
  return True if VVmzFr() else False
 def VVnXM6(self, VV5dDF):
  line = ",".join(VV5dDF)
  FFDDwF(CFG.browserBookmarks, line)
 def VVIyiO(self, path):
  if FFf0vs(path):
   fDir  = FFA4GT(os.path.dirname(path))
   if fDir:
    self["myMenu"].VV1nvG(fDir)
   fName = os.path.basename(path)
   for ndx, item in enumerate(self["myMenu"].list):
    if fName == item[0][0]:
     self["myMenu"].moveToIndex(ndx)
     break
  else:
   FF8PJn(self, "Not found", 1000)
 def VVJ88V(self, moveTo):
  for ndx, item in enumerate(self["myMenu"].list):
   if moveTo == item[0][0]:
    self["myMenu"].moveToIndex(ndx)
    break
 def VVJrtu(self, chDir=True):
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  self.VVIyiO(fPath)
 def VVNbgT(self):
  path = self.VVGyXn(self.VVP5Fg())
  isAdd = False if path in self.VVmzFr() else True
  dirTxt = "Selected" if os.path.isdir(path) else "Current"
  c1, c2, c3 = VVi4ay, VVnQYw, VV6UAe
  VVXXzc = []
  VVXXzc.append(("Find Files ..." , "find"))
  VVXXzc.append(("Sort ..."   , "sort"))
  VVXXzc.append(VVzg1X)
  if isAdd: VVXXzc.append((c1 + "Add %s Dir to Bookmarks"  % dirTxt, "addBM"))
  else : VVXXzc.append((c1 + "Remove %s Dir from Bookmarks" % dirTxt, "remBM"))
  VVXXzc.append(    (c2 + 'Set %s Dir as "Startup Dir"' % dirTxt, "start"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Keys (Shortcuts)", "help"))
  if self.mode == self.VVp4lf or self.VVrlSM:
   VVXXzc.append(VVzg1X)
   if self.VVseaV: VVXXzc.append( (c3 + "Disable Multi-Select ", "multiOff"))
   else     : VVXXzc.append( (c3 + "Enable Multi-Select"  , "multiOn" ))
   VVXXzc.append(       (c3 + "Select all"    , "selAll"  ))
  FFw2XU(self, BF(self.VVKaUu, path), width=750, title="More Options", VVXXzc=VVXXzc, VVVzvS="#00221111", VVhHWW="#00221111")
 def VVKaUu(self, path, item):
  if item:
   if   item == "find"  : self.VVku4S(path)
   elif item == "sort"  : self.VVYgFL()
   elif item == "addBM" : self.VVNXBc(path)
   elif item == "remBM" : self.VVmsvC(None, path)
   elif item == "help"  : self.VVmbTD()
   elif item == "start" : self.VVZltg(path)
   elif item == "multiOn" : self.VVoNbM(True)
   elif item == "multiOff" : self.VVoNbM(False)
   elif item == "selAll" : self.VVoNbM(True, True)
 def VVoNbM(self, isOn, isAll=False):
  self.VVseaV = isOn
  if isAll or not isOn:
   FFTSvN(self, BF(self["myMenu"].VVCB7n, isOn, self.mode, cbFnc=self.VVEXRU), title="Selecting ..." if isOn else "Unselecting ...")
  if isOn      : color = self.VVWJe7
  elif self.VViKGa() : color = self.VVj20W
  else      : color = self.VVyXMk
  self.VVf5kT(color)
  self.VVGJGY()
 def VVEXRU(self):
  self["keyBlue"].setText(self.VVZOWb())
 def VVf5kT(self, mode=0):
  if   mode == self.VVj20W : titBg, bodBg = self.pickTitleBG, self.pickBodyBG
  elif mode == self.VVWJe7: titBg, bodBg = "#01883366", "#11002233"
  else        : titBg, bodBg = self.VVVzvS, self.VVhHWW
  FFu0W6(self["myTitle"], titBg)
  FFu0W6(self["myBar"], titBg)
  FFu0W6(self["myBody"], bodBg)
  FFu0W6(self["myMenu"], bodBg)
  if self.VVseaV: bg, txt = "#01883366", self.VVZOWb()
  else     : bg, txt = VVrew6[3], "Bookmarks"
  FFrvOP(self["keyBlue"], txt)
  FFu0W6(self["keyBlue"], bg)
  self.VVAFvb()
 def VVZOWb(self):
  return "Selected Items = %d" % self["myMenu"].VVID8N()
 def VVAFvb(self):
  if self.VVmzFr() or self.VVseaV: self["keyBlue"].show()
  else            : self["keyBlue"].hide()
 def VVku4S(self, path):
  VVXXzc = []
  VVXXzc.append(("Find in Current Directory"    , "findCur"  ))
  VVXXzc.append(("Find in Current Directory (recursive)" , "findCurR" ))
  VVXXzc.append(("Find in all Storage Systems"    , "findAll"  ))
  FFw2XU(self, BF(self.VVl604, path), width=700, title="Find File/Pattern", VVXXzc=VVXXzc, VVfP2Q=True, VVL6LA=True, VVVzvS="#00221111", VVhHWW="#00221111")
 def VVl604(self, path, item):
  if item:
   title, item, ndx = item
   if   item == "findCur" : self.VV2L2h(0, path, title)
   elif item == "findCurR" : self.VV2L2h(1, path, title)
   elif item == "findAll" : self.VV2L2h(2, path, title)
 def VV2L2h(self, mode, path, title):
  if CFG.lastFileManFindPatt.getValue(): txt = CFG.lastFileManFindPatt.getValue()
  else         : txt = "*.ipk"
  FFttdT(self, BF(self.VVSjlK, mode, path, title), defaultText=txt, title=title, message="Enter Name/Pattern:")
 def VVSjlK(self, mode, path, title, filePatt):
  if filePatt is not None:
   filePatt = filePatt.strip()
   FFDDwF(CFG.lastFileManFindPatt, filePatt)
   badLst = filePatt.replace(" ", "") in ("*.*", "*.", ".*")
   if not filePatt : FF8PJn(self, "No entery", 1500)
   elif badLst  : FF8PJn(self, "Too many file !", 1500)
   else   : self.VVq7V9(mode, path, title, filePatt)
 @FFHF2S("Searching ...")
 def VVq7V9(self, mode, path, title, filePatt):
  lst = FF2gLS("find '%s' %s -type f -iname '%s' %s -print 2> /dev/null" % ("/" if mode==2 else path, FFoSAW(0), filePatt, "-maxdepth 1" if mode == 0 else ""))
  if lst:
   err = CCQdsv.VVbsXD(lst)
   if err:
    FFU9uk(self, err)
   else:
    for ndx, path in enumerate(lst):
     lst[ndx] = (os.path.basename(path), os.path.dirname(path))
    lst.sort(key=lambda x: x[0].lower())
    header = ("File", "Directory" )
    widths = (50 , 50   )
    VV4dTm = (""     , self.VV6VQq , [])
    VV5CrJ = ("Go to File Location", self.VV45Bz  , [])
    FFdCaM(self, None, title="%s : %s" % (title, filePatt), header=header, VV5dDF=lst, VV1PTZ=widths, VV1Wwb=26, VV4dTm=VV4dTm, VV5CrJ=VV5CrJ)
  else:
   FFk1YE(self, "Not found !", 2000)
 def VV45Bz(self, VV5ybN, title, txt, colList):
  path = os.path.join(colList[1], colList[0])
  if FFf0vs(path):
   VV5ybN.cancel()
   self.VVIyiO(path)
  else:
   FF8PJn(VV5ybN, "Path not found !", 1000)
 def VV6VQq(self, VV5ybN, title, txt, colList):
  txt = "%s\n%s\n\n" % (FFITtK("File:"  , VV6UAe), colList[0])
  txt += "%s\n%s"  % (FFITtK("Directory:", VV6UAe), FFA4GT(colList[1]))
  FFyijw(VV5ybN, txt, title=title)
 def VVYgFL(self):
  nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVhPzE()
  VVXXzc = []
  VVXXzc.append(("Name\t%s" % nameAlpTxt, "nameAlp"))
  VVXXzc.append(("Name\t%s" % nameNumTxt, "nameNum"))
  VVXXzc.append(("Date\t%s" % dateTxt, "dateAlp"))
  VVXXzc.append(("Type\t%s" % typeTxt, "typeAlp"))
  VViDZz = ("Mix", BF(self.VVtugS, True))
  FFw2XU(self, BF(self.VVif5I, False), VVcIOx=txt, width=650, title="Sort Options", VVXXzc=VVXXzc, VViDZz=VViDZz, VVL6LA=True, VVVzvS="#00221111", VVhHWW="#00221111")
 def VVtugS(self, isMix, VVZzW8, item):
  self.VVif5I(True, item)
 def VVif5I(self, isMix, item):
  if item:
   nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVhPzE()
   if   item == "nameAlp": mode, isNum =  nameAlpMode, False
   elif item == "nameNum": mode, isNum =  nameNumMode, True
   elif item == "dateAlp": mode, isNum =  dateMode , False
   elif item == "typeAlp": mode, isNum =  typeMode , False
   else      : return
   FFTSvN(self, BF(self["myMenu"].VVF6Qs, mode, isMix, isNum), title="Sorting ... ")
 def VVMahB(self):
  path = self.VVGyXn(self.VVP5Fg())
  self.VVZltg(path)
 def VVZltg(self, path):
  if not os.path.isdir(path):
   path = FF5AKn(path, True)
  FFDDwF(CFG.browserStartPath, path)
  FFar20(self, "Saved as Startup", 1500)
 def VVd15B(self, path, calledFromMenu):
  color = VV6UAe if calledFromMenu else ""
  VVXXzc = []
  if path.endswith(".gz") and not path.endswith(".tar.gz") or path.endswith(".xz") and not path.endswith(".tar.xz"):
   VVXXzc.append((color + "Extract Here", "VVSNAm"))
  else:
   if path.endswith(".zst") and not FFsGnd("unzstd"):
    return []
   if calledFromMenu: VVXXzc.append(VVzg1X)
   VVXXzc.append((color + "List Archived Files", "extract_listFiles"))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((color + 'Extract to "%s"' % self.VVUpo9(os.path.basename(path)) , "extract_toDir"  ))
   VVXXzc.append((color + 'Extract to Root Directory "/"  (recommended for plugins)'  , "extract_toRoot"  ))
   VVXXzc.append((color + "Extract Here"             , "extract_here"  ))
   if iTar and iZip:
    if path.endswith(".zip"):
     if not calledFromMenu: VVXXzc.append(VVzg1X)
     VVXXzc.append((color + "Convert .zip to .tar.gz", "VVzPa5" ))
    elif path.endswith(".tar.gz"):
     if not calledFromMenu: VVXXzc.append(VVzg1X)
     VVXXzc.append((color + "Convert .tar.gz to .zip", "VVVlxY" ))
   if path.endswith((".tar.gz", ".tar.xz", ".tar.zst")):
    VVXXzc.append(VVzg1X)
    if   path.endswith(".gz"): VVXXzc.append((color + "Convert to .tar.xz", "2xz"))
    elif path.endswith(".xz"): VVXXzc.append((color + "Convert to .tar.gz", "2gz"))
    elif path.endswith(".zst"):
     cond = FFsGnd("zstd")
     VVXXzc.append(FFwjWO("Convert to .tar.gz", "2gz", cond, color))
     VVXXzc.append(FFwjWO("Convert to .tar.xz", "2xz", cond, color))
  return VVXXzc
 def VV9j22(self, path):
  title = "Archived File Options"
  VVXXzc = self.VVd15B(path, False)
  if VVXXzc : FFw2XU(self, BF(self.VVikx4, path), title=title, VVXXzc=VVXXzc, width=1050)
  else  : FFHsPu(self, BF(self.VVF0d9, self), 'Missing "zstd" package.\n\nInstall "zstd" ?')
 @staticmethod
 def VVF0d9(SELF):
  cmd = FFiD2M(VVUWS4, "zstd")
  if cmd : FFNQkI(SELF, cmd, title="Installing zstd")
  else : FFD8hf(SELF)
 def VVikx4(self, path, item=None):
  if item is not None:
   if   item == "VVSNAm"         : self.VVSNAm(item, path)
   elif item == "extract_listFiles"        : self.VVNEKt(path)
   elif item == "VVzPa5" and path.endswith(".zip")  : self.VVzPa5(path)
   elif item == "VVVlxY" and path.endswith(".tar.gz") : self.VVVlxY(path)
   elif item == "2gz"             : self.VVIEo3(path, "gz")
   elif item == "2xz"             : self.VVIEo3(path, "xz")
   elif path.endswith((".zip", ".rar", ".7z"))      : self.VV4jaH(item, path)
   else               : self.VVOYh8(item, path)
 def VVUpo9(self, path, addSep=False):
  for ext in (".tar.gz", ".tar.xz", ".tar.bz2", ".tar.zst"):
   if path.endswith(ext):
    print(len(ext))
    return path[:-len(ext)]
  return os.path.splitext(path)[0]
 def VVNEKt(self, path):
  ext = os.path.splitext(os.path.basename(path))[1]
  linux_sep = "echo -e %s;" % SEP
  if ext in (".zip", ".rar", ".7z"):
   if   ext == ".zip": mainC, totC, instC = "unzip -l", "tail -n 1 | awk '{ print $2 }'"     , FF3F9l("unzip", "unzip", "Unzip")
   elif ext == ".rar": mainC, totC, instC = "unrar l" , "tail -n 2 | grep -v \"^$\" | awk '{ print $2 }'" , FF3F9l("unrar", "unrar", "Unrar")
   elif ext == ".7z" : mainC, totC, instC = "7za l" , "tail -n 1 | awk '{ print $5 }'"     , FF3F9l("7za", "p7zip", "P7Zip")
   listC = "%s '%s'" % (mainC, path)
   tooMany = "Will only show first and last 100 files..."
   cmd  = linux_sep
   cmd += instC
   cmd += 'if [ "$allOK" -eq "1" ]; then '
   cmd += " TOTF=$(%s | %s);" % (listC, totC)
   cmd += " echo ''; echo 'Archived Files :'$TOTF;"
   cmd +=   linux_sep
   cmd += " if [ $TOTF -gt 300 ]; then"
   cmd += "  echo -e '%s' %s;"  % (tooMany, FF0VVA(tooMany, VVaR8d))
   cmd +=    linux_sep
   cmd += "  %s | head -n 100;" % listC
   cmd += "  echo ''; echo ' ... MANY LINES COME HERE ... '; echo '';"
   cmd += "  echo '';"
   cmd += "  %s | tail -n 100;" % listC
   cmd += " else"
   cmd += "  %s;" % listC
   cmd += " fi;"
   cmd += "fi;"
  else:
   cmd  = "echo -e 'Archive:\n%s\n\n';" % path
   cmd += "totFiles=$(tar -tf '%s' | wc -l);" % path
   cmd += "if (( $totFiles > 300 )); then moreInf='  ... Will list the first 300 only ...'; else moreInf=''; fi;"
   cmd += "echo -e '\n%s\n--- Contents (Total='$totFiles')'$moreInf'\n%s';" % (SEP, SEP)
   cmd += "tar -tf '%s' | head -n300;" % path
   cmd += "if (( $totFiles > 300 )); then echo '\n... Only the first 300 are listed ...'; fi;"
  cmd += "echo '';"
  cmd += linux_sep
  FF3BM3(self, cmd)
 @FFHF2S("Extracting ...")
 def VVSNAm(self, item, path):
  title = os.path.basename(path)
  res = FFhWCj("RES=$(%s -dk '%s') && echo ok || echo $RES" % ("gzip" if path.endswith("gz") else "xz", path))
  if res == "ok":
   FFSQn9(self, "Extracted File:\n\n%s" % path[:-3], title=title)
   self.VVCIQw()
  else:
   FFU9uk(self, "Error:\n\n%s" % res, title=title)
 def VVOYh8(self, item, path):
  fName = os.path.basename(path)
  lastP = FFVUvT(self.VVUpo9(path))
  parent = FF5AKn(path, False)
  if   item == "extract_toDir" : destP, txt = lastP , " to : %s" % lastP
  elif item == "extract_toRoot" : destP, txt = "/"  , ' to Root Directory ("/")'
  elif item == "extract_here"  : destP, txt = parent, " Here"
  else       : return
  FFHsPu(self, BF(self.VVkTsK, item, path, fName, lastP, parent, destP), "Extract %s ?" % txt, title="File : %s" % fName)
 def VVkTsK(self, item, path, fName, lastP, parent, destP):
  if item == "extract_toDir":
   cmd  = "cd '%s';" % parent
   cmd += FFDTPf("mkdir '%s'"   % lastP)
   cmd += 'if [ -d "%s" ]; then '  % lastP
   cmd += " tar -xf '%s' -C '%s';" % (path, lastP)
   cmd += "else"
   cmd += " echo -e 'Cannot create directory:\n%s';" % lastP
   cmd += "fi"
   destTxt = " : \n\n%s" % os.path.join(parent, destP)
  elif item == "extract_toRoot":
   cmd  = "cd '%s';" % parent
   cmd += "tar -C / -xf '%s'" % path
   destTxt = ' Root Directory ("/")'
  elif item == "extract_here":
   cmd  = "cd '%s';" % parent
   cmd += "tar -xf '%s'" % path
   destTxt = ": \n\n%s" % os.path.join(parent, destP)
  res = FFdV6p(cmd)
  if res : FFyijw(self, "Error while extracting:\n\n%s\n\n%s\n\nError:\n\n%s" % (fName, SEP, res), isErr=True)
  else : FFSQn9(self, "Successfully Extracted to%s" % destTxt, title=fName)
  self.VVCIQw()
 def VV4jaH(self, item, path):
  fName = os.path.basename(path)
  FFHsPu(self, BF(self.VV28Bk, item, path, fName), "Extract file ?\n\n%s" % fName)
 def VV28Bk(self, item, path, fName):
  parent  = FF5AKn(path, False)
  destPath = self.VVUpo9(path)
  archCmd  = ""
  if path.endswith(".zip"):
   cmd = FF3F9l("unzip", "unzip", "Unzip")
   if   item == "extract_toDir" : archCmd += " cd '%s'; [ ! -d '%s' ] && mkdir '%s';" % (parent,destPath, destPath)
   elif item == "extract_toRoot": destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unzip -o -q '%s' -d '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".rar"):
   cmd = FF3F9l("unrar", "unrar", "Unrar")
   if   item == "extract_toDir" : destPath = FFA4GT(destPath)
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unrar x -o+ '%s' '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".7z"):
   cmd = FF3F9l("7za", "p7zip", "P7Zip")
   if   item == "extract_toDir" : destPath = destPath
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += "7za x '%s' -o'%s' -y > /dev/null;" % (path, destPath)
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "echo '';"
  cmd += "echo 'Extracting content ...';"
  cmd +=   archCmd
  cmd += " echo -e 'Done.\n\nExtracted to:\n%s\n' %s;" % (destPath, FF0VVA(destPath, VV8QGw))
  cmd += "fi;"
  FFpL0U(self, cmd, VVUYyP=self.VVCIQw)
 def VVxo8v(self, path):
  FFw2XU(self, BF(self.VVEE5x, path), title="File Options", VVXXzc=self.VVQOq2(path))
 def VVQOq2(self, path, addSep=False):
  isText = path.endswith((".sh", ".py"))
  c1 = VV6UAe
  VVXXzc = []
  if addSep: VVXXzc.append(VVzg1X)
  if isText: VVXXzc.append((c1 + "View"  , "script_View"  ))
  VVXXzc.append((c1 + "Execute in Terminal" , "script_Execute" ))
  if isText: VVXXzc.append((c1 + "Edit"  , "script_Edit"  ))
  if VVpSLv:
   VVXXzc.append(VVzg1X)
   VVXXzc.append((VVsm0W + "Fix SH", "VVVgcL"))
  return VVXXzc
 def VVEE5x(self, path, item=None):
  if item is not None:
   if   item == "script_View"  : FFGPHz(self, path)
   elif item == "script_Execute" : FFHsPu(self, BF(FFTSvN, self, BF(self.session.openWithCallback, self.VVCIQw, CCz488, VVEkUN=path)), "Run File ?\n\n%s" % os.path.basename(path))
   elif item == "script_Edit"  : CCAvJY(self, path, VVuQkS=self.VVy20q)
   elif item == "VVVgcL"  : self.VVVgcL(path)
 def VVVgcL(self, path):
  txt = FF05rJ(path)
  var, ev, scr = txt.partition("eval")
  if ev:
   outF = path + "__.sh"
   var, scr = var.strip(), scr.strip()
   if FF6BfM("%s\necho -e %s > '%s'" % (var, scr, outF)):
    FFSQn9(self, "Saved to:\n\n%s" % outF)
    self.VVCIQw()
   else: FFU9uk(self, "Converstion Error")
  else: FFU9uk(self, "No Eval")
 def VVGrS5(self, addSep=False):
  VVXXzc = []
  if addSep:
   VVXXzc.append(VVzg1X)
  VVXXzc.append((VV6UAe + "Play / Browse Channels", "m3u_Browse" ))
  VVXXzc.append((VV6UAe + "Edit"     , "m3u_Edit" ))
  VVXXzc.append((VV6UAe + "View"     , "m3u_View" ))
  return VVXXzc
 def VVrMoO(self, path):
  FFw2XU(self, BF(self.VVvDJG, path), title="M3U/M3U8 File Options", VVXXzc=self.VVGrS5(), width=550)
 def VVvDJG(self, path, item=None):
  if item is not None:
   if   item == "m3u_Browse" : CCxgvM(self, CCxgvM.VVJiKT, m3uF=path)
   elif item == "m3u_Edit"  : CCAvJY(self, path, VVuQkS=self.VVy20q)
   elif item == "m3u_View"  : FFGPHz(self, path)
 def VVQmKn(self, path):
  if FFf0vs(path) : FFTSvN(self, BF(CC2Ldo.VVXlDL, self, path, BF(self.VV6qDI, path)), title="Loading Codecs ...")
  else    : FFbHk5(self, path)
 def VV6qDI(self, path, item=None):
  if item:
   FFGPHz(self, path, encLst=item)
 def VVQRcc(self, path, title, asUtf8):
  if FFf0vs(path) : FFTSvN(self, BF(CC2Ldo.VVXlDL, self, path, BF(self.VVVurJ, path, title, asUtf8), title="Original Encoding"), title="Loading Codecs ...")
  else    : FFbHk5(self, path)
 def VVVurJ(self, path, title, asUtf8, fromEnc=None):
  if fromEnc:
   if asUtf8: self.VV0VUu(path, title, fromEnc, "UTF-8")
   else  : CC2Ldo.VVSIp1(self, BF(self.VV0VUu, path, title, fromEnc), title="Convert to Encoding")
 def VV0VUu(self, path, title, fromEnc, toEnc):
  if toEnc:
   if not FFf0vs(path):
    FF8PJn(self, "Cannot open file", 2000)
    return
   try:
    outFile = "%s_%s%s" % (path, toEnc, os.path.splitext(path)[1])
    with ioOpen(path, "r", encoding=fromEnc) as src:
     BLOCK_1MB = 1048576
     with ioOpen(outFile, "w", encoding=toEnc) as dest:
      while True:
       cont = src.read(BLOCK_1MB)
       if not cont:
        break
       dest.write(cont)
     txt  = FFITtK("Successful\n\n", VV8QGw)
     txt += FFITtK("From Encoding (%s):\n" % fromEnc, VVaR8d)
     txt += "%s\n\n" % path
     txt += FFITtK("To Encoding (%s):\n" % toEnc, VVaR8d)
     txt += "%s\n\n" % outFile
     FFyijw(self, txt, title=title)
   except:
    FFqlCI(outFile)
    FFU9uk(self, 'Cannot encode the file:\n%s\n\nFrom "%s" to "%s"' % (path, fromEnc, toEnc), title=title)
   self.VVCIQw()
 def VVdKJv(self, path):
  title = "File Line-Break Conversion"
  FFHsPu(self, BF(self.VVWOZl, path, title), "Convert Line-Breaks to Unix for the file:\n\n%s" % path, title=title)
 def VVWOZl(self, path, title):
  if FFf0vs:
   with open(path, 'rb') as f:
    data = f.read()
   done = False
   if data:
    CRLF, LF, To = b"\r\n", b"\r", b"\n"
    totCRLF = data.count(CRLF)
    totLF = data.count(LF)
    if totCRLF or totLF:
     done = True
     with open(path, 'wb') as f:
      f.write(data.replace(CRLF, To).replace(LF, To))
   if done : txt = "%s\n\n%s" % (FFITtK("File converted:", VV8QGw), path)
   else : txt = "Nothing to convert in:\n\n%s" % path
   FFSQn9(self, txt, title=title)
  else:
   FFbHk5(self, path, title=title)
 def VV26G8(self, path, newChmod):
  FFHsPu(self, BF(self.VVMcYX, path, newChmod), "Change Permission to %s ?\n\n%s" % (newChmod, os.path.basename(path)))
 def VVMcYX(self, path, newChmod):
  cmd = "chmod %s '%s' %s" % (newChmod, path, VVJkPQ)
  result = FFhWCj(cmd)
  if result == "Successful" : FFSQn9(self, result)
  else      : FFU9uk(self, result)
 def VVTYgZ(self, path):
  parent = FF5AKn(path, False)
  self.session.openWithCallback(self.VVjay1, BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=parent, VVa5ZQ="Create Symlink here"))
 def VVjay1(self, newPath):
  if len(newPath) > 0:
   target = self.VVGyXn(self.VVP5Fg())
   target = FFHP0y(target)
   linkName = FFVUvT(target)
   dotIndex = linkName.find(".")
   if dotIndex > -1:
    linkName = linkName[:dotIndex]
   newPath = FFA4GT(newPath)
   link = newPath + linkName
   if   os.path.islink(FFHP0y(link)) : txt = ""
   elif os.path.ismount(link)     : txt = "MOUNT:"
   elif os.path.isfile(link)     : txt = "FILE:"
   elif os.path.isdir(link)     : txt = "DIRECTORY:"
   else          : txt = ""
   if len(txt) > 0:
    FFU9uk(self, "Name already used for %s\n\n%s" % (txt, link))
    return
   txt  = "-> TARGET:\n%s\n\n" % target
   txt += "<- LINK:\n%s"  % link
   FFHsPu(self, BF(self.VVUKgG, target, link), "Create Soft Link ?\n\n%s" % txt, VVys8X=True)
 def VVUKgG(self, target, link):
  cmd = 'LINK="%s"; if [ -e "$LINK" ]; then rm "$LINK"; fi; ln -sfv "%s" "%s" &>/dev/null %s' % (link, target, link, VVJkPQ)
  result = FFhWCj(cmd)
  if result == "Successful" : FFSQn9(self, result)
  else      : FFU9uk(self, result)
 def VVCPYT(self, path):
  lastPart = FFVUvT(path)
  FFttdT(self, BF(self.VV0dnU, path), title="Rename", defaultText=lastPart, message="Enter New Name:")
 def VV0dnU(self, path, VVAQKp):
  if VVAQKp:
   parent = FF5AKn(path, True)
   if os.path.isdir(path):
    path = FFHP0y(path)
   newName = parent + VVAQKp
   cmd = "mv '%s' '%s' %s" % (path, newName, VVJkPQ)
   if VVAQKp:
    if os.path.basename(path) != VVAQKp:
     message = "%s\n\nTo:\n\n%s" % (path, newName)
     FFHsPu(self, BF(self.VVK8vL, cmd), message, title="Rename file?")
    else:
     FFU9uk(self, "Cannot use same name!", title="Rename")
 def VVK8vL(self, cmd):
  result = FFhWCj(cmd)
  if "Fail" in result:
   FFU9uk(self, result)
  self.VVCIQw()
 def VVilYz(self, preserve):
  title="Archive to .tar.gz"
  CCXRxc.VVJ9VK(self, VVmj1O=title, titleBg="#22003344", bodyBg="#22001122"
      , VVCJhW  = BF(self.VV6PH4, title, preserve)
      , VVuQkS = BF(self.VVucEh, title))
 def VV6PH4(self, title, preserve, VVM2wn):
  totSel = self["myMenu"].VVID8N()
  totOk = totFail = 0
  VVM2wn.VVqMKy(totSel)
  VVM2wn.VViN1g = ["", totSel, totOk, totFail, ""]
  VVM2wn.VVkdWG("Prepareing targz file")
  VVVhOI = self["myMenu"].VV0whq()
  lastPart = FFVUvT(VVVhOI) or "archive"
  outF = os.path.join(VVVhOI, lastPart + ".tar.gz")
  c = 0
  while FFf0vs(outF):
   c += 1
   outF = os.path.join(VVVhOI, lastPart + "_%d.tar.gz" % c)
  totOk = totFail = 0
  path = ""
  try:
   with iTar.open(outF, mode="w:gz") as tarF:
    for row in self["myMenu"].list:
     if not VVM2wn or VVM2wn.isCancelled:
      return
     if row[2][6]:
      VVM2wn.VVwOHf(1)
      name  = FFHP0y(row[0][0])
      lastPath = FFVUvT(name)
      path  = os.path.join(VVVhOI, name)
      tarF.add(path, arcname=None if preserve else lastPath)
      totOk += 1
      if VVM2wn:
       VVM2wn.VViN1g = [outF, totSel, totOk, totFail, path]
       VVM2wn.VVvSkU(totOk, lastPath)
  except:
   totFail += 1
   if VVM2wn:
    VVM2wn.VViN1g = [outF, totSel, totOk, totFail, path]
 def VVucEh(self, title, VV9zbx, VViN1g, threadCounter, threadTotal, threadErr):
  outF, totSel, totOk, totFail, path = VViN1g
  txt  = "%s:\n%s\n\n"   % (FFITtK("Output File", VV8QGw), outF)
  txt += "Total\t: %d\n"  % totSel
  txt += "Archived\t: %d\n" % totOk
  if totFail   : txt += FFITtK("Failed\t: %d\n" % totFail, VVcahY)
  if not VV9zbx: txt += "%s\n%s" % (FFITtK("\nCancelled while copying:", VVcahY), path)
  FFyijw(self, txt, title=title)
  self.VVCIQw()
 @FFHF2S()
 def VVJliF(self, isMove):
  lst = []
  srcDir = self["myMenu"].VV0whq()
  totSel = self["myMenu"].VVID8N()
  if totSel == 0:
   ndx = self["myMenu"].l.getCurrentSelectionIndex()
   row = self["myMenu"].list[ndx]
   lst = [FFVUvT(row[0][0])]
  else:
   for row in self["myMenu"].list:
    if row[2][6]:
     lst.append(FFVUvT(row[0][0]))
  if lst:
   sDir = CFG.lastCopyMoveDir.getValue() or self["myMenu"].VV0whq()
   self.session.openWithCallback(BF(self.VVwFFo, isMove, lst, srcDir), BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=sDir, VVa5ZQ="Move to here" if isMove else "Paste here"))
  else:
   FFk1YE(self, "Nothing selected", 1500)
 def VVwFFo(self, isMove, lst, srcDir, dstDir):
  if dstDir:
   FFDDwF(CFG.lastCopyMoveDir, dstDir)
   FFTSvN(self, BF(self.session.openWithCallback, self.VVHQZ7, CCcFcS, isMove, lst, srcDir, dstDir))
 def VVHQZ7(self):
  self.VVCIQw()
 def VVpJ1E(self):
  tot = self["myMenu"].VVID8N()
  FFHsPu(self, self.VVSFlw, "Delete %d item%s ?" % (tot, FFEnJs(tot)), title="Delete Selection")
 @FFHF2S("Deleting ...", clearMsg=False)
 def VVSFlw(self):
  path = self["myMenu"].VV0whq()
  for row in self["myMenu"].list:
   if row[2][6]:
    FFQQ78(os.path.join(path, row[0][0]))
  FF8PJn(self)
  self.VVCIQw()
 def VVKuqZ(self, path):
  typ = FFzhsp(path)
  FFHsPu(self, BF(self.VVk4V0, path), "%s\n\nDelete %s ?" % (path, typ), title="Delete %s" % typ)
 @FFHF2S("Deleting ...", clearMsg=False)
 def VVk4V0(self, path):
  FFQQ78(path)
  FF8PJn(self)
  self.VVCIQw()
 def VVx3r4(self, path, isFile):
  VVVhOI = self.VVTAnu()
  if isFile:
   name = CCQdsv.VVb52E(VVVhOI, "file")
  else:
   fPath, fExt = os.path.splitext(path)
   if fPath and fExt and not VVrRHR(fPath) : name = os.path.basename(fPath)
   else          : name = CCQdsv.VVb52E(VVVhOI, "dir")
  self.VVsU40(VVVhOI, name, isFile)
 def VVsU40(self, VVVhOI, name, isFile):
  subj = "File" if isFile else "Directory"
  title = "Create New %s" % subj
  FFttdT(self, BF(self.VVmKZ0, VVVhOI, name, isFile, title), title=title, defaultText=name, message="Enter %s Name:" % subj)
 def VVmKZ0(self, VVVhOI, name, isFile, title, nName):
  if not nName or not nName.strip(): return
  nName = nName.strip()
  path = os.path.join(VVVhOI, nName)
  if nName != FF80BW(nName):
   self.VVsU40(VVVhOI, nName, isFile)
   FFU9uk(self, "Unallowed characters in name", title)
  elif FFf0vs(path):
   self.VVsU40(VVVhOI, nName, isFile)
   FFU9uk(self, "Already exists:\n\n%s" % VVVhOI, title)
  else:
   if isFile: cmd = "touch '%s' %s" % (path, VVJkPQ)
   else  : cmd = "mkdir '%s' %s" % (path, VVJkPQ)
   result = FFhWCj(cmd)
   if not "Successful" in result:
    FFU9uk(self, result, title)
   self.VVCIQw(moveTo=os.path.basename(path) if isFile else FFA4GT(path))
 def VVB7dL(self, path):
  c1, c2, c3, c4 = VVnQYw, VV6UAe, VVCBkQ, VVVAvR
  VVXXzc = []
  VVXXzc.append((c1 + "List Package Files"         , "VVuTix"     ))
  VVXXzc.append((c1 + "Package Information"         , "package_Info"     ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c2 + "Install Package"          , "VVuyQF_CheckVersion" ))
  VVXXzc.append((c2 + "Install Package (force reinstall)"     , "VVuyQF_ForceReinstall" ))
  VVXXzc.append((c2 + "Install Package (force overwrite)"     , "VVuyQF_ForceOverwrite" ))
  VVXXzc.append((c2 + "Install Package (force downgrade)"     , "VVuyQF_ForceDowngrade" ))
  VVXXzc.append((c2 + "Install Package (ignore failed dependencies)"  , "VVuyQF_IgnoreDepends" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Remove Related Package"        , "VVQQAi_ExistingPackage" ))
  VVXXzc.append((c3 + "Remove Related Package (force remove)"    , "VVQQAi_ForceRemove"  ))
  VVXXzc.append((c3 + "Remove Related Package (ignore failed dependencies)" , "VVQQAi_IgnoreDepends" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Generate Feed Listing Info."        , "VVOEdI"    ))
  VVXXzc.append(("Convert to %s" % ("DEB" if path[-3:] == "ipk" else "IPK") , "VVgB5w1"     ))
  VVXXzc.append(("Convert to .tar.gz %s(data part only)" % c4    , "VVgB5w2"     ))
  VVXXzc.append(("Extract Files"           , "VVzpDj"     ))
  VVXXzc.append(("Unbuild Package"           , "VVkWQb"     ))
  FFw2XU(self, BF(self.VVe36z, path), VVXXzc=VVXXzc, VV1Wwb=28, height=1000)
 def VVe36z(self, path, item=None):
  if item is not None:
   if   item == "VVuTix"      : self.VVuTix(path)
   elif item == "package_Info"      : FFTSvN(self, BF(CCJFyo.VVeFdT, self, path))
   elif item == "VVuyQF_CheckVersion"  : self.VVuyQF(path, VVUWS4     )
   elif item == "VVuyQF_ForceReinstall" : self.VVuyQF(path, VVV8Uu )
   elif item == "VVuyQF_ForceOverwrite" : self.VVuyQF(path, VVEY1Y )
   elif item == "VVuyQF_ForceDowngrade" : self.VVuyQF(path, VV6Aie )
   elif item == "VVuyQF_IgnoreDepends" : self.VVuyQF(path, VVWy79 )
   elif item == "VVQQAi_ExistingPackage" : self.VVQQAi(path, VVfSvc    )
   elif item == "VVQQAi_ForceRemove"  : self.VVQQAi(path, VVpt2P )
   elif item == "VVQQAi_IgnoreDepends"  : self.VVQQAi(path, VVcXNB )
   elif item == "VVOEdI"     : self.VVOEdI(path)
   elif item == "VVgB5w1"     : self.VVgB5w(path, False)
   elif item == "VVgB5w2"     : self.VVgB5w(path, True)
   elif item == "VVzpDj"     : self.VVzpDj(path)
   elif item == "VVkWQb"     : self.VVkWQb(path)
 def VVuTix(self, path):
  cTxt = lambda x: " echo -e '\n%s' %s;" % (x, FF0VVA(x, VVaR8d))
  txt  = FFITtK("Package File:\n", VVaR8d)
  txt += "%s\n\n" % path
  txt += FFITtK("Contents\n", VVaR8d)
  txt += "\n".join(FFunRV("ar -t '%s';" % path))
  FFyijw(self, txt)
 def VVOEdI(self, path):
  if CCJFyo.VVwabH(self):
   txt, mTime = CCJFyo.VVRvXn(path)
   pFile = "%s-Packages-File.txt" % path
   tFile = "%s-Packages.stamps.txt" % path
   with open(pFile, "w") as pF: pF.write("%s\n" % txt)
   with open(tFile, "w") as tF: tF.write("%s\n" % mTime)
   self.VVCIQw()
   txt  = "Result files:\n\n"
   txt += "%s\n\n" % os.path.basename(pFile)
   txt += "%s" % os.path.basename(tFile)
   FFyijw(self, txt)
 def VVzpDj(self, path):
  dest = FF5AKn(path, True) + os.path.basename(path)[:-4]
  cmd  =  FFkDck()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd +=    FFDTPf("mkdir '%s'" % dest)
  cmd +=    FFDTPf("cd '%s'" % dest)
  cmd += "  echo 'Extrcting files ...';"
  cmd += "  ar -xo '%s';" % path
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e 'Output Directory:\n%s' %s;" % (dest, FF0VVA(dest, VV8QGw))
  cmd += "fi;"
  FFNQkI(self, cmd, VVUYyP=self.VVCIQw)
 def VVkWQb(self, path):
  outP = path + "_"
  VVTNTl = "DEBIAN" if path.endswith(".deb") else "CONTROL"
  binCmd = "&& rm -f \"$FILE\";"
  dataCmd = "\"$FILE\" -C '%s' && rm -f \"$FILE\";" % outP
  contCmd = "\"$FILE\" -C \"$CONTPATH\" && rm -f \"$FILE\";"
  zstCmd = "--use-compress-program=unzstd"
  zstErr = "NOTE: zstd not installed to decompress :"
  cmd  = FFkDck()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "  rm -rf '%s' > /dev/null 2>&1;" % outP
  cmd += "  mkdir '%s';"      % outP
  cmd += "  CONTPATH='%s/%s';"    % (outP, VVTNTl)
  cmd += '  mkdir "$CONTPATH";'
  cmd += "  cd '%s';"       % outP
  cmd += "  echo 'Unpacking ...';"
  cmd += "  ar -x '%s';"      % path
  cmd += "  FILE='%s/debian-binary';  [ -f \"$FILE\" ]             %s"  % (outP, binCmd)
  cmd += "  FILE='%s/data.tar.gz';    [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.gz'; [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, contCmd)
  cmd += "  FILE='%s/data.tar.xz';    [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.xz'; [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, contCmd)
  if FFsGnd("unzstd"):
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, dataCmd)
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, contCmd)
  else:
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && echo '%s data.tar.zst' %s;" % (outP, zstErr, FF0VVA(zstErr, VVsm0W))
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && echo '%s control.tar.zst' %s;" % (outP, zstErr, FF0VVA(zstErr, VVsm0W))
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e '\nOutput Directory:\n%s' %s;" % (outP, FF0VVA(outP, VV8QGw))
  cmd += "fi;"
  FFNQkI(self, cmd, VVUYyP=self.VVCIQw)
 def VVgB5w(self, path, toTar):
  if CCJFyo.VVwabH(self):
   outF = path[:-3]
   if toTar:
    title = "Convert to tar.gz"
    outF += "tar.gz"
   elif path.endswith(".ipk"):
    title = "Convert to DEB"
    outF += "deb"
   else:
    title = "Convert to IPK"
    outF += "ipk"
   if FFf0vs(path):
    fnc = BF(self.VVvHeH, path, outF, toTar, title)
    if FFf0vs(outF) : FFHsPu(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(outF))
    else    : fnc()
   else:
    FFbHk5(self, path)
 @FFHF2S("Converting ...")
 def VVvHeH(self, path, outF, toTar, title):
  wDir = "/tmp/ajp_tmpDir"
  def VVVkYK():
   FF6usE("rm -rf '%s'" % wDir)
  def VVqIBc(txt):
   FFU9uk(self, txt, title=title)
  def VVjusO():
   FFSQn9(self, "Converted to:\n\n%s" % outF, title=title)
   VVVkYK()
   self.VVCIQw()
  VVVkYK()
  FF6usE("rm -f '%s'" % outF)
  if not FF6usE("mkdir -p '%s';" % wDir):
   VVqIBc("Cannot create working dir.")
   return
  if not FF6usE("cd '%s'; ar -x '%s'" % (wDir, path)):
   VVqIBc("Cannot extract package files.")
   return
  files = FFunRV("find '%s' -type f" % wDir)
  if files:
   for fil in files:
    if   fil.endswith(".gz"): tool = "gzip"
    elif fil.endswith(".xz"): tool = "xz"
    else     : tool = ""
    if tool:
     if not FF6BfM("which %s" % tool):
      VVqIBc("You need to install : %s" % tool)
      return
     if not FF6BfM("%s -d '%s'" % (tool, fil)):
      VVqIBc("Cannot decompress file:\n\n%s" % os.path.basename(fil))
      return
  else:
   VVqIBc("No files extracted from package.")
   return
  if toTar:
   fName = os.path.basename(path)
   dFile = os.path.join(wDir, "data.tar")
   if FFf0vs(dFile):
    if FF6BfM("gzip < '%s' > '%s'" % (dFile, outF)):
     VVjusO()
    else:
     VVqIBc("Cannot create .tar.gz file for:\n\n%s" % fName)
   else:
    VVqIBc("No data in package file:\n\n%s" % fName)
   return
  tool = "gzip" if outF.endswith("ipk") else "xz"
  for fil in FFunRV("find '%s' -type f" % wDir):
   if fil.endswith(".tar"):
    if not FF6BfM("%s '%s'" % (tool, fil)):
     VVqIBc("Cannot compress file:\n\n%s" % os.path.basename(fil))
     return
  files = FFunRV("find '%s' -type f" % wDir)
  if not files :
   VVqIBc("Not enough files in package.")
   return
  debF = ctrlF = dataF = ""
  for fil in files:
   fName = os.path.splitext(os.path.basename(fil))[0]
   if   fName == "debian-binary" : debF = fil
   elif fName == "control.tar"  : ctrlF = fil
   elif fName == "data.tar"  : dataF = fil
  if   not debF : err = "debian-binary"
  elif not ctrlF : err = "control"
  elif not dataF : err = "data"
  else   : err = ""
  if err :
   VVqIBc("Missing '%s' file." % err)
   return
  if FF6usE("ar -r '%s' '%s' '%s' '%s'" % (outF, debF, ctrlF, dataF)):
   VVjusO()
  else:
   VVqIBc("Cannot create package ('ar' failed).")
 def VVuyQF(self, path, cmdOpt):
  cmd = FFiD2M(cmdOpt, path)
  if cmd:
   cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'" % cmd
   FFHsPu(self, BF(FFNQkI, self, cmd, VVUYyP=FFq7xa), "Install Package ?\n\n%s" % os.path.basename(path))
  else:
   FFD8hf(self)
 @FFHF2S()
 def VVQQAi(self, path, cmdOpt):
  infCmd = FFiD2M(VV2z4R, path)
  if not infCmd:
   FFD8hf(self)
   return
  pkg = FFdV6p("%s | grep Package" % infCmd)
  pkg = pkg.partition(":")[2].strip()
  if not pkg:
   FFU9uk(self, "Cannot read Package Name from file.")
   return
  if CCJFyo.VV36XM(pkg):
   cmd = FFiD2M(cmdOpt, pkg)
   FFHsPu(self, BF(FFNQkI, self, cmd, VVUYyP=FFq7xa), "Remove Package:\n\n%s" % pkg)
  else:
   FFU9uk(self, "Package not installed:\n( %s )\n\nFrom file:\n%s" % (pkg, os.path.basename(path)))
 @FFHF2S()
 def VVaT6M(self, path):
  title = FFVUvT(path)
  pkg, err = CCJFyo.VVY854(path)
  if pkg : CCJFyo.VVeFdT(self, pkg, title)
  else : FFU9uk(self, "No package info.", title)
 def VVjakx(self, path, isDir):
  txt1 = "Archive to "
  txt2 = "Archive (Preserve Path Structure) to "
  VVXXzc = []
  VVXXzc.append(("%s.tar"  % txt1 , "archDir_tar"  ))
  VVXXzc.append(("%s.tar.gz" % txt1 , "archDir_tar_gz" ))
  VVXXzc.append(("%s.tar.xz" % txt1 , "archDir_tar_xz" ))
  VVXXzc.append(("%s.tar.bz2" % txt1 , "archDir_tar_bz2" ))
  VVXXzc.append(("%s.zip"  % txt1 , "archDir_zip"  ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("%s.tar"  % txt2 , "archPath_tar" ))
  VVXXzc.append(("%s.tar.gz" % txt2 , "archPath_tar_gz" ))
  VVXXzc.append(("%s.tar.xz" % txt2 , "archPath_tar_xz" ))
  VVXXzc.append(("%s.tar.bz2" % txt2 , "archPath_tar_bz2"))
  VVXXzc.append(("%s.zip"  % txt2 , "archPath_zip" ))
  if isDir and not self.VVseaV:
   VVXXzc.append(VVzg1X)
   VVXXzc.append(('Convert to "ipk" Package', "convertDirToIpk" ))
   VVXXzc.append(('Convert to "deb" Package', "convertDirToDeb" ))
  if isDir: c1, c2, title = "#11003322", "#11002222", "Archive Directory"
  else : c1, c2, title = "#11003344", "#11002244", "Archive File"
  FFw2XU(self, BF(self.VVwgvx, path, isDir, title), VVXXzc=VVXXzc, title=title, VVVzvS=c1, VVhHWW=c2)
 def VVwgvx(self, path, isDir, title, item):
  if item is not None:
   if   item == "archDir_tar"  : self.VVT1Ig(title, path, isDir, ".tar" , False)
   elif item == "archDir_tar_gz" : self.VVT1Ig(title, path, isDir, ".tar.gz" , False)
   elif item == "archDir_tar_xz" : self.VVT1Ig(title, path, isDir, ".tar.xz" , False)
   elif item == "archDir_tar_bz2" : self.VVT1Ig(title, path, isDir, ".tar.bz2", False)
   elif item == "archDir_zip"  : self.VVT1Ig(title, path, isDir, ".zip" , False)
   elif item == "archPath_tar"  : self.VVT1Ig(title, path, isDir, ".tar" , True)
   elif item == "archPath_tar_gz" : self.VVT1Ig(title, path, isDir, ".tar.gz" , True)
   elif item == "archPath_tar_xz" : self.VVT1Ig(title, path, isDir, ".tar.xz" , True)
   elif item == "archPath_tar_bz2" : self.VVT1Ig(title, path, isDir, ".tar.bz2", True)
   elif item == "archPath_zip"  : self.VVT1Ig(title, path, isDir, ".zip" , True)
   elif item == "convertDirToIpk" : self.VVc9m1(path, False)
   elif item == "convertDirToDeb" : self.VVc9m1(path, True)
 def VVc9m1(self, path, VV0fbF):
  self.session.openWithCallback(self.VVCIQw, CC1Scx, path=path, VV0fbF=VV0fbF)
 def VVT1Ig(self, title, path, isDir, fileExt, preserveDirStruct):
  parent  = FF5AKn(path, True)
  lastPart = FFVUvT(path)
  archFile = lastPart + fileExt
  resultFile = parent + archFile
  if preserveDirStruct:
   archFile = resultFile
   targetDir = parent + lastPart
  else:
   targetDir = lastPart
  if isDir: outFile, srcTxt = archFile , "Source Directory"
  else : outFile, srcTxt = resultFile , "Source File"
  if   fileExt == ".tar"  : archCmd, toolCmd = "tar -cvf"  , "allOK='1';"
  elif fileExt == ".tar.gz" : archCmd, toolCmd = "tar -cvzf" , "allOK='1';"
  elif fileExt == ".tar.xz" : archCmd, toolCmd = "tar -cvJf" , FFlMQJ()
  elif fileExt == ".tar.bz2" : archCmd, toolCmd = "tar -cvjf" , FF3F9l("bzip2" , "bzip2" , "BZip2" )
  elif fileExt == ".zip"  : archCmd, toolCmd = "zip -r"  , FF3F9l("zip" , "zip"  , "Zip"  )
  if preserveDirStruct:
   if archCmd.startswith("tar") and targetDir.startswith("/") : archCmd = "%s '%s' -C / '%s';" % (archCmd, outFile, targetDir[1:])
   else              : archCmd = "%s '%s' '%s';"    % (archCmd, outFile, targetDir)
  else:
   if isDir: archCmd = "cd '%s'; %s '../%s' *;" % (path, archCmd, outFile)
   else : archCmd = "cd '%s'; %s '%s' '%s';" % (parent, archCmd, outFile, os.path.basename(path))
  failed = "Process failed !"
  sep  = " echo -e '%s';" % SEP
  cmd  = toolCmd
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += " echo -e 'Archiving ...\n';"
  cmd +=   sep
  cmd +=   FFDTPf("rm -f '%s'" % archFile)
  cmd +=   archCmd
  cmd += " cd '%s';"      % parent
  cmd +=   sep
  cmd += " if [ $? -ne 0 ]; then "
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FF0VVA(failed, VVu50a))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " elif [ -f '%s' ]; then "  % archFile
  cmd += "  chmod 644 '%s';"    % archFile
  cmd += "  echo -e '\nDONE\n';"
  cmd += "  echo -e '%s:' %s;"   % (srcTxt, FF0VVA(srcTxt, VVi4ay))
  cmd += "  echo -e '%s\n';"    % path
  cmd += "  echo -e '%s:' %s;"   % ("Output", FF0VVA("Output", VV8QGw))
  cmd += "  echo -e '%s\n';"    % outFile
  cmd += " else"
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FF0VVA(failed, VVsm0W))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " fi;"
  cmd +=   sep
  cmd += "fi;"
  FFMdwM(self, cmd, VVUYyP=self.VVCIQw, title=title)
 def VVgzsG(self, path, isAll):
  if isAll: title, pathLst = "Add all Media in Directory to a Bouquet", CCQdsv.VVhNQr(FF5AKn(path, True))
  else : title, pathLst = "Add Media File to a Bouquet"   , [path]
  picker = CC41Tt(self, self, title, BF(self.VV5oQU, pathLst))
 def VV5oQU(self, pathLst):
  return CC41Tt.VVONdL(pathLst)
 def VVzPa5(self, VVQNy8):
  title = "Convert .zip to .tar.gz"
  if iZip.is_zipfile(VVQNy8):
   tarPath = os.path.splitext(VVQNy8)[0] + ".tar.gz"
   fnc  = BF(self.VVAYMb, VVQNy8, tarPath, title)
   if FFf0vs(tarPath) : FFHsPu(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(tarPath), title=title)
   else     : fnc()
  else:
   FFU9uk(self, "Invalid zip file:\n\n%s" % os.path.basename(VVQNy8), title=title)
 @FFHF2S("Converting ...")
 def VVAYMb(self, VVQNy8, tarPath, title):
  try:
   with iZip.ZipFile(VVQNy8) as zipF:
    with iTar.open(tarPath, "w:gz") as tarF:
     for zipInfo in zipF.infolist():
      tarInfo = iTar.TarInfo(name=zipInfo.filename)
      tarInfo.size = zipInfo.file_size
      try: tarInfo.mtime = mktime(tuple(list(zipInfo.date_time) + [-1, -1, -1]))
      except: tarInfo.mtime = mktime((2025, 1, 1, 0, 0, 0, -1, -1, -1))
      tarF.addfile(tarinfo=tarInfo, fileobj=zipF.open(zipInfo.filename))
   ok = True
  except:
   ok = False
  if ok and FFf0vs(tarPath):
   FFyijw(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(VVQNy8), os.path.basename(tarPath)), title=title)
   self.VVCIQw()
  else:
   FFqlCI(tarPath)
   FFU9uk(self, "Error while converting.", title=title)
 def VVVlxY(self, tarPath):
  title = "Convert .tar.gz to .zip"
  if iTar.is_tarfile(tarPath):
   VVQNy8 = tarPath[:-7] + ".zip"
   fnc  = BF(self.VVICDo, tarPath, VVQNy8, title)
   if FFf0vs(VVQNy8) : FFHsPu(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(VVQNy8), title=title)
   else     : fnc()
  else:
   FFU9uk(self, "Invalid tar file:\n\n%s" % os.path.basename(tarPath), title=title)
 @FFHF2S("Converting ...")
 def VVICDo(self, tarPath, VVQNy8, title):
  try:
   with iTar.open(tarPath) as tar:
    with iZip.ZipFile(VVQNy8, mode='w', compression=iZip.ZIP_DEFLATED) as zipF:
     for mem in tar.getmembers():
      if mem.isfile():
       mtime = datetime.fromtimestamp(mem.mtime)
       try: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(mtime.year, mtime.month, mtime.day, mtime.hour, mtime.minute, mtime.second))
       except: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(2025, 1, 1, 0, 0, 0))
       zipF.writestr(zipInfo, tar.extractfile(mem).read(), compress_type=iZip.ZIP_DEFLATED)
   ok = True
  except:
   ok = False
  if ok and FFf0vs(tarPath):
   FFyijw(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(tarPath), os.path.basename(VVQNy8)), title=title)
   self.VVCIQw()
  else:
   FFqlCI(VVQNy8)
   FFU9uk(self, "Error while converting.", title=title)
 @FFHF2S("Converting ...")
 def VVIEo3(self, path, ext2):
  title = "Convert to .%s" % ext2
  p1, ext1 = os.path.splitext(path)
  p2 = "%s.%s" % (p1, ext2)
  if   ext1 == ".zst" : cmd1 = "zstd"
  elif ext1 == ".xz" : cmd1 = "xz"
  else    : cmd1 = "gzip"
  cmd2 = ext2 if ext2 == "xz" else "gzip"
  cmd  = FFDTPf("rm -f '%s'" % p2)
  cmd += "%s -d < '%s' | %s > '%s'" % (cmd1, path, cmd2, p2)
  if FF6BfM(cmd):
   FFSQn9(self, "Result:\n\n%s" % os.path.basename(p2), title=title)
   self.VVCIQw()
  else:
   FFU9uk(self, "Could not convert:\n\n%s" % path, title=title)
 @FFHF2S()
 def VV28dh(self, path, isFhd):
  size = "1920x1080" if isFhd else "1280x720"
  title = "Convert to MVI (%s)" % size
  Dir  = FFA4GT(os.path.dirname(path))
  filName = os.path.splitext(os.path.basename(path))[0]
  m1v  = "%s%s_%s.m1v" % (Dir, filName, size)
  mvi  = "%s%s_%s.mvi" % (Dir, filName, size)
  FF6usE("rm -f '%s' '%s'" % (m1v, mvi))
  if FF6usE("ffmpeg -i '%s' -r 25 -b:v 20000 -s %s '%s'" % (path, size, m1v)) and FFf0vs(m1v):
   FF6usE("mv -f '%s' '%s'" % (m1v, mvi))
   self.VVCIQw()
   FFSQn9(self, "Converted to:\n\n%s" % os.path.basename(mvi), title=title)
  else:
   FFU9uk(self, "Cannot convert this file !", title=title)
 def VV31UW(self, path):
  VVXXzc, title, degS = [], "Rotate Image", str(u"\u00b0")
  if CCHa3c.VVV1rP(self, title, False, install=True):
   for i in range(90, 360, 90): VVXXzc.append(("%s%s" % (i, degS), str(i)))
   VVXXzc.append(VVzg1X)
   for i in range(1, 360): VVXXzc.append(("%s%s" % (i, degS), str(i)))
   VViDZz = ("Expand", BF(self.VVIGcZ, path, title))
   FFw2XU(self, BF(self.VVVbn8, path, title), VVXXzc=VVXXzc, width=700, VViDZz=VViDZz, VVL6LA=True, VVcIOx="OK = Same Size", title=title)
 def VVIGcZ(self, path, title, VVZzW8, angle):
  self.VVVbn8(path, title, angle, rotExp=True)
 def VV6sCd(self, path):
  VVXXzc, title = [], "Flip Image"
  if CCHa3c.VVV1rP(self, title, False, install=True):
   VVXXzc.append(("Horizontally" , "h"))
   VVXXzc.append(("Vertically" , "v"))
   FFw2XU(self, BF(self.VVVbn8, path, title), VVXXzc=VVXXzc, width=500, title=title)
 @FFHF2S()
 def VVVbn8(self, path, title, item, rotExp=False):
  if not item: return
  rotTxt = "rotated_%s%s" % (item, "_exp" if rotExp else "")
  flpTxt = "flipped_"
  try:
   from PIL import Image, ImageOps
   im = Image.open(path)
   if   item == "h" : res, im = flpTxt + "H", ImageOps.mirror(im)
   elif item == "v" : res, im = flpTxt + "V", ImageOps.flip(im)
   else    : res, im = rotTxt  , im.rotate(-int(item), expand=rotExp, resample=3)
   fil, ext = os.path.splitext(path)
   outF = "%s_%s%s" % (fil, res, ext)
   im.save(outF)
   self.VVCIQw()
   FFSQn9(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 def VV3YvW(self, path):
  title = "Save as"
  if CCHa3c.VVV1rP(self, title, False, install=True):
   fil, ext = os.path.splitext(path)
   VVXXzc = []
   for s in ("png", "jpg", "gif", "tif", "bmp"):
    VVXXzc.append((s, ) if s == ext[1:] else (s, s))
   FFw2XU(self, BF(self.VVdOtR, path, title), VVXXzc=VVXXzc, width=500, title=title)
 @FFHF2S()
 def VVdOtR(self, path, title, dstExt):
  if not dstExt: return
  try:
   from PIL import Image, ImageSequence
   im = Image.open(path)
   outTyp = "RGBA" if dstExt == "png" else "RGB"
   srcF, srcExt = os.path.splitext(path)
   if srcExt in (".tif", ".gif"):
    txt = "Saved tif Frames:\n\n"
    name = "page" if srcExt == ".tif" else "frame"
    for i, page in enumerate(ImageSequence.Iterator(im), start=1):
     outF = "%s_%s_%03d.%s" % (path, name, i, dstExt)
     page = page.convert(outTyp)
     page.save(outF)
     txt += "  %s\n" % os.path.basename(outF)
    self.VVCIQw()
    FFyijw(self, txt, title=title)
   else:
    im = im.convert(outTyp)
    outF = "%s.%s" % (srcF, dstExt)
    fnc = BF(self.VVGMAO, title, im, outF)
    if FFf0vs(outF) : FFHsPu(self, fnc, "Overwrite existing file ?\n\n%s" % outF, title=title)
    else    : fnc()
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 def VVGMAO(self, title, im, outF):
  try:
   im.save(outF)
   self.VVCIQw()
   FFSQn9(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 @FFHF2S()
 def VVUm3x(self, path, mode):
  ext = "png" if mode == 1 else "jpg"
  title = "Convert to %s" % ext
  outF = path[:-3] + ext
  FFqlCI(outF)
  res = FFdV6p('ffmpeg -hide_banner -i "%s" -frames:v 1 "%s"' % (path, outF))
  if FFf0vs(outF):
   FFSQn9(self, "Saved to:\n\n%s" % outF, title=title)
   self.VVCIQw()
  elif "unhandled version" in res : FFU9uk(self, "Your ffmpeg cannot handle mvi.", title=title)
  else       : FFU9uk(self, "Conversion Error", title=title)
 @FFHF2S()
 def VV8JgI(self, path):
  title = "Convert to Base64 String"
  try:
   ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
   outF = os.path.join(os.path.dirname(path), os.path.basename(path) + "_base64.txt")
   with open(path, "rb") as f: b64 = b64encode(f.read()).decode()
   with open(outF, "w") as f: f.write("data:image/%s;base64,%s" % (ext, b64))
   FFSQn9(self, "Saved to : %s\n\n" % outF, title=title)
   self.VVCIQw()
  except Exception as e:
   FFU9uk(self, str(e), title=title)
 def VVlvYP(self, path):
  title = "Set as PIcon for current channel"
  pPath = CCUNc6.VVQ490()
  if VVrRHR(pPath):
   if CCHa3c.VVV1rP(self, title, False, cbFnc=BF(self.VVlvYP, path)):
    picon = "%s%s.png" % (pPath, CCaZ62(self.session).VV6phL.strip(":").replace(":", "_").upper())
    VVXXzc = []
    for item in ((50,30),(96,64),(100,60),(220,132),(400,160),(400,240),(500,300)):
     VVXXzc.append(("%d x %d" % (item), item))
    VVpuzu = self.VV8k0o
    VViDZz = ("Stretch", BF(self.VVmSDr, title, path, picon))
    VVZzW8 = FFw2XU(self, BF(self.VVMEYI, title, path, picon, False), VVXXzc=VVXXzc, width=700, title='PIcon Max. Size', VVpuzu=VVpuzu, VViDZz=VViDZz, VVcIOx="OK = Fit within size")
    VVZzW8.VVEaHH(3)
  else:
   FFU9uk(self, "PIcons path not found:\n\n%s\n\n( You can change it in Settings )" % pPath, title=title)
 def VVmSDr(self, title, path, picon, selectionObj, item):
  self.VVMEYI(title, path, picon, True, item)
  selectionObj.cancel()
 def VVMEYI(self, title, path, picon, stretch, sz=None):
  if sz:
   try:
    from PIL import Image
    im = Image.open(path)
    if stretch: im = im.resize(sz, Image.ANTIALIAS)
    else   : im.thumbnail(sz)
    im.save(picon)
    CCISy5.VVIXmT(self, VVjex7=CCISy5.VVn7qY)
   except Exception as e:
    FFU9uk(self, "Image Processing error:\n\n%s" % e)
 def VV8k0o(self, VVZzW8, txt, ref, ndx):
  FFpIdO(self, "_help_resize", "Picture File Resizing")
 def VVk3N9(self, path):
  CCSB3R.VVb38U(self, BF(self.VVUN6e, path))
 def VVUN6e(self, path, rType=None):
  if rType:
   FFTSvN(self, BF(self.VVMj5s, self, path, rType), title="Playing Media ...")
 @staticmethod
 def VVMj5s(SELF, path, rType=""):
  if   rType     : prefix = rType
  elif path.endswith(".ts") : prefix = "1"
  else      : prefix = CFG.iptvAddToBouquetRefType.getValue()
  VVDhju = "%s:%s%s" % (prefix, "0:" * 9, path)
  CC2lVw.VVbVSZ(SELF.session, VVQpKh=False, VViMad=False, VV7GTU=VVDhju)
 @staticmethod
 def VVZTzJ(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  fPath = serv and serv.getPath()
  if fPath and FFf0vs(fPath):
   fDir, fName = os.path.split(fPath)
   return fPath, FFA4GT(fDir), fName
  return "", "", ""
 @staticmethod
 def VV87Qo(path):
  try:
   st = os.statvfs(path)
   total = st.f_frsize * st.f_blocks
   used = st.f_frsize * (st.f_blocks - st.f_bfree)
   free = st.f_frsize * st.f_bfree
   avail = st.f_frsize * st.f_bavail
   return total, used, free, avail, ""
  except Exception as e:
   return 0, 0, 0, 0, str(e)
 @staticmethod
 def VVAcha(size, mode=0):
  txt = CCQdsv.VVPVfa(size)
  if size >= 1024 :
   commaSize = format(size, ',d')
   if mode == 1: return "%s (%s)"   % (txt, commaSize)
   if mode == 2: return "%s (%s)"   % (commaSize, txt)
   if mode == 3: return "%s (%s)"   % (size, txt)
   if mode == 4: return "%s"    % txt
   else  : return "%s  ( %s bytes )" % (txt, commaSize)
  else:
   return txt
 @staticmethod
 def VVPVfa(bytes):
  kilo, unit = 1024.0, ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
  if bytes < kilo:
   return "%d B" % bytes
  i = int(iFloor(iLog(bytes, 1024)))
  s = str("%.2f" % (bytes / (kilo ** i))).rstrip(".0")
  return "%s %s" % (s, unit[i])
 @staticmethod
 def VVAAgR(path):
  rangeList = list(range(0x20, 0x100))
  try:
   with open(path, 'rb') as f:
    bytes = f.read(1024)
   textchars = bytearray({7,8,9,10,12,13,27} | set(rangeList) - {0x7f})
   return bool(bytes.translate(None, textchars))
  except:
   return True
 @staticmethod
 def VVz66T(SELF, path, title=""):
  try:
   with ioOpen(path, "r", encoding="UTF-8") as f:
    txt = f.read()
   return True
  except:
   if title:
    FFU9uk(SELF, "File is not in 'UTF-8' Encoding:\n\n%s" % path, title=title.strip())
   return False
 @staticmethod
 def VVrKp4(addDot=False):
  tDict = CCf9Gq.VVl1a5()
  lst = list(tDict["mov"])
  lst.extend(list(tDict["mus"]))
  if addDot: lst = ["." + x for x in lst]
  return tuple(lst)
 @staticmethod
 def VVhNQr(path):
  lst = []
  for ext in CCQdsv.VVrKp4():
   lst.extend(FFYjQm(path, "*.%s" % ext))
  return sorted(lst, key=FFNnh8(FFyTkm))
 @staticmethod
 def VVHZ7y(path):
  return FF6usE("tar -tzf '%s'" % path)
 @staticmethod
 def VVZBjZ(path):
  path = os.path.abspath(path)
  while not os.path.ismount(path):
   path = os.path.dirname(path)
  return path
 @staticmethod
 def VVZksK(addTrailingSlash=True):
  Dict = {}
  for line in FF2iRW("/proc/mounts"):
   parts = line.split(" ")
   if len(parts) > 2:
    fs, mp, typ = parts[:3]
    if addTrailingSlash and os.path.isdir(mp):
     mp = FFA4GT(mp)
    isNet = ":" in fs or fs.startswith("//")
    Dict[mp] = (fs, typ, isNet)
  return Dict
 @staticmethod
 def VVrc3j():
  lst = []
  for key, val in CCQdsv.VVZksK().items():
   if val[2]: lst.append(key)
  return lst
 @staticmethod
 def VVbsXD(lst, fromFind=True):
  if len(lst) == 1 and lst[0] == VVaw89:
   return VVaw89
  elif fromFind:
   for line in lst:
    span = iSearch(r"find:\s*(.+):\s*Input\/output error", line, IGNORECASE)
    if span:
     return 'Filesystem Error in:\n\n%s' % span.group(1)
  for ln in lst:
   if not ln.startswith("/"): return "Error: %s" % ln
  return ""
 @staticmethod
 def VVb52E(path, name):
  c = 0
  newNm = name
  while VVrRHR(os.path.join(path, newNm)):
   c += 1
   newNm = "%s%s" % (name, c)
  return newNm
class CCf9Gq(MenuList):
 VVbSRm   = 0
 VV1blF   = 1
 VVKOJR   = 2
 VVeewk   = 3
 VVY7Gi   = 4
 VVaMlP   = 5
 VVF6vK   = 6
 VViQWM   = 7
 VVOt6P   = "<List of Storage Devices>"
 VV4CiQ  = "<Parent Directory>"
 VV4AJu   = 0
 VVgjMx   = 1
 VVMjD3 = 2
 VVO1S0  = 3
 VVV82E   = 4
 VV5b5I   = 5
 FILE_TYPE_LINK   = 6
 VVMSQH  = 7
 PROHIBITED_FILES  = ["/%s/" % x for x in ("DEBIAN","bin","boot","dev","etc","hdd","home","lib","media","mnt","network","proc","run","sbin","sys","tmp","usr","var")]
 def __init__(self, enableWrapAround=False, directory="/", VVkwiJ=True, VV0LyP=True, VVSHAH=True, VVtfG7=None, VVicvM=False, VVqDJl=False, isTop=False, VVc9A4=None, VVVJxU=1000, VV1Wwb=30, VVwOMI=30):
  MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
  self.VVkwiJ  = VVkwiJ
  self.VV0LyP    = VV0LyP
  self.VVSHAH  = VVSHAH
  self.VVtfG7  = VVtfG7
  self.VVicvM   = VVicvM or []
  self.VVqDJl   = VVqDJl or []
  self.isTop     = isTop
  self.additional_extensions = VVc9A4
  self.VVVJxU    = VVVJxU
  self.VV1Wwb    = VV1Wwb
  self.VVwOMI    = VVwOMI
  self.VVTQSe   = eServiceCenter.getInstance()
  self.mountpoints   = []
  self.networkMounts   = CCQdsv.VVrc3j()
  self.current_directory  = None
  self.current_mountpoint  = None
  self.multiSelect_color  = FFEIV2("#11ff4444")
  self.l.setFont(0, gFont(VVQVcT, self.VV1Wwb))
  self.l.setItemHeight(self.VVwOMI)
  self.png_mntN   = CCf9Gq.VVXRSy("mntN")
  self.png_mntL   = CCf9Gq.VVXRSy("mntL")
  self.png_mem   = CCf9Gq.VVXRSy("mem")
  self.png_usb   = CCf9Gq.VVXRSy("usb")
  self.png_fil   = CCf9Gq.VVXRSy("fil")
  self.png_dir   = CCf9Gq.VVXRSy("dir")
  self.png_dirup   = CCf9Gq.VVXRSy("dirup")
  self.png_slwfil   = CCf9Gq.VVXRSy("slwfil")
  self.png_slbfil   = CCf9Gq.VVXRSy("slbfil")
  self.png_slwdir   = CCf9Gq.VVXRSy("slwdir")
  self.VVSKC5()
  self.VV1nvG(directory)
 @staticmethod
 def VVXRSy(category):
  return LoadPixmap("%s%s.png" % (VV30Jg, category), getDesktop(0))
 @staticmethod
 def VVl1a5():
  return {"pic":("bmp","gif","jpe","jpeg","jpg","png","svg"),"mov":("3g2","3gp","asf","avi","divx","flv","ifo","iso","m2ts","m4v","mkv","mod","mov","mp4","mpe","mpeg","mpg","mts","mvi","ogm","ogv","pva","rm","rmvb","stream","ts","vob","webm","wmv","wtv","h264","h265","mjpeg","mk3d","mks","xvid"),"mus":("aac","ac3","alac","amr","ape","au","dts","flac","m2a","m4a","mid","mka","mp2","mp3","oga","ogg","wav","wave","wma","wv","m4b","m4p","mpc","wpl"),"txt":("cfg","conf","htm","html","txt","xml"),"py":("py","pyo","pyc"),"tar":("bz2","gz","tar","xz"),"rar":("rar",),"zip":("zip",),"p7z":("7z",),"zst":("zst",),"ipk":("ipk",),"deb":("deb",),"scr":("sh",),"m3u":("m3u","m3u8")}
 def VV96yf(self, name, absolute=None, isDir=False, typ=None, png=None):
  if absolute and isDir:
   path = absolute
   path = FFHP0y(path)
   if os.path.islink(path) and not name in (self.VVOt6P, self.VV4CiQ):
    png = self.png_slwdir
    name += FFITtK(" -> " , VVaR8d) + FFITtK(os.readlink(path), VV8QGw)
  tableRow = [ (absolute, isDir, typ) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VVwOMI + 10, 0, self.VVVJxU, self.VVwOMI, 0, LEFT | RT_VALIGN_CENTER, name))
  if png is not None:
   tableRow.append(CCzs7U.VVUqW9(0, 2, self.VVwOMI-4, self.VVwOMI-4, png))
  return tableRow
 @staticmethod
 def VVl2HO(path):
  ext = os.path.splitext(path)[1]
  if ext:
   ext = ext.lstrip(".").lower()
   for cat, lst in CCf9Gq.VVl1a5().items():
    if ext in lst:
     return cat
  return ""
 def VVSKC5(self):
  self.mountpoints = [os.path.join(p.mountpoint, "") for p in harddiskmanager.getMountedPartitions()]
  self.mountpoints.sort(reverse=True)
 def VV1eGz(self, file):
  file = os.path.join(os.path.realpath(file), "")
  for m in self.mountpoints:
   if file.startswith(m):
    return m
  return False
 def VVH6V4(self, file):
  if os.path.realpath(file) == file:
   return self.VV1eGz(file)
  else:
   if file[-1] == "/":
    file = file[:-1]
   mp = self.VV1eGz(file)
   last = file
   file = os.path.dirname(file)
   while last != "/" and mp == self.VV1eGz(file):
    last = file
    file = os.path.dirname(file)
   return os.path.join(last, "")
 def getSelection(self):
  if self.l.getCurrentSelection() is None:
   return None
  return self.l.getCurrentSelection()[0]
 def VVp8N4(self, isUp):
  ndx = self.l.getCurrentSelectionIndex()
  row = self.list[ndx]
  bg = self.multiSelect_color if row[2][6] == None else None
  ndx = self.getSelectionIndex()
  if isUp:
   if ndx > 0:
    self.moveToIndex(self.getSelectionIndex() - 1)
  else:
   if ndx < len(self.list) - 1:
    self.moveToIndex(self.getSelectionIndex() + 1)
  iconData = self.VV3egF(row, bg)
  if iconData:
   row[2] = iconData
   self.l.setList(self.list)
   return True
  else:
   return False
 def VVCB7n(self, isSel, fManMode, cbFnc):
  bg = self.multiSelect_color if isSel else None
  if isSel and fManMode in (CCQdsv.VVwHJr, CCQdsv.VVx2Yd):
   VVVhOI = self.VV0whq()
   for ndx, row in enumerate(self.list):
    if row[0][0]:
     path = os.path.join(VVVhOI, row[0][0])
     isDir = os.path.isdir(path)
     if fManMode == CCQdsv.VVwHJr and not isDir or fManMode == CCQdsv.VVx2Yd and isDir:
      iconData = self.VV3egF(row, bg)
      if iconData:
       row[2] = iconData
  else:
   for ndx, row in enumerate(self.list):
    iconData = self.VV3egF(row, bg)
    if iconData:
     row[2] = iconData
  self.l.setList(self.list)
  cbFnc()
 def VV3egF(self, row, bg):
  if self.VVPqfq(row):
   iconData = list(row[2])
   iconData[6] = bg
   iconData[7] = bg
   return tuple(iconData)
  else:
   return None
 def VVPqfq(self, row):
  if not row[0][0] in self.mountpoints:
   if   row[0][2] in (self.VV5b5I, self.FILE_TYPE_LINK): return True
   elif row[0][2] == self.VVV82E:
    if   VVd25Y           : return True
    elif not row[0][0] in self.PROHIBITED_FILES    : return True
  return False
 def VVN01h(self):
  return self.VVPqfq(self.list[self.l.getCurrentSelectionIndex()])
 def VVID8N(self):
  tot = 0
  for row in self.list:
   if row[2][6]:
    tot += 1
  return tot
 def VVbPnF(self, dir, parents):
  dir = os.path.realpath(dir)
  for p in parents:
   if dir.startswith(p):
    return True
  return False
 def VV1nvG(self, directory, selItem=None):
  self.list = []
  directories = []
  files = []
  if self.current_directory is None:
   if directory and self.VVSHAH:
    self.current_mountpoint = self.VVH6V4(directory)
   else:
    self.current_mountpoint = None
  self.current_directory = directory
  if directory is None:
   if self.VVSHAH:
    for p in harddiskmanager.getMountedPartitions():
     path = os.path.join(p.mountpoint, "")
     if path not in self.VVqDJl and not self.VVbPnF(path, self.VVicvM):
      if path == "/" : png = self.png_mem
      else   : png = self.png_usb
      self.list.append(self.VV96yf(name=p.description, absolute=path, isDir=True, typ=self.VV4AJu, png=png))
    path = "/"
    if path not in self.VVqDJl and not self.VVbPnF(path, self.VVicvM):
     for item in self.list:
      if path == item[0][0]:
       break
     else:
      self.list.append(self.VV96yf(name="INTERNAL FLASH", absolute="/", isDir=True, typ=self.VVgjMx, png=self.png_mem))
  else:
   if FFf0vs(directory):
    try:
     files = os.listdir(directory)
    except:
     files = []
    tmpfiles = files[:]
    for x in tmpfiles:
     tPath = directory + x
     if os.path.isdir(tPath):
      directories.append(tPath + "/")
      files.remove(x)
     elif not FFaW27(tPath):
      files.remove(x)
  if directory is not None and self.VVkwiJ and not self.isTop:
   if directory == self.current_mountpoint and self.VVSHAH:
    self.list.append(self.VV96yf(name=self.VVOt6P, absolute=None, isDir=True, typ=self.VVMjD3, png=self.png_dirup))
   elif (directory != "/") and not (self.VVqDJl and self.VV1eGz(directory) in self.VVqDJl):
    self.list.append(self.VV96yf(name=self.VV4CiQ, absolute='/'.join(directory.split('/')[:-2]) + '/', isDir=True, typ=self.VVO1S0, png=self.png_dirup))
  if self.VVkwiJ:
   for x1 in directories:
    if not (self.VVqDJl and self.VV1eGz(x1) in self.VVqDJl) and not self.VVbPnF(x1, self.VVicvM):
     name = x1.split('/')[-2]
     x2 = FFA4GT(os.path.realpath(x1))
     if os.path.ismount(x2):
      if   x2 in self.mountpoints  : png = self.png_usb
      elif x2 in self.networkMounts : png = self.png_mntN
      else       : png = self.png_mntL
     else        : png = self.png_dir
     self.list.append(self.VV96yf(name=name, absolute=x1, isDir=True, typ=self.FILE_TYPE_LINK if os.path.islink(FFHP0y(x1)) else self.VVV82E, png=png))
  if self.VV0LyP:
   for x in files:
    path = directory + x
    name = x
    png  = self.png_fil
    if os.path.islink(FFHP0y(path)):
     try:
      target = os.readlink(path)
      if FFf0vs(target):
       png = self.png_slwfil
       name += FFITtK(" -> " , VVaR8d) + FFITtK(target, VV8QGw)
      else:
       png = self.png_slbfil
       name += FFITtK(" -> " , VVaR8d) + FFITtK(target, VVsm0W)
     except:
      png = self.png_slbfil
    elif "." in name:
     category = self.VVl2HO(name)
     if category:
      png = LoadPixmap("%s%s.png" % (VV30Jg, category))
    elif not FFaW27(path):
     png = LoadPixmap("%serr.png" % VV30Jg)
    if (self.VVtfG7 is None) or iCompile(self.VVtfG7[0], flags=self.VVtfG7[1]).search(path):
     self.list.append(self.VV96yf(name=name, absolute=x , isDir=False, typ=self.VV5b5I, png=png))
  if self.VVSHAH and len(self.list) == 0:
   self.list.append(self.VV96yf(name=FFITtK("No USB connected", VVVAvR), absolute=None, isDir=False, typ=self.VVMSQH, png=self.png_usb))
  self.l.setList(self.list)
  self.VVF6Qs()
  if selItem is not None:
   i = 0
   self.moveToIndex(0)
   for x in self.list:
    p = x[0][0]
    if isinstance(p, eServiceReference): p = p.getPath()
    if p == selItem: self.moveToIndex(i)
    i += 1
 def VV0whq(self):
  return self.current_directory
 def VVYfQe(self):
  if self.getSelection() is None:
   return False
  return self.getSelection()[1]
 def VVubA7(self):
  return self.VVNiV1() and self.VV0whq()
 def VVNiV1(self):
  return self.list[0][1][7] in (self.VVOt6P, self.VV4CiQ)
 def descent(self):
  if self.getSelection() is None:
   return
  self.VV1nvG(self.getSelection()[0], self.current_directory)
 def VVAA1c(self):
  if self.getSelection() is None:
   return None
  x = self.getSelection()[0]
  if isinstance(x, eServiceReference):
   x = x.getPath()
  return x
 def execBegin(self):
  harddiskmanager.on_partition_list_change.append(self.VVDt6w)
 def execEnd(self):
  harddiskmanager.on_partition_list_change.remove(self.VVDt6w)
 def VVDt6w(self, action, device):
  self.VVSKC5()
  if self.current_directory is None:
   self.VVJIvj()
 def VVJIvj(self):
  tDict = {}
  for row in self.list:
   if row[2][6]:
    tDict[row[0][0]] = 1
  fName = self.VVAA1c()
  self.VV1nvG(self.current_directory, fName if fName and FFf0vs(os.path.join(self.current_directory, fName)) else None)
  isSel = 0
  if tDict:
   for row in self.list:
    if tDict.get(row[0][0], 0):
     row[2] = list(row[2])
     row[2][6] = row[2][7] = self.multiSelect_color
     row[2] = tuple(row[2])
     isSel = 1
   self.l.setList(self.list)
  return isSel
 def VVhPzE(self):
  mode = CFG.browserSortMode.getValue()
  mix  = CFG.browserSortMix.getValue()
  sAZ, sZA, s09, s90, sNO, sON = "A > Z", "Z > A", "0 > 9", "9 > 0", "New > Old", "Old > New"
  if mode == self.VVbSRm : nameAlpMode, nameAlpTxt = self.VV1blF, sZA
  else       : nameAlpMode, nameAlpTxt = self.VVbSRm, sAZ
  if mode == self.VVKOJR : nameNumMode, nameNumTxt = self.VVeewk, s90
  else       : nameNumMode, nameNumTxt = self.VVKOJR, s09
  if mode == self.VVY7Gi : dateMode, dateTxt = self.VVaMlP, sON
  else       : dateMode, dateTxt = self.VVY7Gi, sNO
  if mode == self.VVF6vK : typeMode, typeTxt = self.VViQWM, sZA
  else       : typeMode, typeTxt = self.VVF6vK, sAZ
  if   mode in (self.VVbSRm, self.VV1blF): txt = "Name (%s)" % (sAZ if mode == self.VVbSRm else sZA)
  elif mode in (self.VVKOJR, self.VVeewk): txt = "Name (%s)" % (s09 if mode == self.VVbSRm else s90)
  elif mode in (self.VVY7Gi, self.VVaMlP): txt = "Date (%s)" % (sNO if mode == self.VVY7Gi else sON)
  elif mode in (self.VVF6vK, self.VViQWM): txt = "Type (%s)" % (sAZ if mode == self.VVF6vK else sZA)
  if mix:
   txt += " .. Mixed"
  return nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt, dateMode, dateTxt, typeMode, typeTxt, "Cur = by %s" % txt
 def VVF6Qs(self, mode=None, isMix=False, isNum=False):
  if not mode is None:
   FFDDwF(CFG.browserSortMode, mode)
   FFDDwF(CFG.browserSortMix, isMix)
  if self.list:
   if self.VVNiV1() : item0, topRow = 1, self.list[0]
   else    : item0, topRow = 0, None
   mode = CFG.browserSortMode.getValue()
   isMix = CFG.browserSortMix.getValue()
   if mode in (self.VVbSRm, self.VV1blF):
    rev = True if mode == self.VV1blF else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: x[1][7]         , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], x[1][7]), reverse=rev)
   elif mode in (self.VVKOJR, self.VVeewk):
    rev = True if mode == self.VVeewk else False
    self.list = sorted(self.list[item0:], key=FFNnh8(BF(self.VVoAt5, isMix, rev)), reverse=rev)
   elif mode in (self.VVY7Gi, self.VVaMlP):
    rev = True if mode == self.VVaMlP else False
    self.list = sorted(self.list[item0:], key=FFNnh8(BF(self.VV4BGW, isMix)), reverse=rev)
   else:
    rev = True if mode == self.VViQWM else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: os.path.splitext(x[1][7])[1]            , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], os.path.splitext(x[1][7])[1], x[1][7]) , reverse=rev)
   if topRow:
    self.list.insert(0, topRow)
   self.l.setList(self.list)
 def VVoAt5(self, mix, rev, p1, p2):
  dir1, name1 = p1[0][1], p1[1][7]
  dir2, name2 = p2[0][1], p2[1][7]
  if mix:
   return FFyTkm(name1.lower(), name2.lower())
  else:
   if rev: dir1, dir2 = dir2, dir1
   return FF1FIM(dir2, dir1) or FFyTkm(name1, name2)
 def VV4BGW(self, mix, p1, p2):
  dir1 = p1[0][1]
  dir2 = p2[0][1]
  if mix or dir1 == dir2:
   path1 = "" if dir1 else self.current_directory
   path2 = "" if dir2 else self.current_directory
   try:
    stat1 = os.stat(path1 + p1[0][0])
    stat2 = os.stat(path2 + p2[0][0])
    if mix : return FF1FIM(stat2.st_ctime, stat1.st_ctime)
    else : return FF1FIM(dir2, dir1) or FF1FIM(stat2.st_ctime, stat1.st_ctime)
   except:
    pass
  return 0
class CCYGxc(Screen):
 def __init__(self, session, defFG="", defBG="", onlyBG=False, isBgMode=True):
  self.skin, self.VVuaAL = FFJH4U(VV2ZKp, 900, 700, 35, 10, 14, "#22333333", "#22333333", 30, VVZ3ZU=40)
  self.session  = session
  self.onlyBG   = onlyBG
  self.Title   = "Color"
  self.VVRQlw  = 6
  self.VVwnUG  = 8
  self.VV5dDF   = []
  self.curRow   = 0
  self.curCol   = 0
  self.isBgMode  = isBgMode
  self.defFG   = self.VVXPeF(defFG, "#00FFFFFF")
  self.defBG   = self.VVXPeF(defBG, "#11000000")
  self.transpFg  = int(self.defFG[1:3], 16)
  self.transpBg  = int(self.defBG[1:3], 16)
  self.colors   = (   ("FFFFFF", "FFC0C0", "FFE0C0", "FFFFC0", "C0FFC0", "C0FFFF", "C0C0FF", "FFC0FF")
        , ("E0E0E0", "FF8080", "FFC080", "FFFF80", "80FF80", "80FFFF", "8080FF", "FF80FF")
        , ("C0C0C0", "FF0000", "FF8000", "FFFF00", "00FF00", "00FFFF", "0000FF", "FF00FF")
        , ("808080", "C00000", "C04000", "C0C000", "00C000", "00C0C0", "0000C0", "C000C0")
        , ("404040", "800000", "804000", "808000", "008000", "008080", "000080", "800080")
        , ("000000", "400000", "804040", "404000", "004000", "004040", "000040", "400040")
        )
  FFfmZP(self, self.Title)
  self["keyRed"].show()
  FFrvOP(self["keyGreen"] , "< > Transp.")
  FFrvOP(self["keyYellow"], "Foreground")
  FFrvOP(self["keyBlue"] , "Background")
  if self.onlyBG:
   self["keyYellow"].hide()
   self["keyBlue"].hide()
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    self["myColor%d%d" % (row, col)] = Label()
  self["myColorPtr"] = Label()
  self["myColorTst"] = Label("This is a test message.\n0123456789")
  FFewq4(self,
  {
   "ok"   : self.VV3dtI     ,
   "green"   : self.VV3dtI     ,
   "yellow"  : BF(self.VVVGqA, False)  ,
   "blue"   : BF(self.VVVGqA, True)  ,
   "up"   : self.VVY6L2       ,
   "down"   : self.VVgn7U      ,
   "left"   : self.VVT8GX      ,
   "right"   : self.VVMljc      ,
   "last"   : BF(self.VVRwyN, -5) ,
   "next"   : BF(self.VVRwyN, 5) ,
   "cancel"  : BF(self.close, None, None)
  })
  self.onShown.append(self.VVvFMs)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    FFu0W6(self["myColor%d%d" % (row, col)], "#11%s" % self.colors[row][col])
  c = "#11333333"
  FFu0W6(self["keyRed"] , c)
  FFu0W6(self["keyGreen"] , c)
  self.VVSWky()
  self.VVvmiv()
  FFNucL(self["myColorTst"], self.defFG, self.defBG)
  self.VVEIkV(0, 0)
 def VVXPeF(self, color, defColor):
  color = color.upper()
  span = iSearch(r"([#][a-fA-F0-9]{8})", color, IGNORECASE)
  if span : return color
  else : return defColor
 def VVvmiv(self):
  for row in range(self.VVRQlw):
   for col in range(self.VVwnUG):
    color = self.colors[row][col]
    found = False
    if self.isBgMode:
     if self.defBG[3:] == self.colors[row][col]:
      found = True
    else:
     if self.defFG[3:] == self.colors[row][col]:
      found = True
    if found:
     self.curRow = row
     self.curCol = col
     self.VVEIkV(0, 0)
     return
 def VV3dtI(self):
  self.close(self.defFG, self.defBG)
 def VVY6L2(self): self.VVEIkV(-1, 0)
 def VVgn7U(self): self.VVEIkV(1, 0)
 def VVT8GX(self): self.VVEIkV(0, -1)
 def VVMljc(self): self.VVEIkV(0, 1)
 def VVEIkV(self, row, col):
  self.curRow += row
  self.curCol += col
  if   self.curRow > self.VVRQlw -1 : self.curRow = 0
  elif self.curRow < 0     : self.curRow = self.VVRQlw - 1
  if   self.curCol > self.VVwnUG -1 : self.curCol = 0
  elif self.curCol < 0     : self.curCol = self.VVwnUG - 1
  color = self.VVy9KJ()
  self["keyRed"].setText(color)
  if self.isBgMode: self.defBG = color
  else   : self.defFG = color
  gap = int(self.VVuaAL["VVNGHW"] / 2)
  pos = self["myColor%d%d" % (self.curRow, self.curCol)].getPosition()
  self["myColorPtr"].instance.move(ePoint(pos[0] - gap - 2, pos[1] - gap - 2))
  self.VVBx5S()
 def VVSWky(self):
  self["myTitle"].setText("  %s %s" % ("Background" if self.isBgMode else "Foreground", self.Title))
 def VVBx5S(self):
  color = self.VVy9KJ()
  if self.isBgMode: FFu0W6(self["myColorTst"], color)
  else   : FFcfsH(self["myColorTst"], color)
 def VVVGqA(self, isBg):
  if not self.onlyBG:
   self.isBgMode = isBg
   self.VVSWky()
   self.VVvmiv()
 def VVRwyN(self, val):
  if self.isBgMode: self.transpBg = FF9BdF(self.transpBg + val, 0, 255)
  else   : self.transpFg = FF9BdF(self.transpFg + val, 0, 255)
  self. VVEIkV(0, 0)
 def VVZ3Bm(self):
  if self.isBgMode: return hex(self.transpBg)[2:].zfill(2)
  else   : return hex(self.transpFg)[2:].zfill(2)
 def VVy9KJ(self):
  return ("#%s%s" % (self.VVZ3Bm(), self.colors[self.curRow][self.curCol])).upper()
class CCBalh(Screen, CCCHs8):
 def __init__(self, session, playerObj=None):
  self.skin, self.VVuaAL = FFJH4U(VVM9On, 1860, 1030, 20, 20, 30, "#33002233", "#33002233", 25, VV1fgG=2)
  self.session   = session
  self.playerObj   = playerObj
  self.VVJZJs  = eTimer()
  self.VVplh9  = eTimer()
  self.VVwFOe  = eTimer()
  self.VVgovL = eTimer()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  self.subtList   = []
  self.curSubtFullData = None
  self.lastSubtInfo  = ""
  self.lastSubtFile  = ""
  self.lastSubtEnc  = ""
  self.settingShown  = False
  self.CursorPos   = 0
  self.Title    = "Subtitle Settings"
  self.VVZzW8  = None
  self.subtMenuFromPlayer = True
  if FFujkg() and CC6z2a.VVjIf8() in ("Gemini", "Dream-Elite"):
   self.VVbPBu = 400
   self.VVbj2y = 0.4
  else:
   self.VVbPBu = 50
   self.VVbj2y = 0.18
  self.minDelay, self.maxDelay = self.VV9QyI()
  self.diac    = u"\u0610\u0611\u0612\u0613\u0614\u0615\u0616\u0617\u0618\u0619\u061a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065a\u065b\u065c\u065d\u065e\u0670\u06d6\u06d7\u06d8\u06d9\u06da\u06db\u06dc\u06df\u06e0\u06e1\u06e2\u06e3\u06e4\u06e7\u06e8\u06ea\u06eb\u06ec\u06ed"
  CCCHs8.__init__(self)
  FFfmZP(self, title="%s%s%s" % (self.Title, " " * 10, FFITtK("Change values with Up , Down, < , 0 , >", VVVAvR)))
  self["mySubtCover"] = Label()
  self.ctrlBtns = ("keyRed", "keyGreen", "keyYellow", "keyBlue")
  subj = ("Reset All", "Save", "Reset Delay", "Pick Line")
  for i, name in enumerate(self.ctrlBtns):
   self[name] = Label(subj[i])
  self["mySubtCursor"] = Label()
  subj = ("Delay", "BG Trans %", "Text Color", "Text Font", "Text Size", "Alignment", "Shadow Color", "Shadow Size", "Position")
  self.settingLabels = ["Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos"]
  self.settingLabels1 = list(self.settingLabels)
  for i, name in enumerate(self.settingLabels):
   self.settingLabels[i]  = "mySubt%s"   % name
   self.settingLabels1[i] = "mySubt%s1"  % name
   self[self.settingLabels[i]]  = Label(subj[i])
   self[self.settingLabels1[i]] = Label(subj[i])
  self["mySubtFr"] = Label()
  for i in range(3): self["mySubt%d"  % i] = Label()
  for i in range(4): self["mySubtSep%d" % i] = Label()
  for i in range(4): self["mySubtChng%d" % i] = Label()
  self["mySubtChng1"].setText("Line (Left/Right) , Delay (Up/Down)")
  self["myRest1"] = Label("Reset")
  self.VVR4F6()
  FFewq4(self,
  {
   "ok"  : self.VVTOku      ,
   "cancel" : self.VVkIEK      ,
   "info"  : self.VVP7PX    ,
   "red"  : self.VVFjQQ  ,
   "green"  : self.VV019n   ,
   "yellow" : BF(self.VVmIKX, 0)  ,
   "blue"  : self.VVAPYU    ,
   "menu"  : self.VVigfp      ,
   "left"  : BF(self.VVjNsQ, -1),
   "right"  : BF(self.VVjNsQ, 1) ,
   "last"  : self.VVWcVa     ,
   "next"  : self.VVBrsH     ,
   "0"   : self.VVzC6X    ,
   "up"  : self.VVY6L2       ,
   "down"  : self.VVgn7U      ,
   "pageUp" : BF(self.VVIox2, True) ,
   "pageDown" : BF(self.VVIox2, False) ,
   "chanUp" : BF(self.VVIox2, True) ,
   "chanDown" : BF(self.VVIox2, False) ,
   "longPlay" : BF(self.VVAF2t, "longPlay") ,
   "play"  : BF(self.VVAF2t, "pause")  ,
   "pause"  : BF(self.VVAF2t, "pause")  ,
   "playPause" : BF(self.VVAF2t, "pause")  ,
   "stop"  : BF(self.VVAF2t, "pause")  ,
   "audio"  : BF(self.VVAF2t, "audio")  ,
   "subtitle" : BF(self.VVAF2t, "subtitle") ,
   "rewind" : BF(self.VVtPY5, "rewind") ,
   "forward" : BF(self.VVtPY5, "forward") ,
   "rewindDm" : BF(self.VVtPY5, "rewind") ,
   "forwardDm" : BF(self.VVtPY5, "forward")
  })
  self.VVZNfv()
  self.onShown.append(self.VVvFMs)
  self.onClose.append(self.VVmlhY)
 def VVZNfv(self):
  lst = []
  for fil in FFYjQm(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"):
   name = os.path.splitext(os.path.basename(fil))[0]
   lst.append((fil, name))
  if lst:
   lst.sort(key=lambda x: x[1].lower())
   default = CFG.subtTextFont.default
   if default == VVxg3T:
    for path, name in lst:
     if "almateen" in name.lower():
      default = name
      break
   CFG.subtTextFont = ConfigSelection(default=default, choices=lst)
 def VVvFMs(self):
  self.onShown.remove(self.VVvFMs)
  FFE1T7(self)
  FF1uow(self)
  FFiZTW(self["myRest1"], "#000000", 3)
  for i in range(3):
   self["mySubt%d" % i].hide()
  self.VVZHjK()
  self.VV0Jh1()
  srtCfgPath = CCBalh.VVKPfR(self)
  FF6usE("mv -f '%s.dis' '%s'" % (srtCfgPath, srtCfgPath))
  self.VVqJYe()
 def VVmlhY(self):
  self.VVJZJs.stop()
  self.VVplh9.stop()
  self.VVwFOe.stop()
  self.VVgovL.stop()
 def VVrhgl(self):
  self.settingShown = True
  for name in self.ctrlBtns: self[name].show()
  for name in self.settingLabels : self[name].show()
  for name in self.settingLabels1: self[name].show()
  for i in range(4): self["mySubtSep%d" % i].show()
  self["myTitle"].show()
  self["mySubtFr"].show()
  FFu0W6(self["myBody"], "#33002233")
  self["keyMenu"].show()
  self["keyInfo"].show()
  self["mySubtCover"].hide()
  self.VVmlYq()
 def VVZHjK(self):
  self.settingShown = False
  for name in self.ctrlBtns: self[name].hide()
  for name in self.settingLabels : self[name].hide()
  for name in self.settingLabels1: self[name].hide()
  for i in range(4): self["mySubtSep%d" % i].hide()
  self["myTitle"].hide()
  self["mySubtFr"].hide()
  FFu0W6(self["myBody"], "#ff000000")
  self["keyMenu"].hide()
  self["keyInfo"].hide()
  self["mySubtCover"].show()
 def VVTOku(self):
  if self.settingShown:
   confItem = self.VVfM6j()[self.CursorPos]
   title = self[self.settingLabels[self.CursorPos]].getText()
   CC8MwG.VVlTg2(self, confItem, title, cbFnc=self.VVy7XU)
  elif self.VVqACg():
   self.VVR4F6()
  else:
   self.close("subtExit")
 def VVy7XU(self):
  self.VVmlYq()
  self.VV0Jh1()
  self.VVReIt(True)
 def VVkIEK(self):
  for confItem in self.VVfM6j():
   if FF0kJX(confItem):
    FFHsPu(self, BF(self.VV5IA9, cbFnc=self.VVr8WY), "Save Changes ?", callBack_No=self.VVNqHS, title=self.Title)
    break
  else:
   self.VVr8WY()
 def VVr8WY(self):
  if  self.settingShown   : self.VVZHjK()
  elif self.VVqACg() : self.VVR4F6()
  else       : self.close("subtExit")
 def VVNqHS(self):
  for confItem in self.VVfM6j(): confItem.cancel()
  if self.settingShown:
   self.VVmlYq()
   self.VV0Jh1()
   self.VVZHjK()
  else:
   self.close("subtExit")
 def VVigfp(self):
  if self.settingShown   : self.VVKXap()
  elif self.VVqACg() : pass
  else       : self.VVrhgl()
 def VVjNsQ(self, pos):
  if self.settingShown:
   self.CursorPos += pos
   if   self.CursorPos > len(self.settingLabels) - 1: self.CursorPos = 0
   elif self.CursorPos < 0        : self.CursorPos = len(self.settingLabels) - 1
   inst = self[self.settingLabels[self.CursorPos]].instance
   left = inst.position().x() - 5
   inst = self["mySubtCursor"].instance
   inst.move(ePoint(left, int(inst.position().y())))
  else:
   self.VVc0R7(pos)
 def VVc0R7(self, pos):
  posVal, durVal = self.VVkBsZ()
  if pos == -1: ndx = self.VV9eSW(posVal)
  else  : ndx = self.VVoczn(posVal)
  if   ndx < 0      : FF8PJn(self, "No lines"  , 500)
  elif ndx == 0      : FF8PJn(self, "First line", 500)
  elif ndx == len(self.subtList) - 1 : FF8PJn(self, "Last line" , 500)
  else:
   capNum, frmSec, toSec, subtLines = self.subtList[ndx]
   delay, color, allow = self.VV4DGv(frmSec)
   if allow:
    if self.VVqACg():
     self.VVmIKX(delay, True)
     self.VVReIt(force=True)
    else:
     self.VVbNMu(delay, frmSec)
   else:
    FF8PJn(self, "Delay out of range", 800)
 def VViSWR(self, val):
  self.VVmIKX(CFG.subtDelaySec.getValue() + val)
  self.VVReIt(force=True)
 def VVbNMu(self, delay, frmSec):
  self["mySubtChng2"].setText("Line Time = %s" % FF79L2(frmSec))
  self["mySubtChng3"].setText("Delay = %s second%s" % (delay, FFEnJs(delay)))
  for i in range(4): self["mySubtChng%d" % i].show()
  self["myRest1"].show()
  try: self.VVgovL_conn = self.VVgovL.timeout.connect(self.VVMDqo)
  except: self.VVgovL.callback.append(self.VVMDqo)
  self.VVgovL.start(100, False)
 def VVMDqo(self):
  if self.curSubtFullData:
   capNum, frmSec, toSec, subtLines, VVlBZZ = self.curSubtFullData
   if frmSec > 0 and toSec - frmSec > 0:
    self["mySubtChng2"].setText("Line %s      %s" % (capNum, FF79L2(frmSec)))
    self["mySubtChng3"].setText("Delay = %s Sec" % CFG.subtDelaySec.getValue())
 def VVR4F6(self):
  self.VVgovL.stop()
  for i in range(4): self["mySubtChng%d" % i].hide()
  self["myRest1"].hide()
 def VVqACg(self):
  return self["mySubtChng1"].getVisible()
 def VVIox2(self, isUp):
  if not self.settingShown and not self.VVqACg():
   self.close("subtZapUp" if isUp else "subtZapDn")
 def VVAF2t(self, reason):
  if not self.settingShown:
   self.close(reason)
 def VVtPY5(self, act):
  if self.playerObj:
   if   act == "rewind" : self.playerObj.VVjvFx()
   elif act == "forward" : self.playerObj.VVX4hH()
 def VVWcVa(self) : self.VVb3u5(5)
 def VVBrsH(self) : self.VVb3u5(6)
 def VVzC6X(self) : self.VVb3u5(-1)
 def VVY6L2(self):
  if  self.settingShown   : self.VVb3u5(1)
  elif self.VVqACg() : self.VViSWR(1)
  else       : self.VVIox2(True)
 def VVgn7U(self):
  if self.settingShown: self.VVb3u5(0)
  elif self.VVqACg() : self.VViSWR(-1)
  else    : self.VVIox2(False)
 def VVb3u5(self, direction):
  if self.settingShown:
   confItem = self.VVfM6j()[self.CursorPos]
   if direction == -1:
    confItem.setValue(confItem.default)
   else:
    if direction in (0, 1) and confItem in (CFG.subtTextFg, CFG.subtTextFont, CFG.subtTextAlign, CFG.subtShadowColor, CFG.subtVerticalPos):
     direction = 0 if direction == 1 else 1
    confItem.handleKey(direction)
   if confItem is CFG.subtTextAlign:
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    for i in range(3):
     inst = self["mySubt%d" % i].instance
     w   = inst.calculateSize().width() + 50
     if   align == "0" : left = 0
     elif align == "2" : left = boxWidth - w
     else    : left = int((getDesktop(0).size().width() - w) / 2.0)
     inst.move(ePoint(left, int(inst.position().y())))
   self.VVmlYq()
   self.VV0Jh1()
   self.VVReIt(True)
 def VVfM6j(self):
  return (  CFG.subtDelaySec
    , CFG.subtBGTransp
    , CFG.subtTextFg
    , CFG.subtTextFont
    , CFG.subtTextSize
    , CFG.subtTextAlign
    , CFG.subtShadowColor
    , CFG.subtShadowSize
    , CFG.subtVerticalPos)
 def VVFjQQ(self):
  if self.settingShown:
   FFHsPu(self, self.VVLbZk, "Reset Subtitle Settings to default ?", title=self.Title)
 def VVLbZk(self):
  for confItem in self.VVfM6j(): confItem.setValue(confItem.default)
  self.VV5IA9()
  self.VVmlYq()
  self.VV0Jh1()
 def VVmIKX(self, delay, force=False):
  if self.settingShown or self.VVqACg() or force:
   FFDDwF(CFG.subtDelaySec, delay)
   self.VVrUKC()
   self.VVmlYq()
   self.VV0Jh1()
   if  self.settingShown and delay == 0: FFar20(self, 'Reset to "0"', 800)
   elif self.VVqACg()   : self.VVMDqo()
 def VVipQN(self):
  Max = CFG.subtDelayMax.getValue() * 60
  CFG.subtDelaySec = ConfigSelectionNumber(default=0, stepwidth=1, min=-Max, max=Max, wraparound=False)
  FFDDwF(CFG.subtDelaySec, 0)
  self.minDelay, self.maxDelay = self.VV9QyI()
  self.VV5IA9()
  self.VVmlYq()
 def VV019n(self):
  if self.settingShown:
   self.VV5IA9()
   self.VVZHjK()
 def VV5IA9(self, cbFnc=None):
  for confItem in self.VVfM6j(): confItem.save()
  configfile.save()
  self.VVrUKC()
  FFar20(self, "Saved")
  if cbFnc:
   cbFnc()
 def VVmlYq(self):
  cfgLst = self.VVfM6j()
  for i, name in enumerate(self.settingLabels1):
   self[name].setText(str(cfgLst[i].getText()))
 def VV0Jh1(self):
  path = CFG.subtTextFont.getValue()
  if FFf0vs(path):
   fnt = "AJP_Subtitle"
   FFB3Un(path, fnt, isRepl=1)
  else:
   fnt = VVQVcT
  lineH = 0
  top = self["mySubt0"].instance.position().y()
  bg = int(FFPSde(CFG.subtBGTransp.getValue(), 0, 100, 0, 255))
  try:
   for i in range(3):
    obj = self["mySubt%d" % i]
    inst = obj.instance
    if CFG.subtTextFg.getValue().startswith("#"):
     FFcfsH(obj, CFG.subtTextFg.getValue())
    VVdJm7 = CFG.subtTextSize.getValue()
    inst.setFont(gFont(fnt, VVdJm7))
    FFu0W6(obj, "#%0.2X000000" % bg)
    FFiZTW(self["mySubt%d" % i], CFG.subtShadowColor.getValue(), int(CFG.subtShadowSize.getValue()))
    lineH = FFwvYs(VVdJm7, self.VVbj2y)
    inst.resize(eSize(*(int(inst.size().width()), lineH)))
    if i > 0:
     inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
   for i in range(1, 4):
    inst = self["mySubtSep%d" % i].instance
    inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
  except:
   pass
  inst = self["mySubt2"].instance
  winH = inst.position().y() + inst.size().height() + 2
  winW = self.instance.size().width()
  self.instance.resize(eSize(*(int(winW), int(winH))))
  y = int(FFPSde(CFG.subtVerticalPos.getValue(), 0, 100, 0, FFUA0v()[1] - winH))
  self.instance.move(ePoint(int(self.instance.position().x()), y))
  FFDEXp(self, winW, winH)
 def VVP7PX(self):
  sp = "    "
  txt  = "%s\n"   % FFITtK("Subtitle File:", VV6UAe)
  txt += sp + "%s\n\n" % self.lastSubtFile
  txt += "%s\n"     % FFITtK("Subtitle Settings:", VV6UAe)
  txt += sp + "Encoding\t: %s\n" % (self.lastSubtEnc or "Default")
  txt += sp + "Delay\t: %s sec\n" % CFG.subtDelaySec.getValue()
  if self.subtList:
   posVal, durVal = self.VVkBsZ()
   capNum1, frmSec1, toSec1, subtLines1 = self.subtList[0]
   capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
   time1 = FF79L2(frmSec1)
   time2 = FF79L2(toSec2)
   txt += "\n"
   txt += "%s\n"       % FFITtK("Timing:", VV6UAe)
   txt += sp + "Captions\t: %s - %s\n"  % (capNum1, capNum2)
   txt += sp + "Subt. Time\t: %s - %s\n" % (time1, time2)
   txt += sp + "Event Dur.\t: %s\n"  % FF79L2(durVal)
   txt += sp + "Progress\t: %s\n" % FF79L2(posVal)
   err = self.VVsru7(posVal)
   if err:
    txt += sp + "Remarks\t: %s\n" % FFITtK(err, VVcahY)
  FFyijw(self, txt, title="Current Subtitle")
 @FFHF2S("Checking Subtitle ...", clearMsg=False)
 def VVqJYe(self, path="", delay=0, enc=""):
  try:
   self.VVJZJs.stop()
   if path:
    subtList, err = self.VVbHGZ(path, enc=enc)
    if err    : self.close(err)
    elif not subtList : self.close("subtInval")
    else    :
     self.subtList = subtList
     CFG.subtDelaySec.setValue(int(delay))
     FFDDwF(CFG.subtDelaySec, int(delay))
     self.VVmlYq()
     self.VVitWM()
   else:
    path, delay, enc = CCBalh.VVqT0V(self)
    if path:
     self.VVqJYe(path=path, delay=delay, enc=enc)
    else:
     self.VVKXap()
  except:
   pass
 def VVitWM(self):
  CCBalh.VV88Fx(None)
  try: self.VVJZJs_conn = self.VVJZJs.timeout.connect(self.VVReIt)
  except: self.VVJZJs.callback.append(self.VVReIt)
  self.VVJZJs.start(500, False)
  try: self.VVplh9_conn = self.VVplh9.timeout.connect(self.VV70rp)
  except: self.VVplh9.callback.append(self.VV70rp)
  err = self.VVsru7()
  if err : FFar20(self, err)
  else : FFar20(self, "Subtitle started", 700)
 def VVsru7(self, posVal=None):
  if posVal == None:
   posVal, durVal = self.VVkBsZ()
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  return "Subtitle end reached" if (posVal - int(CFG.subtDelaySec.getValue()) > toSec2) else ""
 def VVhcbq(self, posVal, margin=0):
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  if posVal + self.maxDelay > toSec2:
   path = CCBalh.VVKPfR(self)
   FFar20(self, "End of subtitle reached")
   return True
  else:
   return False
 def VVKXap(self):
  c1, c2, c3, c4, c5, c6 = VV6UAe, VVnQYw, VVkLs0, VVUPyu, VVCBkQ, VVcahY
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  txt1 = FFITtK("... from Favourite Path", VVgzFX)
  VVXXzc = []
  VVXXzc.append(("Select from Favourites Path"     , "listFav"  ))
  VVXXzc.append(("Select from All Paths"      , "listAll"  ))
  VVXXzc.append((c1 + "Select from File Manager"    , "listFMan" ))
  VVXXzc.append(FFwjWO("Select from Current Movie Path" , "listCur", fPath, c2 ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Set Maximum Delay (Minutes)"     , "setMaxDelay" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Set Favourite Path"      , "setFavPath" ))
  VVXXzc.append((c3 + "Set Auto-Find Event Name Language"  , "setFavLang" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append((c3 + "Suggest files (%s35%%%s match) %s" % (c4, c3, txt1), "sugSrt0.35"))
  VVXXzc.append((c3 + "Suggest files (%s50%%%s match) %s" % (c4, c3, txt1), "sugSrt0.50"))
  VVXXzc.append((c3 + "Suggest files (%s80%%%s match) %s" % (c4, c3, txt1), "sugSrt0.80"))
  if self.settingShown:
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c5 + "Change Subtitle File Encoding" , "enc"  ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append((c6 + "Disable Current Subtitle"  , "disb" ))
   VVXXzc.append(VVzg1X)
   VVXXzc.append(("Help (Keys)"       , "help" ))
  VV5LxL = self.VVb1tz
  FFw2XU(self, self.VVrNfH, VVXXzc=VVXXzc, width=900, height=1000, title='Find Subtitle "srt" File', VV5LxL=VV5LxL, VVVzvS="#22001122", VVhHWW="#11000509", VVlIBH="#08554455")
 def VVb1tz(self, item=None):
  if item:
   VVZzW8, title, item, ndx = item
   self.VVZzW8 = VVZzW8
   title = FFes9J(title).partition("...")[0].strip()
   if   item == "listFav"   : self.VVeYIk(0, title)
   elif item == "listAll"   : self.VVeYIk(1, title)
   elif item == "listFMan"   : self.session.openWithCallback(self.VVhIhC, BF(CCQdsv, VVmysg="srt", VV82pi=CFG.lastSubtFManFindDir.getValue()))
   elif item == "listCur"   : self.VVeYIk(2, title)
   elif item == "setMaxDelay"  : CC8MwG.VVlTg2(self, CFG.subtDelayMax, "Subtitle Delay Limit (Minutes)", cbFnc=self.VVipQN, isSave=True, width=700)
   elif item == "setFavPath"  : self.session.openWithCallback(self.VVxTN9, BF(CCQdsv, mode=CCQdsv.VVx2Yd, VV82pi=CFG.subtitleFavPath.getValue()))
   elif item == "setFavLang"  : CC8MwG.VVlTg2(self, CFG.subtitleEventLang, "Event Name Search Language", cbFnc=BF(FFar20, self.VVZzW8 or self, "Saved"), isSave=True, width=700)
   elif item.startswith("sugSrt") : self.VVeYIk(3, title, coeff=float(item[6:]))
   elif item == "enc":
    if self.lastSubtFile and FFf0vs(self.lastSubtFile) : FFTSvN(self.VVZzW8 or self, BF(CC2Ldo.VVXlDL, self, self.lastSubtFile, self.VV53uJ, self.lastSubtEnc or CFG.subtDefaultEnc.getValue()), title="Loading Codecs ...")
    else             : FF8PJn(self, "SRT File error", 1000)
   elif item == "disb"    : self.VVAD40()
   elif item == "help"    : FFpIdO(self, "_help_subt", "Subtitle (Keys)")
 def VVAD40(self, item=None):
  subtRefFile = CCBalh.VVKPfR(self)
  fPath, fDir, fName = CCQdsv.VVZTzJ(self)
  if fPath and subtRefFile:
   fPath += ".ajp"
   if FFf0vs(fPath):
    FF6usE("mv -f '%s' '%s.dis'" % (fPath, fPath))
  else:
   FFqlCI(subtRefFile)
  self.VVc62Q()
  self.close("subtExit")
 def VVrNfH(self, item=None):
  if not self.settingShown and self.subtMenuFromPlayer:
   self.close("subtCancel")
 def VVc62Q(self):
  self.subtMenuFromPlayer = False
  if self.VVZzW8: self.VVZzW8.cancel()
  if self.settingShown: self.VVZHjK()
 def VV53uJ(self, item=None):
  if item:
   self.VVc62Q()
   FFTSvN(self.VVZzW8 or self, BF(self.VVqJYe, path=self.lastSubtFile, delay=CFG.subtDelaySec.getValue(), enc=item), title="Loading Subtitle ...")
 def VVhIhC(self, path):
  if path:
   self.VVc62Q()
   FFDDwF(CFG.lastSubtFManFindDir, os.path.dirname(path))
   self.VVqJYe(path=path)
 def VVxTN9(self, path):
  if path:
   FFDDwF(CFG.subtitleFavPath, path)
   FFar20(self.VVZzW8 or self, "Saved")
 def VVeYIk(self, mode, title, coeff=0.25):
  FFTSvN(self.VVZzW8 or self, BF(self.VV0QHN, mode, title, coeff), title="Searching for srt files")
 def VV0QHN(self, mode, title, coeff):
  evName = CCfClD.VVZ1cH(self).strip()
  if mode == 3 and not evName:
   FFk1YE(self.VVZzW8 or self, "No event Name", 2000)
   return
  if   mode == 0: sPath = CFG.subtitleFavPath.getValue()
  elif mode == 1: sPath = "/"
  elif mode == 2: sPath = CCQdsv.VVZTzJ(self)[1]
  elif mode == 3: sPath = CFG.subtitleFavPath.getValue()
  srtList = FF2gLS(r'find "%s" %s \( -iname "*.srt" \) | grep -i "\.srt"' % (sPath, FFoSAW(1)))
  if srtList and srtList[0].startswith("find:"):
   FFU9uk(self, "Error in path:\n\n%s" % sPath, title=title)
   return
  if not srtList:
   FFk1YE(self.VVZzW8 or self, "No srt files", 1500)
   return
  srtList.sort(key=lambda x: x.lower())
  if mode == 3:
   trName = evName
   if CFG.subtitleEventLang.getValue() == "s":
    trName = CCfClD.VVMR9P(evName, "en")[0] or evName
   title = "%s %s\t%s %s" % (title, VVVAvR, VVaR8d, trName)
   self.VVwKwI(self.VVZzW8 or self, BF(self.VVKBqB, mode, evName, trName, title), trName, srtList, 20, coeff)
  else:
   self.VVKBqB(mode, evName, "", title, srtList, "")
 def VVKBqB(self, mode, evName, trName, title, srtList, err):
  if mode == 3:
   if not srtList: err = err or "No Similar Names"
   if err:
    if evName == trName : FFk1YE(self.VVZzW8 or self, err, 2000)
    else    : FFU9uk(self, err, title="Event : %s" % trName)
    return
  VVJwgn = []
  curColor = "#f#0000FF00#"
  for path in srtList:
   fName, Dir = os.path.basename(path), FFA4GT(os.path.dirname(path))
   if self.lastSubtFile == Dir + fName:
    fName, Dir = curColor + fName, curColor + Dir
   VVJwgn.append((fName, Dir))
  VVI3Oq  = ("Select"    , self.VViXEA        , [])
  VV4dTm = (""     , self.VVJNeJ          , [])
  VVsB8G = (""     , BF(self.VVwzXn, self.lastSubtFile, False) , [])
  VV5CrJ = ("Find Current File" , BF(self.VVwzXn, self.lastSubtFile, True) , [])
  header   = ("File" , "Directory" )
  widths   = (60  , 40   )
  FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VV1PTZ=widths, VV1Wwb=28, VVI3Oq=VVI3Oq, VV4dTm=VV4dTm, VVsB8G=VVsB8G, VV5CrJ=VV5CrJ, VV7VIQ=CFG.lastFindSubtitle
    , VVVzvS="#11002222", VVhHWW="#22001111", VVpaQ6="#22001111", VVqecq="#11ffff00", VVI4UA="#11552233", VVcv6F="#22222222", VVsOjr="#11002233")
 def VVJNeJ(self, VV5ybN, title, txt, colList):
  fName, Dir = colList
  FFyijw(VV5ybN, "%s\n\n%s%s" % (FFITtK("Path:", VV6UAe), Dir, fName), title=title)
 def VVwzXn(self, path, VVqUOx, VV5ybN, title, txt, colList):
  for ndx, row in enumerate(VV5ybN.VVTq0J()):
   if path == row[1].strip() + row[0].strip():
    VV5ybN.VV43d2(ndx)
    break
  else:
   if VVqUOx:
    FF8PJn(VV5ybN, "Not in list !", 1000)
 def VViXEA(self, VV5ybN, title, txt, colList):
  VV5ybN.cancel()
  self.VVc62Q()
  path = "%s%s" % (colList[1].strip(), colList[0].strip())
  FFTSvN(self.VVZzW8, BF(self.VVqJYe, path=path))
 def VVbHGZ(self, path, enc=None):
  if enc and CC2Ldo.VVQKht(path, enc)      : enc = enc
  elif CC2Ldo.VVQKht(path, CFG.subtDefaultEnc.getValue()): enc = CFG.subtDefaultEnc.getValue()
  else                   : enc = None
  if not FFf0vs(path):
   return [], "File not found"
  if (FFX42v(path) > 1024 * 700):
   return [], "File too big"
  frmSec = toSec = bold = italic = under = 0
  capNum  = ""
  capFound = True
  color  = ""
  subtLines = []
  subtList = []
  lines  = FF2iRW(path, encLst=enc)
  lastNdx  = len(lines) - 1
  for ndx, line in enumerate(lines):
   line = str(line).strip()
   if line:
    if line.isdigit():
     capNum = line
    else:
     span = iSearch(r'(\d{2}:\d{2}:\d{2},\d{3})\s*\-->\s*(\d{2}:\d{2}:\d{2},\d{3})', line, IGNORECASE)
     if span:
      p  = list(map(int, span.group(1).replace(",", ":").split(":")))
      frmSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      p  = list(map(int, span.group(2).replace(",", ":").split(":")))
      toSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      subtLines = []
     else:
      span = iSearch(r'<font color="(.+)">(.+)', line, IGNORECASE)
      if span:
       color = self.VVkFSw(span.group(1))
       line = span.group(2)
      if "<b>" in line: bold = 1
      if "<i>" in line: italic = 1
      if "<u>" in line: under = 1
      line = line.replace("</font>", "").replace("</b>", "").replace("</i>", "").replace("</u>", "")
      line = line.replace("<b>", "").replace("<i>", "").replace("<u>", "")
      span = iSearch(r"{\\a\d}(.+)", line, IGNORECASE)
      if span:
       line = span.group(1)
      line = self.VVT6OJ(line)
      subtLines.append((line.strip(), color, bold, italic, under))
      if ndx == lastNdx and subtList and (toSec - frmSec) > 0 and not subtList[len(subtList) - 1] == (capNum, frmSec, toSec, subtLines):
       subtList.append((capNum, frmSec, toSec, subtLines))
   else:
    if toSec > frmSec and subtLines:
     subtList.append((capNum, frmSec, toSec, subtLines))
    frmSec = toSec = bold = italic = under = 0
    capNum  = ""
    color  = ""
    subtLines = []
  if subtList:
   self.lastSubtFile = path
   self.lastSubtEnc  = enc
   self.VVrUKC()
  return subtList, ""
 def VVT6OJ(self, line):
  line = line.replace(u"\u202A", "")
  line = line.replace(u"\u202B", "")
  line = line.replace(u"\u202C", "")
  for char in line:
   if 0x600 <= ord(char) <= 0x6FF and char in self.diac:
    line = line.replace(char, "")
  line = line.replace("\r", "..").replace("\n", "..")
  return str(line)
 def VVkFSw(self, color):
  lst = { "black": "#000000", "blue": "#0000ff", "brown":"#a52a2a", "cyan":"#00ffff", "darkblue": "#0000a0", "gray":"#808080", "green":"#008000", "grey": "#808080", "lightblue":"#add8E6", "lime":"#00ff00", "magenta":"#ff00ff", "maroon":"#800000", "olive":"#808000", "orange":"#ffa500", "purple":"#800080", "red":"#ff0000", "silver":"#c0c0c0", "white":"#ffffff", "yellow":"#ffff00"}
  code = lst.get(color.lower(), "")
  if code:
   return code
  else:
   span = iSearch(r"(#[A-Fa-f0-9]{6})", color, IGNORECASE)
   if span : return span.group(1)
   else : return ""
 def VVrUKC(self):
  path = CCBalh.VVKPfR(self)
  if path:
   try:
    with open(path, "w") as f:
     f.write("srt=%s\n" % self.lastSubtFile)
     f.write("delay=%s\n" % CFG.subtDelaySec.getValue())
     if self.lastSubtEnc:
      f.write("enc=%s\n" % self.lastSubtEnc)
   except:
    pass
 def VVReIt(self, force=False):
  posVal, durVal = self.VVkBsZ()
  err = self.VVsru7(posVal)
  if err:
   return
  VVlBZZ = self.VVsolt(posVal)
  if VVlBZZ < 0:
   return
  txtDur = 0
  if posVal:
   capNum, frmSec, toSec, subtLines = self.subtList[VVlBZZ]
   if force or not self.lastSubtInfo == subtLines:
    self.lastSubtInfo = subtLines
    self.curSubtFullData = (capNum, frmSec, toSec, subtLines, VVlBZZ)
    settingColor = ""
    if CFG.subtTextFg.getValue().startswith("#"):
     settingColor = CFG.subtTextFg.getValue()
    self.VV70rp()
    subtLines = list(subtLines)
    l = len(subtLines)
    for i in range(3 - len(subtLines)):
     subtLines.insert(0, ("", "", 0, 0, 0))
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    txtDur = int(toSec * 1000 - frmSec * 1000)
    if txtDur > 0:
     for ndx, (line, color, bold, italic, under) in enumerate(subtLines):
      if line:
       if   bold   : newColor = "#aaffff"
       elif italic   : newColor = "#aaaaaa"
       elif under   : newColor = "#ffffaa"
       elif settingColor : newColor = settingColor
       elif color   : newColor = color
       else    : newColor = ""
       if ndx < 3:
        obj  = self["mySubt%d" % ndx]
        inst = obj.instance
        if newColor:
         FFcfsH(obj, newColor)
        obj.setText(line)
        obj.show()
        w = inst.calculateSize().width() + self.VVbPBu
        inst.resize(eSize(*(w, inst.size().height())))
        if   align == "0" : left = 0
        elif align == "2" : left = boxWidth - w
        else    : left = int((getDesktop(0).size().width() - w) / 2.0)
        inst.move(ePoint(left, int(inst.position().y())))
    if txtDur > 0:
     self.VVplh9.start(txtDur, True)
 def VVkBsZ(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CC2lVw.VVp3Eo(self)
  if not durVal and not posVal:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CCfClD.VVk1vV(self)
   if evTime and evDur:
    posVal, durVal = iTime() - evTime, evDur
  return posVal, durVal
 def VVsolt(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if posVal > frmSec and posVal < toSec:
     return ndx
  return -1
 def VV9eSW(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if toSec > posVal:
     return ndx -1
  return -1
 def VVoczn(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if frmSec > posVal:
     return ndx
  return -1
 def VV70rp(self):
  for i in range(3):
   self["mySubt%d" % i].setText("")
   FFcfsH(self["mySubt%d" % i], "#00ffffff")
   self["mySubt%d" % i].hide()
 def VVAPYU(self):
  if not self.VVqACg():
   self.VVd0GX()
 @FFHF2S("Loading Lines ...")
 def VVd0GX(self):
  VVJwgn = []
  for cap, frm, to, lines in self.subtList:
   firstLine = lines[0][0] if lines else ""
   VVJwgn.append((cap, FF79L2(frm), str(frm), firstLine))
  if VVJwgn:
   title = "Select Current Subtitle Line"
   VVLj1d = self.VVG5Wt
   VVsB8G = (""    , self.VVYUkZ , [])
   VVI3Oq  = ("Select"   , self.VVGrJR , [title])
   VV5CrJ = ("Current Line" , self.VVdqsY , [True])
   VVbQ6N = ("Reset Delay" , self.VVHYUt , [])
   header   = ("Cap" , "Time", "Time Val", "Subtitle Text" )
   widths   = (8  , 15 , 0    , 77    )
   VVgKQc  = (CENTER , CENTER, CENTER , LEFT    )
   VV5ybN = FFdCaM(self, None, title=title, header=header, VV5dDF=VVJwgn, VVgKQc=VVgKQc, VV1PTZ=widths, VV1Wwb=28, VVsB8G=VVsB8G, VVLj1d=VVLj1d, VVI3Oq=VVI3Oq, VV5CrJ=VV5CrJ, VVbQ6N=VVbQ6N
          , VVVzvS="#33002222", VVhHWW="#33001111", VVpaQ6="#33110011", VVqecq="#11ffff00", VVI4UA="#0a334455", VVcv6F="#22222222", VVsOjr="#33002233")
   err = self.VVsru7()
   if err:
    VV5ybN.VVU4Vz()
    FF8PJn(VV5ybN, err, 1500)
  else:
   FFk1YE(self, "Cannot read lines !", 2000)
 def VVYUkZ(self, VV5ybN, title, txt, colList):
  self.subtLinesTable = VV5ybN
  if int(CFG.subtDelaySec.getValue()):
   VV5ybN["keyYellow"].show()
   VV5ybN["keyYellow"].setText("Reset Delay (%s sec)" % CFG.subtDelaySec.getValue())
  else:
   VV5ybN["keyYellow"].hide()
  VV5ybN["keyBlue"].setText("New Delay: %s sec" % CFG.subtDelaySec.getValue())
  VV5ybN["keyBlue"].show()
  FFu0W6(VV5ybN["keyBlue"], "#22222222")
  VV5ybN.VVIl4g(BF(self.VVYk3N, VV5ybN))
  self.VVdqsY(VV5ybN, False)
  try: self.VVwFOe_conn = self.VVwFOe.timeout.connect(self.VVjtiG)
  except: self.VVwFOe.callback.append(self.VVjtiG)
  self.VVwFOe.start(500, False)
 def VVG5Wt(self, VV5ybN):
  self.VVwFOe.stop()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  VV5ybN.cancel()
 def VVjtiG(self):
  if self.subtLinesTable:
   VV5ybN = self.subtLinesTable
   posVal, durVal = self.VVkBsZ()
   color = "#b#11551111#"
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVlBZZ = self.VVsolt(posVal)
    if VVlBZZ > -1:
     if self.subtLinesTableNdx > -1:
      row = VV5ybN.VVVB7s(self.subtLinesTableNdx)
      row[0] = row[0].replace(color, "")
      VV5ybN.VVZmhU(self.subtLinesTableNdx, row)
     row = VV5ybN.VVVB7s(VVlBZZ)
     row[0] = color + row[0]
     VV5ybN.VVZmhU(VVlBZZ, row)
     self.subtLinesTableNdx = VVlBZZ
 def VVGrJR(self, VV5ybN, Title):
  delay, color, allow = self.VViBwY(VV5ybN)
  if allow:
   self.VVG5Wt(VV5ybN)
   self.VVmIKX(delay, True)
  else:
   FF8PJn(VV5ybN, "Delay out of range", 1500)
 def VVdqsY(self, VV5ybN, VVqUOx, onlyColor=False):
  if VV5ybN:
   posVal, durVal = self.VVkBsZ()
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVlBZZ = self.VVsolt(posVal)
    if VVlBZZ > -1:
     VV5ybN.VV43d2(VVlBZZ)
    else:
     ndx = self.VV9eSW(posVal)
     if ndx > -1:
      VV5ybN.VV43d2(ndx)
 def VVHYUt(self, VV5ybN, title, txt, colList):
  if VV5ybN["keyYellow"].getVisible():
   self.VVmIKX(0, True)
   VV5ybN["keyYellow"].hide()
   self.VVdqsY(VV5ybN, False)
 def VVYk3N(self, VV5ybN):
  delay, color, allow = self.VViBwY(VV5ybN)
  VV5ybN["keyBlue"].setText("%sNew Delay: %s sec" % (color, delay))
 def VViBwY(self, VV5ybN):
  lineTime = float(VV5ybN.VVqY3Q()[2].strip())
  return self.VV4DGv(lineTime)
 def VV4DGv(self, lineTime):
  posVal, durVal = self.VVkBsZ()
  delay, color, allow = 0, "", False
  if posVal > 0:
   val = int(round(posVal - lineTime))
   if self.minDelay <= val <= self.maxDelay: allow, color = True , VVnQYw
   else          : allow, color = False, VVu50a
   delay = FF9BdF(val, self.minDelay, self.maxDelay)
  return delay, color, allow
 def VV9QyI(self):
  lst = CFG.subtDelaySec.choices.choices
  tMin = lst[0]
  tMax = lst[len(lst) - 1]
  if isinstance(tMin, tuple):
   tMin = tMin[0]
   tMax = tMax[0]
  return int(tMin), int(tMax)
 @staticmethod
 def VVMEHg(SELF):
  srtCfgPath = CCBalh.VVKPfR(SELF)
  if srtCfgPath and FFf0vs(srtCfgPath + ".dis"):
   return False
  path, delay, enc = CCBalh.VVqT0V(SELF)
  return True if path else False
 @staticmethod
 def VVqT0V(SELF):
  path, delay, enc = CCBalh.VVfEtY(SELF)
  if not path:
   path = CCBalh.VVsXHu(SELF)
  return path, delay, enc
 @staticmethod
 def VVfEtY(SELF):
  srtCfgPath = CCBalh.VVKPfR(SELF)
  path = enc = ""
  delay = 0
  if srtCfgPath:
   if FFf0vs(srtCfgPath):
    lines = FF2iRW(srtCfgPath)
    for line in lines:
     line = line.strip()
     if   line.startswith("srt=") : path = line.split("=")[1].strip()
     elif line.startswith("delay=") : delay = line.split("=")[1].strip()
     elif line.startswith("enc=") : enc = line.split("=")[1].strip()
  if path and FFf0vs(path):
   try:
    delay = int(delay)
   except:
    pass
   return path, delay, enc
  else:
   return "", 0, ""
 @staticmethod
 def VVKPfR(SELF):
  fPath, fDir, fName = CCQdsv.VVZTzJ(SELF)
  if not fPath:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CCfClD.VVk1vV(SELF)
   if evName.strip() and evTime and evDur:
    fPath = "/tmp/" + evName[:30].strip()
  if not fPath:
   VVeZBd = CCaZ62(SELF.session).VVeZBd.strip()
   if VVeZBd:
    fPath = "/tmp/" + VVeZBd
  if fPath: return fPath + ".ajp"
  else : return ""
 @staticmethod
 def VVsXHu(SELF):
  bestRatio = 0
  fPath, fDir, fName = CCQdsv.VVZTzJ(SELF)
  if fName:
   bestSrt = os.path.splitext(fPath)[0] + ".srt"
   if FFf0vs(bestSrt):
    return bestSrt
   else:
    movName = os.path.splitext(fName)[0]
    paths = CCBalh.VVPpBm(SELF)
    nm = CCCHs8()
    bLst, err = nm.VVW7IJ(movName, paths, 1, 0.3)
    if bLst:
     return bLst[0]
  return ""
 @staticmethod
 def VVPpBm(SELF):
  fPath, fDir, fName = CCQdsv.VVZTzJ(SELF)
  if VVrRHR(fDir):
   files = FFYjQm(fDir, "*.srt")
   if files:
    return files
  return []
 @staticmethod
 def VVmEsO():
  try:
   return InfoBar.instance.selected_subtitle
  except:
   try:
    return InfoBar.instance.__selected_subtitle
   except:
    return None
 @staticmethod
 def VV88Fx(subt):
  if subt and isinstance(subt, tuple) and len(subt) >= 4 : state = True
  else             : subt, state = None, False
  try:
   InfoBar.instance.enableSubtitle(subt)
  except:
   try:
    if state:
     InfoBar.instance.__selected_subtitle = subt
    InfoBar.instance.setSubtitlesEnable(state)
   except:
    pass
  CCBalh.VVVpxZ()
 @staticmethod
 def VVVpxZ():
  try:
   if config.subtitles.show.value : InfoBar.instance.subtitle_window.show()
   else       : InfoBar.instance.subtitle_window.hide()
  except:
   pass
class CCxtRQ(ScrollLabel):
 def __init__(self, VVslQq, text="", VViwi5=True):
  ScrollLabel.__init__(self, text)
  self.VViwi5   = VViwi5
  self.long_text    = None
  self.scrollbar    = None
  self.message    = text
  self.instance    = None
  self.VVXAxt  = 0
  self.curPos     = 0
  self.pageHeight    = 0
  self.pageLines    = 0
  self.column     = 0
  self.VVUrKi  = ""
  self.VVslQq    = VVslQq
  self.VVNhgp   = None
  self.fontFamily    = None
  self.VV1Wwb    = None
  self.parentW    = None
  self.parentH    = None
  self.VV8nG3   = True
  self.addNewLine    = True
  self.maxChars    = 0
  self.VVeacl  = 50 if FFujkg() else 0
  VVslQq["keyRedTop"]  = Label("Menu")
  VVslQq["keyGreenTop"] = Label("Reset")
  VVslQq["keyYellowTop"] = Label("Font -")
  VVslQq["keyBlueTop"] = Label("Font +")
  for s in ("Red", "Green", "Yellow", "Blue"):
   VVslQq["key%sTop1" % s] = Label()
  FFewq4(VVslQq,
  {
   "ok"   : VVslQq.close  ,
   "cancel"  : VVslQq.close  ,
   "menu"   : self.VVyZvH ,
   "green"   : self.VVQ4pd ,
   "yellow"  : self.VVZQnI ,
   "blue"   : self.VVof7V ,
   "up"   : self.VVeXT6   ,
   "down"   : self.VVNZhV  ,
   "left"   : self.VVeXT6   ,
   "right"   : self.VVNZhV  ,
   "last"   : BF(self.VVJkv7, 0) ,
   "0"    : BF(self.VVJkv7, 1) ,
   "next"   : BF(self.VVJkv7, 2) ,
   "pageUp"  : self.VVHOrz   ,
   "chanUp"  : self.VVHOrz   ,
   "pageDown"  : self.VV1AjE   ,
   "chanDown"  : self.VV1AjE
  })
 def VVuyIP(self, VVNhgp=True, VV0tn7=False, VVUrKi="", addNewLine=True, hideBtns=False, maxChars=0):
  self.VVUrKi = VVUrKi
  self.addNewLine = addNewLine
  self.maxChars = maxChars
  if hideBtns:
   for b in ("keyRedTop", "keyGreenTop", "keyYellowTop", "keyBlueTop", "keyRedTop1", "keyGreenTop1", "keyYellowTop1", "keyBlueTop1"):
    self.VVslQq[b].hide()
  FFNucL(self.VVslQq["keyRedTop"], "#00FFFF55" if VVUrKi else "#00FFFFFF", "#11000000")
  FFE1T7(self.VVslQq, True)
  self.VVNhgp = VVNhgp
  if VV0tn7:
   self.long_text.setHAlign(1)
  size    = self.VVslQq.instance.size()
  self.parentW  = size.width()
  self.parentH  = size.height()
  font    = self.long_text.getFont()
  self.fontFamily  = font.family
  self.VV1Wwb  = font.pointSize
  try:  self.scrollbar.setBorderColor(parseColor("#11555555"))
  except: pass
  try:  self.scrollbar.setForegroundColor(parseColor("#11AA8E48"))
  except: pass
  try:  self.scrollbar.setBackgroundColor(parseColor("#11111111"))
  except: pass
  color = self.VVslQq.VVuaAL["VVQbHY"]
  FFu0W6(self, color)
 def VVyq0j(self, color):
  self.long_text.setBackgroundColor(parseColor(color))
 def applySkin(self, desktop, parent):
  import skin
  from enigma import eLabel, eSlider
  self.long_text = eLabel(self.instance)
  self.scrollbar = eSlider(self.instance)
  skin.applyAllAttributes(self.long_text, desktop, self.skinAttributes, parent.scale)
  self.pageWidth = self.long_text.size().width()
  VVwOMI  = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont())) or 30
  self.pageLines = int(self.long_text.size().height() / VVwOMI)
  margin   = int(VVwOMI / 6)
  self.pageHeight = int(self.pageLines * VVwOMI)
  self.instance.move(self.long_text.position())
  self.instance.resize(eSize(self.pageWidth, self.pageHeight + margin))
  w = 20
  self.scrollbar.move(ePoint(self.pageWidth - w, 0))
  self.scrollbar.resize(eSize(w, self.pageHeight + margin))
  self.scrollbar.setOrientation(eSlider.orVertical)
  self.scrollbar.setRange(0, 100)
  self.scrollbar.setBorderWidth(1)
  return True
 def setPos(self, pos):
  self.curPos = max(0, min(pos, self.VVXAxt - self.pageHeight))
  self.long_text.move(ePoint(0, -self.curPos))
  self.VVasfs()
 def VVeXT6(self):
  if self.VVXAxt > self.pageHeight:
   self.setPos(self.curPos - self.pageHeight)
 def VVNZhV(self):
  if self.VVXAxt > self.pageHeight:
   self.setPos(self.curPos + self.pageHeight)
 def VVHOrz(self):
  self.setPos(0)
 def VV1AjE(self):
  self.setPos(self.VVXAxt-self.pageHeight)
 def VVvf09(self):
  return self.VVXAxt <= self.pageHeight or self.curPos == self.VVXAxt - self.pageHeight
 def getText(self):
  return self.message
 def VVasfs(self):
  try:
   vis = int(max(100 * self.pageHeight / self.VVXAxt, 3))
   start = int((100 - vis) * self.curPos / (self.VVXAxt - self.pageHeight))
   self.scrollbar.setStartEnd(start, start + vis)
  except:
   pass
 def setText(self, text, VVPsQd=VVWqOp):
  old_VVvf09 = self.VVvf09()
  self.message = str(text)
  if self.maxChars > 0 and len(self.message) > self.maxChars:
   self.message = self.message[-self.maxChars:]
   if "\n" in self.message[:100]:
    self.message = self.message[self.message.index("\n"):]
  if self.pageHeight:
   if self.addNewLine and len(self.message.splitlines()) < self.pageLines - 2:
    if not self.message.startswith("\n"):
     self.message = "\n" + self.message
    self.message = self.message.rstrip() + "\n"
   self.long_text.setText(self.message)
   self.VVXAxt = self.long_text.calculateSize().height()
   if self.VViwi5 and self.VVXAxt > self.pageHeight:
    self.scrollbar.show()
    self.VVasfs()
    w = self.VVslQq.VVuaAL["scrollBarW"] + 5
    pageWidth  = self.instance.size().width() - w
    self.long_text.resize(eSize(pageWidth, self.VVXAxt))
    self.VVXAxt = self.long_text.calculateSize().height()
    self.long_text.resize(eSize(pageWidth, self.VVXAxt))
   else:
    self.scrollbar.hide()
   if   VVPsQd == VV73ng: self.setPos(0)
   elif VVPsQd == VVtU2A : self.VV1AjE()
   elif old_VVvf09    : self.VV1AjE()
 def appendText(self, text, VVPsQd=VVtU2A):
  self.setText(self.message + str(text), VVPsQd=VVPsQd)
 def VVZQnI(self):
  size = int(self.long_text.getFont().pointSize * 0.8)
  if size > 5:
   self.VVV3ca(size)
 def VVof7V(self):
  size = int(self.long_text.getFont().pointSize * 1.2)
  if size < 80:
   self.VVV3ca(size)
 def VVQ4pd(self):
  self.VVV3ca(self.VV1Wwb)
 def VVV3ca(self, VV1Wwb):
  self.long_text.setFont(gFont(self.fontFamily, VV1Wwb))
  self.setText(self.message, VVPsQd=VVWqOp)
  self.VVNtRi()
 def VVJkv7(self, align):
  self.long_text.setHAlign(align)
 def VVyZvH(self):
  VVXXzc = []
  VVXXzc.append(("%s Wrapping" % ("Disable" if self.VV8nG3 else "Enable"), "wrap" ))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Align Left" , "left" ))
  VVXXzc.append(("Align Center" , "center" ))
  VVXXzc.append(("Align Right" , "right" ))
  if self.VVUrKi:
   VVXXzc.append(VVzg1X)
   VVXXzc.append((FFITtK("Save to File", VV6UAe), "save"))
  VVXXzc.append(VVzg1X)
  VVXXzc.append(("Keys (Shortcuts)", "help"))
  FFw2XU(self.VVslQq, self.VVtzDC, VVXXzc=VVXXzc, title="Text Option", width=500)
 def VVtzDC(self, item=None):
  if item:
   if item == "wrap"  : self.VVfO3g()
   elif item == "left"  : self.VVJkv7(0)
   elif item == "center" : self.VVJkv7(1)
   elif item == "right" : self.VVJkv7(2)
   elif item == "save"  : self.VVXk7i()
   elif item == "help"  : FFpIdO(self.VVslQq, "_help_txt", "Text Viewer (Keys)")
 def VVlCqA(self, isOn):
  self.VV8nG3 = isOn
  self.long_text.setNoWrap(not isOn)
 def VVfO3g(self):
  self.VVlCqA(not self.VV8nG3)
 def VVXk7i(self):
  title = "%s Log File" % self.VVUrKi.capitalize()
  expPath = FFg1mx()
  try:
   outF = "%sAJPanel_log_%s_%s.txt" % (FFA4GT(expPath), self.VVUrKi, FF6eWd())
   with open(outF, "w") as f:
    f.write(FFes9J(self.message))
   FFSQn9(self.VVslQq, "Saved to:\n\n%s" % outF, title=title)
  except:
   FFU9uk(self.VVslQq, "Could not save to:\n\n%s" % expPath, title=title)
 def VVNtRi(self, minHeight=0):
  if self.VVNhgp:
   VVwOMI = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont()))
   textH = min(self.pageHeight, VVwOMI * (len(self.message.splitlines()) + 1))
   if textH < self.pageHeight and self.VVXAxt < self.pageHeight:
    textH = max(textH, self.VVXAxt) + self.VVeacl
   self.resize(eSize(*(self.instance.size().width(), textH + 6)))
   diff = self.pageHeight - textH
   newH = self.parentH - diff
   if diff < 0:
    newH = self.parentH
   if minHeight > 0:
    newH = max(newH, minHeight + self.VVslQq.VVuaAL["titleH"] + self.VVslQq.VVuaAL["VV8IXD"] * 2 + 1)
   screenSize = getDesktop(0).size()
   self.VVslQq.instance.resize(eSize(*(self.parentW, min(self.parentH, newH))))
   self.VVslQq.instance.move(ePoint((screenSize.width() - self.parentW) // 2, (screenSize.height() - newH) // 2))
